import require$$1 from 'process';
import require$$4$1 from 'tls';
import require$$0 from 'fs';
import require$$0$1 from 'os';
import require$$0$2 from 'net';
import require$$0$3 from 'events';
import require$$0$4 from 'stream';
import require$$1$1 from 'path';
import require$$0$5 from 'http2';
import require$$3$1 from 'http';
import require$$7 from 'url';
import require$$1$2 from 'dns';
import require$$0$6 from 'zlib';
import require$$1$3 from 'util';
import assert from 'node:assert';
import { AsyncLocalStorage } from 'node:async_hooks';
import * as tty from 'node:tty';
// -- Shims --
import cjsUrl from 'node:url';
import cjsPath from 'node:path';
const __filename = cjsUrl.fileURLToPath(import.meta.url);
const __dirname = cjsPath.dirname(__filename);
// -- End Shims --


var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var indexMinimal = {};

var minimal$1 = {};

var aspromise;
var hasRequiredAspromise;

function requireAspromise () {
	if (hasRequiredAspromise) return aspromise;
	hasRequiredAspromise = 1;
	aspromise = asPromise;

	/**
	 * Callback as used by {@link util.asPromise}.
	 * @typedef asPromiseCallback
	 * @type {function}
	 * @param {Error|null} error Error, if any
	 * @param {...*} params Additional arguments
	 * @returns {undefined}
	 */

	/**
	 * Returns a promise from a node-style callback function.
	 * @memberof util
	 * @param {asPromiseCallback} fn Function to call
	 * @param {*} ctx Function context
	 * @param {...*} params Function arguments
	 * @returns {Promise<*>} Promisified function
	 */
	function asPromise(fn, ctx/*, varargs */) {
	    var params  = new Array(arguments.length - 1),
	        offset  = 0,
	        index   = 2,
	        pending = true;
	    while (index < arguments.length)
	        params[offset++] = arguments[index++];
	    return new Promise(function executor(resolve, reject) {
	        params[offset] = function callback(err/*, varargs */) {
	            if (pending) {
	                pending = false;
	                if (err)
	                    reject(err);
	                else {
	                    var params = new Array(arguments.length - 1),
	                        offset = 0;
	                    while (offset < params.length)
	                        params[offset++] = arguments[offset];
	                    resolve.apply(null, params);
	                }
	            }
	        };
	        try {
	            fn.apply(ctx || null, params);
	        } catch (err) {
	            if (pending) {
	                pending = false;
	                reject(err);
	            }
	        }
	    });
	}
	return aspromise;
}

var base64 = {};

var hasRequiredBase64;

function requireBase64 () {
	if (hasRequiredBase64) return base64;
	hasRequiredBase64 = 1;
	(function (exports) {

		/**
		 * A minimal base64 implementation for number arrays.
		 * @memberof util
		 * @namespace
		 */
		var base64 = exports;

		/**
		 * Calculates the byte length of a base64 encoded string.
		 * @param {string} string Base64 encoded string
		 * @returns {number} Byte length
		 */
		base64.length = function length(string) {
		    var p = string.length;
		    if (!p)
		        return 0;
		    var n = 0;
		    while (--p % 4 > 1 && string.charAt(p) === "=")
		        ++n;
		    return Math.ceil(string.length * 3) / 4 - n;
		};

		// Base64 encoding table
		var b64 = new Array(64);

		// Base64 decoding table
		var s64 = new Array(123);

		// 65..90, 97..122, 48..57, 43, 47
		for (var i = 0; i < 64;)
		    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

		/**
		 * Encodes a buffer to a base64 encoded string.
		 * @param {Uint8Array} buffer Source buffer
		 * @param {number} start Source start
		 * @param {number} end Source end
		 * @returns {string} Base64 encoded string
		 */
		base64.encode = function encode(buffer, start, end) {
		    var parts = null,
		        chunk = [];
		    var i = 0, // output index
		        j = 0, // goto index
		        t;     // temporary
		    while (start < end) {
		        var b = buffer[start++];
		        switch (j) {
		            case 0:
		                chunk[i++] = b64[b >> 2];
		                t = (b & 3) << 4;
		                j = 1;
		                break;
		            case 1:
		                chunk[i++] = b64[t | b >> 4];
		                t = (b & 15) << 2;
		                j = 2;
		                break;
		            case 2:
		                chunk[i++] = b64[t | b >> 6];
		                chunk[i++] = b64[b & 63];
		                j = 0;
		                break;
		        }
		        if (i > 8191) {
		            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
		            i = 0;
		        }
		    }
		    if (j) {
		        chunk[i++] = b64[t];
		        chunk[i++] = 61;
		        if (j === 1)
		            chunk[i++] = 61;
		    }
		    if (parts) {
		        if (i)
		            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
		        return parts.join("");
		    }
		    return String.fromCharCode.apply(String, chunk.slice(0, i));
		};

		var invalidEncoding = "invalid encoding";

		/**
		 * Decodes a base64 encoded string to a buffer.
		 * @param {string} string Source string
		 * @param {Uint8Array} buffer Destination buffer
		 * @param {number} offset Destination offset
		 * @returns {number} Number of bytes written
		 * @throws {Error} If encoding is invalid
		 */
		base64.decode = function decode(string, buffer, offset) {
		    var start = offset;
		    var j = 0, // goto index
		        t;     // temporary
		    for (var i = 0; i < string.length;) {
		        var c = string.charCodeAt(i++);
		        if (c === 61 && j > 1)
		            break;
		        if ((c = s64[c]) === undefined)
		            throw Error(invalidEncoding);
		        switch (j) {
		            case 0:
		                t = c;
		                j = 1;
		                break;
		            case 1:
		                buffer[offset++] = t << 2 | (c & 48) >> 4;
		                t = c;
		                j = 2;
		                break;
		            case 2:
		                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
		                t = c;
		                j = 3;
		                break;
		            case 3:
		                buffer[offset++] = (t & 3) << 6 | c;
		                j = 0;
		                break;
		        }
		    }
		    if (j === 1)
		        throw Error(invalidEncoding);
		    return offset - start;
		};

		/**
		 * Tests if the specified string appears to be base64 encoded.
		 * @param {string} string String to test
		 * @returns {boolean} `true` if probably base64 encoded, otherwise false
		 */
		base64.test = function test(string) {
		    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
		}; 
	} (base64));
	return base64;
}

var eventemitter;
var hasRequiredEventemitter;

function requireEventemitter () {
	if (hasRequiredEventemitter) return eventemitter;
	hasRequiredEventemitter = 1;
	eventemitter = EventEmitter;

	/**
	 * Constructs a new event emitter instance.
	 * @classdesc A minimal event emitter.
	 * @memberof util
	 * @constructor
	 */
	function EventEmitter() {

	    /**
	     * Registered listeners.
	     * @type {Object.<string,*>}
	     * @private
	     */
	    this._listeners = {};
	}

	/**
	 * Registers an event listener.
	 * @param {string} evt Event name
	 * @param {function} fn Listener
	 * @param {*} [ctx] Listener context
	 * @returns {util.EventEmitter} `this`
	 */
	EventEmitter.prototype.on = function on(evt, fn, ctx) {
	    (this._listeners[evt] || (this._listeners[evt] = [])).push({
	        fn  : fn,
	        ctx : ctx || this
	    });
	    return this;
	};

	/**
	 * Removes an event listener or any matching listeners if arguments are omitted.
	 * @param {string} [evt] Event name. Removes all listeners if omitted.
	 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
	 * @returns {util.EventEmitter} `this`
	 */
	EventEmitter.prototype.off = function off(evt, fn) {
	    if (evt === undefined)
	        this._listeners = {};
	    else {
	        if (fn === undefined)
	            this._listeners[evt] = [];
	        else {
	            var listeners = this._listeners[evt];
	            for (var i = 0; i < listeners.length;)
	                if (listeners[i].fn === fn)
	                    listeners.splice(i, 1);
	                else
	                    ++i;
	        }
	    }
	    return this;
	};

	/**
	 * Emits an event by calling its listeners with the specified arguments.
	 * @param {string} evt Event name
	 * @param {...*} args Arguments
	 * @returns {util.EventEmitter} `this`
	 */
	EventEmitter.prototype.emit = function emit(evt) {
	    var listeners = this._listeners[evt];
	    if (listeners) {
	        var args = [],
	            i = 1;
	        for (; i < arguments.length;)
	            args.push(arguments[i++]);
	        for (i = 0; i < listeners.length;)
	            listeners[i].fn.apply(listeners[i++].ctx, args);
	    }
	    return this;
	};
	return eventemitter;
}

var float;
var hasRequiredFloat;

function requireFloat () {
	if (hasRequiredFloat) return float;
	hasRequiredFloat = 1;

	float = factory(factory);

	/**
	 * Reads / writes floats / doubles from / to buffers.
	 * @name util.float
	 * @namespace
	 */

	/**
	 * Writes a 32 bit float to a buffer using little endian byte order.
	 * @name util.float.writeFloatLE
	 * @function
	 * @param {number} val Value to write
	 * @param {Uint8Array} buf Target buffer
	 * @param {number} pos Target buffer offset
	 * @returns {undefined}
	 */

	/**
	 * Writes a 32 bit float to a buffer using big endian byte order.
	 * @name util.float.writeFloatBE
	 * @function
	 * @param {number} val Value to write
	 * @param {Uint8Array} buf Target buffer
	 * @param {number} pos Target buffer offset
	 * @returns {undefined}
	 */

	/**
	 * Reads a 32 bit float from a buffer using little endian byte order.
	 * @name util.float.readFloatLE
	 * @function
	 * @param {Uint8Array} buf Source buffer
	 * @param {number} pos Source buffer offset
	 * @returns {number} Value read
	 */

	/**
	 * Reads a 32 bit float from a buffer using big endian byte order.
	 * @name util.float.readFloatBE
	 * @function
	 * @param {Uint8Array} buf Source buffer
	 * @param {number} pos Source buffer offset
	 * @returns {number} Value read
	 */

	/**
	 * Writes a 64 bit double to a buffer using little endian byte order.
	 * @name util.float.writeDoubleLE
	 * @function
	 * @param {number} val Value to write
	 * @param {Uint8Array} buf Target buffer
	 * @param {number} pos Target buffer offset
	 * @returns {undefined}
	 */

	/**
	 * Writes a 64 bit double to a buffer using big endian byte order.
	 * @name util.float.writeDoubleBE
	 * @function
	 * @param {number} val Value to write
	 * @param {Uint8Array} buf Target buffer
	 * @param {number} pos Target buffer offset
	 * @returns {undefined}
	 */

	/**
	 * Reads a 64 bit double from a buffer using little endian byte order.
	 * @name util.float.readDoubleLE
	 * @function
	 * @param {Uint8Array} buf Source buffer
	 * @param {number} pos Source buffer offset
	 * @returns {number} Value read
	 */

	/**
	 * Reads a 64 bit double from a buffer using big endian byte order.
	 * @name util.float.readDoubleBE
	 * @function
	 * @param {Uint8Array} buf Source buffer
	 * @param {number} pos Source buffer offset
	 * @returns {number} Value read
	 */

	// Factory function for the purpose of node-based testing in modified global environments
	function factory(exports) {

	    // float: typed array
	    if (typeof Float32Array !== "undefined") (function() {

	        var f32 = new Float32Array([ -0 ]),
	            f8b = new Uint8Array(f32.buffer),
	            le  = f8b[3] === 128;

	        function writeFloat_f32_cpy(val, buf, pos) {
	            f32[0] = val;
	            buf[pos    ] = f8b[0];
	            buf[pos + 1] = f8b[1];
	            buf[pos + 2] = f8b[2];
	            buf[pos + 3] = f8b[3];
	        }

	        function writeFloat_f32_rev(val, buf, pos) {
	            f32[0] = val;
	            buf[pos    ] = f8b[3];
	            buf[pos + 1] = f8b[2];
	            buf[pos + 2] = f8b[1];
	            buf[pos + 3] = f8b[0];
	        }

	        /* istanbul ignore next */
	        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
	        /* istanbul ignore next */
	        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

	        function readFloat_f32_cpy(buf, pos) {
	            f8b[0] = buf[pos    ];
	            f8b[1] = buf[pos + 1];
	            f8b[2] = buf[pos + 2];
	            f8b[3] = buf[pos + 3];
	            return f32[0];
	        }

	        function readFloat_f32_rev(buf, pos) {
	            f8b[3] = buf[pos    ];
	            f8b[2] = buf[pos + 1];
	            f8b[1] = buf[pos + 2];
	            f8b[0] = buf[pos + 3];
	            return f32[0];
	        }

	        /* istanbul ignore next */
	        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
	        /* istanbul ignore next */
	        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

	    // float: ieee754
	    })(); else (function() {

	        function writeFloat_ieee754(writeUint, val, buf, pos) {
	            var sign = val < 0 ? 1 : 0;
	            if (sign)
	                val = -val;
	            if (val === 0)
	                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
	            else if (isNaN(val))
	                writeUint(2143289344, buf, pos);
	            else if (val > 3.4028234663852886e+38) // +-Infinity
	                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
	            else if (val < 1.1754943508222875e-38) // denormal
	                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
	            else {
	                var exponent = Math.floor(Math.log(val) / Math.LN2),
	                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
	                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
	            }
	        }

	        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
	        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

	        function readFloat_ieee754(readUint, buf, pos) {
	            var uint = readUint(buf, pos),
	                sign = (uint >> 31) * 2 + 1,
	                exponent = uint >>> 23 & 255,
	                mantissa = uint & 8388607;
	            return exponent === 255
	                ? mantissa
	                ? NaN
	                : sign * Infinity
	                : exponent === 0 // denormal
	                ? sign * 1.401298464324817e-45 * mantissa
	                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
	        }

	        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
	        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

	    })();

	    // double: typed array
	    if (typeof Float64Array !== "undefined") (function() {

	        var f64 = new Float64Array([-0]),
	            f8b = new Uint8Array(f64.buffer),
	            le  = f8b[7] === 128;

	        function writeDouble_f64_cpy(val, buf, pos) {
	            f64[0] = val;
	            buf[pos    ] = f8b[0];
	            buf[pos + 1] = f8b[1];
	            buf[pos + 2] = f8b[2];
	            buf[pos + 3] = f8b[3];
	            buf[pos + 4] = f8b[4];
	            buf[pos + 5] = f8b[5];
	            buf[pos + 6] = f8b[6];
	            buf[pos + 7] = f8b[7];
	        }

	        function writeDouble_f64_rev(val, buf, pos) {
	            f64[0] = val;
	            buf[pos    ] = f8b[7];
	            buf[pos + 1] = f8b[6];
	            buf[pos + 2] = f8b[5];
	            buf[pos + 3] = f8b[4];
	            buf[pos + 4] = f8b[3];
	            buf[pos + 5] = f8b[2];
	            buf[pos + 6] = f8b[1];
	            buf[pos + 7] = f8b[0];
	        }

	        /* istanbul ignore next */
	        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
	        /* istanbul ignore next */
	        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

	        function readDouble_f64_cpy(buf, pos) {
	            f8b[0] = buf[pos    ];
	            f8b[1] = buf[pos + 1];
	            f8b[2] = buf[pos + 2];
	            f8b[3] = buf[pos + 3];
	            f8b[4] = buf[pos + 4];
	            f8b[5] = buf[pos + 5];
	            f8b[6] = buf[pos + 6];
	            f8b[7] = buf[pos + 7];
	            return f64[0];
	        }

	        function readDouble_f64_rev(buf, pos) {
	            f8b[7] = buf[pos    ];
	            f8b[6] = buf[pos + 1];
	            f8b[5] = buf[pos + 2];
	            f8b[4] = buf[pos + 3];
	            f8b[3] = buf[pos + 4];
	            f8b[2] = buf[pos + 5];
	            f8b[1] = buf[pos + 6];
	            f8b[0] = buf[pos + 7];
	            return f64[0];
	        }

	        /* istanbul ignore next */
	        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
	        /* istanbul ignore next */
	        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

	    // double: ieee754
	    })(); else (function() {

	        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
	            var sign = val < 0 ? 1 : 0;
	            if (sign)
	                val = -val;
	            if (val === 0) {
	                writeUint(0, buf, pos + off0);
	                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
	            } else if (isNaN(val)) {
	                writeUint(0, buf, pos + off0);
	                writeUint(2146959360, buf, pos + off1);
	            } else if (val > 1.7976931348623157e+308) { // +-Infinity
	                writeUint(0, buf, pos + off0);
	                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
	            } else {
	                var mantissa;
	                if (val < 2.2250738585072014e-308) { // denormal
	                    mantissa = val / 5e-324;
	                    writeUint(mantissa >>> 0, buf, pos + off0);
	                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
	                } else {
	                    var exponent = Math.floor(Math.log(val) / Math.LN2);
	                    if (exponent === 1024)
	                        exponent = 1023;
	                    mantissa = val * Math.pow(2, -exponent);
	                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
	                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
	                }
	            }
	        }

	        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
	        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

	        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
	            var lo = readUint(buf, pos + off0),
	                hi = readUint(buf, pos + off1);
	            var sign = (hi >> 31) * 2 + 1,
	                exponent = hi >>> 20 & 2047,
	                mantissa = 4294967296 * (hi & 1048575) + lo;
	            return exponent === 2047
	                ? mantissa
	                ? NaN
	                : sign * Infinity
	                : exponent === 0 // denormal
	                ? sign * 5e-324 * mantissa
	                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
	        }

	        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
	        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

	    })();

	    return exports;
	}

	// uint helpers

	function writeUintLE(val, buf, pos) {
	    buf[pos    ] =  val        & 255;
	    buf[pos + 1] =  val >>> 8  & 255;
	    buf[pos + 2] =  val >>> 16 & 255;
	    buf[pos + 3] =  val >>> 24;
	}

	function writeUintBE(val, buf, pos) {
	    buf[pos    ] =  val >>> 24;
	    buf[pos + 1] =  val >>> 16 & 255;
	    buf[pos + 2] =  val >>> 8  & 255;
	    buf[pos + 3] =  val        & 255;
	}

	function readUintLE(buf, pos) {
	    return (buf[pos    ]
	          | buf[pos + 1] << 8
	          | buf[pos + 2] << 16
	          | buf[pos + 3] << 24) >>> 0;
	}

	function readUintBE(buf, pos) {
	    return (buf[pos    ] << 24
	          | buf[pos + 1] << 16
	          | buf[pos + 2] << 8
	          | buf[pos + 3]) >>> 0;
	}
	return float;
}

var inquire_1;
var hasRequiredInquire;

function requireInquire () {
	if (hasRequiredInquire) return inquire_1;
	hasRequiredInquire = 1;
	inquire_1 = inquire;

	/**
	 * Requires a module only if available.
	 * @memberof util
	 * @param {string} moduleName Module to require
	 * @returns {?Object} Required module if available and not empty, otherwise `null`
	 */
	function inquire(moduleName) {
	    try {
	        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
	        if (mod && (mod.length || Object.keys(mod).length))
	            return mod;
	    } catch (e) {} // eslint-disable-line no-empty
	    return null;
	}
	return inquire_1;
}

var utf8 = {};

var hasRequiredUtf8;

function requireUtf8 () {
	if (hasRequiredUtf8) return utf8;
	hasRequiredUtf8 = 1;
	(function (exports) {

		/**
		 * A minimal UTF8 implementation for number arrays.
		 * @memberof util
		 * @namespace
		 */
		var utf8 = exports;

		/**
		 * Calculates the UTF8 byte length of a string.
		 * @param {string} string String
		 * @returns {number} Byte length
		 */
		utf8.length = function utf8_length(string) {
		    var len = 0,
		        c = 0;
		    for (var i = 0; i < string.length; ++i) {
		        c = string.charCodeAt(i);
		        if (c < 128)
		            len += 1;
		        else if (c < 2048)
		            len += 2;
		        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
		            ++i;
		            len += 4;
		        } else
		            len += 3;
		    }
		    return len;
		};

		/**
		 * Reads UTF8 bytes as a string.
		 * @param {Uint8Array} buffer Source buffer
		 * @param {number} start Source start
		 * @param {number} end Source end
		 * @returns {string} String read
		 */
		utf8.read = function utf8_read(buffer, start, end) {
		    var len = end - start;
		    if (len < 1)
		        return "";
		    var parts = null,
		        chunk = [],
		        i = 0, // char offset
		        t;     // temporary
		    while (start < end) {
		        t = buffer[start++];
		        if (t < 128)
		            chunk[i++] = t;
		        else if (t > 191 && t < 224)
		            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
		        else if (t > 239 && t < 365) {
		            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
		            chunk[i++] = 0xD800 + (t >> 10);
		            chunk[i++] = 0xDC00 + (t & 1023);
		        } else
		            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
		        if (i > 8191) {
		            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
		            i = 0;
		        }
		    }
		    if (parts) {
		        if (i)
		            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
		        return parts.join("");
		    }
		    return String.fromCharCode.apply(String, chunk.slice(0, i));
		};

		/**
		 * Writes a string as UTF8 bytes.
		 * @param {string} string Source string
		 * @param {Uint8Array} buffer Destination buffer
		 * @param {number} offset Destination offset
		 * @returns {number} Bytes written
		 */
		utf8.write = function utf8_write(string, buffer, offset) {
		    var start = offset,
		        c1, // character 1
		        c2; // character 2
		    for (var i = 0; i < string.length; ++i) {
		        c1 = string.charCodeAt(i);
		        if (c1 < 128) {
		            buffer[offset++] = c1;
		        } else if (c1 < 2048) {
		            buffer[offset++] = c1 >> 6       | 192;
		            buffer[offset++] = c1       & 63 | 128;
		        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
		            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
		            ++i;
		            buffer[offset++] = c1 >> 18      | 240;
		            buffer[offset++] = c1 >> 12 & 63 | 128;
		            buffer[offset++] = c1 >> 6  & 63 | 128;
		            buffer[offset++] = c1       & 63 | 128;
		        } else {
		            buffer[offset++] = c1 >> 12      | 224;
		            buffer[offset++] = c1 >> 6  & 63 | 128;
		            buffer[offset++] = c1       & 63 | 128;
		        }
		    }
		    return offset - start;
		}; 
	} (utf8));
	return utf8;
}

var pool_1;
var hasRequiredPool;

function requirePool () {
	if (hasRequiredPool) return pool_1;
	hasRequiredPool = 1;
	pool_1 = pool;

	/**
	 * An allocator as used by {@link util.pool}.
	 * @typedef PoolAllocator
	 * @type {function}
	 * @param {number} size Buffer size
	 * @returns {Uint8Array} Buffer
	 */

	/**
	 * A slicer as used by {@link util.pool}.
	 * @typedef PoolSlicer
	 * @type {function}
	 * @param {number} start Start offset
	 * @param {number} end End offset
	 * @returns {Uint8Array} Buffer slice
	 * @this {Uint8Array}
	 */

	/**
	 * A general purpose buffer pool.
	 * @memberof util
	 * @function
	 * @param {PoolAllocator} alloc Allocator
	 * @param {PoolSlicer} slice Slicer
	 * @param {number} [size=8192] Slab size
	 * @returns {PoolAllocator} Pooled allocator
	 */
	function pool(alloc, slice, size) {
	    var SIZE   = size || 8192;
	    var MAX    = SIZE >>> 1;
	    var slab   = null;
	    var offset = SIZE;
	    return function pool_alloc(size) {
	        if (size < 1 || size > MAX)
	            return alloc(size);
	        if (offset + size > SIZE) {
	            slab = alloc(SIZE);
	            offset = 0;
	        }
	        var buf = slice.call(slab, offset, offset += size);
	        if (offset & 7) // align to 32 bit
	            offset = (offset | 7) + 1;
	        return buf;
	    };
	}
	return pool_1;
}

var longbits;
var hasRequiredLongbits;

function requireLongbits () {
	if (hasRequiredLongbits) return longbits;
	hasRequiredLongbits = 1;
	longbits = LongBits;

	var util = requireMinimal$1();

	/**
	 * Constructs new long bits.
	 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
	 * @memberof util
	 * @constructor
	 * @param {number} lo Low 32 bits, unsigned
	 * @param {number} hi High 32 bits, unsigned
	 */
	function LongBits(lo, hi) {

	    // note that the casts below are theoretically unnecessary as of today, but older statically
	    // generated converter code might still call the ctor with signed 32bits. kept for compat.

	    /**
	     * Low bits.
	     * @type {number}
	     */
	    this.lo = lo >>> 0;

	    /**
	     * High bits.
	     * @type {number}
	     */
	    this.hi = hi >>> 0;
	}

	/**
	 * Zero bits.
	 * @memberof util.LongBits
	 * @type {util.LongBits}
	 */
	var zero = LongBits.zero = new LongBits(0, 0);

	zero.toNumber = function() { return 0; };
	zero.zzEncode = zero.zzDecode = function() { return this; };
	zero.length = function() { return 1; };

	/**
	 * Zero hash.
	 * @memberof util.LongBits
	 * @type {string}
	 */
	var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

	/**
	 * Constructs new long bits from the specified number.
	 * @param {number} value Value
	 * @returns {util.LongBits} Instance
	 */
	LongBits.fromNumber = function fromNumber(value) {
	    if (value === 0)
	        return zero;
	    var sign = value < 0;
	    if (sign)
	        value = -value;
	    var lo = value >>> 0,
	        hi = (value - lo) / 4294967296 >>> 0;
	    if (sign) {
	        hi = ~hi >>> 0;
	        lo = ~lo >>> 0;
	        if (++lo > 4294967295) {
	            lo = 0;
	            if (++hi > 4294967295)
	                hi = 0;
	        }
	    }
	    return new LongBits(lo, hi);
	};

	/**
	 * Constructs new long bits from a number, long or string.
	 * @param {Long|number|string} value Value
	 * @returns {util.LongBits} Instance
	 */
	LongBits.from = function from(value) {
	    if (typeof value === "number")
	        return LongBits.fromNumber(value);
	    if (util.isString(value)) {
	        /* istanbul ignore else */
	        if (util.Long)
	            value = util.Long.fromString(value);
	        else
	            return LongBits.fromNumber(parseInt(value, 10));
	    }
	    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
	};

	/**
	 * Converts this long bits to a possibly unsafe JavaScript number.
	 * @param {boolean} [unsigned=false] Whether unsigned or not
	 * @returns {number} Possibly unsafe number
	 */
	LongBits.prototype.toNumber = function toNumber(unsigned) {
	    if (!unsigned && this.hi >>> 31) {
	        var lo = ~this.lo + 1 >>> 0,
	            hi = ~this.hi     >>> 0;
	        if (!lo)
	            hi = hi + 1 >>> 0;
	        return -(lo + hi * 4294967296);
	    }
	    return this.lo + this.hi * 4294967296;
	};

	/**
	 * Converts this long bits to a long.
	 * @param {boolean} [unsigned=false] Whether unsigned or not
	 * @returns {Long} Long
	 */
	LongBits.prototype.toLong = function toLong(unsigned) {
	    return util.Long
	        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
	        /* istanbul ignore next */
	        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
	};

	var charCodeAt = String.prototype.charCodeAt;

	/**
	 * Constructs new long bits from the specified 8 characters long hash.
	 * @param {string} hash Hash
	 * @returns {util.LongBits} Bits
	 */
	LongBits.fromHash = function fromHash(hash) {
	    if (hash === zeroHash)
	        return zero;
	    return new LongBits(
	        ( charCodeAt.call(hash, 0)
	        | charCodeAt.call(hash, 1) << 8
	        | charCodeAt.call(hash, 2) << 16
	        | charCodeAt.call(hash, 3) << 24) >>> 0
	    ,
	        ( charCodeAt.call(hash, 4)
	        | charCodeAt.call(hash, 5) << 8
	        | charCodeAt.call(hash, 6) << 16
	        | charCodeAt.call(hash, 7) << 24) >>> 0
	    );
	};

	/**
	 * Converts this long bits to a 8 characters long hash.
	 * @returns {string} Hash
	 */
	LongBits.prototype.toHash = function toHash() {
	    return String.fromCharCode(
	        this.lo        & 255,
	        this.lo >>> 8  & 255,
	        this.lo >>> 16 & 255,
	        this.lo >>> 24      ,
	        this.hi        & 255,
	        this.hi >>> 8  & 255,
	        this.hi >>> 16 & 255,
	        this.hi >>> 24
	    );
	};

	/**
	 * Zig-zag encodes this long bits.
	 * @returns {util.LongBits} `this`
	 */
	LongBits.prototype.zzEncode = function zzEncode() {
	    var mask =   this.hi >> 31;
	    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
	    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
	    return this;
	};

	/**
	 * Zig-zag decodes this long bits.
	 * @returns {util.LongBits} `this`
	 */
	LongBits.prototype.zzDecode = function zzDecode() {
	    var mask = -(this.lo & 1);
	    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
	    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
	    return this;
	};

	/**
	 * Calculates the length of this longbits when encoded as a varint.
	 * @returns {number} Length
	 */
	LongBits.prototype.length = function length() {
	    var part0 =  this.lo,
	        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
	        part2 =  this.hi >>> 24;
	    return part2 === 0
	         ? part1 === 0
	           ? part0 < 16384
	             ? part0 < 128 ? 1 : 2
	             : part0 < 2097152 ? 3 : 4
	           : part1 < 16384
	             ? part1 < 128 ? 5 : 6
	             : part1 < 2097152 ? 7 : 8
	         : part2 < 128 ? 9 : 10;
	};
	return longbits;
}

var hasRequiredMinimal$1;

function requireMinimal$1 () {
	if (hasRequiredMinimal$1) return minimal$1;
	hasRequiredMinimal$1 = 1;
	(function (exports) {
		var util = exports;

		// used to return a Promise where callback is omitted
		util.asPromise = requireAspromise();

		// converts to / from base64 encoded strings
		util.base64 = requireBase64();

		// base class of rpc.Service
		util.EventEmitter = requireEventemitter();

		// float handling accross browsers
		util.float = requireFloat();

		// requires modules optionally and hides the call from bundlers
		util.inquire = requireInquire();

		// converts to / from utf8 encoded strings
		util.utf8 = requireUtf8();

		// provides a node-like buffer pool in the browser
		util.pool = requirePool();

		// utility to work with the low and high bits of a 64 bit value
		util.LongBits = requireLongbits();

		/**
		 * Whether running within node or not.
		 * @memberof util
		 * @type {boolean}
		 */
		util.isNode = Boolean(typeof commonjsGlobal !== "undefined"
		                   && commonjsGlobal
		                   && commonjsGlobal.process
		                   && commonjsGlobal.process.versions
		                   && commonjsGlobal.process.versions.node);

		/**
		 * Global object reference.
		 * @memberof util
		 * @type {Object}
		 */
		util.global = util.isNode && commonjsGlobal
		           || typeof window !== "undefined" && window
		           || typeof self   !== "undefined" && self
		           || commonjsGlobal; // eslint-disable-line no-invalid-this

		/**
		 * An immuable empty array.
		 * @memberof util
		 * @type {Array.<*>}
		 * @const
		 */
		util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

		/**
		 * An immutable empty object.
		 * @type {Object}
		 * @const
		 */
		util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

		/**
		 * Tests if the specified value is an integer.
		 * @function
		 * @param {*} value Value to test
		 * @returns {boolean} `true` if the value is an integer
		 */
		util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
		    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
		};

		/**
		 * Tests if the specified value is a string.
		 * @param {*} value Value to test
		 * @returns {boolean} `true` if the value is a string
		 */
		util.isString = function isString(value) {
		    return typeof value === "string" || value instanceof String;
		};

		/**
		 * Tests if the specified value is a non-null object.
		 * @param {*} value Value to test
		 * @returns {boolean} `true` if the value is a non-null object
		 */
		util.isObject = function isObject(value) {
		    return value && typeof value === "object";
		};

		/**
		 * Checks if a property on a message is considered to be present.
		 * This is an alias of {@link util.isSet}.
		 * @function
		 * @param {Object} obj Plain object or message instance
		 * @param {string} prop Property name
		 * @returns {boolean} `true` if considered to be present, otherwise `false`
		 */
		util.isset =

		/**
		 * Checks if a property on a message is considered to be present.
		 * @param {Object} obj Plain object or message instance
		 * @param {string} prop Property name
		 * @returns {boolean} `true` if considered to be present, otherwise `false`
		 */
		util.isSet = function isSet(obj, prop) {
		    var value = obj[prop];
		    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
		        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
		    return false;
		};

		/**
		 * Any compatible Buffer instance.
		 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
		 * @interface Buffer
		 * @extends Uint8Array
		 */

		/**
		 * Node's Buffer class if available.
		 * @type {Constructor<Buffer>}
		 */
		util.Buffer = (function() {
		    try {
		        var Buffer = util.inquire("buffer").Buffer;
		        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
		        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
		    } catch (e) {
		        /* istanbul ignore next */
		        return null;
		    }
		})();

		// Internal alias of or polyfull for Buffer.from.
		util._Buffer_from = null;

		// Internal alias of or polyfill for Buffer.allocUnsafe.
		util._Buffer_allocUnsafe = null;

		/**
		 * Creates a new buffer of whatever type supported by the environment.
		 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
		 * @returns {Uint8Array|Buffer} Buffer
		 */
		util.newBuffer = function newBuffer(sizeOrArray) {
		    /* istanbul ignore next */
		    return typeof sizeOrArray === "number"
		        ? util.Buffer
		            ? util._Buffer_allocUnsafe(sizeOrArray)
		            : new util.Array(sizeOrArray)
		        : util.Buffer
		            ? util._Buffer_from(sizeOrArray)
		            : typeof Uint8Array === "undefined"
		                ? sizeOrArray
		                : new Uint8Array(sizeOrArray);
		};

		/**
		 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
		 * @type {Constructor<Uint8Array>}
		 */
		util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

		/**
		 * Any compatible Long instance.
		 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
		 * @interface Long
		 * @property {number} low Low bits
		 * @property {number} high High bits
		 * @property {boolean} unsigned Whether unsigned or not
		 */

		/**
		 * Long.js's Long class if available.
		 * @type {Constructor<Long>}
		 */
		util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
		         || /* istanbul ignore next */ util.global.Long
		         || util.inquire("long");

		/**
		 * Regular expression used to verify 2 bit (`bool`) map keys.
		 * @type {RegExp}
		 * @const
		 */
		util.key2Re = /^true|false|0|1$/;

		/**
		 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
		 * @type {RegExp}
		 * @const
		 */
		util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

		/**
		 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
		 * @type {RegExp}
		 * @const
		 */
		util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

		/**
		 * Converts a number or long to an 8 characters long hash string.
		 * @param {Long|number} value Value to convert
		 * @returns {string} Hash
		 */
		util.longToHash = function longToHash(value) {
		    return value
		        ? util.LongBits.from(value).toHash()
		        : util.LongBits.zeroHash;
		};

		/**
		 * Converts an 8 characters long hash string to a long or number.
		 * @param {string} hash Hash
		 * @param {boolean} [unsigned=false] Whether unsigned or not
		 * @returns {Long|number} Original value
		 */
		util.longFromHash = function longFromHash(hash, unsigned) {
		    var bits = util.LongBits.fromHash(hash);
		    if (util.Long)
		        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
		    return bits.toNumber(Boolean(unsigned));
		};

		/**
		 * Merges the properties of the source object into the destination object.
		 * @memberof util
		 * @param {Object.<string,*>} dst Destination object
		 * @param {Object.<string,*>} src Source object
		 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
		 * @returns {Object.<string,*>} Destination object
		 */
		function merge(dst, src, ifNotSet) { // used by converters
		    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
		        if (dst[keys[i]] === undefined || !ifNotSet)
		            dst[keys[i]] = src[keys[i]];
		    return dst;
		}

		util.merge = merge;

		/**
		 * Converts the first character of a string to lower case.
		 * @param {string} str String to convert
		 * @returns {string} Converted string
		 */
		util.lcFirst = function lcFirst(str) {
		    return str.charAt(0).toLowerCase() + str.substring(1);
		};

		/**
		 * Creates a custom error constructor.
		 * @memberof util
		 * @param {string} name Error name
		 * @returns {Constructor<Error>} Custom error constructor
		 */
		function newError(name) {

		    function CustomError(message, properties) {

		        if (!(this instanceof CustomError))
		            return new CustomError(message, properties);

		        // Error.call(this, message);
		        // ^ just returns a new error instance because the ctor can be called as a function

		        Object.defineProperty(this, "message", { get: function() { return message; } });

		        /* istanbul ignore next */
		        if (Error.captureStackTrace) // node
		            Error.captureStackTrace(this, CustomError);
		        else
		            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

		        if (properties)
		            merge(this, properties);
		    }

		    CustomError.prototype = Object.create(Error.prototype, {
		        constructor: {
		            value: CustomError,
		            writable: true,
		            enumerable: false,
		            configurable: true,
		        },
		        name: {
		            get: function get() { return name; },
		            set: undefined,
		            enumerable: false,
		            // configurable: false would accurately preserve the behavior of
		            // the original, but I'm guessing that was not intentional.
		            // For an actual error subclass, this property would
		            // be configurable.
		            configurable: true,
		        },
		        toString: {
		            value: function value() { return this.name + ": " + this.message; },
		            writable: true,
		            enumerable: false,
		            configurable: true,
		        },
		    });

		    return CustomError;
		}

		util.newError = newError;

		/**
		 * Constructs a new protocol error.
		 * @classdesc Error subclass indicating a protocol specifc error.
		 * @memberof util
		 * @extends Error
		 * @template T extends Message<T>
		 * @constructor
		 * @param {string} message Error message
		 * @param {Object.<string,*>} [properties] Additional properties
		 * @example
		 * try {
		 *     MyMessage.decode(someBuffer); // throws if required fields are missing
		 * } catch (e) {
		 *     if (e instanceof ProtocolError && e.instance)
		 *         console.log("decoded so far: " + JSON.stringify(e.instance));
		 * }
		 */
		util.ProtocolError = newError("ProtocolError");

		/**
		 * So far decoded message instance.
		 * @name util.ProtocolError#instance
		 * @type {Message<T>}
		 */

		/**
		 * A OneOf getter as returned by {@link util.oneOfGetter}.
		 * @typedef OneOfGetter
		 * @type {function}
		 * @returns {string|undefined} Set field name, if any
		 */

		/**
		 * Builds a getter for a oneof's present field name.
		 * @param {string[]} fieldNames Field names
		 * @returns {OneOfGetter} Unbound getter
		 */
		util.oneOfGetter = function getOneOf(fieldNames) {
		    var fieldMap = {};
		    for (var i = 0; i < fieldNames.length; ++i)
		        fieldMap[fieldNames[i]] = 1;

		    /**
		     * @returns {string|undefined} Set field name, if any
		     * @this Object
		     * @ignore
		     */
		    return function() { // eslint-disable-line consistent-return
		        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
		            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
		                return keys[i];
		    };
		};

		/**
		 * A OneOf setter as returned by {@link util.oneOfSetter}.
		 * @typedef OneOfSetter
		 * @type {function}
		 * @param {string|undefined} value Field name
		 * @returns {undefined}
		 */

		/**
		 * Builds a setter for a oneof's present field name.
		 * @param {string[]} fieldNames Field names
		 * @returns {OneOfSetter} Unbound setter
		 */
		util.oneOfSetter = function setOneOf(fieldNames) {

		    /**
		     * @param {string} name Field name
		     * @returns {undefined}
		     * @this Object
		     * @ignore
		     */
		    return function(name) {
		        for (var i = 0; i < fieldNames.length; ++i)
		            if (fieldNames[i] !== name)
		                delete this[fieldNames[i]];
		    };
		};

		/**
		 * Default conversion options used for {@link Message#toJSON} implementations.
		 *
		 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
		 *
		 * - Longs become strings
		 * - Enums become string keys
		 * - Bytes become base64 encoded strings
		 * - (Sub-)Messages become plain objects
		 * - Maps become plain objects with all string keys
		 * - Repeated fields become arrays
		 * - NaN and Infinity for float and double fields become strings
		 *
		 * @type {IConversionOptions}
		 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
		 */
		util.toJSONOptions = {
		    longs: String,
		    enums: String,
		    bytes: String,
		    json: true
		};

		// Sets up buffer utility according to the environment (called in index-minimal)
		util._configure = function() {
		    var Buffer = util.Buffer;
		    /* istanbul ignore if */
		    if (!Buffer) {
		        util._Buffer_from = util._Buffer_allocUnsafe = null;
		        return;
		    }
		    // because node 4.x buffers are incompatible & immutable
		    // see: https://github.com/dcodeIO/protobuf.js/pull/665
		    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
		        /* istanbul ignore next */
		        function Buffer_from(value, encoding) {
		            return new Buffer(value, encoding);
		        };
		    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
		        /* istanbul ignore next */
		        function Buffer_allocUnsafe(size) {
		            return new Buffer(size);
		        };
		}; 
	} (minimal$1));
	return minimal$1;
}

var writer;
var hasRequiredWriter;

function requireWriter () {
	if (hasRequiredWriter) return writer;
	hasRequiredWriter = 1;
	writer = Writer;

	var util      = requireMinimal$1();

	var BufferWriter; // cyclic

	var LongBits  = util.LongBits,
	    base64    = util.base64,
	    utf8      = util.utf8;

	/**
	 * Constructs a new writer operation instance.
	 * @classdesc Scheduled writer operation.
	 * @constructor
	 * @param {function(*, Uint8Array, number)} fn Function to call
	 * @param {number} len Value byte length
	 * @param {*} val Value to write
	 * @ignore
	 */
	function Op(fn, len, val) {

	    /**
	     * Function to call.
	     * @type {function(Uint8Array, number, *)}
	     */
	    this.fn = fn;

	    /**
	     * Value byte length.
	     * @type {number}
	     */
	    this.len = len;

	    /**
	     * Next operation.
	     * @type {Writer.Op|undefined}
	     */
	    this.next = undefined;

	    /**
	     * Value to write.
	     * @type {*}
	     */
	    this.val = val; // type varies
	}

	/* istanbul ignore next */
	function noop() {} // eslint-disable-line no-empty-function

	/**
	 * Constructs a new writer state instance.
	 * @classdesc Copied writer state.
	 * @memberof Writer
	 * @constructor
	 * @param {Writer} writer Writer to copy state from
	 * @ignore
	 */
	function State(writer) {

	    /**
	     * Current head.
	     * @type {Writer.Op}
	     */
	    this.head = writer.head;

	    /**
	     * Current tail.
	     * @type {Writer.Op}
	     */
	    this.tail = writer.tail;

	    /**
	     * Current buffer length.
	     * @type {number}
	     */
	    this.len = writer.len;

	    /**
	     * Next state.
	     * @type {State|null}
	     */
	    this.next = writer.states;
	}

	/**
	 * Constructs a new writer instance.
	 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
	 * @constructor
	 */
	function Writer() {

	    /**
	     * Current length.
	     * @type {number}
	     */
	    this.len = 0;

	    /**
	     * Operations head.
	     * @type {Object}
	     */
	    this.head = new Op(noop, 0, 0);

	    /**
	     * Operations tail
	     * @type {Object}
	     */
	    this.tail = this.head;

	    /**
	     * Linked forked states.
	     * @type {Object|null}
	     */
	    this.states = null;

	    // When a value is written, the writer calculates its byte length and puts it into a linked
	    // list of operations to perform when finish() is called. This both allows us to allocate
	    // buffers of the exact required size and reduces the amount of work we have to do compared
	    // to first calculating over objects and then encoding over objects. In our case, the encoding
	    // part is just a linked list walk calling operations with already prepared values.
	}

	var create = function create() {
	    return util.Buffer
	        ? function create_buffer_setup() {
	            return (Writer.create = function create_buffer() {
	                return new BufferWriter();
	            })();
	        }
	        /* istanbul ignore next */
	        : function create_array() {
	            return new Writer();
	        };
	};

	/**
	 * Creates a new writer.
	 * @function
	 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
	 */
	Writer.create = create();

	/**
	 * Allocates a buffer of the specified size.
	 * @param {number} size Buffer size
	 * @returns {Uint8Array} Buffer
	 */
	Writer.alloc = function alloc(size) {
	    return new util.Array(size);
	};

	// Use Uint8Array buffer pool in the browser, just like node does with buffers
	/* istanbul ignore else */
	if (util.Array !== Array)
	    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

	/**
	 * Pushes a new operation to the queue.
	 * @param {function(Uint8Array, number, *)} fn Function to call
	 * @param {number} len Value byte length
	 * @param {number} val Value to write
	 * @returns {Writer} `this`
	 * @private
	 */
	Writer.prototype._push = function push(fn, len, val) {
	    this.tail = this.tail.next = new Op(fn, len, val);
	    this.len += len;
	    return this;
	};

	function writeByte(val, buf, pos) {
	    buf[pos] = val & 255;
	}

	function writeVarint32(val, buf, pos) {
	    while (val > 127) {
	        buf[pos++] = val & 127 | 128;
	        val >>>= 7;
	    }
	    buf[pos] = val;
	}

	/**
	 * Constructs a new varint writer operation instance.
	 * @classdesc Scheduled varint writer operation.
	 * @extends Op
	 * @constructor
	 * @param {number} len Value byte length
	 * @param {number} val Value to write
	 * @ignore
	 */
	function VarintOp(len, val) {
	    this.len = len;
	    this.next = undefined;
	    this.val = val;
	}

	VarintOp.prototype = Object.create(Op.prototype);
	VarintOp.prototype.fn = writeVarint32;

	/**
	 * Writes an unsigned 32 bit value as a varint.
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.uint32 = function write_uint32(value) {
	    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
	    // uint32 is by far the most frequently used operation and benefits significantly from this.
	    this.len += (this.tail = this.tail.next = new VarintOp(
	        (value = value >>> 0)
	                < 128       ? 1
	        : value < 16384     ? 2
	        : value < 2097152   ? 3
	        : value < 268435456 ? 4
	        :                     5,
	    value)).len;
	    return this;
	};

	/**
	 * Writes a signed 32 bit value as a varint.
	 * @function
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.int32 = function write_int32(value) {
	    return value < 0
	        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
	        : this.uint32(value);
	};

	/**
	 * Writes a 32 bit value as a varint, zig-zag encoded.
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.sint32 = function write_sint32(value) {
	    return this.uint32((value << 1 ^ value >> 31) >>> 0);
	};

	function writeVarint64(val, buf, pos) {
	    while (val.hi) {
	        buf[pos++] = val.lo & 127 | 128;
	        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
	        val.hi >>>= 7;
	    }
	    while (val.lo > 127) {
	        buf[pos++] = val.lo & 127 | 128;
	        val.lo = val.lo >>> 7;
	    }
	    buf[pos++] = val.lo;
	}

	/**
	 * Writes an unsigned 64 bit value as a varint.
	 * @param {Long|number|string} value Value to write
	 * @returns {Writer} `this`
	 * @throws {TypeError} If `value` is a string and no long library is present.
	 */
	Writer.prototype.uint64 = function write_uint64(value) {
	    var bits = LongBits.from(value);
	    return this._push(writeVarint64, bits.length(), bits);
	};

	/**
	 * Writes a signed 64 bit value as a varint.
	 * @function
	 * @param {Long|number|string} value Value to write
	 * @returns {Writer} `this`
	 * @throws {TypeError} If `value` is a string and no long library is present.
	 */
	Writer.prototype.int64 = Writer.prototype.uint64;

	/**
	 * Writes a signed 64 bit value as a varint, zig-zag encoded.
	 * @param {Long|number|string} value Value to write
	 * @returns {Writer} `this`
	 * @throws {TypeError} If `value` is a string and no long library is present.
	 */
	Writer.prototype.sint64 = function write_sint64(value) {
	    var bits = LongBits.from(value).zzEncode();
	    return this._push(writeVarint64, bits.length(), bits);
	};

	/**
	 * Writes a boolish value as a varint.
	 * @param {boolean} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.bool = function write_bool(value) {
	    return this._push(writeByte, 1, value ? 1 : 0);
	};

	function writeFixed32(val, buf, pos) {
	    buf[pos    ] =  val         & 255;
	    buf[pos + 1] =  val >>> 8   & 255;
	    buf[pos + 2] =  val >>> 16  & 255;
	    buf[pos + 3] =  val >>> 24;
	}

	/**
	 * Writes an unsigned 32 bit value as fixed 32 bits.
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.fixed32 = function write_fixed32(value) {
	    return this._push(writeFixed32, 4, value >>> 0);
	};

	/**
	 * Writes a signed 32 bit value as fixed 32 bits.
	 * @function
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.sfixed32 = Writer.prototype.fixed32;

	/**
	 * Writes an unsigned 64 bit value as fixed 64 bits.
	 * @param {Long|number|string} value Value to write
	 * @returns {Writer} `this`
	 * @throws {TypeError} If `value` is a string and no long library is present.
	 */
	Writer.prototype.fixed64 = function write_fixed64(value) {
	    var bits = LongBits.from(value);
	    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
	};

	/**
	 * Writes a signed 64 bit value as fixed 64 bits.
	 * @function
	 * @param {Long|number|string} value Value to write
	 * @returns {Writer} `this`
	 * @throws {TypeError} If `value` is a string and no long library is present.
	 */
	Writer.prototype.sfixed64 = Writer.prototype.fixed64;

	/**
	 * Writes a float (32 bit).
	 * @function
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.float = function write_float(value) {
	    return this._push(util.float.writeFloatLE, 4, value);
	};

	/**
	 * Writes a double (64 bit float).
	 * @function
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.double = function write_double(value) {
	    return this._push(util.float.writeDoubleLE, 8, value);
	};

	var writeBytes = util.Array.prototype.set
	    ? function writeBytes_set(val, buf, pos) {
	        buf.set(val, pos); // also works for plain array values
	    }
	    /* istanbul ignore next */
	    : function writeBytes_for(val, buf, pos) {
	        for (var i = 0; i < val.length; ++i)
	            buf[pos + i] = val[i];
	    };

	/**
	 * Writes a sequence of bytes.
	 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.bytes = function write_bytes(value) {
	    var len = value.length >>> 0;
	    if (!len)
	        return this._push(writeByte, 1, 0);
	    if (util.isString(value)) {
	        var buf = Writer.alloc(len = base64.length(value));
	        base64.decode(value, buf, 0);
	        value = buf;
	    }
	    return this.uint32(len)._push(writeBytes, len, value);
	};

	/**
	 * Writes a string.
	 * @param {string} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.string = function write_string(value) {
	    var len = utf8.length(value);
	    return len
	        ? this.uint32(len)._push(utf8.write, len, value)
	        : this._push(writeByte, 1, 0);
	};

	/**
	 * Forks this writer's state by pushing it to a stack.
	 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
	 * @returns {Writer} `this`
	 */
	Writer.prototype.fork = function fork() {
	    this.states = new State(this);
	    this.head = this.tail = new Op(noop, 0, 0);
	    this.len = 0;
	    return this;
	};

	/**
	 * Resets this instance to the last state.
	 * @returns {Writer} `this`
	 */
	Writer.prototype.reset = function reset() {
	    if (this.states) {
	        this.head   = this.states.head;
	        this.tail   = this.states.tail;
	        this.len    = this.states.len;
	        this.states = this.states.next;
	    } else {
	        this.head = this.tail = new Op(noop, 0, 0);
	        this.len  = 0;
	    }
	    return this;
	};

	/**
	 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
	 * @returns {Writer} `this`
	 */
	Writer.prototype.ldelim = function ldelim() {
	    var head = this.head,
	        tail = this.tail,
	        len  = this.len;
	    this.reset().uint32(len);
	    if (len) {
	        this.tail.next = head.next; // skip noop
	        this.tail = tail;
	        this.len += len;
	    }
	    return this;
	};

	/**
	 * Finishes the write operation.
	 * @returns {Uint8Array} Finished buffer
	 */
	Writer.prototype.finish = function finish() {
	    var head = this.head.next, // skip noop
	        buf  = this.constructor.alloc(this.len),
	        pos  = 0;
	    while (head) {
	        head.fn(head.val, buf, pos);
	        pos += head.len;
	        head = head.next;
	    }
	    // this.head = this.tail = null;
	    return buf;
	};

	Writer._configure = function(BufferWriter_) {
	    BufferWriter = BufferWriter_;
	    Writer.create = create();
	    BufferWriter._configure();
	};
	return writer;
}

var writer_buffer;
var hasRequiredWriter_buffer;

function requireWriter_buffer () {
	if (hasRequiredWriter_buffer) return writer_buffer;
	hasRequiredWriter_buffer = 1;
	writer_buffer = BufferWriter;

	// extends Writer
	var Writer = requireWriter();
	(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

	var util = requireMinimal$1();

	/**
	 * Constructs a new buffer writer instance.
	 * @classdesc Wire format writer using node buffers.
	 * @extends Writer
	 * @constructor
	 */
	function BufferWriter() {
	    Writer.call(this);
	}

	BufferWriter._configure = function () {
	    /**
	     * Allocates a buffer of the specified size.
	     * @function
	     * @param {number} size Buffer size
	     * @returns {Buffer} Buffer
	     */
	    BufferWriter.alloc = util._Buffer_allocUnsafe;

	    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
	        ? function writeBytesBuffer_set(val, buf, pos) {
	          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
	          // also works for plain array values
	        }
	        /* istanbul ignore next */
	        : function writeBytesBuffer_copy(val, buf, pos) {
	          if (val.copy) // Buffer values
	            val.copy(buf, pos, 0, val.length);
	          else for (var i = 0; i < val.length;) // plain array values
	            buf[pos++] = val[i++];
	        };
	};


	/**
	 * @override
	 */
	BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
	    if (util.isString(value))
	        value = util._Buffer_from(value, "base64");
	    var len = value.length >>> 0;
	    this.uint32(len);
	    if (len)
	        this._push(BufferWriter.writeBytesBuffer, len, value);
	    return this;
	};

	function writeStringBuffer(val, buf, pos) {
	    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
	        util.utf8.write(val, buf, pos);
	    else if (buf.utf8Write)
	        buf.utf8Write(val, pos);
	    else
	        buf.write(val, pos);
	}

	/**
	 * @override
	 */
	BufferWriter.prototype.string = function write_string_buffer(value) {
	    var len = util.Buffer.byteLength(value);
	    this.uint32(len);
	    if (len)
	        this._push(writeStringBuffer, len, value);
	    return this;
	};


	/**
	 * Finishes the write operation.
	 * @name BufferWriter#finish
	 * @function
	 * @returns {Buffer} Finished buffer
	 */

	BufferWriter._configure();
	return writer_buffer;
}

var reader;
var hasRequiredReader;

function requireReader () {
	if (hasRequiredReader) return reader;
	hasRequiredReader = 1;
	reader = Reader;

	var util      = requireMinimal$1();

	var BufferReader; // cyclic

	var LongBits  = util.LongBits,
	    utf8      = util.utf8;

	/* istanbul ignore next */
	function indexOutOfRange(reader, writeLength) {
	    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
	}

	/**
	 * Constructs a new reader instance using the specified buffer.
	 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
	 * @constructor
	 * @param {Uint8Array} buffer Buffer to read from
	 */
	function Reader(buffer) {

	    /**
	     * Read buffer.
	     * @type {Uint8Array}
	     */
	    this.buf = buffer;

	    /**
	     * Read buffer position.
	     * @type {number}
	     */
	    this.pos = 0;

	    /**
	     * Read buffer length.
	     * @type {number}
	     */
	    this.len = buffer.length;
	}

	var create_array = typeof Uint8Array !== "undefined"
	    ? function create_typed_array(buffer) {
	        if (buffer instanceof Uint8Array || Array.isArray(buffer))
	            return new Reader(buffer);
	        throw Error("illegal buffer");
	    }
	    /* istanbul ignore next */
	    : function create_array(buffer) {
	        if (Array.isArray(buffer))
	            return new Reader(buffer);
	        throw Error("illegal buffer");
	    };

	var create = function create() {
	    return util.Buffer
	        ? function create_buffer_setup(buffer) {
	            return (Reader.create = function create_buffer(buffer) {
	                return util.Buffer.isBuffer(buffer)
	                    ? new BufferReader(buffer)
	                    /* istanbul ignore next */
	                    : create_array(buffer);
	            })(buffer);
	        }
	        /* istanbul ignore next */
	        : create_array;
	};

	/**
	 * Creates a new reader using the specified buffer.
	 * @function
	 * @param {Uint8Array|Buffer} buffer Buffer to read from
	 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
	 * @throws {Error} If `buffer` is not a valid buffer
	 */
	Reader.create = create();

	Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

	/**
	 * Reads a varint as an unsigned 32 bit value.
	 * @function
	 * @returns {number} Value read
	 */
	Reader.prototype.uint32 = (function read_uint32_setup() {
	    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
	    return function read_uint32() {
	        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
	        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
	        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
	        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
	        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

	        /* istanbul ignore if */
	        if ((this.pos += 5) > this.len) {
	            this.pos = this.len;
	            throw indexOutOfRange(this, 10);
	        }
	        return value;
	    };
	})();

	/**
	 * Reads a varint as a signed 32 bit value.
	 * @returns {number} Value read
	 */
	Reader.prototype.int32 = function read_int32() {
	    return this.uint32() | 0;
	};

	/**
	 * Reads a zig-zag encoded varint as a signed 32 bit value.
	 * @returns {number} Value read
	 */
	Reader.prototype.sint32 = function read_sint32() {
	    var value = this.uint32();
	    return value >>> 1 ^ -(value & 1) | 0;
	};

	/* eslint-disable no-invalid-this */

	function readLongVarint() {
	    // tends to deopt with local vars for octet etc.
	    var bits = new LongBits(0, 0);
	    var i = 0;
	    if (this.len - this.pos > 4) { // fast route (lo)
	        for (; i < 4; ++i) {
	            // 1st..4th
	            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
	            if (this.buf[this.pos++] < 128)
	                return bits;
	        }
	        // 5th
	        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
	        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
	        if (this.buf[this.pos++] < 128)
	            return bits;
	        i = 0;
	    } else {
	        for (; i < 3; ++i) {
	            /* istanbul ignore if */
	            if (this.pos >= this.len)
	                throw indexOutOfRange(this);
	            // 1st..3th
	            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
	            if (this.buf[this.pos++] < 128)
	                return bits;
	        }
	        // 4th
	        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
	        return bits;
	    }
	    if (this.len - this.pos > 4) { // fast route (hi)
	        for (; i < 5; ++i) {
	            // 6th..10th
	            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
	            if (this.buf[this.pos++] < 128)
	                return bits;
	        }
	    } else {
	        for (; i < 5; ++i) {
	            /* istanbul ignore if */
	            if (this.pos >= this.len)
	                throw indexOutOfRange(this);
	            // 6th..10th
	            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
	            if (this.buf[this.pos++] < 128)
	                return bits;
	        }
	    }
	    /* istanbul ignore next */
	    throw Error("invalid varint encoding");
	}

	/* eslint-enable no-invalid-this */

	/**
	 * Reads a varint as a signed 64 bit value.
	 * @name Reader#int64
	 * @function
	 * @returns {Long} Value read
	 */

	/**
	 * Reads a varint as an unsigned 64 bit value.
	 * @name Reader#uint64
	 * @function
	 * @returns {Long} Value read
	 */

	/**
	 * Reads a zig-zag encoded varint as a signed 64 bit value.
	 * @name Reader#sint64
	 * @function
	 * @returns {Long} Value read
	 */

	/**
	 * Reads a varint as a boolean.
	 * @returns {boolean} Value read
	 */
	Reader.prototype.bool = function read_bool() {
	    return this.uint32() !== 0;
	};

	function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
	    return (buf[end - 4]
	          | buf[end - 3] << 8
	          | buf[end - 2] << 16
	          | buf[end - 1] << 24) >>> 0;
	}

	/**
	 * Reads fixed 32 bits as an unsigned 32 bit integer.
	 * @returns {number} Value read
	 */
	Reader.prototype.fixed32 = function read_fixed32() {

	    /* istanbul ignore if */
	    if (this.pos + 4 > this.len)
	        throw indexOutOfRange(this, 4);

	    return readFixed32_end(this.buf, this.pos += 4);
	};

	/**
	 * Reads fixed 32 bits as a signed 32 bit integer.
	 * @returns {number} Value read
	 */
	Reader.prototype.sfixed32 = function read_sfixed32() {

	    /* istanbul ignore if */
	    if (this.pos + 4 > this.len)
	        throw indexOutOfRange(this, 4);

	    return readFixed32_end(this.buf, this.pos += 4) | 0;
	};

	/* eslint-disable no-invalid-this */

	function readFixed64(/* this: Reader */) {

	    /* istanbul ignore if */
	    if (this.pos + 8 > this.len)
	        throw indexOutOfRange(this, 8);

	    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
	}

	/* eslint-enable no-invalid-this */

	/**
	 * Reads fixed 64 bits.
	 * @name Reader#fixed64
	 * @function
	 * @returns {Long} Value read
	 */

	/**
	 * Reads zig-zag encoded fixed 64 bits.
	 * @name Reader#sfixed64
	 * @function
	 * @returns {Long} Value read
	 */

	/**
	 * Reads a float (32 bit) as a number.
	 * @function
	 * @returns {number} Value read
	 */
	Reader.prototype.float = function read_float() {

	    /* istanbul ignore if */
	    if (this.pos + 4 > this.len)
	        throw indexOutOfRange(this, 4);

	    var value = util.float.readFloatLE(this.buf, this.pos);
	    this.pos += 4;
	    return value;
	};

	/**
	 * Reads a double (64 bit float) as a number.
	 * @function
	 * @returns {number} Value read
	 */
	Reader.prototype.double = function read_double() {

	    /* istanbul ignore if */
	    if (this.pos + 8 > this.len)
	        throw indexOutOfRange(this, 4);

	    var value = util.float.readDoubleLE(this.buf, this.pos);
	    this.pos += 8;
	    return value;
	};

	/**
	 * Reads a sequence of bytes preceeded by its length as a varint.
	 * @returns {Uint8Array} Value read
	 */
	Reader.prototype.bytes = function read_bytes() {
	    var length = this.uint32(),
	        start  = this.pos,
	        end    = this.pos + length;

	    /* istanbul ignore if */
	    if (end > this.len)
	        throw indexOutOfRange(this, length);

	    this.pos += length;
	    if (Array.isArray(this.buf)) // plain array
	        return this.buf.slice(start, end);

	    if (start === end) { // fix for IE 10/Win8 and others' subarray returning array of size 1
	        var nativeBuffer = util.Buffer;
	        return nativeBuffer
	            ? nativeBuffer.alloc(0)
	            : new this.buf.constructor(0);
	    }
	    return this._slice.call(this.buf, start, end);
	};

	/**
	 * Reads a string preceeded by its byte length as a varint.
	 * @returns {string} Value read
	 */
	Reader.prototype.string = function read_string() {
	    var bytes = this.bytes();
	    return utf8.read(bytes, 0, bytes.length);
	};

	/**
	 * Skips the specified number of bytes if specified, otherwise skips a varint.
	 * @param {number} [length] Length if known, otherwise a varint is assumed
	 * @returns {Reader} `this`
	 */
	Reader.prototype.skip = function skip(length) {
	    if (typeof length === "number") {
	        /* istanbul ignore if */
	        if (this.pos + length > this.len)
	            throw indexOutOfRange(this, length);
	        this.pos += length;
	    } else {
	        do {
	            /* istanbul ignore if */
	            if (this.pos >= this.len)
	                throw indexOutOfRange(this);
	        } while (this.buf[this.pos++] & 128);
	    }
	    return this;
	};

	/**
	 * Skips the next element of the specified wire type.
	 * @param {number} wireType Wire type received
	 * @returns {Reader} `this`
	 */
	Reader.prototype.skipType = function(wireType) {
	    switch (wireType) {
	        case 0:
	            this.skip();
	            break;
	        case 1:
	            this.skip(8);
	            break;
	        case 2:
	            this.skip(this.uint32());
	            break;
	        case 3:
	            while ((wireType = this.uint32() & 7) !== 4) {
	                this.skipType(wireType);
	            }
	            break;
	        case 5:
	            this.skip(4);
	            break;

	        /* istanbul ignore next */
	        default:
	            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
	    }
	    return this;
	};

	Reader._configure = function(BufferReader_) {
	    BufferReader = BufferReader_;
	    Reader.create = create();
	    BufferReader._configure();

	    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
	    util.merge(Reader.prototype, {

	        int64: function read_int64() {
	            return readLongVarint.call(this)[fn](false);
	        },

	        uint64: function read_uint64() {
	            return readLongVarint.call(this)[fn](true);
	        },

	        sint64: function read_sint64() {
	            return readLongVarint.call(this).zzDecode()[fn](false);
	        },

	        fixed64: function read_fixed64() {
	            return readFixed64.call(this)[fn](true);
	        },

	        sfixed64: function read_sfixed64() {
	            return readFixed64.call(this)[fn](false);
	        }

	    });
	};
	return reader;
}

var reader_buffer;
var hasRequiredReader_buffer;

function requireReader_buffer () {
	if (hasRequiredReader_buffer) return reader_buffer;
	hasRequiredReader_buffer = 1;
	reader_buffer = BufferReader;

	// extends Reader
	var Reader = requireReader();
	(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

	var util = requireMinimal$1();

	/**
	 * Constructs a new buffer reader instance.
	 * @classdesc Wire format reader using node buffers.
	 * @extends Reader
	 * @constructor
	 * @param {Buffer} buffer Buffer to read from
	 */
	function BufferReader(buffer) {
	    Reader.call(this, buffer);

	    /**
	     * Read buffer.
	     * @name BufferReader#buf
	     * @type {Buffer}
	     */
	}

	BufferReader._configure = function () {
	    /* istanbul ignore else */
	    if (util.Buffer)
	        BufferReader.prototype._slice = util.Buffer.prototype.slice;
	};


	/**
	 * @override
	 */
	BufferReader.prototype.string = function read_string_buffer() {
	    var len = this.uint32(); // modifies pos
	    return this.buf.utf8Slice
	        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
	        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
	};

	/**
	 * Reads a sequence of bytes preceeded by its length as a varint.
	 * @name BufferReader#bytes
	 * @function
	 * @returns {Buffer} Value read
	 */

	BufferReader._configure();
	return reader_buffer;
}

var rpc = {};

var service$1;
var hasRequiredService$1;

function requireService$1 () {
	if (hasRequiredService$1) return service$1;
	hasRequiredService$1 = 1;
	service$1 = Service;

	var util = requireMinimal$1();

	// Extends EventEmitter
	(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

	/**
	 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
	 *
	 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
	 * @typedef rpc.ServiceMethodCallback
	 * @template TRes extends Message<TRes>
	 * @type {function}
	 * @param {Error|null} error Error, if any
	 * @param {TRes} [response] Response message
	 * @returns {undefined}
	 */

	/**
	 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
	 * @typedef rpc.ServiceMethod
	 * @template TReq extends Message<TReq>
	 * @template TRes extends Message<TRes>
	 * @type {function}
	 * @param {TReq|Properties<TReq>} request Request message or plain object
	 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
	 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
	 */

	/**
	 * Constructs a new RPC service instance.
	 * @classdesc An RPC service as returned by {@link Service#create}.
	 * @exports rpc.Service
	 * @extends util.EventEmitter
	 * @constructor
	 * @param {RPCImpl} rpcImpl RPC implementation
	 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
	 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
	 */
	function Service(rpcImpl, requestDelimited, responseDelimited) {

	    if (typeof rpcImpl !== "function")
	        throw TypeError("rpcImpl must be a function");

	    util.EventEmitter.call(this);

	    /**
	     * RPC implementation. Becomes `null` once the service is ended.
	     * @type {RPCImpl|null}
	     */
	    this.rpcImpl = rpcImpl;

	    /**
	     * Whether requests are length-delimited.
	     * @type {boolean}
	     */
	    this.requestDelimited = Boolean(requestDelimited);

	    /**
	     * Whether responses are length-delimited.
	     * @type {boolean}
	     */
	    this.responseDelimited = Boolean(responseDelimited);
	}

	/**
	 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
	 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
	 * @param {Constructor<TReq>} requestCtor Request constructor
	 * @param {Constructor<TRes>} responseCtor Response constructor
	 * @param {TReq|Properties<TReq>} request Request message or plain object
	 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
	 * @returns {undefined}
	 * @template TReq extends Message<TReq>
	 * @template TRes extends Message<TRes>
	 */
	Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

	    if (!request)
	        throw TypeError("request must be specified");

	    var self = this;
	    if (!callback)
	        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

	    if (!self.rpcImpl) {
	        setTimeout(function() { callback(Error("already ended")); }, 0);
	        return undefined;
	    }

	    try {
	        return self.rpcImpl(
	            method,
	            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
	            function rpcCallback(err, response) {

	                if (err) {
	                    self.emit("error", err, method);
	                    return callback(err);
	                }

	                if (response === null) {
	                    self.end(/* endedByRPC */ true);
	                    return undefined;
	                }

	                if (!(response instanceof responseCtor)) {
	                    try {
	                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
	                    } catch (err) {
	                        self.emit("error", err, method);
	                        return callback(err);
	                    }
	                }

	                self.emit("data", response, method);
	                return callback(null, response);
	            }
	        );
	    } catch (err) {
	        self.emit("error", err, method);
	        setTimeout(function() { callback(err); }, 0);
	        return undefined;
	    }
	};

	/**
	 * Ends this service and emits the `end` event.
	 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
	 * @returns {rpc.Service} `this`
	 */
	Service.prototype.end = function end(endedByRPC) {
	    if (this.rpcImpl) {
	        if (!endedByRPC) // signal end to rpcImpl
	            this.rpcImpl(null, null, null);
	        this.rpcImpl = null;
	        this.emit("end").off();
	    }
	    return this;
	};
	return service$1;
}

var hasRequiredRpc;

function requireRpc () {
	if (hasRequiredRpc) return rpc;
	hasRequiredRpc = 1;
	(function (exports) {

		/**
		 * Streaming RPC helpers.
		 * @namespace
		 */
		var rpc = exports;

		/**
		 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
		 * @typedef RPCImpl
		 * @type {function}
		 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
		 * @param {Uint8Array} requestData Request data
		 * @param {RPCImplCallback} callback Callback function
		 * @returns {undefined}
		 * @example
		 * function rpcImpl(method, requestData, callback) {
		 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
		 *         throw Error("no such method");
		 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
		 *         callback(err, responseData);
		 *     });
		 * }
		 */

		/**
		 * Node-style callback as used by {@link RPCImpl}.
		 * @typedef RPCImplCallback
		 * @type {function}
		 * @param {Error|null} error Error, if any, otherwise `null`
		 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
		 * @returns {undefined}
		 */

		rpc.Service = requireService$1(); 
	} (rpc));
	return rpc;
}

var roots;
var hasRequiredRoots;

function requireRoots () {
	if (hasRequiredRoots) return roots;
	hasRequiredRoots = 1;
	roots = {};

	/**
	 * Named roots.
	 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
	 * Can also be used manually to make roots available across modules.
	 * @name roots
	 * @type {Object.<string,Root>}
	 * @example
	 * // pbjs -r myroot -o compiled.js ...
	 *
	 * // in another module:
	 * require("./compiled.js");
	 *
	 * // in any subsequent module:
	 * var root = protobuf.roots["myroot"];
	 */
	return roots;
}

var hasRequiredIndexMinimal;

function requireIndexMinimal () {
	if (hasRequiredIndexMinimal) return indexMinimal;
	hasRequiredIndexMinimal = 1;
	(function (exports) {
		var protobuf = exports;

		/**
		 * Build type, one of `"full"`, `"light"` or `"minimal"`.
		 * @name build
		 * @type {string}
		 * @const
		 */
		protobuf.build = "minimal";

		// Serialization
		protobuf.Writer       = requireWriter();
		protobuf.BufferWriter = requireWriter_buffer();
		protobuf.Reader       = requireReader();
		protobuf.BufferReader = requireReader_buffer();

		// Utility
		protobuf.util         = requireMinimal$1();
		protobuf.rpc          = requireRpc();
		protobuf.roots        = requireRoots();
		protobuf.configure    = configure;

		/* istanbul ignore next */
		/**
		 * Reconfigures the library according to the environment.
		 * @returns {undefined}
		 */
		function configure() {
		    protobuf.util._configure();
		    protobuf.Writer._configure(protobuf.BufferWriter);
		    protobuf.Reader._configure(protobuf.BufferReader);
		}

		// Set up buffer utility according to the environment
		configure(); 
	} (indexMinimal));
	return indexMinimal;
}

var minimal;
var hasRequiredMinimal;

function requireMinimal () {
	if (hasRequiredMinimal) return minimal;
	hasRequiredMinimal = 1;
	minimal = requireIndexMinimal();
	return minimal;
}

var minimalExports = requireMinimal();
const _m0 = /*@__PURE__*/getDefaultExportFromCjs(minimalExports);

/**
 * Tests if a value is a `function`.
 *
 * @param input - The value to test.
 *
 * @example
 * ```ts
 * import { isFunction } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isFunction(isFunction), true)
 * assert.deepStrictEqual(isFunction("function"), false)
 * ```
 *
 * @category guards
 * @since 2.0.0
 */
const isFunction$1 = input => typeof input === "function";
/**
 * Creates a function that can be used in a data-last (aka `pipe`able) or
 * data-first style.
 *
 * The first parameter to `dual` is either the arity of the uncurried function
 * or a predicate that determines if the function is being used in a data-first
 * or data-last style.
 *
 * Using the arity is the most common use case, but there are some cases where
 * you may want to use a predicate. For example, if you have a function that
 * takes an optional argument, you can use a predicate to determine if the
 * function is being used in a data-first or data-last style.
 *
 * @param arity - Either the arity of the uncurried function or a predicate
 *                which determines if the function is being used in a data-first
 *                or data-last style.
 * @param body - The definition of the uncurried function.
 *
 * @example
 * ```ts
 * import { dual, pipe } from "effect/Function"
 *
 * // Exampe using arity to determine data-first or data-last style
 * const sum: {
 *   (that: number): (self: number) => number
 *   (self: number, that: number): number
 * } = dual(2, (self: number, that: number): number => self + that)
 *
 * assert.deepStrictEqual(sum(2, 3), 5)
 * assert.deepStrictEqual(pipe(2, sum(3)), 5)
 *
 * // Example using a predicate to determine data-first or data-last style
 * const sum2: {
 *   (that: number): (self: number) => number
 *   (self: number, that: number): number
 * } = dual((args) => args.length === 1, (self: number, that: number): number => self + that)
 *
 * assert.deepStrictEqual(sum(2, 3), 5)
 * assert.deepStrictEqual(pipe(2, sum(3)), 5)
 * ```
 *
 * @since 2.0.0
 */
const dual = function (arity, body) {
  if (typeof arity === "function") {
    return function () {
      if (arity(arguments)) {
        // @ts-expect-error
        return body.apply(this, arguments);
      }
      return self => body(self, ...arguments);
    };
  }
  switch (arity) {
    case 0:
    case 1:
      throw new RangeError(`Invalid arity ${arity}`);
    case 2:
      return function (a, b) {
        if (arguments.length >= 2) {
          return body(a, b);
        }
        return function (self) {
          return body(self, a);
        };
      };
    case 3:
      return function (a, b, c) {
        if (arguments.length >= 3) {
          return body(a, b, c);
        }
        return function (self) {
          return body(self, a, b);
        };
      };
    case 4:
      return function (a, b, c, d) {
        if (arguments.length >= 4) {
          return body(a, b, c, d);
        }
        return function (self) {
          return body(self, a, b, c);
        };
      };
    case 5:
      return function (a, b, c, d, e) {
        if (arguments.length >= 5) {
          return body(a, b, c, d, e);
        }
        return function (self) {
          return body(self, a, b, c, d);
        };
      };
    default:
      return function () {
        if (arguments.length >= arity) {
          // @ts-expect-error
          return body.apply(this, arguments);
        }
        const args = arguments;
        return function (self) {
          return body(self, ...args);
        };
      };
  }
};
/**
 * The identity function, i.e. A function that returns its input argument.
 *
 * @param a - The input argument.
 *
 * @example
 * ```ts
 * import { identity } from "effect/Function"
 *
 * assert.deepStrictEqual(identity(5), 5)
 * ```
 *
 * @since 2.0.0
 */
const identity = a => a;
/**
 * Creates a constant value that never changes.
 *
 * This is useful when you want to pass a value to a higher-order function (a function that takes another function as its argument)
 * and want that inner function to always use the same value, no matter how many times it is called.
 *
 * @param value - The constant value to be returned.
 *
 * @example
 * ```ts
 * import { constant } from "effect/Function"
 *
 * const constNull = constant(null)
 *
 * assert.deepStrictEqual(constNull(), null)
 * assert.deepStrictEqual(constNull(), null)
 * ```
 *
 * @since 2.0.0
 */
const constant = value => () => value;
/**
 * A thunk that returns always `true`.
 *
 * @example
 * ```ts
 * import { constTrue } from "effect/Function"
 *
 * assert.deepStrictEqual(constTrue(), true)
 * ```
 *
 * @since 2.0.0
 */
const constTrue = /*#__PURE__*/constant(true);
/**
 * A thunk that returns always `false`.
 *
 * @example
 * ```ts
 * import { constFalse } from "effect/Function"
 *
 * assert.deepStrictEqual(constFalse(), false)
 * ```
 *
 * @since 2.0.0
 */
const constFalse = /*#__PURE__*/constant(false);
/**
 * A thunk that returns always `undefined`.
 *
 * @example
 * ```ts
 * import { constUndefined } from "effect/Function"
 *
 * assert.deepStrictEqual(constUndefined(), undefined)
 * ```
 *
 * @since 2.0.0
 */
const constUndefined = /*#__PURE__*/constant(undefined);
/**
 * A thunk that returns always `void`.
 *
 * @example
 * ```ts
 * import { constVoid } from "effect/Function"
 *
 * assert.deepStrictEqual(constVoid(), undefined)
 * ```
 *
 * @since 2.0.0
 */
const constVoid = constUndefined;
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default:
      {
        let ret = arguments[0];
        for (let i = 1; i < arguments.length; i++) {
          ret = arguments[i](ret);
        }
        return ret;
      }
  }
}

/**
 * This module provides an implementation of the `Equivalence` type class, which defines a binary relation
 * that is reflexive, symmetric, and transitive. In other words, it defines a notion of equivalence between values of a certain type.
 * These properties are also known in mathematics as an "equivalence relation".
 *
 * @since 2.0.0
 */
/**
 * @category constructors
 * @since 2.0.0
 */
const make$r = isEquivalent => (self, that) => self === that || isEquivalent(self, that);
const isStrictEquivalent = (x, y) => x === y;
/**
 * Return an `Equivalence` that uses strict equality (===) to compare values.
 *
 * @since 2.0.0
 * @category constructors
 */
const strict = () => isStrictEquivalent;
/**
 * @category instances
 * @since 2.0.0
 */
const number$2 = /*#__PURE__*/strict();
/**
 * @category mapping
 * @since 2.0.0
 */
const mapInput$1 = /*#__PURE__*/dual(2, (self, f) => make$r((x, y) => self(f(x), f(y))));
/**
 * @category instances
 * @since 2.0.0
 */
const Date$1 = /*#__PURE__*/mapInput$1(number$2, date => date.getTime());
/**
 * Creates a new `Equivalence` for an array of values based on a given `Equivalence` for the elements of the array.
 *
 * @category combinators
 * @since 2.0.0
 */
const array$1 = item => make$r((self, that) => {
  if (self.length !== that.length) {
    return false;
  }
  for (let i = 0; i < self.length; i++) {
    const isEq = item(self[i], that[i]);
    if (!isEq) {
      return false;
    }
  }
  return true;
});

let moduleVersion = "3.12.1";
const getCurrentVersion = () => moduleVersion;

/**
 * The `GlobalValue` module ensures that a single instance of a value is created globally,
 * even when modules are imported multiple times (e.g., due to mixing CommonJS and ESM builds)
 * or during hot-reloading in development environments like Next.js or Remix.
 *
 * It achieves this by using a versioned global store, identified by a unique `Symbol` tied to
 * the current version of the `effect` library. The store holds values that are keyed by an identifier,
 * allowing the reuse of previously computed instances across imports or reloads.
 *
 * This pattern is particularly useful in scenarios where frequent reloading can cause services or
 * single-instance objects to be recreated unnecessarily, such as in development environments with hot-reloading.
 *
 * @since 2.0.0
 */
const globalStoreId = `effect/GlobalValue/globalStoreId/${/*#__PURE__*/getCurrentVersion()}`;
let globalStore;
/**
 * Retrieves or computes a global value associated with the given `id`. If the value for this `id`
 * has already been computed, it will be returned from the global store. If it does not exist yet,
 * the provided `compute` function will be executed to compute the value, store it, and then return it.
 *
 * This ensures that even in cases where the module is imported multiple times (e.g., in mixed environments
 * like CommonJS and ESM, or during hot-reloading in development), the value is computed only once and reused
 * thereafter.
 *
 * @example
 * ```ts
 * import { globalValue } from "effect/GlobalValue"
 *
 * // This cache will persist as long as the module is running,
 * // even if reloaded or imported elsewhere
 * const myCache = globalValue(
 *   Symbol.for("myCache"),
 *   () => new WeakMap<object, number>()
 * )
 * ```
 *
 * @since 2.0.0
 */
const globalValue = (id, compute) => {
  if (!globalStore) {
    // @ts-expect-error
    globalThis[globalStoreId] ??= new Map();
    // @ts-expect-error
    globalStore = globalThis[globalStoreId];
  }
  if (!globalStore.has(id)) {
    globalStore.set(id, compute());
  }
  return globalStore.get(id);
};

/**
 * @since 2.0.0
 */
/**
 * Tests if a value is `truthy`.
 *
 * @param input - The value to test.
 *
 * @example
 * ```ts
 * import { isTruthy } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isTruthy(1), true)
 * assert.deepStrictEqual(isTruthy(0), false)
 * assert.deepStrictEqual(isTruthy(""), false)
 * ```
 *
 * @category guards
 * @since 2.0.0
 */
const isTruthy = input => !!input;
/**
 * Tests if a value is a `string`.
 *
 * @param input - The value to test.
 *
 * @example
 * ```ts
 * import { isString } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isString("a"), true)
 *
 * assert.deepStrictEqual(isString(1), false)
 * ```
 *
 * @category guards
 * @since 2.0.0
 */
const isString = input => typeof input === "string";
/**
 * Tests if a value is a `number`.
 *
 * @param input - The value to test.
 *
 * @example
 * ```ts
 * import { isNumber } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isNumber(2), true)
 *
 * assert.deepStrictEqual(isNumber("2"), false)
 * ```
 *
 * @category guards
 * @since 2.0.0
 */
const isNumber = input => typeof input === "number";
/**
 * Tests if a value is a `boolean`.
 *
 * @param input - The value to test.
 *
 * @example
 * ```ts
 * import { isBoolean } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isBoolean(true), true)
 *
 * assert.deepStrictEqual(isBoolean("true"), false)
 * ```
 *
 * @category guards
 * @since 2.0.0
 */
const isBoolean = input => typeof input === "boolean";
/**
 * Tests if a value is a `bigint`.
 *
 * @param input - The value to test.
 *
 * @example
 * ```ts
 * import { isBigInt } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isBigInt(1n), true)
 *
 * assert.deepStrictEqual(isBigInt(1), false)
 * ```
 *
 * @category guards
 * @since 2.0.0
 */
const isBigInt = input => typeof input === "bigint";
/**
 * Tests if a value is a `symbol`.
 *
 * @param input - The value to test.
 *
 * @example
 * ```ts
 * import { isSymbol } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isSymbol(Symbol.for("a")), true)
 *
 * assert.deepStrictEqual(isSymbol("a"), false)
 * ```
 *
 * @category guards
 * @since 2.0.0
 */
const isSymbol = input => typeof input === "symbol";
/**
 * Tests if a value is a `function`.
 *
 * @param input - The value to test.
 *
 * @example
 * ```ts
 * import { isFunction } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isFunction(isFunction), true)
 *
 * assert.deepStrictEqual(isFunction("function"), false)
 * ```
 *
 * @category guards
 * @since 2.0.0
 */
const isFunction = isFunction$1;
/**
 * Tests if a value is `undefined`.
 *
 * @param input - The value to test.
 *
 * @example
 * ```ts
 * import { isUndefined } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isUndefined(undefined), true)
 *
 * assert.deepStrictEqual(isUndefined(null), false)
 * assert.deepStrictEqual(isUndefined("undefined"), false)
 * ```
 *
 * @category guards
 * @since 2.0.0
 */
const isUndefined = input => input === undefined;
/**
 * Tests if a value is not `undefined`.
 *
 * @param input - The value to test.
 *
 * @example
 * ```ts
 * import { isNotUndefined } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isNotUndefined(null), true)
 * assert.deepStrictEqual(isNotUndefined("undefined"), true)
 *
 * assert.deepStrictEqual(isNotUndefined(undefined), false)
 * ```
 *
 * @category guards
 * @since 2.0.0
 */
const isNotUndefined = input => input !== undefined;
/**
 * Tests if a value is not `null`.
 *
 * @param input - The value to test.
 *
 * @example
 * ```ts
 * import { isNotNull } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isNotNull(undefined), true)
 * assert.deepStrictEqual(isNotNull("null"), true)
 *
 * assert.deepStrictEqual(isNotNull(null), false)
 * ```
 *
 * @category guards
 * @since 2.0.0
 */
const isNotNull = input => input !== null;
/**
 * A guard that always fails.
 *
 * @param _ - The value to test.
 *
 * @example
 * ```ts
 * import { isNever } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isNever(null), false)
 * assert.deepStrictEqual(isNever(undefined), false)
 * assert.deepStrictEqual(isNever({}), false)
 * assert.deepStrictEqual(isNever([]), false)
 * ```
 *
 * @category guards
 * @since 2.0.0
 */
const isNever = _ => false;
/** @internal */
const isRecordOrArray = input => typeof input === "object" && input !== null;
/**
 * Tests if a value is an `object`.
 *
 * @param input - The value to test.
 *
 * @example
 * ```ts
 * import { isObject } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isObject({}), true)
 * assert.deepStrictEqual(isObject([]), true)
 *
 * assert.deepStrictEqual(isObject(null), false)
 * assert.deepStrictEqual(isObject(undefined), false)
 * ```
 *
 * @category guards
 * @since 2.0.0
 */
const isObject = input => isRecordOrArray(input) || isFunction(input);
/**
 * Checks whether a value is an `object` containing a specified property key.
 *
 * @param property - The field to check within the object.
 * @param self - The value to examine.
 *
 * @category guards
 * @since 2.0.0
 */
const hasProperty = /*#__PURE__*/dual(2, (self, property) => isObject(self) && property in self);
/**
 * Tests if a value is an `object` with a property `_tag` that matches the given tag.
 *
 * @param input - The value to test.
 * @param tag - The tag to test for.
 *
 * @example
 * ```ts
 * import { isTagged } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isTagged(1, "a"), false)
 * assert.deepStrictEqual(isTagged(null, "a"), false)
 * assert.deepStrictEqual(isTagged({}, "a"), false)
 * assert.deepStrictEqual(isTagged({ a: "a" }, "a"), false)
 * assert.deepStrictEqual(isTagged({ _tag: "a" }, "a"), true)
 * assert.deepStrictEqual(isTagged("a")({ _tag: "a" }), true)
 * ```
 *
 * @category guards
 * @since 2.0.0
 */
const isTagged = /*#__PURE__*/dual(2, (self, tag) => hasProperty(self, "_tag") && self["_tag"] === tag);
/**
 * A guard that succeeds when the input is `null` or `undefined`.
 *
 * @param input - The value to test.
 *
 * @example
 * ```ts
 * import { isNullable } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isNullable(null), true)
 * assert.deepStrictEqual(isNullable(undefined), true)
 *
 * assert.deepStrictEqual(isNullable({}), false)
 * assert.deepStrictEqual(isNullable([]), false)
 * ```
 *
 * @category guards
 * @since 2.0.0
 */
const isNullable = input => input === null || input === undefined;
/**
 * A guard that succeeds when the input is not `null` or `undefined`.
 *
 * @param input - The value to test.
 *
 * @example
 * ```ts
 * import { isNotNullable } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isNotNullable({}), true)
 * assert.deepStrictEqual(isNotNullable([]), true)
 *
 * assert.deepStrictEqual(isNotNullable(null), false)
 * assert.deepStrictEqual(isNotNullable(undefined), false)
 * ```
 *
 * @category guards
 * @since 2.0.0
 */
const isNotNullable = input => input !== null && input !== undefined;
/**
 * A guard that succeeds when the input is a `Uint8Array`.
 *
 * @param input - The value to test.
 *
 * @example
 * ```ts
 * import { isUint8Array } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isUint8Array(new Uint8Array()), true)
 *
 * assert.deepStrictEqual(isUint8Array(null), false)
 * assert.deepStrictEqual(isUint8Array({}), false)
 * ```
 *
 * @category guards
 * @since 2.0.0
 */
const isUint8Array = input => input instanceof Uint8Array;
/**
 * A guard that succeeds when the input is a `Date`.
 *
 * @param input - The value to test.
 *
 * @example
 * ```ts
 * import { isDate } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isDate(new Date()), true)
 *
 * assert.deepStrictEqual(isDate(null), false)
 * assert.deepStrictEqual(isDate({}), false)
 * ```
 *
 * @category guards
 * @since 2.0.0
 */
const isDate = input => input instanceof Date;
/**
 * A guard that succeeds when the input is an `Iterable`.
 *
 * @param input - The value to test.
 *
 * @example
 * ```ts
 * import { isIterable } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isIterable([]), true)
 * assert.deepStrictEqual(isIterable(new Set()), true)
 *
 * assert.deepStrictEqual(isIterable(null), false)
 * assert.deepStrictEqual(isIterable({}), false)
 * ```
 *
 * @category guards
 * @since 2.0.0
 */
const isIterable = input => hasProperty(input, Symbol.iterator);
/**
 * A guard that succeeds when the input is a record.
 *
 * @param input - The value to test.
 *
 * @example
 * ```ts
 * import { isRecord } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isRecord({}), true)
 * assert.deepStrictEqual(isRecord({ a: 1 }), true)
 *
 * assert.deepStrictEqual(isRecord([]), false)
 * assert.deepStrictEqual(isRecord([1, 2, 3]), false)
 * assert.deepStrictEqual(isRecord(null), false)
 * assert.deepStrictEqual(isRecord(undefined), false)
 * assert.deepStrictEqual(isRecord(() => null), false)
 * ```
 *
 * @category guards
 * @since 2.0.0
 */
const isRecord = input => isRecordOrArray(input) && !Array.isArray(input);
/**
 * @category guards
 * @since 2.0.0
 */
const isPromiseLike = input => hasProperty(input, "then") && isFunction(input.then);

/**
 * @since 2.0.0
 */
/** @internal */
const getBugErrorMessage = message => `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`;

/**
 * @since 2.0.0
 */
/**
 * @category constructors
 * @since 2.0.0
 */
let SingleShotGen$1 = class SingleShotGen {
  self;
  called = false;
  constructor(self) {
    this.self = self;
  }
  /**
   * @since 2.0.0
   */
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  /**
   * @since 2.0.0
   */
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  /**
   * @since 2.0.0
   */
  throw(e) {
    throw e;
  }
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new SingleShotGen(this.self);
  }
};
const defaultIncHi = 0x14057b7e;
const defaultIncLo = 0xf767814f;
const MUL_HI = 0x5851f42d >>> 0;
const MUL_LO = 0x4c957f2d >>> 0;
const BIT_53 = 9007199254740992.0;
const BIT_27 = 134217728.0;
/**
 * PCG is a family of simple fast space-efficient statistically good algorithms
 * for random number generation. Unlike many general-purpose RNGs, they are also
 * hard to predict.
 *
 * @category model
 * @since 2.0.0
 */
class PCGRandom {
  _state;
  constructor(seedHi, seedLo, incHi, incLo) {
    if (isNullable(seedLo) && isNullable(seedHi)) {
      seedLo = Math.random() * 0xffffffff >>> 0;
      seedHi = 0;
    } else if (isNullable(seedLo)) {
      seedLo = seedHi;
      seedHi = 0;
    }
    if (isNullable(incLo) && isNullable(incHi)) {
      incLo = this._state ? this._state[3] : defaultIncLo;
      incHi = this._state ? this._state[2] : defaultIncHi;
    } else if (isNullable(incLo)) {
      incLo = incHi;
      incHi = 0;
    }
    this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);
    this._next();
    add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);
    this._next();
    return this;
  }
  /**
   * Returns a copy of the internal state of this random number generator as a
   * JavaScript Array.
   *
   * @category getters
   * @since 2.0.0
   */
  getState() {
    return [this._state[0], this._state[1], this._state[2], this._state[3]];
  }
  /**
   * Restore state previously retrieved using `getState()`.
   *
   * @since 2.0.0
   */
  setState(state) {
    this._state[0] = state[0];
    this._state[1] = state[1];
    this._state[2] = state[2];
    this._state[3] = state[3] | 1;
  }
  /**
   * Get a uniformly distributed 32 bit integer between [0, max).
   *
   * @category getter
   * @since 2.0.0
   */
  integer(max) {
    return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max;
  }
  /**
   * Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with
   * 53 bits of precision (every bit of the mantissa is randomized).
   *
   * @category getters
   * @since 2.0.0
   */
  number() {
    const hi = (this._next() & 0x03ffffff) * 1.0;
    const lo = (this._next() & 0x07ffffff) * 1.0;
    return (hi * BIT_27 + lo) / BIT_53;
  }
  /** @internal */
  _next() {
    // save current state (what we'll use for this number)
    const oldHi = this._state[0] >>> 0;
    const oldLo = this._state[1] >>> 0;
    // churn LCG.
    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);
    add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);
    // get least sig. 32 bits of ((oldstate >> 18) ^ oldstate) >> 27
    let xsHi = oldHi >>> 18;
    let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;
    xsHi = (xsHi ^ oldHi) >>> 0;
    xsLo = (xsLo ^ oldLo) >>> 0;
    const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;
    // rotate xorshifted right a random amount, based on the most sig. 5 bits
    // bits of the old state.
    const rot = oldHi >>> 27;
    const rot2 = (-rot >>> 0 & 31) >>> 0;
    return (xorshifted >>> rot | xorshifted << rot2) >>> 0;
  }
}
function mul64(out, aHi, aLo, bHi, bLo) {
  let c1 = (aLo >>> 16) * (bLo & 0xffff) >>> 0;
  let c0 = (aLo & 0xffff) * (bLo >>> 16) >>> 0;
  let lo = (aLo & 0xffff) * (bLo & 0xffff) >>> 0;
  let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;
  c0 = c0 << 16 >>> 0;
  lo = lo + c0 >>> 0;
  if (lo >>> 0 < c0 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  c1 = c1 << 16 >>> 0;
  lo = lo + c1 >>> 0;
  if (lo >>> 0 < c1 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  hi = hi + Math.imul(aLo, bHi) >>> 0;
  hi = hi + Math.imul(aHi, bLo) >>> 0;
  out[0] = hi;
  out[1] = lo;
}
// add two 64 bit numbers (given in parts), and store the result in `out`.
function add64(out, aHi, aLo, bHi, bLo) {
  let hi = aHi + bHi >>> 0;
  const lo = aLo + bLo >>> 0;
  if (lo >>> 0 < aLo >>> 0) {
    hi = hi + 1 | 0;
  }
  out[0] = hi;
  out[1] = lo;
}
/**
 * @since 3.0.6
 */
const YieldWrapTypeId = /*#__PURE__*/Symbol.for("effect/Utils/YieldWrap");
/**
 * @since 3.0.6
 */
class YieldWrap {
  /**
   * @since 3.0.6
   */
  #value;
  constructor(value) {
    this.#value = value;
  }
  /**
   * @since 3.0.6
   */
  [YieldWrapTypeId]() {
    return this.#value;
  }
}
/**
 * @since 3.0.6
 */
function yieldWrapGet(self) {
  if (typeof self === "object" && self !== null && YieldWrapTypeId in self) {
    return self[YieldWrapTypeId]();
  }
  throw new Error(getBugErrorMessage("yieldWrapGet"));
}
/**
 * Note: this is an experimental feature made available to allow custom matchers in tests, not to be directly used yet in user code
 *
 * @since 3.1.1
 * @status experimental
 * @category modifiers
 */
const structuralRegionState = /*#__PURE__*/globalValue("effect/Utils/isStructuralRegion", () => ({
  enabled: false,
  tester: undefined
}));
const tracingFunction = name => {
  const wrap = {
    [name](body) {
      return body();
    }
  };
  return function (fn) {
    return wrap[name](fn);
  };
};
/**
 * @since 3.2.2
 * @status experimental
 * @category tracing
 */
const internalCall = /*#__PURE__*/tracingFunction("effect_internal_function");

/**
 * @since 2.0.0
 */
/** @internal */
const randomHashCache = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for("effect/Hash/randomHashCache"), () => new WeakMap());
/**
 * @since 2.0.0
 * @category symbols
 */
const symbol$1 = /*#__PURE__*/Symbol.for("effect/Hash");
/**
 * @since 2.0.0
 * @category hashing
 */
const hash = self => {
  if (structuralRegionState.enabled === true) {
    return 0;
  }
  switch (typeof self) {
    case "number":
      return number$1(self);
    case "bigint":
      return string(self.toString(10));
    case "boolean":
      return string(String(self));
    case "symbol":
      return string(String(self));
    case "string":
      return string(self);
    case "undefined":
      return string("undefined");
    case "function":
    case "object":
      {
        if (self === null) {
          return string("null");
        } else if (self instanceof Date) {
          return hash(self.toISOString());
        } else if (isHash(self)) {
          return self[symbol$1]();
        } else {
          return random(self);
        }
      }
    default:
      throw new Error(`BUG: unhandled typeof ${typeof self} - please report an issue at https://github.com/Effect-TS/effect/issues`);
  }
};
/**
 * @since 2.0.0
 * @category hashing
 */
const random = self => {
  if (!randomHashCache.has(self)) {
    randomHashCache.set(self, number$1(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));
  }
  return randomHashCache.get(self);
};
/**
 * @since 2.0.0
 * @category hashing
 */
const combine$5 = b => self => self * 53 ^ b;
/**
 * @since 2.0.0
 * @category hashing
 */
const optimize = n => n & 0xbfffffff | n >>> 1 & 0x40000000;
/**
 * @since 2.0.0
 * @category guards
 */
const isHash = u => hasProperty(u, symbol$1);
/**
 * @since 2.0.0
 * @category hashing
 */
const number$1 = n => {
  if (n !== n || n === Infinity) {
    return 0;
  }
  let h = n | 0;
  if (h !== n) {
    h ^= n * 0xffffffff;
  }
  while (n > 0xffffffff) {
    h ^= n /= 0xffffffff;
  }
  return optimize(h);
};
/**
 * @since 2.0.0
 * @category hashing
 */
const string = str => {
  let h = 5381,
    i = str.length;
  while (i) {
    h = h * 33 ^ str.charCodeAt(--i);
  }
  return optimize(h);
};
/**
 * @since 2.0.0
 * @category hashing
 */
const structureKeys = (o, keys) => {
  let h = 12289;
  for (let i = 0; i < keys.length; i++) {
    h ^= pipe(string(keys[i]), combine$5(hash(o[keys[i]])));
  }
  return optimize(h);
};
/**
 * @since 2.0.0
 * @category hashing
 */
const structure = o => structureKeys(o, Object.keys(o));
/**
 * @since 2.0.0
 * @category hashing
 */
const array = arr => {
  let h = 6151;
  for (let i = 0; i < arr.length; i++) {
    h = pipe(h, combine$5(hash(arr[i])));
  }
  return optimize(h);
};
/**
 * @since 2.0.0
 * @category hashing
 */
const cached = function () {
  if (arguments.length === 1) {
    const self = arguments[0];
    return function (hash) {
      Object.defineProperty(self, symbol$1, {
        value() {
          return hash;
        },
        enumerable: false
      });
      return hash;
    };
  }
  const self = arguments[0];
  const hash = arguments[1];
  Object.defineProperty(self, symbol$1, {
    value() {
      return hash;
    },
    enumerable: false
  });
  return hash;
};

/**
 * @since 2.0.0
 * @category symbols
 */
const symbol = /*#__PURE__*/Symbol.for("effect/Equal");
function equals$2() {
  if (arguments.length === 1) {
    return self => compareBoth(self, arguments[0]);
  }
  return compareBoth(arguments[0], arguments[1]);
}
function compareBoth(self, that) {
  if (self === that) {
    return true;
  }
  const selfType = typeof self;
  if (selfType !== typeof that) {
    return false;
  }
  if (selfType === "object" || selfType === "function") {
    if (self !== null && that !== null) {
      if (isEqual(self) && isEqual(that)) {
        if (hash(self) === hash(that) && self[symbol](that)) {
          return true;
        } else {
          return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
        }
      } else if (self instanceof Date && that instanceof Date) {
        return self.toISOString() === that.toISOString();
      }
    }
    if (structuralRegionState.enabled) {
      if (Array.isArray(self) && Array.isArray(that)) {
        return self.length === that.length && self.every((v, i) => compareBoth(v, that[i]));
      }
      if (Object.getPrototypeOf(self) === Object.prototype && Object.getPrototypeOf(self) === Object.prototype) {
        const keysSelf = Object.keys(self);
        const keysThat = Object.keys(that);
        if (keysSelf.length === keysThat.length) {
          for (const key of keysSelf) {
            // @ts-expect-error
            if (!(key in that && compareBoth(self[key], that[key]))) {
              return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
            }
          }
          return true;
        }
      }
      return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
    }
  }
  return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
}
/**
 * @since 2.0.0
 * @category guards
 */
const isEqual = u => hasProperty(u, symbol);
/**
 * @since 2.0.0
 * @category instances
 */
const equivalence = () => equals$2;

/**
 * @since 2.0.0
 */
/**
 * @since 2.0.0
 * @category symbols
 */
const NodeInspectSymbol = /*#__PURE__*/Symbol.for("nodejs.util.inspect.custom");
/**
 * @since 2.0.0
 */
const toJSON = x => {
  try {
    if (hasProperty(x, "toJSON") && isFunction(x["toJSON"]) && x["toJSON"].length === 0) {
      return x.toJSON();
    } else if (Array.isArray(x)) {
      return x.map(toJSON);
    }
  } catch (_) {
    return {};
  }
  return redact(x);
};
/**
 * @since 2.0.0
 */
const format$4 = x => JSON.stringify(x, null, 2);
/**
 * @since 2.0.0
 */
const toStringUnknown = (u, whitespace = 2) => {
  if (typeof u === "string") {
    return u;
  }
  try {
    return typeof u === "object" ? stringifyCircular(u, whitespace) : String(u);
  } catch (_) {
    return String(u);
  }
};
/**
 * @since 2.0.0
 */
const stringifyCircular = (obj, whitespace) => {
  let cache = [];
  const retVal = JSON.stringify(obj, (_key, value) => typeof value === "object" && value !== null ? cache.includes(value) ? undefined // circular reference
  : cache.push(value) && (redactableState.fiberRefs !== undefined && isRedactable(value) ? value[symbolRedactable](redactableState.fiberRefs) : value) : value, whitespace);
  cache = undefined;
  return retVal;
};
/**
 * @since 3.10.0
 * @category redactable
 */
const symbolRedactable = /*#__PURE__*/Symbol.for("effect/Inspectable/Redactable");
/**
 * @since 3.10.0
 * @category redactable
 */
const isRedactable = u => typeof u === "object" && u !== null && symbolRedactable in u;
const redactableState = /*#__PURE__*/globalValue("effect/Inspectable/redactableState", () => ({
  fiberRefs: undefined
}));
/**
 * @since 3.10.0
 * @category redactable
 */
const withRedactableContext = (context, f) => {
  const prev = redactableState.fiberRefs;
  redactableState.fiberRefs = context;
  try {
    return f();
  } finally {
    redactableState.fiberRefs = prev;
  }
};
/**
 * @since 3.10.0
 * @category redactable
 */
const redact = u => {
  if (isRedactable(u) && redactableState.fiberRefs !== undefined) {
    return u[symbolRedactable](redactableState.fiberRefs);
  }
  return u;
};

/**
 * @since 2.0.0
 */
/**
 * @since 2.0.0
 */
const pipeArguments = (self, args) => {
  switch (args.length) {
    case 0:
      return self;
    case 1:
      return args[0](self);
    case 2:
      return args[1](args[0](self));
    case 3:
      return args[2](args[1](args[0](self)));
    case 4:
      return args[3](args[2](args[1](args[0](self))));
    case 5:
      return args[4](args[3](args[2](args[1](args[0](self)))));
    case 6:
      return args[5](args[4](args[3](args[2](args[1](args[0](self))))));
    case 7:
      return args[6](args[5](args[4](args[3](args[2](args[1](args[0](self)))))));
    case 8:
      return args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self))))))));
    case 9:
      return args[8](args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self)))))))));
    default:
      {
        let ret = self;
        for (let i = 0, len = args.length; i < len; i++) {
          ret = args[i](ret);
        }
        return ret;
      }
  }
};

/** @internal */
const OP_ASYNC = "Async";
/** @internal */
const OP_COMMIT = "Commit";
/** @internal */
const OP_FAILURE = "Failure";
/** @internal */
const OP_ON_FAILURE = "OnFailure";
/** @internal */
const OP_ON_SUCCESS = "OnSuccess";
/** @internal */
const OP_ON_SUCCESS_AND_FAILURE = "OnSuccessAndFailure";
/** @internal */
const OP_SUCCESS = "Success";
/** @internal */
const OP_SYNC = "Sync";
/** @internal */
const OP_TAG = "Tag";
/** @internal */
const OP_UPDATE_RUNTIME_FLAGS = "UpdateRuntimeFlags";
/** @internal */
const OP_WHILE = "While";
/** @internal */
const OP_ITERATOR = "Iterator";
/** @internal */
const OP_WITH_RUNTIME = "WithRuntime";
/** @internal */
const OP_YIELD = "Yield";
/** @internal */
const OP_REVERT_FLAGS = "RevertFlags";

/** @internal */
const EffectTypeId$1 = /*#__PURE__*/Symbol.for("effect/Effect");
/** @internal */
const StreamTypeId = /*#__PURE__*/Symbol.for("effect/Stream");
/** @internal */
const SinkTypeId = /*#__PURE__*/Symbol.for("effect/Sink");
/** @internal */
const ChannelTypeId = /*#__PURE__*/Symbol.for("effect/Channel");
/** @internal */
const effectVariance = {
  /* c8 ignore next */
  _R: _ => _,
  /* c8 ignore next */
  _E: _ => _,
  /* c8 ignore next */
  _A: _ => _,
  _V: /*#__PURE__*/getCurrentVersion()
};
const sinkVariance = {
  /* c8 ignore next */
  _A: _ => _,
  /* c8 ignore next */
  _In: _ => _,
  /* c8 ignore next */
  _L: _ => _,
  /* c8 ignore next */
  _E: _ => _,
  /* c8 ignore next */
  _R: _ => _
};
const channelVariance = {
  /* c8 ignore next */
  _Env: _ => _,
  /* c8 ignore next */
  _InErr: _ => _,
  /* c8 ignore next */
  _InElem: _ => _,
  /* c8 ignore next */
  _InDone: _ => _,
  /* c8 ignore next */
  _OutErr: _ => _,
  /* c8 ignore next */
  _OutElem: _ => _,
  /* c8 ignore next */
  _OutDone: _ => _
};
/** @internal */
const EffectPrototype$1 = {
  [EffectTypeId$1]: effectVariance,
  [StreamTypeId]: effectVariance,
  [SinkTypeId]: sinkVariance,
  [ChannelTypeId]: channelVariance,
  [symbol](that) {
    return this === that;
  },
  [symbol$1]() {
    return cached(this, random(this));
  },
  [Symbol.iterator]() {
    return new SingleShotGen$1(new YieldWrap(this));
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
/** @internal */
const StructuralPrototype = {
  [symbol$1]() {
    return cached(this, structure(this));
  },
  [symbol](that) {
    const selfKeys = Object.keys(this);
    const thatKeys = Object.keys(that);
    if (selfKeys.length !== thatKeys.length) {
      return false;
    }
    for (const key of selfKeys) {
      if (!(key in that && equals$2(this[key], that[key]))) {
        return false;
      }
    }
    return true;
  }
};
/** @internal */
const CommitPrototype$1 = {
  ...EffectPrototype$1,
  _op: OP_COMMIT
};
/** @internal */
const StructuralCommitPrototype = {
  ...CommitPrototype$1,
  ...StructuralPrototype
};
/** @internal */
const Base$1 = /*#__PURE__*/function () {
  function Base() {}
  Base.prototype = CommitPrototype$1;
  return Base;
}();

/**
 * @since 2.0.0
 */
const TypeId$c = /*#__PURE__*/Symbol.for("effect/Option");
const CommonProto$1 = {
  ...EffectPrototype$1,
  [TypeId$c]: {
    _A: _ => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format$4(this.toJSON());
  }
};
const SomeProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(CommonProto$1), {
  _tag: "Some",
  _op: "Some",
  [symbol](that) {
    return isOption$1(that) && isSome$1(that) && equals$2(this.value, that.value);
  },
  [symbol$1]() {
    return cached(this, combine$5(hash(this._tag))(hash(this.value)));
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag,
      value: toJSON(this.value)
    };
  }
});
const NoneHash = /*#__PURE__*/hash("None");
const NoneProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(CommonProto$1), {
  _tag: "None",
  _op: "None",
  [symbol](that) {
    return isOption$1(that) && isNone$1(that);
  },
  [symbol$1]() {
    return NoneHash;
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag
    };
  }
});
/** @internal */
const isOption$1 = input => hasProperty(input, TypeId$c);
/** @internal */
const isNone$1 = fa => fa._tag === "None";
/** @internal */
const isSome$1 = fa => fa._tag === "Some";
/** @internal */
const none$5 = /*#__PURE__*/Object.create(NoneProto);
/** @internal */
const some$1 = value => {
  const a = Object.create(SomeProto);
  a.value = value;
  return a;
};

/**
 * @since 2.0.0
 */
/**
 * @internal
 */
const TypeId$b = /*#__PURE__*/Symbol.for("effect/Either");
const CommonProto = {
  ...EffectPrototype$1,
  [TypeId$b]: {
    _R: _ => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format$4(this.toJSON());
  }
};
const RightProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(CommonProto), {
  _tag: "Right",
  _op: "Right",
  [symbol](that) {
    return isEither(that) && isRight$1(that) && equals$2(this.right, that.right);
  },
  [symbol$1]() {
    return combine$5(hash(this._tag))(hash(this.right));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      right: toJSON(this.right)
    };
  }
});
const LeftProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(CommonProto), {
  _tag: "Left",
  _op: "Left",
  [symbol](that) {
    return isEither(that) && isLeft$1(that) && equals$2(this.left, that.left);
  },
  [symbol$1]() {
    return combine$5(hash(this._tag))(hash(this.left));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      left: toJSON(this.left)
    };
  }
});
/** @internal */
const isEither = input => hasProperty(input, TypeId$b);
/** @internal */
const isLeft$1 = ma => ma._tag === "Left";
/** @internal */
const isRight$1 = ma => ma._tag === "Right";
/** @internal */
const left$1 = left => {
  const a = Object.create(LeftProto);
  a.left = left;
  return a;
};
/** @internal */
const right$1 = right => {
  const a = Object.create(RightProto);
  a.right = right;
  return a;
};
/** @internal */
const fromOption$2 = /*#__PURE__*/dual(2, (self, onNone) => isNone$1(self) ? left$1(onNone()) : right$1(self.value));

/**
 * @since 2.0.0
 */
/**
 * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias
 * of this structure.
 *
 * @category constructors
 * @since 2.0.0
 */
const right = right$1;
/**
 * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this
 * structure.
 *
 * @category constructors
 * @since 2.0.0
 */
const left = left$1;
/**
 * @example
 * ```ts
 * import { Either, Option } from "effect"
 *
 * assert.deepStrictEqual(Either.fromOption(Option.some(1), () => 'error'), Either.right(1))
 * assert.deepStrictEqual(Either.fromOption(Option.none(), () => 'error'), Either.left('error'))
 * ```
 *
 * @category constructors
 * @since 2.0.0
 */
const fromOption$1 = fromOption$2;
/**
 * Determine if a `Either` is a `Left`.
 *
 * @param self - The `Either` to check.
 *
 * @example
 * ```ts
 * import { Either } from "effect"
 *
 * assert.deepStrictEqual(Either.isLeft(Either.right(1)), false)
 * assert.deepStrictEqual(Either.isLeft(Either.left("a")), true)
 * ```
 *
 * @category guards
 * @since 2.0.0
 */
const isLeft = isLeft$1;
/**
 * Determine if a `Either` is a `Right`.
 *
 * @param self - The `Either` to check.
 *
 * @example
 * ```ts
 * import { Either } from "effect"
 *
 * assert.deepStrictEqual(Either.isRight(Either.right(1)), true)
 * assert.deepStrictEqual(Either.isRight(Either.left("a")), false)
 * ```
 *
 * @category guards
 * @since 2.0.0
 */
const isRight = isRight$1;
/**
 * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the `onLeft function,
 * if the value is a `Right` the inner value is applied to the `onRight` function.
 *
 * @example
 * ```ts
 * import { pipe, Either } from "effect"
 *
 * const onLeft  = (strings: ReadonlyArray<string>): string => `strings: ${strings.join(', ')}`
 *
 * const onRight = (value: number): string => `Ok: ${value}`
 *
 * assert.deepStrictEqual(pipe(Either.right(1), Either.match({ onLeft, onRight })), 'Ok: 1')
 * assert.deepStrictEqual(
 *   pipe(Either.left(['string 1', 'string 2']), Either.match({ onLeft, onRight })),
 *   'strings: string 1, string 2'
 * )
 * ```
 *
 * @category pattern matching
 * @since 2.0.0
 */
const match$4 = /*#__PURE__*/dual(2, (self, {
  onLeft,
  onRight
}) => isLeft(self) ? onLeft(self.left) : onRight(self.right));
/**
 * @category getters
 * @since 2.0.0
 */
const merge$3 = /*#__PURE__*/match$4({
  onLeft: identity,
  onRight: identity
});
/**
 * Extracts the value of an `Either` or throws if the `Either` is `Left`.
 *
 * If a default error is sufficient for your use case and you don't need to configure the thrown error, see {@link getOrThrow}.
 *
 * @param self - The `Either` to extract the value from.
 * @param onLeft - A function that will be called if the `Either` is `Left`. It returns the error to be thrown.
 *
 * @example
 * ```ts
 * import { Either } from "effect"
 *
 * assert.deepStrictEqual(
 *   Either.getOrThrowWith(Either.right(1), () => new Error('Unexpected Left')),
 *   1
 * )
 * assert.throws(() => Either.getOrThrowWith(Either.left("error"), () => new Error('Unexpected Left')))
 * ```
 *
 * @category getters
 * @since 2.0.0
 */
const getOrThrowWith$1 = /*#__PURE__*/dual(2, (self, onLeft) => {
  if (isRight(self)) {
    return self.right;
  }
  throw onLeft(self.left);
});

/**
 * @since 2.0.0
 */
/** @internal */
const isNonEmptyArray$1 = self => self.length > 0;

/**
 * This module provides an implementation of the `Order` type class which is used to define a total ordering on some type `A`.
 * An order is defined by a relation `<=`, which obeys the following laws:
 *
 * - either `x <= y` or `y <= x` (totality)
 * - if `x <= y` and `y <= x`, then `x == y` (antisymmetry)
 * - if `x <= y` and `y <= z`, then `x <= z` (transitivity)
 *
 * The truth table for compare is defined as follows:
 *
 * | `x <= y` | `x >= y` | Ordering |                       |
 * | -------- | -------- | -------- | --------------------- |
 * | `true`   | `true`   | `0`      | corresponds to x == y |
 * | `true`   | `false`  | `< 0`    | corresponds to x < y  |
 * | `false`  | `true`   | `> 0`    | corresponds to x > y  |
 *
 * @since 2.0.0
 */
/**
 * @category constructors
 * @since 2.0.0
 */
const make$q = compare => (self, that) => self === that ? 0 : compare(self, that);
/**
 * @category instances
 * @since 2.0.0
 */
const number = /*#__PURE__*/make$q((self, that) => self < that ? -1 : 1);
/**
 * @category mapping
 * @since 2.0.0
 */
const mapInput = /*#__PURE__*/dual(2, (self, f) => make$q((b1, b2) => self(f(b1), f(b2))));
/**
 * Test whether one value is _strictly greater than_ another.
 *
 * @since 2.0.0
 */
const greaterThan$2 = O => dual(2, (self, that) => O(self, that) === 1);

/**
 * Creates a new `Option` that represents the absence of a value.
 *
 * @category constructors
 * @since 2.0.0
 */
const none$4 = () => none$5;
/**
 * Creates a new `Option` that wraps the given value.
 *
 * @param value - The value to wrap.
 *
 * @category constructors
 * @since 2.0.0
 */
const some = some$1;
/**
 * Checks if a given value is an `Option` value.
 *
 * @param input - The value to check.
 *
 * @example
 * ```ts
 * import { Option } from "effect"
 *
 * assert.deepStrictEqual(Option.isOption(Option.some(1)), true)
 * assert.deepStrictEqual(Option.isOption(Option.none()), true)
 * assert.deepStrictEqual(Option.isOption({}), false)
 * ```
 *
 * @category guards
 * @since 2.0.0
 */
const isOption = isOption$1;
/**
 * Determine if a `Option` is a `None`.
 *
 * @param self - The `Option` to check.
 *
 * @example
 * ```ts
 * import { Option } from "effect"
 *
 * assert.deepStrictEqual(Option.isNone(Option.some(1)), false)
 * assert.deepStrictEqual(Option.isNone(Option.none()), true)
 * ```
 *
 * @category guards
 * @since 2.0.0
 */
const isNone = isNone$1;
/**
 * Determine if a `Option` is a `Some`.
 *
 * @param self - The `Option` to check.
 *
 * @example
 * ```ts
 * import { Option } from "effect"
 *
 * assert.deepStrictEqual(Option.isSome(Option.some(1)), true)
 * assert.deepStrictEqual(Option.isSome(Option.none()), false)
 * ```
 *
 * @category guards
 * @since 2.0.0
 */
const isSome = isSome$1;
/**
 * Matches the given `Option` and returns either the provided `onNone` value or the result of the provided `onSome`
 * function when passed the `Option`'s value.
 *
 * @param self - The `Option` to match
 * @param onNone - The value to be returned if the `Option` is `None`
 * @param onSome - The function to be called if the `Option` is `Some`, it will be passed the `Option`'s value and its result will be returned
 *
 * @example
 * ```ts
 * import { pipe, Option } from "effect"
 *
 * assert.deepStrictEqual(
 *   pipe(Option.some(1), Option.match({ onNone: () => 'a none', onSome: (a) => `a some containing ${a}` })),
 *   'a some containing 1'
 * )
 *
 * assert.deepStrictEqual(
 *   pipe(Option.none(), Option.match({ onNone: () => 'a none', onSome: (a) => `a some containing ${a}` })),
 *   'a none'
 * )
 * ```
 *
 * @category pattern matching
 * @since 2.0.0
 */
const match$3 = /*#__PURE__*/dual(2, (self, {
  onNone,
  onSome
}) => isNone(self) ? onNone() : onSome(self.value));
/**
 * Returns the value of the `Option` if it is `Some`, otherwise returns `onNone`
 *
 * @param self - The `Option` to get the value of.
 * @param onNone - Function that returns the default value to return if the `Option` is `None`.
 *
 * @example
 * ```ts
 * import { pipe, Option } from "effect"
 *
 * assert.deepStrictEqual(pipe(Option.some(1), Option.getOrElse(() => 0)), 1)
 * assert.deepStrictEqual(pipe(Option.none(), Option.getOrElse(() => 0)), 0)
 * ```
 *
 * @category getters
 * @since 2.0.0
 */
const getOrElse = /*#__PURE__*/dual(2, (self, onNone) => isNone(self) ? onNone() : self.value);
/**
 * Returns the provided `Option` `that` if `self` is `None`, otherwise returns `self`.
 *
 * @param self - The first `Option` to be checked.
 * @param that - The `Option` to return if `self` is `None`.
 *
 * @example
 * ```ts
 * import { pipe, Option } from "effect"
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     Option.none(),
 *     Option.orElse(() => Option.none())
 *   ),
 *   Option.none()
 * )
 * assert.deepStrictEqual(
 *   pipe(
 *     Option.some('a'),
 *     Option.orElse(() => Option.none())
 *   ),
 *   Option.some('a')
 * )
 * assert.deepStrictEqual(
 *   pipe(
 *     Option.none(),
 *     Option.orElse(() => Option.some('b'))
 *   ),
 *   Option.some('b')
 * )
 * assert.deepStrictEqual(
 *   pipe(
 *     Option.some('a'),
 *     Option.orElse(() => Option.some('b'))
 *   ),
 *   Option.some('a')
 * )
 * ```
 *
 * @category error handling
 * @since 2.0.0
 */
const orElse$2 = /*#__PURE__*/dual(2, (self, that) => isNone(self) ? that() : self);
/**
 * Returns the provided default value as `Some` if `self` is `None`, otherwise returns `self`.
 *
 * @param self - The first `Option` to be checked.
 * @param onNone - Function that returns the default value to return if the `Option` is `None`.
 *
 * @example
 * ```ts
 * import { pipe, Option } from "effect"
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     Option.none(),
 *     Option.orElseSome(() => 'b')
 *   ),
 *   Option.some('b')
 * )
 * assert.deepStrictEqual(
 *   pipe(
 *     Option.some('a'),
 *     Option.orElseSome(() => 'b')
 *   ),
 *   Option.some('a')
 * )
 * ```
 *
 * @category error handling
 * @since 2.0.0
 */
const orElseSome = /*#__PURE__*/dual(2, (self, onNone) => isNone(self) ? some(onNone()) : self);
/**
 * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise
 * returns the value wrapped in a `Some`.
 *
 * @param nullableValue - The nullable value to be converted to an `Option`.
 *
 * @example
 * ```ts
 * import { Option } from "effect"
 *
 * assert.deepStrictEqual(Option.fromNullable(undefined), Option.none())
 * assert.deepStrictEqual(Option.fromNullable(null), Option.none())
 * assert.deepStrictEqual(Option.fromNullable(1), Option.some(1))
 * ```
 *
 * @category conversions
 * @since 2.0.0
 */
const fromNullable = nullableValue => nullableValue == null ? none$4() : some(nullableValue);
/**
 * Returns the value of the `Option` if it is a `Some`, otherwise returns `undefined`.
 *
 * @param self - The `Option` to extract the value from.
 *
 * @example
 * ```ts
 * import { Option } from "effect"
 *
 * assert.deepStrictEqual(Option.getOrUndefined(Option.some(1)), 1)
 * assert.deepStrictEqual(Option.getOrUndefined(Option.none()), undefined)
 * ```
 *
 * @category getters
 * @since 2.0.0
 */
const getOrUndefined = /*#__PURE__*/getOrElse(constUndefined);
/**
 * A utility function that lifts a function that throws exceptions into a function that returns an `Option`.
 *
 * This function is useful for any function that might throw an exception, allowing the developer to handle
 * the exception in a more functional way.
 *
 * @param f - the function that can throw exceptions.
 *
 * @example
 * ```ts
 * import { Option } from "effect"
 *
 * const parse = Option.liftThrowable(JSON.parse)
 *
 * assert.deepStrictEqual(parse("1"), Option.some(1))
 * assert.deepStrictEqual(parse(""), Option.none())
 * ```
 *
 * @category conversions
 * @since 2.0.0
 */
const liftThrowable = f => (...a) => {
  try {
    return some(f(...a));
  } catch (e) {
    return none$4();
  }
};
/**
 * Extracts the value of an `Option` or throws if the `Option` is `None`.
 *
 * If a default error is sufficient for your use case and you don't need to configure the thrown error, see {@link getOrThrow}.
 *
 * @param self - The `Option` to extract the value from.
 * @param onNone - A function that will be called if the `Option` is `None`. It returns the error to be thrown.
 *
 * @example
 * ```ts
 * import { Option } from "effect"
 *
 * assert.deepStrictEqual(
 *   Option.getOrThrowWith(Option.some(1), () => new Error('Unexpected None')),
 *   1
 * )
 * assert.throws(() => Option.getOrThrowWith(Option.none(), () => new Error('Unexpected None')))
 * ```
 *
 * @category conversions
 * @since 2.0.0
 */
const getOrThrowWith = /*#__PURE__*/dual(2, (self, onNone) => {
  if (isSome(self)) {
    return self.value;
  }
  throw onNone();
});
/**
 * Extracts the value of an `Option` or throws if the `Option` is `None`.
 *
 * The thrown error is a default error. To configure the error thrown, see  {@link getOrThrowWith}.
 *
 * @param self - The `Option` to extract the value from.
 * @throws `Error("getOrThrow called on a None")`
 *
 * @example
 * ```ts
 * import { Option } from "effect"
 *
 * assert.deepStrictEqual(Option.getOrThrow(Option.some(1)), 1)
 * assert.throws(() => Option.getOrThrow(Option.none()))
 * ```
 *
 * @category conversions
 * @since 2.0.0
 */
const getOrThrow = /*#__PURE__*/getOrThrowWith(() => new Error("getOrThrow called on a None"));
/**
 * Maps the `Some` side of an `Option` value to a new `Option` value.
 *
 * @param self - An `Option` to map
 * @param f - The function to map over the value of the `Option`
 *
 * @category mapping
 * @since 2.0.0
 */
const map$6 = /*#__PURE__*/dual(2, (self, f) => isNone(self) ? none$4() : some(f(self.value)));
/**
 * Applies a function to the value of an `Option` and flattens the result, if the input is `Some`.
 *
 * @category sequencing
 * @since 2.0.0
 */
const flatMap$5 = /*#__PURE__*/dual(2, (self, f) => isNone(self) ? none$4() : f(self.value));
/**
 * Maps over the value of an `Option` and filters out `None`s.
 *
 * Useful when in addition to filtering you also want to change the type of the `Option`.
 *
 * @param self - The `Option` to map over.
 * @param f - A function to apply to the value of the `Option`.
 *
 * @example
 * ```ts
 * import { Option } from "effect"
 *
 * const evenNumber = (n: number) => n % 2 === 0 ? Option.some(n) : Option.none()
 *
 * assert.deepStrictEqual(Option.filterMap(Option.none(), evenNumber), Option.none())
 * assert.deepStrictEqual(Option.filterMap(Option.some(3), evenNumber), Option.none())
 * assert.deepStrictEqual(Option.filterMap(Option.some(2), evenNumber), Option.some(2))
 * ```
 *
 * @category filtering
 * @since 2.0.0
 */
const filterMap = /*#__PURE__*/dual(2, (self, f) => isNone(self) ? none$4() : f(self.value));
/**
 * Filters an `Option` using a predicate. If the predicate is not satisfied or the `Option` is `None` returns `None`.
 *
 * If you need to change the type of the `Option` in addition to filtering, see `filterMap`.
 *
 * @param predicate - A predicate function to apply to the `Option` value.
 * @param fb - The `Option` to filter.
 *
 * @example
 * ```ts
 * import { Option } from "effect"
 *
 * // predicate
 * const isEven = (n: number) => n % 2 === 0
 *
 * assert.deepStrictEqual(Option.filter(Option.none(), isEven), Option.none())
 * assert.deepStrictEqual(Option.filter(Option.some(3), isEven), Option.none())
 * assert.deepStrictEqual(Option.filter(Option.some(2), isEven), Option.some(2))
 *
 * // refinement
 * const isNumber = (v: unknown): v is number => typeof v === "number"
 *
 * assert.deepStrictEqual(Option.filter(Option.none(), isNumber), Option.none())
 * assert.deepStrictEqual(Option.filter(Option.some('hello'), isNumber), Option.none())
 * assert.deepStrictEqual(Option.filter(Option.some(2), isNumber), Option.some(2))
 * ```
 *
 * @category filtering
 * @since 2.0.0
 */
const filter$2 = /*#__PURE__*/dual(2, (self, predicate) => filterMap(self, b => predicate(b) ? some$1(b) : none$5));
/**
 * @example
 * ```ts
 * import { Option, Number } from "effect"
 *
 * const isEquivalent = Option.getEquivalence(Number.Equivalence)
 * assert.deepStrictEqual(isEquivalent(Option.none(), Option.none()), true)
 * assert.deepStrictEqual(isEquivalent(Option.none(), Option.some(1)), false)
 * assert.deepStrictEqual(isEquivalent(Option.some(1), Option.none()), false)
 * assert.deepStrictEqual(isEquivalent(Option.some(1), Option.some(2)), false)
 * assert.deepStrictEqual(isEquivalent(Option.some(1), Option.some(1)), true)
 * ```
 *
 * @category equivalence
 * @since 2.0.0
 */
const getEquivalence$3 = isEquivalent => make$r((x, y) => isNone(x) ? isNone(y) : isNone(y) ? false : isEquivalent(x.value, y.value));
/**
 * Returns a function that checks if a `Option` contains a given value using a provided `isEquivalent` function.
 *
 * @param equivalent - An `Equivalence` instance to compare values of the `Option`.
 * @param self - The `Option` to apply the comparison to.
 * @param a - The value to compare against the `Option`.
 *
 * @example
 * ```ts
 * import { pipe, Option, Number } from "effect"
 *
 * assert.deepStrictEqual(pipe(Option.some(2), Option.containsWith(Number.Equivalence)(2)), true)
 * assert.deepStrictEqual(pipe(Option.some(1), Option.containsWith(Number.Equivalence)(2)), false)
 * assert.deepStrictEqual(pipe(Option.none(), Option.containsWith(Number.Equivalence)(2)), false)
 * ```
 *
 * @category elements
 * @since 2.0.0
 */
const containsWith = isEquivalent => dual(2, (self, a) => isNone(self) ? false : isEquivalent(self.value, a));
const _equivalence$3 = /*#__PURE__*/equivalence();
/**
 * Returns a function that checks if an `Option` contains a given value using the default `Equivalence`.
 *
 * @category elements
 * @since 2.0.0
 */
const contains = /*#__PURE__*/containsWith(_equivalence$3);

/**
 * This module provides utility functions for working with tuples in TypeScript.
 *
 * @since 2.0.0
 */
/**
 * Constructs a new tuple from the provided values.
 *
 * @param elements - The list of elements to create the tuple from.
 *
 * @example
 * ```ts
 * import { make } from "effect/Tuple"
 *
 * assert.deepStrictEqual(make(1, 'hello', true), [1, 'hello', true])
 * ```
 *
 * @category constructors
 * @since 2.0.0
 */
const make$p = (...elements) => elements;

/**
 * This module provides utility functions for working with arrays in TypeScript.
 *
 * @since 2.0.0
 */
/**
 * Creates a new `Array` of the specified length.
 *
 * @example
 * ```ts
 * import { Array } from "effect"
 *
 * const result = Array.allocate<number>(3)
 * assert.deepStrictEqual(result.length, 3)
 * ```
 *
 * @category constructors
 * @since 2.0.0
 */
const allocate = n => new Array(n);
/**
 * Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.
 *
 * **Note**. `n` is normalized to an integer >= 1.
 *
 * @example
 * ```ts
 * import { makeBy } from "effect/Array"
 *
 * assert.deepStrictEqual(makeBy(5, n => n * 2), [0, 2, 4, 6, 8])
 * ```
 *
 * @category constructors
 * @since 2.0.0
 */
const makeBy = (n, f) => {
  const max = Math.max(1, Math.floor(n));
  const out = new Array(max);
  for (let i = 0; i < max; i++) {
    out[i] = f(i);
  }
  return out;
};
/**
 * Creates a new `Array` from an iterable collection of values.
 * If the input is already an array, it returns the input as-is.
 * Otherwise, it converts the iterable collection to an array.
 *
 * @example
 * ```ts
 * import { Array } from "effect"
 *
 * const set = new Set([1, 2, 3])
 * const result = Array.fromIterable(set)
 * assert.deepStrictEqual(result, [1, 2, 3])
 * ```
 *
 * @category constructors
 * @since 2.0.0
 */
const fromIterable$6 = collection => Array.isArray(collection) ? collection : Array.from(collection);
/**
 * Creates a new `Array` from a value that might not be an iterable.
 *
 * @example
 * ```ts
 * import { Array } from "effect"
 *
 * assert.deepStrictEqual(Array.ensure("a"), ["a"])
 * assert.deepStrictEqual(Array.ensure(["a"]), ["a"])
 * assert.deepStrictEqual(Array.ensure(["a", "b", "c"]), ["a", "b", "c"])
 * ```
 *
 * @category constructors
 * @since 3.3.0
 */
const ensure = self => Array.isArray(self) ? self : [self];
/**
 * Matches the elements of an array from the left, applying functions to cases of empty and non-empty arrays.
 *
 * @example
 * ```ts
 * import { Array } from "effect"
 *
 * const matchLeft = Array.matchLeft({
 *   onEmpty: () => "empty",
 *   onNonEmpty: (head, tail) => `head: ${head}, tail: ${tail.length}`
 * })
 * assert.deepStrictEqual(matchLeft([]), "empty")
 * assert.deepStrictEqual(matchLeft([1, 2, 3]), "head: 1, tail: 2")
 * ```
 *
 * @category pattern matching
 * @since 2.0.0
 */
const matchLeft = /*#__PURE__*/dual(2, (self, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(headNonEmpty$1(self), tailNonEmpty$1(self)) : onEmpty());
/**
 * Prepend an element to the front of an `Iterable`, creating a new `NonEmptyArray`.
 *
 * @example
 * ```ts
 * import { Array } from "effect"
 *
 * const original = [2, 3, 4];
 * const result = Array.prepend(original, 1);
 * assert.deepStrictEqual(result, [1, 2, 3, 4]);
 * ```
 *
 * @category concatenating
 * @since 2.0.0
 */
const prepend$2 = /*#__PURE__*/dual(2, (self, head) => [head, ...self]);
/**
 * Append an element to the end of an `Iterable`, creating a new `NonEmptyArray`.
 *
 * @example
 * ```ts
 * import { Array } from "effect"
 *
 * const original = [1, 2, 3];
 * const result = Array.append(original, 4);
 * assert.deepStrictEqual(result, [1, 2, 3, 4]);
 * ```
 *
 * @category concatenating
 * @since 2.0.0
 */
const append$1 = /*#__PURE__*/dual(2, (self, last) => [...self, last]);
/**
 * Concatenates two arrays (or iterables), combining their elements.
 * If either array is non-empty, the result is also a non-empty array.
 *
 * @category concatenating
 * @since 2.0.0
 */
const appendAll$2 = /*#__PURE__*/dual(2, (self, that) => fromIterable$6(self).concat(fromIterable$6(that)));
/**
 * Determine if `unknown` is an Array.
 *
 * @param self - The value to check.
 *
 * @example
 * ```ts
 * import { isArray } from "effect/Array"
 *
 * assert.deepStrictEqual(isArray(null), false);
 * assert.deepStrictEqual(isArray([1, 2, 3]), true);
 * ```
 *
 * @category guards
 * @since 2.0.0
 */
const isArray = Array.isArray;
/**
 * Determine if an `Array` is empty narrowing down the type to `[]`.
 *
 * @param self - The `Array` to check.
 *
 * @example
 * ```ts
 * import { isEmptyArray } from "effect/Array"
 *
 * assert.deepStrictEqual(isEmptyArray([]), true);
 * assert.deepStrictEqual(isEmptyArray([1, 2, 3]), false);
 * ```
 *
 * @category guards
 * @since 2.0.0
 */
const isEmptyArray = self => self.length === 0;
/**
 * Determine if a `ReadonlyArray` is empty narrowing down the type to `readonly []`.
 *
 * @param self - The `ReadonlyArray` to check.
 *
 * @example
 * ```ts
 * import { isEmptyReadonlyArray } from "effect/Array"
 *
 * assert.deepStrictEqual(isEmptyReadonlyArray([]), true);
 * assert.deepStrictEqual(isEmptyReadonlyArray([1, 2, 3]), false);
 * ```
 *
 * @category guards
 * @since 2.0.0
 */
const isEmptyReadonlyArray = isEmptyArray;
/**
 * Determine if an `Array` is non empty narrowing down the type to `NonEmptyArray`.
 *
 * An `Array` is considered to be a `NonEmptyArray` if it contains at least one element.
 *
 * @param self - The `Array` to check.
 *
 * @example
 * ```ts
 * import { isNonEmptyArray } from "effect/Array"
 *
 * assert.deepStrictEqual(isNonEmptyArray([]), false);
 * assert.deepStrictEqual(isNonEmptyArray([1, 2, 3]), true);
 * ```
 *
 * @category guards
 * @since 2.0.0
 */
const isNonEmptyArray = isNonEmptyArray$1;
/**
 * Determine if a `ReadonlyArray` is non empty narrowing down the type to `NonEmptyReadonlyArray`.
 *
 * A `ReadonlyArray` is considered to be a `NonEmptyReadonlyArray` if it contains at least one element.
 *
 * @param self - The `ReadonlyArray` to check.
 *
 * @example
 * ```ts
 * import { isNonEmptyReadonlyArray } from "effect/Array"
 *
 * assert.deepStrictEqual(isNonEmptyReadonlyArray([]), false);
 * assert.deepStrictEqual(isNonEmptyReadonlyArray([1, 2, 3]), true);
 * ```
 *
 * @category guards
 * @since 2.0.0
 */
const isNonEmptyReadonlyArray = isNonEmptyArray$1;
const isOutOfBound = (i, as) => i < 0 || i >= as.length;
const clamp = (i, as) => Math.floor(Math.min(Math.max(0, i), as.length));
/**
 * This function provides a safe way to read a value at a particular index from a `ReadonlyArray`.
 *
 * @category getters
 * @since 2.0.0
 */
const get$a = /*#__PURE__*/dual(2, (self, index) => {
  const i = Math.floor(index);
  return isOutOfBound(i, self) ? none$4() : some(self[i]);
});
/**
 * Gets an element unsafely, will throw on out of bounds.
 *
 * @since 2.0.0
 * @category unsafe
 */
const unsafeGet$3 = /*#__PURE__*/dual(2, (self, index) => {
  const i = Math.floor(index);
  if (isOutOfBound(i, self)) {
    throw new Error(`Index ${i} out of bounds`);
  }
  return self[i];
});
/**
 * Get the first element of a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.
 *
 * @category getters
 * @since 2.0.0
 */
const head = /*#__PURE__*/get$a(0);
/**
 * Get the first element of a non empty array.
 *
 * @example
 * ```ts
 * import { Array } from "effect"
 *
 * const result = Array.headNonEmpty([1, 2, 3, 4])
 * assert.deepStrictEqual(result, 1)
 * ```
 *
 * @category getters
 * @since 2.0.0
 */
const headNonEmpty$1 = /*#__PURE__*/unsafeGet$3(0);
/**
 * Get the last element in a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.
 *
 * @category getters
 * @since 2.0.0
 */
const last = self => isNonEmptyReadonlyArray(self) ? some(lastNonEmpty(self)) : none$4();
/**
 * Get the last element of a non empty array.
 *
 * @example
 * ```ts
 * import { Array } from "effect"
 *
 * const result = Array.lastNonEmpty([1, 2, 3, 4])
 * assert.deepStrictEqual(result, 4)
 * ```
 *
 * @category getters
 * @since 2.0.0
 */
const lastNonEmpty = self => self[self.length - 1];
/**
 * Get all but the first element of a `NonEmptyReadonlyArray`.
 *
 * @example
 * ```ts
 * import { Array } from "effect"
 *
 * const result = Array.tailNonEmpty([1, 2, 3, 4])
 * assert.deepStrictEqual(result, [2, 3, 4])
 * ```
 *
 * @category getters
 * @since 2.0.0
 */
const tailNonEmpty$1 = self => self.slice(1);
/**
 * Get all but the last element of a non empty array, creating a new array.
 *
 * @example
 * ```ts
 * import { Array } from "effect"
 *
 * const result = Array.initNonEmpty([1, 2, 3, 4])
 * assert.deepStrictEqual(result, [1, 2, 3])
 * ```
 *
 * @category getters
 * @since 2.0.0
 */
const initNonEmpty = self => self.slice(0, -1);
const spanIndex = (self, predicate) => {
  let i = 0;
  for (const a of self) {
    if (!predicate(a, i)) {
      break;
    }
    i++;
  }
  return i;
};
/**
 * Split an `Iterable` into two parts:
 *
 * 1. the longest initial subarray for which all elements satisfy the specified predicate
 * 2. the remaining elements
 *
 * @category splitting
 * @since 2.0.0
 */
const span = /*#__PURE__*/dual(2, (self, predicate) => splitAt(self, spanIndex(self, predicate)));
/**
 * Drop a max number of elements from the start of an `Iterable`, creating a new `Array`.
 *
 * **Note**. `n` is normalized to a non negative integer.
 *
 * @example
 * ```ts
 * import { Array } from "effect"
 *
 * const numbers = [1, 2, 3, 4, 5]
 * const result = Array.drop(numbers, 2)
 * assert.deepStrictEqual(result, [3, 4, 5])
 * ```
 *
 * @category getters
 * @since 2.0.0
 */
const drop$1 = /*#__PURE__*/dual(2, (self, n) => {
  const input = fromIterable$6(self);
  return input.slice(clamp(n, input), input.length);
});
/**
 * Reverse an `Iterable`, creating a new `Array`.
 *
 * @example
 * ```ts
 * import { Array } from "effect"
 *
 * const numbers = [1, 2, 3, 4]
 * const result = Array.reverse(numbers)
 * assert.deepStrictEqual(result, [4, 3, 2, 1])
 * ```
 *
 * @category elements
 * @since 2.0.0
 */
const reverse$2 = self => Array.from(self).reverse();
/**
 * Create a new array with elements sorted in increasing order based on the specified comparator.
 * If the input is a `NonEmptyReadonlyArray`, the output will also be a `NonEmptyReadonlyArray`.
 *
 * @category sorting
 * @since 2.0.0
 */
const sort = /*#__PURE__*/dual(2, (self, O) => {
  const out = Array.from(self);
  out.sort(O);
  return out;
});
/**
 * Takes two `Iterable`s and returns an `Array` of corresponding pairs.
 * If one input `Iterable` is short, excess elements of the
 * longer `Iterable` are discarded.
 *
 * @example
 * ```ts
 * import { Array } from "effect"
 *
 * const array1 = [1, 2, 3]
 * const array2 = ['a', 'b']
 * const result = Array.zip(array1, array2)
 * assert.deepStrictEqual(result, [[1, 'a'], [2, 'b']])
 * ```
 *
 * @category zipping
 * @since 2.0.0
 */
const zip$1 = /*#__PURE__*/dual(2, (self, that) => zipWith(self, that, make$p));
/**
 * Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results in a new `Array`. If one
 * input `Iterable` is short, excess elements of the longer `Iterable` are discarded.
 *
 * @example
 * ```ts
 * import { Array } from "effect"
 *
 * const array1 = [1, 2, 3]
 * const array2 = [4, 5, 6]
 * const result = Array.zipWith(array1, array2, (a, b) => a + b)
 * assert.deepStrictEqual(result, [5, 7, 9])
 * ```
 *
 * @category zipping
 * @since 2.0.0
 */
const zipWith = /*#__PURE__*/dual(3, (self, that, f) => {
  const as = fromIterable$6(self);
  const bs = fromIterable$6(that);
  if (isNonEmptyReadonlyArray(as) && isNonEmptyReadonlyArray(bs)) {
    const out = [f(headNonEmpty$1(as), headNonEmpty$1(bs))];
    const len = Math.min(as.length, bs.length);
    for (let i = 1; i < len; i++) {
      out[i] = f(as[i], bs[i]);
    }
    return out;
  }
  return [];
});
/**
 * Apply a function to the last element, creating a new `NonEmptyReadonlyArray`.
 *
 * @example
 * ```ts
 * import { Array } from "effect"
 *
 * const result = Array.modifyNonEmptyLast([1, 2, 3], n => n * 2)
 * assert.deepStrictEqual(result, [1, 2, 6])
 * ```
 *
 * @since 2.0.0
 */
const modifyNonEmptyLast = /*#__PURE__*/dual(2, (self, f) => append$1(initNonEmpty(self), f(lastNonEmpty(self))));
const _equivalence$2 = /*#__PURE__*/equivalence();
/**
 * Splits an `Iterable` into two segments, with the first segment containing a maximum of `n` elements.
 * The value of `n` can be `0`.
 *
 * @example
 * ```ts
 * import { Array } from "effect"
 *
 * const numbers = [1, 2, 3, 4, 5]
 * const result = Array.splitAt(numbers, 3)
 * assert.deepStrictEqual(result, [[1, 2, 3], [4, 5]])
 * ```
 *
 * @category splitting
 * @since 2.0.0
 */
const splitAt = /*#__PURE__*/dual(2, (self, n) => {
  const input = Array.from(self);
  const _n = Math.floor(n);
  if (isNonEmptyReadonlyArray(input)) {
    if (_n >= 1) {
      return splitNonEmptyAt(input, _n);
    }
    return [[], input];
  }
  return [input, []];
});
/**
 * Splits a `NonEmptyReadonlyArray` into two segments, with the first segment containing a maximum of `n` elements.
 * The value of `n` must be `>= 1`.
 *
 * @example
 * ```ts
 * import { Array } from "effect"
 *
 * const result = Array.splitNonEmptyAt(["a", "b", "c", "d", "e"], 3)
 * assert.deepStrictEqual(result, [["a", "b", "c"], ["d", "e"]])
 * ```
 *
 * @category splitting
 * @since 2.0.0
 */
const splitNonEmptyAt = /*#__PURE__*/dual(2, (self, n) => {
  const _n = Math.max(1, Math.floor(n));
  return _n >= self.length ? [copy$1(self), []] : [prepend$2(self.slice(1, _n), headNonEmpty$1(self)), self.slice(_n)];
});
/**
 * Copies an array.
 *
 * @example
 * ```ts
 * import { Array } from "effect"
 *
 * const numbers = [1, 2, 3]
 * const copy = Array.copy(numbers)
 * assert.deepStrictEqual(copy, [1, 2, 3])
 * ```
 *
 * @since 2.0.0
 */
const copy$1 = self => self.slice();
/**
 * Calculates the union of two arrays using the provided equivalence relation.
 *
 * @example
 * ```ts
 * import { Array } from "effect"
 *
 * const array1 = [1, 2]
 * const array2 = [2, 3]
 * const union = Array.unionWith(array1, array2, (a, b) => a === b)
 * assert.deepStrictEqual(union, [1, 2, 3])
 * ```
 *
 * @since 2.0.0
 */
const unionWith = /*#__PURE__*/dual(3, (self, that, isEquivalent) => {
  const a = fromIterable$6(self);
  const b = fromIterable$6(that);
  if (isNonEmptyReadonlyArray(a)) {
    if (isNonEmptyReadonlyArray(b)) {
      const dedupe = dedupeWith(isEquivalent);
      return dedupe(appendAll$2(a, b));
    }
    return a;
  }
  return b;
});
/**
 * Creates a union of two arrays, removing duplicates.
 *
 * @example
 * ```ts
 * import { Array } from "effect"
 *
 * const array1 = [1, 2]
 * const array2 = [2, 3]
 * const result = Array.union(array1, array2)
 * assert.deepStrictEqual(result, [1, 2, 3])
 * ```
 *
 * @since 2.0.0
 */
const union$2 = /*#__PURE__*/dual(2, (self, that) => unionWith(self, that, _equivalence$2));
/**
 * @category constructors
 * @since 2.0.0
 */
const empty$j = () => [];
/**
 * Constructs a new `NonEmptyArray<A>` from the specified value.
 *
 * @category constructors
 * @since 2.0.0
 */
const of$2 = a => [a];
/**
 * @category mapping
 * @since 2.0.0
 */
const map$5 = /*#__PURE__*/dual(2, (self, f) => self.map(f));
/**
 * Applies a function to each element in an array and returns a new array containing the concatenated mapped elements.
 *
 * @category sequencing
 * @since 2.0.0
 */
const flatMap$4 = /*#__PURE__*/dual(2, (self, f) => {
  if (isEmptyReadonlyArray(self)) {
    return [];
  }
  const out = [];
  for (let i = 0; i < self.length; i++) {
    const inner = f(self[i], i);
    for (let j = 0; j < inner.length; j++) {
      out.push(inner[j]);
    }
  }
  return out;
});
/**
 * Combines multiple arrays into a single array by concatenating all elements
 * from each nested array. This function ensures that the structure of nested
 * arrays is collapsed into a single, flat array.
 *
 * @example
 * ```ts
 * import { Array } from "effect";
 *
 * const nestedArrays = [[1, 2], [], [3, 4], [], [5, 6]]
 * const result = Array.flatten(nestedArrays)
 *
 * assert.deepStrictEqual(result, [1, 2, 3, 4, 5, 6]);
 * ```
 *
 * @category sequencing
 * @since 2.0.0
 */
const flatten$3 = /*#__PURE__*/flatMap$4(identity);
/**
 * Reduces an array from the left.
 *
 * @example
 * ```ts
 * import { Array } from "effect"
 *
 * const numbers = [1, 2, 3]
 * const result = Array.reduce(numbers, 0, (acc, n) => acc + n)
 * assert.deepStrictEqual(result, 6)
 * ```
 *
 * @category folding
 * @since 2.0.0
 */
const reduce$6 = /*#__PURE__*/dual(3, (self, b, f) => fromIterable$6(self).reduce((b, a, i) => f(b, a, i), b));
/**
 * @category constructors
 * @since 2.0.0
 */
const unfold = (b, f) => {
  const out = [];
  let next = b;
  let o;
  while (isSome(o = f(next))) {
    const [a, b] = o.value;
    out.push(a);
    next = b;
  }
  return out;
};
/**
 * Creates an equivalence relation for arrays.
 *
 * @example
 * ```ts
 * import { Array } from "effect"
 *
 * const numbers1 = [1, 2, 3]
 * const numbers2 = [1, 2, 3]
 * const eq = Array.getEquivalence<number>((a, b) => a === b)
 * assert.deepStrictEqual(eq(numbers1, numbers2), true)
 * ```
 *
 * @category instances
 * @since 2.0.0
 */
const getEquivalence$2 = array$1;
/**
 * Remove duplicates from an `Iterable` using the provided `isEquivalent` function,
 * preserving the order of the first occurrence of each element.
 *
 * @example
 * ```ts
 * import { Array } from "effect"
 *
 * const numbers = [1, 2, 2, 3, 3, 3]
 * const unique = Array.dedupeWith(numbers, (a, b) => a === b)
 * assert.deepStrictEqual(unique, [1, 2, 3])
 * ```
 *
 * @since 2.0.0
 */
const dedupeWith = /*#__PURE__*/dual(2, (self, isEquivalent) => {
  const input = fromIterable$6(self);
  if (isNonEmptyReadonlyArray(input)) {
    const out = [headNonEmpty$1(input)];
    const rest = tailNonEmpty$1(input);
    for (const r of rest) {
      if (out.every(a => !isEquivalent(r, a))) {
        out.push(r);
      }
    }
    return out;
  }
  return [];
});
/**
 * Remove duplicates from an `Iterable`, preserving the order of the first occurrence of each element.
 * The equivalence used to compare elements is provided by `Equal.equivalence()` from the `Equal` module.
 *
 * @since 2.0.0
 */
const dedupe = self => dedupeWith(self, equivalence());
/**
 * Joins the elements together with "sep" in the middle.
 *
 * @example
 * ```ts
 * import { Array } from "effect"
 *
 * const strings = ["a", "b", "c"]
 * const joined = Array.join(strings, "-")
 * assert.deepStrictEqual(joined, "a-b-c")
 * ```
 *
 * @since 2.0.0
 * @category folding
 */
const join$1 = /*#__PURE__*/dual(2, (self, sep) => fromIterable$6(self).join(sep));

/**
 * This module provides utility functions and type class instances for working with the `number` type in TypeScript.
 * It includes functions for basic arithmetic operations, as well as type class instances for
 * `Equivalence` and `Order`.
 *
 * @since 2.0.0
 */
/**
 * @category instances
 * @since 2.0.0
 */
const Order$1 = number;
/**
 * Tries to parse a `number` from a `string` using the `Number()` function.
 * The following special string values are supported: "NaN", "Infinity", "-Infinity".
 *
 * @category constructors
 * @since 2.0.0
 */
const parse = s => {
  if (s === "NaN") {
    return some$1(NaN);
  }
  if (s === "Infinity") {
    return some$1(Infinity);
  }
  if (s === "-Infinity") {
    return some$1(-Infinity);
  }
  if (s.trim() === "") {
    return none$5;
  }
  const n = Number(s);
  return Number.isNaN(n) ? none$5 : some$1(n);
};

/**
 * This module provides utility functions for working with RegExp in TypeScript.
 *
 * @since 2.0.0
 */
/**
 * Escapes special characters in a regular expression pattern.
 *
 * @example
 * ```ts
 * import { RegExp } from "effect"
 *
 * assert.deepStrictEqual(RegExp.escape("a*b"), "a\\*b")
 * ```
 *
 * @since 2.0.0
 */
const escape = string => string.replace(/[/\\^$*+?.()|[\]{}]/g, "\\$&");

/** @internal */
const getKeysForIndexSignature = (input, parameter) => {
  switch (parameter._tag) {
    case "StringKeyword":
    case "TemplateLiteral":
      return Object.keys(input);
    case "SymbolKeyword":
      return Object.getOwnPropertySymbols(input);
    case "Refinement":
      return getKeysForIndexSignature(input, parameter.from);
  }
};
/** @internal */
const ownKeys = o => Object.keys(o).concat(Object.getOwnPropertySymbols(o));
/** @internal */
const memoizeThunk = f => {
  let done = false;
  let a;
  return () => {
    if (done) {
      return a;
    }
    a = f();
    done = true;
    return a;
  };
};
/** @internal */
const formatUnknown = u => {
  if (isString(u)) {
    return JSON.stringify(u);
  } else if (isNumber(u) || u == null || isBoolean(u) || isSymbol(u) || isDate(u)) {
    return String(u);
  } else if (isBigInt(u)) {
    return String(u) + "n";
  } else if (!Array.isArray(u) && hasProperty(u, "toString") && isFunction(u["toString"]) && u["toString"] !== Object.prototype.toString) {
    return u["toString"]();
  }
  try {
    JSON.stringify(u);
    if (Array.isArray(u)) {
      return `[${u.map(formatUnknown).join(",")}]`;
    } else {
      return `{${ownKeys(u).map(k => `${isString(k) ? JSON.stringify(k) : String(k)}:${formatUnknown(u[k])}`).join(",")}}`;
    }
  } catch (e) {
    return String(u);
  }
};
/** @internal */
const formatPropertyKey$1 = name => typeof name === "string" ? JSON.stringify(name) : String(name);

/** @internal */
const getDuplicatePropertySignatureErrorMessage = name => `Duplicate property signature ${formatUnknown(name)}`;
/** @internal */
const getErrorMessage = (api, message) => `${api}: ${message}`;

/**
 * @since 0.67.0
 */
/**
 * @category annotations
 * @since 0.67.0
 */
const TypeAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Type");
/**
 * @category annotations
 * @since 0.67.0
 */
const MessageAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Message");
/**
 * @category annotations
 * @since 0.67.0
 */
const IdentifierAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Identifier");
/**
 * @category annotations
 * @since 0.67.0
 */
const TitleAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Title");
/**
 * @category annotations
 * @since 0.67.0
 */
const DescriptionAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Description");
/**
 * @category annotations
 * @since 0.67.0
 */
const ExamplesAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Examples");
/**
 * @category annotations
 * @since 0.67.0
 */
const DefaultAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Default");
/**
 * @category annotations
 * @since 0.67.0
 */
const JSONSchemaAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/JSONSchema");
/**
 * @category annotations
 * @since 0.67.0
 */
const DocumentationAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Documentation");
/**
 * @category annotations
 * @since 0.67.0
 */
const ConcurrencyAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Concurrency");
/**
 * @category annotations
 * @since 0.67.0
 */
const BatchingAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Batching");
/**
 * @category annotations
 * @since 0.67.0
 */
const ParseIssueTitleAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/ParseIssueTitle");
/** @internal */
const SurrogateAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/Surrogate");
/**
 * @category annotations
 * @since 0.67.0
 */
const getAnnotation = /*#__PURE__*/dual(2, (annotated, key) => Object.prototype.hasOwnProperty.call(annotated.annotations, key) ? some(annotated.annotations[key]) : none$4());
/**
 * @category annotations
 * @since 0.67.0
 */
const getMessageAnnotation = /*#__PURE__*/getAnnotation(MessageAnnotationId);
/**
 * @category annotations
 * @since 0.67.0
 */
const getTitleAnnotation = /*#__PURE__*/getAnnotation(TitleAnnotationId);
/**
 * @category annotations
 * @since 0.67.0
 */
const getIdentifierAnnotation = /*#__PURE__*/getAnnotation(IdentifierAnnotationId);
/**
 * @category annotations
 * @since 0.67.0
 */
const getDescriptionAnnotation = /*#__PURE__*/getAnnotation(DescriptionAnnotationId);
/**
 * @category annotations
 * @since 0.67.0
 */
const getConcurrencyAnnotation = /*#__PURE__*/getAnnotation(ConcurrencyAnnotationId);
/**
 * @category annotations
 * @since 0.67.0
 */
const getBatchingAnnotation = /*#__PURE__*/getAnnotation(BatchingAnnotationId);
/**
 * @category annotations
 * @since 0.67.0
 */
const getParseIssueTitleAnnotation$1 = /*#__PURE__*/getAnnotation(ParseIssueTitleAnnotationId);
/** @internal */
const getSurrogateAnnotation = /*#__PURE__*/getAnnotation(SurrogateAnnotationId);
const JSONIdentifierAnnotationId = /*#__PURE__*/Symbol.for("@effect/schema/annotation/JSONIdentifier");
/** @internal */
const getJSONIdentifierAnnotation = /*#__PURE__*/getAnnotation(JSONIdentifierAnnotationId);
/**
 * @category model
 * @since 0.67.0
 */
let Declaration$1 = class Declaration {
  typeParameters;
  decodeUnknown;
  encodeUnknown;
  annotations;
  /**
   * @since 0.67.0
   */
  _tag = "Declaration";
  constructor(typeParameters, decodeUnknown, encodeUnknown, annotations = {}) {
    this.typeParameters = typeParameters;
    this.decodeUnknown = decodeUnknown;
    this.encodeUnknown = encodeUnknown;
    this.annotations = annotations;
  }
  /**
   * @since 0.67.0
   */
  toString(verbose = false) {
    return getOrElse(getExpected(this, verbose), () => "<declaration schema>");
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      typeParameters: this.typeParameters.map(ast => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
const createASTGuard = tag => ast => ast._tag === tag;
/**
 * @category model
 * @since 0.67.0
 */
let Literal$1 = class Literal {
  literal;
  annotations;
  /**
   * @since 0.67.0
   */
  _tag = "Literal";
  constructor(literal, annotations = {}) {
    this.literal = literal;
    this.annotations = annotations;
  }
  /**
   * @since 0.67.0
   */
  toString(verbose = false) {
    return getOrElse(getExpected(this, verbose), () => formatUnknown(this.literal));
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      literal: isBigInt(this.literal) ? String(this.literal) : this.literal,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
/**
 * @category guards
 * @since 0.67.0
 */
const isLiteral = /*#__PURE__*/createASTGuard("Literal");
const $null = /*#__PURE__*/new Literal$1(null, {
  [IdentifierAnnotationId]: "null"
});
/**
 * @category model
 * @since 0.67.0
 */
class UniqueSymbol {
  symbol;
  annotations;
  /**
   * @since 0.67.0
   */
  _tag = "UniqueSymbol";
  constructor(symbol, annotations = {}) {
    this.symbol = symbol;
    this.annotations = annotations;
  }
  /**
   * @since 0.67.0
   */
  toString(verbose = false) {
    return getOrElse(getExpected(this, verbose), () => formatUnknown(this.symbol));
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      symbol: String(this.symbol),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
 * @category model
 * @since 0.67.0
 */
class UndefinedKeyword {
  annotations;
  /**
   * @since 0.67.0
   */
  _tag = "UndefinedKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
   * @since 0.67.0
   */
  toString(verbose = false) {
    return formatKeyword(this, verbose);
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
 * @category constructors
 * @since 0.67.0
 */
const undefinedKeyword = /*#__PURE__*/new UndefinedKeyword({
  [TitleAnnotationId]: "undefined"
});
/**
 * @category model
 * @since 0.67.0
 */
class VoidKeyword {
  annotations;
  /**
   * @since 0.67.0
   */
  _tag = "VoidKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
   * @since 0.67.0
   */
  toString(verbose = false) {
    return formatKeyword(this, verbose);
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
 * @category constructors
 * @since 0.67.0
 */
const voidKeyword = /*#__PURE__*/new VoidKeyword({
  [TitleAnnotationId]: "void"
});
/**
 * @category model
 * @since 0.67.0
 */
class NeverKeyword {
  annotations;
  /**
   * @since 0.67.0
   */
  _tag = "NeverKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
   * @since 0.67.0
   */
  toString(verbose = false) {
    return formatKeyword(this, verbose);
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
 * @category constructors
 * @since 0.67.0
 */
const neverKeyword = /*#__PURE__*/new NeverKeyword({
  [TitleAnnotationId]: "never"
});
/**
 * @category model
 * @since 0.67.0
 */
class UnknownKeyword {
  annotations;
  /**
   * @since 0.67.0
   */
  _tag = "UnknownKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
   * @since 0.67.0
   */
  toString(verbose = false) {
    return formatKeyword(this, verbose);
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
 * @category constructors
 * @since 0.67.0
 */
const unknownKeyword = /*#__PURE__*/new UnknownKeyword({
  [TitleAnnotationId]: "unknown"
});
/**
 * @category model
 * @since 0.67.0
 */
class AnyKeyword {
  annotations;
  /**
   * @since 0.67.0
   */
  _tag = "AnyKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
   * @since 0.67.0
   */
  toString(verbose = false) {
    return formatKeyword(this, verbose);
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
 * @category constructors
 * @since 0.67.0
 */
const anyKeyword = /*#__PURE__*/new AnyKeyword({
  [TitleAnnotationId]: "any"
});
/**
 * @category model
 * @since 0.67.0
 */
class StringKeyword {
  annotations;
  /**
   * @since 0.67.0
   */
  _tag = "StringKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
   * @since 0.67.0
   */
  toString(verbose = false) {
    return formatKeyword(this, verbose);
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
 * @category constructors
 * @since 0.67.0
 */
const stringKeyword = /*#__PURE__*/new StringKeyword({
  [TitleAnnotationId]: "string",
  [DescriptionAnnotationId]: "a string"
});
/**
 * @category guards
 * @since 0.67.0
 */
const isStringKeyword = /*#__PURE__*/createASTGuard("StringKeyword");
/**
 * @category model
 * @since 0.67.0
 */
class NumberKeyword {
  annotations;
  /**
   * @since 0.67.0
   */
  _tag = "NumberKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
   * @since 0.67.0
   */
  toString(verbose = false) {
    return formatKeyword(this, verbose);
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
 * @category constructors
 * @since 0.67.0
 */
const numberKeyword = /*#__PURE__*/new NumberKeyword({
  [TitleAnnotationId]: "number",
  [DescriptionAnnotationId]: "a number"
});
/**
 * @category guards
 * @since 0.67.0
 */
const isNumberKeyword = /*#__PURE__*/createASTGuard("NumberKeyword");
/**
 * @category model
 * @since 0.67.0
 */
class BooleanKeyword {
  annotations;
  /**
   * @since 0.67.0
   */
  _tag = "BooleanKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
   * @since 0.67.0
   */
  toString(verbose = false) {
    return formatKeyword(this, verbose);
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
 * @category constructors
 * @since 0.67.0
 */
const booleanKeyword = /*#__PURE__*/new BooleanKeyword({
  [TitleAnnotationId]: "boolean",
  [DescriptionAnnotationId]: "a boolean"
});
/**
 * @category model
 * @since 0.67.0
 */
class BigIntKeyword {
  annotations;
  /**
   * @since 0.67.0
   */
  _tag = "BigIntKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
   * @since 0.67.0
   */
  toString(verbose = false) {
    return formatKeyword(this, verbose);
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
 * @category constructors
 * @since 0.67.0
 */
const bigIntKeyword = /*#__PURE__*/new BigIntKeyword({
  [TitleAnnotationId]: "bigint",
  [DescriptionAnnotationId]: "a bigint"
});
/**
 * @category model
 * @since 0.67.0
 */
class SymbolKeyword {
  annotations;
  /**
   * @since 0.67.0
   */
  _tag = "SymbolKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
   * @since 0.67.0
   */
  toString(verbose = false) {
    return formatKeyword(this, verbose);
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
 * @category constructors
 * @since 0.67.0
 */
const symbolKeyword = /*#__PURE__*/new SymbolKeyword({
  [TitleAnnotationId]: "symbol",
  [DescriptionAnnotationId]: "a symbol"
});
/**
 * @category guards
 * @since 0.67.0
 */
const isSymbolKeyword = /*#__PURE__*/createASTGuard("SymbolKeyword");
/**
 * @category model
 * @since 0.67.0
 */
class ObjectKeyword {
  annotations;
  /**
   * @since 0.67.0
   */
  _tag = "ObjectKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
   * @since 0.67.0
   */
  toString(verbose = false) {
    return formatKeyword(this, verbose);
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
 * @category constructors
 * @since 0.67.0
 */
const objectKeyword = /*#__PURE__*/new ObjectKeyword({
  [IdentifierAnnotationId]: "object",
  [TitleAnnotationId]: "object",
  [DescriptionAnnotationId]: "an object in the TypeScript meaning, i.e. the `object` type"
});
/**
 * @category model
 * @since 0.67.0
 */
let Enums$1 = class Enums {
  enums;
  annotations;
  /**
   * @since 0.67.0
   */
  _tag = "Enums";
  constructor(enums, annotations = {}) {
    this.enums = enums;
    this.annotations = annotations;
  }
  /**
   * @since 0.67.0
   */
  toString(verbose = false) {
    return getOrElse(getExpected(this, verbose), () => `<enum ${this.enums.length} value(s): ${this.enums.map((_, value) => JSON.stringify(value)).join(" | ")}>`);
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      enums: this.enums,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
/**
 * @category model
 * @since 0.67.0
 */
class TemplateLiteralSpan {
  type;
  literal;
  constructor(type, literal) {
    this.type = type;
    this.literal = literal;
  }
  /**
   * @since 0.67.0
   */
  toString() {
    switch (this.type._tag) {
      case "StringKeyword":
        return "${string}";
      case "NumberKeyword":
        return "${number}";
    }
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      type: this.type.toJSON(),
      literal: this.literal
    };
  }
}
/**
 * @category model
 * @since 0.67.0
 */
let TemplateLiteral$1 = class TemplateLiteral {
  head;
  spans;
  annotations;
  static make = (head, spans, annotations = {}) => isNonEmptyReadonlyArray(spans) ? new TemplateLiteral(head, spans, annotations) : new Literal$1(head);
  /**
   * @since 0.67.0
   */
  _tag = "TemplateLiteral";
  constructor(head, spans, annotations = {}) {
    this.head = head;
    this.spans = spans;
    this.annotations = annotations;
  }
  /**
   * @since 0.67.0
   */
  toString(verbose = false) {
    return getOrElse(getExpected(this, verbose), () => formatTemplateLiteral(this));
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      head: this.head,
      spans: this.spans.map(span => span.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
const formatTemplateLiteral = ast => "`" + ast.head + ast.spans.map(span => String(span) + span.literal).join("") + "`";
/**
 * @category model
 * @since 0.67.0
 */
class Element {
  type;
  isOptional;
  constructor(type, isOptional) {
    this.type = type;
    this.isOptional = isOptional;
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      type: this.type.toJSON(),
      isOptional: this.isOptional
    };
  }
  /**
   * @since 0.67.0
   */
  toString() {
    return String(this.type) + (this.isOptional ? "?" : "");
  }
}
/**
 * @category model
 * @since 0.67.0
 */
let TupleType$1 = class TupleType {
  elements;
  rest;
  isReadonly;
  annotations;
  /**
   * @since 0.67.0
   */
  _tag = "TupleType";
  constructor(elements, rest, isReadonly, annotations = {}) {
    this.elements = elements;
    this.rest = rest;
    this.isReadonly = isReadonly;
    this.annotations = annotations;
    let hasOptionalElement = false;
    let hasIllegalRequiredElement = false;
    for (const e of elements) {
      if (e.isOptional) {
        hasOptionalElement = true;
      } else if (hasOptionalElement) {
        hasIllegalRequiredElement = true;
        break;
      }
    }
    if (hasIllegalRequiredElement || hasOptionalElement && rest.length > 1) {
      throw new Error(getRequiredElementFollowinAnOptionalElementErrorMessage);
    }
  }
  /**
   * @since 0.67.0
   */
  toString(verbose = false) {
    return getOrElse(getExpected(this, verbose), () => formatTuple(this));
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      elements: this.elements.map(e => e.toJSON()),
      rest: this.rest.map(ast => ast.toJSON()),
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
const formatTuple = ast => {
  const formattedElements = ast.elements.map(String).join(", ");
  return matchLeft(ast.rest, {
    onEmpty: () => `readonly [${formattedElements}]`,
    onNonEmpty: (head, tail) => {
      const formattedHead = String(head);
      const wrappedHead = formattedHead.includes(" | ") ? `(${formattedHead})` : formattedHead;
      if (tail.length > 0) {
        const formattedTail = tail.map(String).join(", ");
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`;
        } else {
          return `readonly [...${wrappedHead}[], ${formattedTail}]`;
        }
      } else {
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[]]`;
        } else {
          return `ReadonlyArray<${formattedHead}>`;
        }
      }
    }
  });
};
/**
 * @category model
 * @since 0.67.0
 */
class PropertySignature {
  name;
  type;
  isOptional;
  isReadonly;
  annotations;
  constructor(name, type, isOptional, isReadonly, annotations = {}) {
    this.name = name;
    this.type = type;
    this.isOptional = isOptional;
    this.isReadonly = isReadonly;
    this.annotations = annotations;
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      name: String(this.name),
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
 * @since 0.67.0
 */
const isParameter = ast => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return true;
    case "Refinement":
      return isParameter(ast.from);
  }
  return false;
};
/**
 * @category model
 * @since 0.67.0
 */
class IndexSignature {
  type;
  isReadonly;
  /**
   * @since 0.67.0
   */
  parameter;
  constructor(parameter, type, isReadonly) {
    this.type = type;
    this.isReadonly = isReadonly;
    if (isParameter(parameter)) {
      this.parameter = parameter;
    } else {
      throw new Error(getIndexSignatureParameterErrorMessage);
    }
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      parameter: this.parameter.toJSON(),
      type: this.type.toJSON(),
      isReadonly: this.isReadonly
    };
  }
}
/**
 * @category model
 * @since 0.67.0
 */
let TypeLiteral$1 = class TypeLiteral {
  annotations;
  /**
   * @since 0.67.0
   */
  _tag = "TypeLiteral";
  /**
   * @since 0.67.0
   */
  propertySignatures;
  /**
   * @since 0.67.0
   */
  indexSignatures;
  constructor(propertySignatures, indexSignatures, annotations = {}) {
    this.annotations = annotations;
    // check for duplicate property signatures
    const keys = {};
    for (let i = 0; i < propertySignatures.length; i++) {
      const name = propertySignatures[i].name;
      if (Object.prototype.hasOwnProperty.call(keys, name)) {
        throw new Error(getDuplicatePropertySignatureErrorMessage(name));
      }
      keys[name] = null;
    }
    // check for duplicate index signatures
    const parameters = {
      string: false,
      symbol: false
    };
    for (let i = 0; i < indexSignatures.length; i++) {
      const parameter = getParameterBase(indexSignatures[i].parameter);
      if (isStringKeyword(parameter)) {
        if (parameters.string) {
          throw new Error(getDuplicateIndexSignatureErrorMessage("string"));
        }
        parameters.string = true;
      } else if (isSymbolKeyword(parameter)) {
        if (parameters.symbol) {
          throw new Error(getDuplicateIndexSignatureErrorMessage("symbol"));
        }
        parameters.symbol = true;
      }
    }
    this.propertySignatures = sortPropertySignatures(propertySignatures);
    this.indexSignatures = sortIndexSignatures(indexSignatures);
  }
  /**
   * @since 0.67.0
   */
  toString(verbose = false) {
    return getOrElse(getExpected(this, verbose), () => formatTypeLiteral(this));
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      propertySignatures: this.propertySignatures.map(ps => ps.toJSON()),
      indexSignatures: this.indexSignatures.map(ps => ps.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
const formatTypeLiteral = ast => {
  const formattedPropertySignatures = ast.propertySignatures.map(ps => (ps.isReadonly ? "readonly " : "") + String(ps.name) + (ps.isOptional ? "?" : "") + ": " + ps.type).join("; ");
  if (ast.indexSignatures.length > 0) {
    const formattedIndexSignatures = ast.indexSignatures.map(is => (is.isReadonly ? "readonly " : "") + `[x: ${getParameterBase(is.parameter)}]: ${is.type}`).join("; ");
    if (ast.propertySignatures.length > 0) {
      return `{ ${formattedPropertySignatures}; ${formattedIndexSignatures} }`;
    } else {
      return `{ ${formattedIndexSignatures} }`;
    }
  } else {
    if (ast.propertySignatures.length > 0) {
      return `{ ${formattedPropertySignatures} }`;
    } else {
      return "{}";
    }
  }
};
const removeNevers = candidates => candidates.filter(ast => !(ast === neverKeyword));
const sortCandidates = /*#__PURE__*/sort( /*#__PURE__*/mapInput(Order$1, ast => {
  switch (ast._tag) {
    case "AnyKeyword":
      return 0;
    case "UnknownKeyword":
      return 1;
    case "ObjectKeyword":
      return 2;
    case "StringKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
      return 3;
  }
  return 4;
}));
const literalMap = {
  string: "StringKeyword",
  number: "NumberKeyword",
  boolean: "BooleanKeyword",
  bigint: "BigIntKeyword"
};
/** @internal */
const flatten$2 = candidates => flatMap$4(candidates, ast => isUnion(ast) ? flatten$2(ast.types) : [ast]);
/** @internal */
const unify = candidates => {
  const cs = sortCandidates(candidates);
  const out = [];
  const uniques = {};
  const literals = [];
  for (const ast of cs) {
    switch (ast._tag) {
      case "NeverKeyword":
        break;
      case "AnyKeyword":
        return [anyKeyword];
      case "UnknownKeyword":
        return [unknownKeyword];
      // uniques
      case "ObjectKeyword":
      case "UndefinedKeyword":
      case "VoidKeyword":
      case "StringKeyword":
      case "NumberKeyword":
      case "BooleanKeyword":
      case "BigIntKeyword":
      case "SymbolKeyword":
        {
          if (!uniques[ast._tag]) {
            uniques[ast._tag] = ast;
            out.push(ast);
          }
          break;
        }
      case "Literal":
        {
          const type = typeof ast.literal;
          switch (type) {
            case "string":
            case "number":
            case "bigint":
            case "boolean":
              {
                const _tag = literalMap[type];
                if (!uniques[_tag] && !literals.includes(ast.literal)) {
                  literals.push(ast.literal);
                  out.push(ast);
                }
                break;
              }
            // null
            case "object":
              {
                if (!literals.includes(ast.literal)) {
                  literals.push(ast.literal);
                  out.push(ast);
                }
                break;
              }
          }
          break;
        }
      case "UniqueSymbol":
        {
          if (!uniques["SymbolKeyword"] && !literals.includes(ast.symbol)) {
            literals.push(ast.symbol);
            out.push(ast);
          }
          break;
        }
      case "TupleType":
        {
          if (!uniques["ObjectKeyword"]) {
            out.push(ast);
          }
          break;
        }
      case "TypeLiteral":
        {
          if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
            if (!uniques["{}"]) {
              uniques["{}"] = ast;
              out.push(ast);
            }
          } else if (!uniques["ObjectKeyword"]) {
            out.push(ast);
          }
          break;
        }
      default:
        out.push(ast);
    }
  }
  return out;
};
/**
 * @category model
 * @since 0.67.0
 */
let Union$2 = class Union {
  types;
  annotations;
  static make = (candidates, annotations) => {
    const types = [];
    const memo = new Set();
    for (let i = 0; i < candidates.length; i++) {
      const ast = candidates[i];
      if (ast === neverKeyword || memo.has(ast)) {
        continue;
      }
      memo.add(ast);
      types.push(ast);
    }
    return Union.union(types, annotations);
  };
  /** @internal */
  static members = (candidates, annotations) => {
    return Union.union(removeNevers(candidates), annotations);
  };
  /** @internal */
  static unify = (candidates, annotations) => {
    return Union.union(unify(flatten$2(candidates)), annotations);
  };
  /** @internal */
  static union = (types, annotations) => {
    return isMembers(types) ? new Union(types, annotations) : types.length === 1 ? types[0] : neverKeyword;
  };
  /**
   * @since 0.67.0
   */
  _tag = "Union";
  constructor(types, annotations = {}) {
    this.types = types;
    this.annotations = annotations;
  }
  /**
   * @since 0.67.0
   */
  toString(verbose = false) {
    return getOrElse(getExpected(this, verbose), () => this.types.map(String).join(" | "));
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      types: this.types.map(ast => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
/** @internal */
const mapMembers = (members, f) => members.map(f);
/** @internal */
const isMembers = as => as.length > 1;
/**
 * @category guards
 * @since 0.67.0
 */
const isUnion = /*#__PURE__*/createASTGuard("Union");
const toJSONMemoMap = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for("@effect/schema/AST/toJSONMemoMap"), () => new WeakMap());
/**
 * @category model
 * @since 0.67.0
 */
class Suspend {
  f;
  annotations;
  /**
   * @since 0.67.0
   */
  _tag = "Suspend";
  constructor(f, annotations = {}) {
    this.f = f;
    this.annotations = annotations;
    this.f = memoizeThunk(f);
  }
  /**
   * @since 0.67.0
   */
  toString(verbose = false) {
    return getExpected(this, verbose).pipe(orElse$2(() => flatMap$5(liftThrowable(this.f)(), ast => getExpected(ast, verbose))), getOrElse(() => "<suspended schema>"));
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    const ast = this.f();
    let out = toJSONMemoMap.get(ast);
    if (out) {
      return out;
    }
    toJSONMemoMap.set(ast, {
      _tag: this._tag
    });
    out = {
      _tag: this._tag,
      ast: ast.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
    toJSONMemoMap.set(ast, out);
    return out;
  }
}
/**
 * @category model
 * @since 0.67.0
 */
let Refinement$1 = class Refinement {
  from;
  filter;
  annotations;
  /**
   * @since 0.67.0
   */
  _tag = "Refinement";
  constructor(from, filter, annotations = {}) {
    this.from = from;
    this.filter = filter;
    this.annotations = annotations;
  }
  /**
   * @since 0.67.0
   */
  toString(verbose = false) {
    return getOrElse(getExpected(this, verbose), () => `{ ${this.from} | filter }`);
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
/**
 * @category guards
 * @since 0.67.0
 */
const isRefinement = /*#__PURE__*/createASTGuard("Refinement");
/**
 * @since 0.67.0
 */
const defaultParseOption = {};
/**
 * @category model
 * @since 0.67.0
 */
let Transformation$1 = class Transformation {
  from;
  to;
  transformation;
  annotations;
  /**
   * @since 0.67.0
   */
  _tag = "Transformation";
  constructor(from, to, transformation, annotations = {}) {
    this.from = from;
    this.to = to;
    this.transformation = transformation;
    this.annotations = annotations;
  }
  /**
   * @since 0.67.0
   */
  toString(verbose = false) {
    return getOrElse(getExpected(this, verbose), () => `(${String(this.from)} <-> ${String(this.to)})`);
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      to: this.to.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
/**
 * @category model
 * @since 0.67.0
 */
class FinalTransformation {
  decode;
  encode;
  /**
   * @since 0.67.0
   */
  _tag = "FinalTransformation";
  constructor(decode, encode) {
    this.decode = decode;
    this.encode = encode;
  }
}
/**
 * Represents a `PropertySignature -> PropertySignature` transformation
 *
 * The semantic of `decode` is:
 * - `none()` represents the absence of the key/value pair
 * - `some(value)` represents the presence of the key/value pair
 *
 * The semantic of `encode` is:
 * - `none()` you don't want to output the key/value pair
 * - `some(value)` you want to output the key/value pair
 *
 * @category model
 * @since 0.67.0
 */
let PropertySignatureTransformation$1 = class PropertySignatureTransformation {
  from;
  to;
  decode;
  encode;
  constructor(from, to, decode, encode) {
    this.from = from;
    this.to = to;
    this.decode = decode;
    this.encode = encode;
  }
};
/**
 * @category model
 * @since 0.67.0
 */
class TypeLiteralTransformation {
  propertySignatureTransformations;
  /**
   * @since 0.67.0
   */
  _tag = "TypeLiteralTransformation";
  constructor(propertySignatureTransformations) {
    this.propertySignatureTransformations = propertySignatureTransformations;
    // check for duplicate property signature transformations
    const fromKeys = {};
    const toKeys = {};
    for (const pst of propertySignatureTransformations) {
      const from = pst.from;
      if (fromKeys[from]) {
        throw new Error(getDuplicatePropertySignatureTransformationErrorMessage(from));
      }
      fromKeys[from] = true;
      const to = pst.to;
      if (toKeys[to]) {
        throw new Error(getDuplicatePropertySignatureTransformationErrorMessage(to));
      }
      toKeys[to] = true;
    }
  }
}
// -------------------------------------------------------------------------------------
// API
// -------------------------------------------------------------------------------------
/**
 * Adds a group of annotations, potentially overwriting existing annotations.
 *
 * @since 0.67.0
 */
const annotations = (ast, annotations) => {
  const d = Object.getOwnPropertyDescriptors(ast);
  d.annotations.value = {
    ...ast.annotations,
    ...annotations
  };
  return Object.create(Object.getPrototypeOf(ast), d);
};
const STRING_KEYWORD_PATTERN = ".*";
const NUMBER_KEYWORD_PATTERN = "[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?";
/**
 * @since 0.67.0
 */
const getTemplateLiteralRegExp = ast => {
  let pattern = `^${escape(ast.head)}`;
  for (const span of ast.spans) {
    if (isStringKeyword(span.type)) {
      pattern += STRING_KEYWORD_PATTERN;
    } else if (isNumberKeyword(span.type)) {
      pattern += NUMBER_KEYWORD_PATTERN;
    }
    pattern += escape(span.literal);
  }
  pattern += "$";
  return new RegExp(pattern);
};
/** @internal */
const record = (key, value) => {
  const propertySignatures = [];
  const indexSignatures = [];
  const go = key => {
    switch (key._tag) {
      case "NeverKeyword":
        break;
      case "StringKeyword":
      case "SymbolKeyword":
      case "TemplateLiteral":
      case "Refinement":
        indexSignatures.push(new IndexSignature(key, value, true));
        break;
      case "Literal":
        if (isString(key.literal) || isNumber(key.literal)) {
          propertySignatures.push(new PropertySignature(key.literal, value, false, true));
        } else {
          throw new Error(getErrorMessage("record", `unsupported literal (${formatUnknown(key.literal)})`));
        }
        break;
      case "Enums":
        {
          for (const [_, name] of key.enums) {
            propertySignatures.push(new PropertySignature(name, value, false, true));
          }
          break;
        }
      case "UniqueSymbol":
        propertySignatures.push(new PropertySignature(key.symbol, value, false, true));
        break;
      case "Union":
        key.types.forEach(go);
        break;
      default:
        throw new Error(getErrorMessage("record", `unsupported key schema (${key})`));
    }
  };
  go(key);
  return {
    propertySignatures,
    indexSignatures
  };
};
/**
 * Creates a new AST with shallow mutability applied to its properties.
 *
 * @param ast - The original AST to make properties mutable (shallowly).
 *
 * @since 0.67.0
 */
const mutable$1 = ast => {
  switch (ast._tag) {
    case "TupleType":
      return ast.isReadonly === false ? ast : new TupleType$1(ast.elements, ast.rest, false, ast.annotations);
    case "TypeLiteral":
      {
        const propertySignatures = changeMap(ast.propertySignatures, ps => ps.isReadonly === false ? ps : new PropertySignature(ps.name, ps.type, ps.isOptional, false, ps.annotations));
        const indexSignatures = changeMap(ast.indexSignatures, is => is.isReadonly === false ? is : new IndexSignature(is.parameter, is.type, false));
        return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral$1(propertySignatures, indexSignatures, ast.annotations);
      }
    case "Union":
      {
        const types = changeMap(ast.types, mutable$1);
        return types === ast.types ? ast : Union$2.make(types, ast.annotations);
      }
    case "Suspend":
      return new Suspend(() => mutable$1(ast.f()), ast.annotations);
    case "Refinement":
      {
        const from = mutable$1(ast.from);
        return from === ast.from ? ast : new Refinement$1(from, ast.filter, ast.annotations);
      }
    case "Transformation":
      {
        const from = mutable$1(ast.from);
        const to = mutable$1(ast.to);
        return from === ast.from && to === ast.to ? ast : new Transformation$1(from, to, ast.transformation, ast.annotations);
      }
  }
  return ast;
};
/**
 * @since 0.67.0
 */
const typeAST = ast => {
  switch (ast._tag) {
    case "Declaration":
      {
        const typeParameters = changeMap(ast.typeParameters, typeAST);
        return typeParameters === ast.typeParameters ? ast : new Declaration$1(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
      }
    case "TupleType":
      {
        const elements = changeMap(ast.elements, e => {
          const type = typeAST(e.type);
          return type === e.type ? e : new Element(type, e.isOptional);
        });
        const rest = changeMap(ast.rest, typeAST);
        return elements === ast.elements && rest === ast.rest ? ast : new TupleType$1(elements, rest, ast.isReadonly, ast.annotations);
      }
    case "TypeLiteral":
      {
        const propertySignatures = changeMap(ast.propertySignatures, p => {
          const type = typeAST(p.type);
          return type === p.type ? p : new PropertySignature(p.name, type, p.isOptional, p.isReadonly);
        });
        const indexSignatures = changeMap(ast.indexSignatures, is => {
          const type = typeAST(is.type);
          return type === is.type ? is : new IndexSignature(is.parameter, type, is.isReadonly);
        });
        return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral$1(propertySignatures, indexSignatures, ast.annotations);
      }
    case "Union":
      {
        const types = changeMap(ast.types, typeAST);
        return types === ast.types ? ast : Union$2.make(types, ast.annotations);
      }
    case "Suspend":
      return new Suspend(() => typeAST(ast.f()), ast.annotations);
    case "Refinement":
      {
        const from = typeAST(ast.from);
        return from === ast.from ? ast : new Refinement$1(from, ast.filter, ast.annotations);
      }
    case "Transformation":
      return typeAST(ast.to);
  }
  return ast;
};
/** @internal */
const getJSONIdentifier = annotated => orElse$2(getJSONIdentifierAnnotation(annotated), () => getIdentifierAnnotation(annotated));
const createJSONIdentifierAnnotation = annotated => match$3(getJSONIdentifier(annotated), {
  onNone: () => undefined,
  onSome: identifier => ({
    [JSONIdentifierAnnotationId]: identifier
  })
});
function changeMap(as, f) {
  let changed = false;
  const out = allocate(as.length);
  for (let i = 0; i < as.length; i++) {
    const a = as[i];
    const fa = f(a);
    if (fa !== a) {
      changed = true;
    }
    out[i] = fa;
  }
  return changed ? out : as;
}
const encodedAST_ = (ast, isBound) => {
  switch (ast._tag) {
    case "Declaration":
      {
        const typeParameters = changeMap(ast.typeParameters, ast => encodedAST_(ast));
        return typeParameters === ast.typeParameters ? ast : new Declaration$1(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
      }
    case "TupleType":
      {
        const elements = changeMap(ast.elements, e => {
          const type = encodedAST_(e.type);
          return type === e.type ? e : new Element(type, e.isOptional);
        });
        const rest = changeMap(ast.rest, ast => encodedAST_(ast));
        return elements === ast.elements && rest === ast.rest ? ast : new TupleType$1(elements, rest, ast.isReadonly, createJSONIdentifierAnnotation(ast));
      }
    case "TypeLiteral":
      {
        const propertySignatures = changeMap(ast.propertySignatures, ps => {
          const type = encodedAST_(ps.type);
          return type === ps.type ? ps : new PropertySignature(ps.name, type, ps.isOptional, ps.isReadonly);
        });
        const indexSignatures = changeMap(ast.indexSignatures, is => {
          const type = encodedAST_(is.type);
          return type === is.type ? is : new IndexSignature(is.parameter, type, is.isReadonly);
        });
        return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral$1(propertySignatures, indexSignatures, createJSONIdentifierAnnotation(ast));
      }
    case "Union":
      {
        const types = changeMap(ast.types, ast => encodedAST_(ast));
        return types === ast.types ? ast : Union$2.make(types, createJSONIdentifierAnnotation(ast));
      }
    case "Suspend":
      return new Suspend(() => encodedAST_(ast.f()), createJSONIdentifierAnnotation(ast));
    case "Refinement":
      {
        const from = encodedAST_(ast.from);
        return from;
      }
    case "Transformation":
      return encodedAST_(ast.from);
  }
  return ast;
};
/**
 * @since 0.67.0
 */
const encodedAST = ast => encodedAST_(ast);
const toJSONAnnotations = annotations => {
  const out = {};
  for (const k of Object.getOwnPropertySymbols(annotations)) {
    out[String(k)] = annotations[k];
  }
  return out;
};
/** @internal */
const getCardinality = ast => {
  switch (ast._tag) {
    case "NeverKeyword":
      return 0;
    case "Literal":
    case "UndefinedKeyword":
    case "VoidKeyword":
    case "UniqueSymbol":
      return 1;
    case "BooleanKeyword":
      return 2;
    case "StringKeyword":
    case "NumberKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
      return 3;
    case "ObjectKeyword":
      return 5;
    case "UnknownKeyword":
    case "AnyKeyword":
      return 6;
    default:
      return 4;
  }
};
const sortPropertySignatures = /*#__PURE__*/sort( /*#__PURE__*/mapInput(Order$1, ps => getCardinality(ps.type)));
const sortIndexSignatures = /*#__PURE__*/sort( /*#__PURE__*/mapInput(Order$1, is => {
  switch (getParameterBase(is.parameter)._tag) {
    case "StringKeyword":
      return 2;
    case "SymbolKeyword":
      return 3;
    case "TemplateLiteral":
      return 1;
  }
}));
/** @internal */
const getParameterBase = ast => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return ast;
    case "Refinement":
      return getParameterBase(ast.from);
  }
};
const formatKeyword = (ast, verbose = false) => getOrElse(getExpected(ast, verbose), () => ast._tag);
const getExpected = (ast, verbose) => {
  if (verbose) {
    const description = getDescriptionAnnotation(ast).pipe(orElse$2(() => getTitleAnnotation(ast)));
    return match$3(getIdentifierAnnotation(ast), {
      onNone: () => description,
      onSome: identifier => match$3(description, {
        onNone: () => some(identifier),
        onSome: description => some(`${identifier} (${description})`)
      })
    });
  } else {
    return getIdentifierAnnotation(ast).pipe(orElse$2(() => getTitleAnnotation(ast)), orElse$2(() => getDescriptionAnnotation(ast)));
  }
};
const getDuplicateIndexSignatureErrorMessage = name => `Duplicate index signature for type \`${name}\``;
const getIndexSignatureParameterErrorMessage = "An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types";
const getRequiredElementFollowinAnOptionalElementErrorMessage = "A required element cannot follow an optional element. ts(1257)";
const getDuplicatePropertySignatureTransformationErrorMessage = name => `Duplicate property signature transformation ${formatUnknown(name)}`;

/** @internal */
const GreaterThanTypeId$1 = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/GreaterThan");
/** @internal */
const GreaterThanOrEqualToTypeId$1 = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/GreaterThanOrEqualTo");
/** @internal */
const LessThanTypeId$1 = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/LessThan");
/** @internal */
const LessThanOrEqualToTypeId$1 = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/LessThanOrEqualTo");
/** @internal */
const IntTypeId$1 = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/Int");
/** @internal */
const MinLengthTypeId$1 = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/MinLength");
/** @internal */
const LengthTypeId$1 = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/Length");

/**
 * @since 0.67.0
 */
/**
 * @category hooks
 * @since 0.67.0
 */
const ArbitraryHookId = /*#__PURE__*/Symbol.for("@effect/schema/ArbitraryHookId");

/**
 * @since 2.0.0
 */
const TypeId$a = /*#__PURE__*/Symbol.for("effect/Chunk");
function copy(src, srcPos, dest, destPos, len) {
  for (let i = srcPos; i < Math.min(src.length, srcPos + len); i++) {
    dest[destPos + i - srcPos] = src[i];
  }
  return dest;
}
const emptyArray = [];
/**
 * Compares the two chunks of equal length using the specified function
 *
 * @category equivalence
 * @since 2.0.0
 */
const getEquivalence$1 = isEquivalent => make$r((self, that) => self.length === that.length && toReadonlyArray(self).every((value, i) => isEquivalent(value, unsafeGet$2(that, i))));
const _equivalence$1 = /*#__PURE__*/getEquivalence$1(equals$2);
const ChunkProto = {
  [TypeId$a]: {
    _A: _ => _
  },
  toString() {
    return format$4(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Chunk",
      values: toReadonlyArray(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol](that) {
    return isChunk(that) && _equivalence$1(this, that);
  },
  [symbol$1]() {
    return cached(this, array(toReadonlyArray(this)));
  },
  [Symbol.iterator]() {
    switch (this.backing._tag) {
      case "IArray":
        {
          return this.backing.array[Symbol.iterator]();
        }
      case "IEmpty":
        {
          return emptyArray[Symbol.iterator]();
        }
      default:
        {
          return toReadonlyArray(this)[Symbol.iterator]();
        }
    }
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
const makeChunk = backing => {
  const chunk = Object.create(ChunkProto);
  chunk.backing = backing;
  switch (backing._tag) {
    case "IEmpty":
      {
        chunk.length = 0;
        chunk.depth = 0;
        chunk.left = chunk;
        chunk.right = chunk;
        break;
      }
    case "IConcat":
      {
        chunk.length = backing.left.length + backing.right.length;
        chunk.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
        chunk.left = backing.left;
        chunk.right = backing.right;
        break;
      }
    case "IArray":
      {
        chunk.length = backing.array.length;
        chunk.depth = 0;
        chunk.left = _empty$6;
        chunk.right = _empty$6;
        break;
      }
    case "ISingleton":
      {
        chunk.length = 1;
        chunk.depth = 0;
        chunk.left = _empty$6;
        chunk.right = _empty$6;
        break;
      }
    case "ISlice":
      {
        chunk.length = backing.length;
        chunk.depth = backing.chunk.depth + 1;
        chunk.left = _empty$6;
        chunk.right = _empty$6;
        break;
      }
  }
  return chunk;
};
/**
 * Checks if `u` is a `Chunk<unknown>`
 *
 * @category constructors
 * @since 2.0.0
 */
const isChunk = u => hasProperty(u, TypeId$a);
const _empty$6 = /*#__PURE__*/makeChunk({
  _tag: "IEmpty"
});
/**
 * @category constructors
 * @since 2.0.0
 */
const empty$i = () => _empty$6;
/**
 * Builds a `NonEmptyChunk` from an non-empty collection of elements.
 *
 * @category constructors
 * @since 2.0.0
 */
const make$o = (...as) => as.length === 1 ? of$1(as[0]) : unsafeFromNonEmptyArray(as);
/**
 * Builds a `NonEmptyChunk` from a single element.
 *
 * @category constructors
 * @since 2.0.0
 */
const of$1 = a => makeChunk({
  _tag: "ISingleton",
  a
});
/**
 * Creates a new `Chunk` from an iterable collection of values.
 *
 * @category constructors
 * @since 2.0.0
 */
const fromIterable$5 = self => isChunk(self) ? self : makeChunk({
  _tag: "IArray",
  array: fromIterable$6(self)
});
const copyToArray = (self, array, initial) => {
  switch (self.backing._tag) {
    case "IArray":
      {
        copy(self.backing.array, 0, array, initial, self.length);
        break;
      }
    case "IConcat":
      {
        copyToArray(self.left, array, initial);
        copyToArray(self.right, array, initial + self.left.length);
        break;
      }
    case "ISingleton":
      {
        array[initial] = self.backing.a;
        break;
      }
    case "ISlice":
      {
        let i = 0;
        let j = initial;
        while (i < self.length) {
          array[j] = unsafeGet$2(self, i);
          i += 1;
          j += 1;
        }
        break;
      }
  }
};
const toReadonlyArray_ = self => {
  switch (self.backing._tag) {
    case "IEmpty":
      {
        return emptyArray;
      }
    case "IArray":
      {
        return self.backing.array;
      }
    default:
      {
        const arr = new Array(self.length);
        copyToArray(self, arr, 0);
        self.backing = {
          _tag: "IArray",
          array: arr
        };
        self.left = _empty$6;
        self.right = _empty$6;
        self.depth = 0;
        return arr;
      }
  }
};
/**
 * Converts a `Chunk` into a `ReadonlyArray`. If the provided `Chunk` is
 * non-empty (`NonEmptyChunk`), the function will return a
 * `NonEmptyReadonlyArray`, ensuring the non-empty property is preserved.
 *
 * @category conversions
 * @since 2.0.0
 */
const toReadonlyArray = toReadonlyArray_;
const reverseChunk = self => {
  switch (self.backing._tag) {
    case "IEmpty":
    case "ISingleton":
      return self;
    case "IArray":
      {
        return makeChunk({
          _tag: "IArray",
          array: reverse$2(self.backing.array)
        });
      }
    case "IConcat":
      {
        return makeChunk({
          _tag: "IConcat",
          left: reverse$1(self.backing.right),
          right: reverse$1(self.backing.left)
        });
      }
    case "ISlice":
      return unsafeFromArray(reverse$2(toReadonlyArray(self)));
  }
};
/**
 * Reverses the order of elements in a `Chunk`.
 * Importantly, if the input chunk is a `NonEmptyChunk`, the reversed chunk will also be a `NonEmptyChunk`.
 *
 * @example
 * ```ts
 * import { Chunk } from "effect"
 *
 * const numbers = Chunk.make(1, 2, 3)
 * const reversedNumbers = Chunk.reverse(numbers)
 * assert.deepStrictEqual(reversedNumbers, Chunk.make(3, 2, 1))
 * ```
 *
 * @since 2.0.0
 * @category elements
 */
const reverse$1 = reverseChunk;
/**
 * Wraps an array into a chunk without copying, unsafe on mutable arrays
 *
 * @since 2.0.0
 * @category unsafe
 */
const unsafeFromArray = self => makeChunk({
  _tag: "IArray",
  array: self
});
/**
 * Wraps an array into a chunk without copying, unsafe on mutable arrays
 *
 * @since 2.0.0
 * @category unsafe
 */
const unsafeFromNonEmptyArray = self => unsafeFromArray(self);
/**
 * Gets an element unsafely, will throw on out of bounds
 *
 * @since 2.0.0
 * @category unsafe
 */
const unsafeGet$2 = /*#__PURE__*/dual(2, (self, index) => {
  switch (self.backing._tag) {
    case "IEmpty":
      {
        throw new Error(`Index out of bounds`);
      }
    case "ISingleton":
      {
        if (index !== 0) {
          throw new Error(`Index out of bounds`);
        }
        return self.backing.a;
      }
    case "IArray":
      {
        if (index >= self.length || index < 0) {
          throw new Error(`Index out of bounds`);
        }
        return self.backing.array[index];
      }
    case "IConcat":
      {
        return index < self.left.length ? unsafeGet$2(self.left, index) : unsafeGet$2(self.right, index - self.left.length);
      }
    case "ISlice":
      {
        return unsafeGet$2(self.backing.chunk, index + self.backing.offset);
      }
  }
});
/**
 * Appends the specified element to the end of the `Chunk`.
 *
 * @category concatenating
 * @since 2.0.0
 */
const append = /*#__PURE__*/dual(2, (self, a) => appendAll$1(self, of$1(a)));
/**
 * Prepend an element to the front of a `Chunk`, creating a new `NonEmptyChunk`.
 *
 * @category concatenating
 * @since 2.0.0
 */
const prepend$1 = /*#__PURE__*/dual(2, (self, elem) => appendAll$1(of$1(elem), self));
/**
 * Drops the first up to `n` elements from the chunk
 *
 * @since 2.0.0
 */
const drop = /*#__PURE__*/dual(2, (self, n) => {
  if (n <= 0) {
    return self;
  } else if (n >= self.length) {
    return _empty$6;
  } else {
    switch (self.backing._tag) {
      case "ISlice":
        {
          return makeChunk({
            _tag: "ISlice",
            chunk: self.backing.chunk,
            offset: self.backing.offset + n,
            length: self.backing.length - n
          });
        }
      case "IConcat":
        {
          if (n > self.left.length) {
            return drop(self.right, n - self.left.length);
          }
          return makeChunk({
            _tag: "IConcat",
            left: drop(self.left, n),
            right: self.right
          });
        }
      default:
        {
          return makeChunk({
            _tag: "ISlice",
            chunk: self,
            offset: n,
            length: self.length - n
          });
        }
    }
  }
});
/**
 * Concatenates two chunks, combining their elements.
 * If either chunk is non-empty, the result is also a non-empty chunk.
 *
 * @example
 * ```ts
 * import { Chunk } from "effect"
 *
 * assert.deepStrictEqual(
 *   Chunk.make(1, 2).pipe(Chunk.appendAll(Chunk.make("a", "b")), Chunk.toArray),
 *   [1, 2, "a", "b"]
 * )
 * ```
 *
 * @category concatenating
 * @since 2.0.0
 */
const appendAll$1 = /*#__PURE__*/dual(2, (self, that) => {
  if (self.backing._tag === "IEmpty") {
    return that;
  }
  if (that.backing._tag === "IEmpty") {
    return self;
  }
  const diff = that.depth - self.depth;
  if (Math.abs(diff) <= 1) {
    return makeChunk({
      _tag: "IConcat",
      left: self,
      right: that
    });
  } else if (diff < -1) {
    if (self.left.depth >= self.right.depth) {
      const nr = appendAll$1(self.right, that);
      return makeChunk({
        _tag: "IConcat",
        left: self.left,
        right: nr
      });
    } else {
      const nrr = appendAll$1(self.right.right, that);
      if (nrr.depth === self.depth - 3) {
        const nr = makeChunk({
          _tag: "IConcat",
          left: self.right.left,
          right: nrr
        });
        return makeChunk({
          _tag: "IConcat",
          left: self.left,
          right: nr
        });
      } else {
        const nl = makeChunk({
          _tag: "IConcat",
          left: self.left,
          right: self.right.left
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: nrr
        });
      }
    }
  } else {
    if (that.right.depth >= that.left.depth) {
      const nl = appendAll$1(self, that.left);
      return makeChunk({
        _tag: "IConcat",
        left: nl,
        right: that.right
      });
    } else {
      const nll = appendAll$1(self, that.left.left);
      if (nll.depth === that.depth - 3) {
        const nl = makeChunk({
          _tag: "IConcat",
          left: nll,
          right: that.left.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: that.right
        });
      } else {
        const nr = makeChunk({
          _tag: "IConcat",
          left: that.left.right,
          right: that.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nll,
          right: nr
        });
      }
    }
  }
});
/**
 * Determines if the chunk is empty.
 *
 * @since 2.0.0
 * @category elements
 */
const isEmpty$3 = self => self.length === 0;
/**
 * Determines if the chunk is not empty.
 *
 * @since 2.0.0
 * @category elements
 */
const isNonEmpty = self => self.length > 0;
/**
 * Returns the first element of this chunk.
 *
 * It will throw an error if the chunk is empty.
 *
 * @since 2.0.0
 * @category unsafe
 */
const unsafeHead = self => unsafeGet$2(self, 0);
/**
 * Returns the first element of this non empty chunk.
 *
 * @since 2.0.0
 * @category elements
 */
const headNonEmpty = unsafeHead;
/**
 * Returns every elements after the first.
 *
 * @since 2.0.0
 * @category elements
 */
const tailNonEmpty = self => drop(self, 1);

/** @internal */
const SIZE = 5;
/** @internal */
const BUCKET_SIZE = /*#__PURE__*/Math.pow(2, SIZE);
/** @internal */
const MASK = BUCKET_SIZE - 1;
/** @internal */
const MAX_INDEX_NODE = BUCKET_SIZE / 2;
/** @internal */
const MIN_ARRAY_NODE = BUCKET_SIZE / 4;

/**
 * Hamming weight.
 *
 * Taken from: http://jsperf.com/hamming-weight
 *
 * @internal
 */
function popcount(x) {
  x -= x >> 1 & 0x55555555;
  x = (x & 0x33333333) + (x >> 2 & 0x33333333);
  x = x + (x >> 4) & 0x0f0f0f0f;
  x += x >> 8;
  x += x >> 16;
  return x & 0x7f;
}
/** @internal */
function hashFragment(shift, h) {
  return h >>> shift & MASK;
}
/** @internal */
function toBitmap(x) {
  return 1 << x;
}
/** @internal */
function fromBitmap(bitmap, bit) {
  return popcount(bitmap & bit - 1);
}

const make$n = (value, previous) => ({
  value,
  previous
});

/** @internal */
function arrayUpdate(mutate, at, v, arr) {
  let out = arr;
  if (!mutate) {
    const len = arr.length;
    out = new Array(len);
    for (let i = 0; i < len; ++i) out[i] = arr[i];
  }
  out[at] = v;
  return out;
}
/** @internal */
function arraySpliceOut(mutate, at, arr) {
  const newLen = arr.length - 1;
  let i = 0;
  let g = 0;
  let out = arr;
  if (mutate) {
    i = g = at;
  } else {
    out = new Array(newLen);
    while (i < at) out[g++] = arr[i++];
  }
  ++i;
  while (i <= newLen) out[g++] = arr[i++];
  if (mutate) {
    out.length = newLen;
  }
  return out;
}
/** @internal */
function arraySpliceIn(mutate, at, v, arr) {
  const len = arr.length;
  if (mutate) {
    let i = len;
    while (i >= at) arr[i--] = arr[i];
    arr[at] = v;
    return arr;
  }
  let i = 0,
    g = 0;
  const out = new Array(len + 1);
  while (i < at) out[g++] = arr[i++];
  out[at] = v;
  while (i < len) out[++g] = arr[i++];
  return out;
}

/** @internal */
class EmptyNode {
  _tag = "EmptyNode";
  modify(edit, _shift, f, hash, key, size) {
    const v = f(none$4());
    if (isNone(v)) return new EmptyNode();
    ++size.value;
    return new LeafNode(edit, hash, key, v);
  }
}
/** @internal */
function isEmptyNode(a) {
  return isTagged(a, "EmptyNode");
}
/** @internal */
function isLeafNode(node) {
  return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
}
/** @internal */
function canEditNode(node, edit) {
  return isEmptyNode(node) ? false : edit === node.edit;
}
/** @internal */
class LeafNode {
  edit;
  hash;
  key;
  value;
  _tag = "LeafNode";
  constructor(edit, hash, key, value) {
    this.edit = edit;
    this.hash = hash;
    this.key = key;
    this.value = value;
  }
  modify(edit, shift, f, hash, key, size) {
    if (equals$2(key, this.key)) {
      const v = f(this.value);
      if (v === this.value) return this;else if (isNone(v)) {
        --size.value;
        return new EmptyNode();
      }
      if (canEditNode(this, edit)) {
        this.value = v;
        return this;
      }
      return new LeafNode(edit, hash, key, v);
    }
    const v = f(none$4());
    if (isNone(v)) return this;
    ++size.value;
    return mergeLeaves(edit, shift, this.hash, this, hash, new LeafNode(edit, hash, key, v));
  }
}
/** @internal */
class CollisionNode {
  edit;
  hash;
  children;
  _tag = "CollisionNode";
  constructor(edit, hash, children) {
    this.edit = edit;
    this.hash = hash;
    this.children = children;
  }
  modify(edit, shift, f, hash, key, size) {
    if (hash === this.hash) {
      const canEdit = canEditNode(this, edit);
      const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f, key, size);
      if (list === this.children) return this;
      return list.length > 1 ? new CollisionNode(edit, this.hash, list) : list[0]; // collapse single element collision list
    }
    const v = f(none$4());
    if (isNone(v)) return this;
    ++size.value;
    return mergeLeaves(edit, shift, this.hash, this, hash, new LeafNode(edit, hash, key, v));
  }
  updateCollisionList(mutate, edit, hash, list, f, key, size) {
    const len = list.length;
    for (let i = 0; i < len; ++i) {
      const child = list[i];
      if ("key" in child && equals$2(key, child.key)) {
        const value = child.value;
        const newValue = f(value);
        if (newValue === value) return list;
        if (isNone(newValue)) {
          --size.value;
          return arraySpliceOut(mutate, i, list);
        }
        return arrayUpdate(mutate, i, new LeafNode(edit, hash, key, newValue), list);
      }
    }
    const newValue = f(none$4());
    if (isNone(newValue)) return list;
    ++size.value;
    return arrayUpdate(mutate, len, new LeafNode(edit, hash, key, newValue), list);
  }
}
/** @internal */
class IndexedNode {
  edit;
  mask;
  children;
  _tag = "IndexedNode";
  constructor(edit, mask, children) {
    this.edit = edit;
    this.mask = mask;
    this.children = children;
  }
  modify(edit, shift, f, hash, key, size) {
    const mask = this.mask;
    const children = this.children;
    const frag = hashFragment(shift, hash);
    const bit = toBitmap(frag);
    const indx = fromBitmap(mask, bit);
    const exists = mask & bit;
    const canEdit = canEditNode(this, edit);
    if (!exists) {
      const _newChild = new EmptyNode().modify(edit, shift + SIZE, f, hash, key, size);
      if (!_newChild) return this;
      return children.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children) : new IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children));
    }
    const current = children[indx];
    const child = current.modify(edit, shift + SIZE, f, hash, key, size);
    if (current === child) return this;
    let bitmap = mask;
    let newChildren;
    if (isEmptyNode(child)) {
      // remove
      bitmap &= ~bit;
      if (!bitmap) return new EmptyNode();
      if (children.length <= 2 && isLeafNode(children[indx ^ 1])) {
        return children[indx ^ 1]; // collapse
      }
      newChildren = arraySpliceOut(canEdit, indx, children);
    } else {
      // modify
      newChildren = arrayUpdate(canEdit, indx, child, children);
    }
    if (canEdit) {
      this.mask = bitmap;
      this.children = newChildren;
      return this;
    }
    return new IndexedNode(edit, bitmap, newChildren);
  }
}
/** @internal */
class ArrayNode {
  edit;
  size;
  children;
  _tag = "ArrayNode";
  constructor(edit, size, children) {
    this.edit = edit;
    this.size = size;
    this.children = children;
  }
  modify(edit, shift, f, hash, key, size) {
    let count = this.size;
    const children = this.children;
    const frag = hashFragment(shift, hash);
    const child = children[frag];
    const newChild = (child || new EmptyNode()).modify(edit, shift + SIZE, f, hash, key, size);
    if (child === newChild) return this;
    const canEdit = canEditNode(this, edit);
    let newChildren;
    if (isEmptyNode(child) && !isEmptyNode(newChild)) {
      ++count;
      newChildren = arrayUpdate(canEdit, frag, newChild, children);
    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
      --count;
      if (count <= MIN_ARRAY_NODE) {
        return pack(edit, count, frag, children);
      }
      newChildren = arrayUpdate(canEdit, frag, new EmptyNode(), children);
    } else {
      // modify
      newChildren = arrayUpdate(canEdit, frag, newChild, children);
    }
    if (canEdit) {
      this.size = count;
      this.children = newChildren;
      return this;
    }
    return new ArrayNode(edit, count, newChildren);
  }
}
function pack(edit, count, removed, elements) {
  const children = new Array(count - 1);
  let g = 0;
  let bitmap = 0;
  for (let i = 0, len = elements.length; i < len; ++i) {
    if (i !== removed) {
      const elem = elements[i];
      if (elem && !isEmptyNode(elem)) {
        children[g++] = elem;
        bitmap |= 1 << i;
      }
    }
  }
  return new IndexedNode(edit, bitmap, children);
}
function expand(edit, frag, child, bitmap, subNodes) {
  const arr = [];
  let bit = bitmap;
  let count = 0;
  for (let i = 0; bit; ++i) {
    if (bit & 1) arr[i] = subNodes[count++];
    bit >>>= 1;
  }
  arr[frag] = child;
  return new ArrayNode(edit, count + 1, arr);
}
function mergeLeavesInner(edit, shift, h1, n1, h2, n2) {
  if (h1 === h2) return new CollisionNode(edit, h1, [n2, n1]);
  const subH1 = hashFragment(shift, h1);
  const subH2 = hashFragment(shift, h2);
  if (subH1 === subH2) {
    return child => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child]);
  } else {
    const children = subH1 < subH2 ? [n1, n2] : [n2, n1];
    return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children);
  }
}
function mergeLeaves(edit, shift, h1, n1, h2, n2) {
  let stack = undefined;
  let currentShift = shift;
  while (true) {
    const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2);
    if (typeof res === "function") {
      stack = make$n(res, stack);
      currentShift = currentShift + SIZE;
    } else {
      let final = res;
      while (stack != null) {
        final = stack.value(final);
        stack = stack.previous;
      }
      return final;
    }
  }
}

const HashMapSymbolKey = "effect/HashMap";
/** @internal */
const HashMapTypeId = /*#__PURE__*/Symbol.for(HashMapSymbolKey);
const HashMapProto = {
  [HashMapTypeId]: HashMapTypeId,
  [Symbol.iterator]() {
    return new HashMapIterator(this, (k, v) => [k, v]);
  },
  [symbol$1]() {
    let hash$1 = hash(HashMapSymbolKey);
    for (const item of this) {
      hash$1 ^= pipe(hash(item[0]), combine$5(hash(item[1])));
    }
    return cached(this, hash$1);
  },
  [symbol](that) {
    if (isHashMap(that)) {
      if (that._size !== this._size) {
        return false;
      }
      for (const item of this) {
        const elem = pipe(that, getHash(item[0], hash(item[0])));
        if (isNone(elem)) {
          return false;
        } else {
          if (!equals$2(item[1], elem.value)) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  },
  toString() {
    return format$4(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
const makeImpl$1 = (editable, edit, root, size) => {
  const map = Object.create(HashMapProto);
  map._editable = editable;
  map._edit = edit;
  map._root = root;
  map._size = size;
  return map;
};
class HashMapIterator {
  map;
  f;
  v;
  constructor(map, f) {
    this.map = map;
    this.f = f;
    this.v = visitLazy(this.map._root, this.f, undefined);
  }
  next() {
    if (isNone(this.v)) {
      return {
        done: true,
        value: undefined
      };
    }
    const v0 = this.v.value;
    this.v = applyCont(v0.cont);
    return {
      done: false,
      value: v0.value
    };
  }
  [Symbol.iterator]() {
    return new HashMapIterator(this.map, this.f);
  }
}
const applyCont = cont => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : none$4();
const visitLazy = (node, f, cont = undefined) => {
  switch (node._tag) {
    case "LeafNode":
      {
        if (isSome(node.value)) {
          return some({
            value: f(node.key, node.value.value),
            cont
          });
        }
        return applyCont(cont);
      }
    case "CollisionNode":
    case "ArrayNode":
    case "IndexedNode":
      {
        const children = node.children;
        return visitLazyChildren(children.length, children, 0, f, cont);
      }
    default:
      {
        return applyCont(cont);
      }
  }
};
const visitLazyChildren = (len, children, i, f, cont) => {
  while (i < len) {
    const child = children[i++];
    if (child && !isEmptyNode(child)) {
      return visitLazy(child, f, [len, children, i, f, cont]);
    }
  }
  return applyCont(cont);
};
const _empty$5 = /*#__PURE__*/makeImpl$1(false, 0, /*#__PURE__*/new EmptyNode(), 0);
/** @internal */
const empty$h = () => _empty$5;
/** @internal */
const fromIterable$4 = entries => {
  const map = beginMutation$1(empty$h());
  for (const entry of entries) {
    set$3(map, entry[0], entry[1]);
  }
  return endMutation$1(map);
};
/** @internal */
const isHashMap = u => hasProperty(u, HashMapTypeId);
/** @internal */
const isEmpty$2 = self => self && isEmptyNode(self._root);
/** @internal */
const get$9 = /*#__PURE__*/dual(2, (self, key) => getHash(self, key, hash(key)));
/** @internal */
const getHash = /*#__PURE__*/dual(3, (self, key, hash) => {
  let node = self._root;
  let shift = 0;
  while (true) {
    switch (node._tag) {
      case "LeafNode":
        {
          return equals$2(key, node.key) ? node.value : none$4();
        }
      case "CollisionNode":
        {
          if (hash === node.hash) {
            const children = node.children;
            for (let i = 0, len = children.length; i < len; ++i) {
              const child = children[i];
              if ("key" in child && equals$2(key, child.key)) {
                return child.value;
              }
            }
          }
          return none$4();
        }
      case "IndexedNode":
        {
          const frag = hashFragment(shift, hash);
          const bit = toBitmap(frag);
          if (node.mask & bit) {
            node = node.children[fromBitmap(node.mask, bit)];
            shift += SIZE;
            break;
          }
          return none$4();
        }
      case "ArrayNode":
        {
          node = node.children[hashFragment(shift, hash)];
          if (node) {
            shift += SIZE;
            break;
          }
          return none$4();
        }
      default:
        return none$4();
    }
  }
});
/** @internal */
const has$3 = /*#__PURE__*/dual(2, (self, key) => isSome(getHash(self, key, hash(key))));
/** @internal */
const set$3 = /*#__PURE__*/dual(3, (self, key, value) => modifyAt$1(self, key, () => some(value)));
/** @internal */
const setTree = /*#__PURE__*/dual(3, (self, newRoot, newSize) => {
  if (self._editable) {
    self._root = newRoot;
    self._size = newSize;
    return self;
  }
  return newRoot === self._root ? self : makeImpl$1(self._editable, self._edit, newRoot, newSize);
});
/** @internal */
const keys$1 = self => new HashMapIterator(self, key => key);
/** @internal */
const size$3 = self => self._size;
/** @internal */
const beginMutation$1 = self => makeImpl$1(true, self._edit + 1, self._root, self._size);
/** @internal */
const endMutation$1 = self => {
  self._editable = false;
  return self;
};
/** @internal */
const modifyAt$1 = /*#__PURE__*/dual(3, (self, key, f) => modifyHash(self, key, hash(key), f));
/** @internal */
const modifyHash = /*#__PURE__*/dual(4, (self, key, hash, f) => {
  const size = {
    value: self._size
  };
  const newRoot = self._root.modify(self._editable ? self._edit : NaN, 0, f, hash, key, size);
  return pipe(self, setTree(newRoot, size.value));
});
/** @internal */
const remove$2 = /*#__PURE__*/dual(2, (self, key) => modifyAt$1(self, key, none$4));
/**
 * Maps over the entries of the `HashMap` using the specified function.
 *
 * @since 2.0.0
 * @category mapping
 */
const map$4 = /*#__PURE__*/dual(2, (self, f) => reduce$5(self, empty$h(), (map, value, key) => set$3(map, key, f(value, key))));
/** @internal */
const forEach$3 = /*#__PURE__*/dual(2, (self, f) => reduce$5(self, undefined, (_, value, key) => f(value, key)));
/** @internal */
const reduce$5 = /*#__PURE__*/dual(3, (self, zero, f) => {
  const root = self._root;
  if (root._tag === "LeafNode") {
    return isSome(root.value) ? f(zero, root.value.value, root.key) : zero;
  }
  if (root._tag === "EmptyNode") {
    return zero;
  }
  const toVisit = [root.children];
  let children;
  while (children = toVisit.pop()) {
    for (let i = 0, len = children.length; i < len;) {
      const child = children[i++];
      if (child && !isEmptyNode(child)) {
        if (child._tag === "LeafNode") {
          if (isSome(child.value)) {
            zero = f(zero, child.value.value, child.key);
          }
        } else {
          toVisit.push(child.children);
        }
      }
    }
  }
  return zero;
});

const HashSetSymbolKey = "effect/HashSet";
/** @internal */
const HashSetTypeId = /*#__PURE__*/Symbol.for(HashSetSymbolKey);
const HashSetProto = {
  [HashSetTypeId]: HashSetTypeId,
  [Symbol.iterator]() {
    return keys$1(this._keyMap);
  },
  [symbol$1]() {
    return cached(this, combine$5(hash(this._keyMap))(hash(HashSetSymbolKey)));
  },
  [symbol](that) {
    if (isHashSet(that)) {
      return size$3(this._keyMap) === size$3(that._keyMap) && equals$2(this._keyMap, that._keyMap);
    }
    return false;
  },
  toString() {
    return format$4(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
/** @internal */
const makeImpl = keyMap => {
  const set = Object.create(HashSetProto);
  set._keyMap = keyMap;
  return set;
};
/** @internal */
const isHashSet = u => hasProperty(u, HashSetTypeId);
const _empty$4 = /*#__PURE__*/makeImpl( /*#__PURE__*/empty$h());
/** @internal */
const empty$g = () => _empty$4;
/** @internal */
const fromIterable$3 = elements => {
  const set = beginMutation(empty$g());
  for (const value of elements) {
    add$3(set, value);
  }
  return endMutation(set);
};
/** @internal */
const make$m = (...elements) => {
  const set = beginMutation(empty$g());
  for (const value of elements) {
    add$3(set, value);
  }
  return endMutation(set);
};
/** @internal */
const has$2 = /*#__PURE__*/dual(2, (self, value) => has$3(self._keyMap, value));
/** @internal */
const size$2 = self => size$3(self._keyMap);
/** @internal */
const beginMutation = self => makeImpl(beginMutation$1(self._keyMap));
/** @internal */
const endMutation = self => {
  self._keyMap._editable = false;
  return self;
};
/** @internal */
const mutate = /*#__PURE__*/dual(2, (self, f) => {
  const transient = beginMutation(self);
  f(transient);
  return endMutation(transient);
});
/** @internal */
const add$3 = /*#__PURE__*/dual(2, (self, value) => self._keyMap._editable ? (set$3(value, true)(self._keyMap), self) : makeImpl(set$3(value, true)(self._keyMap)));
/** @internal */
const remove$1 = /*#__PURE__*/dual(2, (self, value) => self._keyMap._editable ? (remove$2(value)(self._keyMap), self) : makeImpl(remove$2(value)(self._keyMap)));
/** @internal */
const difference$1 = /*#__PURE__*/dual(2, (self, that) => mutate(self, set => {
  for (const value of that) {
    remove$1(set, value);
  }
}));
/** @internal */
const union$1 = /*#__PURE__*/dual(2, (self, that) => mutate(empty$g(), set => {
  forEach$2(self, value => add$3(set, value));
  for (const value of that) {
    add$3(set, value);
  }
}));
/** @internal */
const forEach$2 = /*#__PURE__*/dual(2, (self, f) => forEach$3(self._keyMap, (_, k) => f(k)));
/** @internal */
const reduce$4 = /*#__PURE__*/dual(3, (self, zero, f) => reduce$5(self._keyMap, zero, (z, _, a) => f(z, a)));

/**
 * @since 2.0.0
 */
/**
 * Creates an empty `HashSet`.
 *
 * @since 2.0.0
 * @category constructors
 */
const empty$f = empty$g;
/**
 * Creates a new `HashSet` from an iterable collection of values.
 *
 * @since 2.0.0
 * @category constructors
 */
const fromIterable$2 = fromIterable$3;
/**
 * Construct a new `HashSet` from a variable number of values.
 *
 * @since 2.0.0
 * @category constructors
 */
const make$l = make$m;
/**
 * Checks if the specified value exists in the `HashSet`.
 *
 * @since 2.0.0
 * @category elements
 */
const has$1 = has$2;
/**
 * Calculates the number of values in the `HashSet`.
 *
 * @since 2.0.0
 * @category getters
 */
const size$1 = size$2;
/**
 * Adds a value to the `HashSet`.
 *
 * @since 2.0.0
 */
const add$2 = add$3;
/**
 * Removes a value from the `HashSet`.
 *
 * @since 2.0.0
 */
const remove = remove$1;
/**
 * Computes the set difference between this `HashSet` and the specified
 * `Iterable<A>`.
 *
 * **NOTE**: the hash and equal of the values in both the set and the iterable
 * must be the same.
 *
 * @since 2.0.0
 */
const difference = difference$1;
/**
 * Computes the set union `(`self` + `that`)` between this `HashSet` and the
 * specified `Iterable<A>`.
 *
 * **NOTE**: the hash and equal of the values in both the set and the iterable
 * must be the same.
 *
 * @since 2.0.0
 */
const union = union$1;
/**
 * Reduces the specified state over the values of the `HashSet`.
 *
 * @since 2.0.0
 * @category folding
 */
const reduce$3 = reduce$4;

/** @internal */
const OP_DIE = "Die";
/** @internal */
const OP_EMPTY$2 = "Empty";
/** @internal */
const OP_FAIL$1 = "Fail";
/** @internal */
const OP_INTERRUPT = "Interrupt";
/** @internal */
const OP_PARALLEL$1 = "Parallel";
/** @internal */
const OP_SEQUENTIAL$1 = "Sequential";

// -----------------------------------------------------------------------------
// Models
// -----------------------------------------------------------------------------
/** @internal */
const CauseSymbolKey = "effect/Cause";
/** @internal */
const CauseTypeId = /*#__PURE__*/Symbol.for(CauseSymbolKey);
const variance$7 = {
  /* c8 ignore next */
  _E: _ => _
};
/** @internal */
const proto$2 = {
  [CauseTypeId]: variance$7,
  [symbol$1]() {
    return pipe(hash(CauseSymbolKey), combine$5(hash(flattenCause(this))), cached(this));
  },
  [symbol](that) {
    return isCause(that) && causeEquals(this, that);
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toJSON() {
    switch (this._tag) {
      case "Empty":
        return {
          _id: "Cause",
          _tag: this._tag
        };
      case "Die":
        return {
          _id: "Cause",
          _tag: this._tag,
          defect: toJSON(this.defect)
        };
      case "Interrupt":
        return {
          _id: "Cause",
          _tag: this._tag,
          fiberId: this.fiberId.toJSON()
        };
      case "Fail":
        return {
          _id: "Cause",
          _tag: this._tag,
          failure: toJSON(this.error)
        };
      case "Sequential":
      case "Parallel":
        return {
          _id: "Cause",
          _tag: this._tag,
          left: toJSON(this.left),
          right: toJSON(this.right)
        };
    }
  },
  toString() {
    return pretty(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
// -----------------------------------------------------------------------------
// Constructors
// -----------------------------------------------------------------------------
/** @internal */
const empty$e = /*#__PURE__*/(() => {
  const o = /*#__PURE__*/Object.create(proto$2);
  o._tag = OP_EMPTY$2;
  return o;
})();
/** @internal */
const fail$2 = error => {
  const o = Object.create(proto$2);
  o._tag = OP_FAIL$1;
  o.error = error;
  return o;
};
/** @internal */
const die$1 = defect => {
  const o = Object.create(proto$2);
  o._tag = OP_DIE;
  o.defect = defect;
  return o;
};
/** @internal */
const interrupt = fiberId => {
  const o = Object.create(proto$2);
  o._tag = OP_INTERRUPT;
  o.fiberId = fiberId;
  return o;
};
/** @internal */
const parallel$2 = (left, right) => {
  const o = Object.create(proto$2);
  o._tag = OP_PARALLEL$1;
  o.left = left;
  o.right = right;
  return o;
};
/** @internal */
const sequential$2 = (left, right) => {
  const o = Object.create(proto$2);
  o._tag = OP_SEQUENTIAL$1;
  o.left = left;
  o.right = right;
  return o;
};
// -----------------------------------------------------------------------------
// Refinements
// -----------------------------------------------------------------------------
/** @internal */
const isCause = u => hasProperty(u, CauseTypeId);
/** @internal */
const isEmptyType = self => self._tag === OP_EMPTY$2;
/** @internal */
const isEmpty$1 = self => {
  if (self._tag === OP_EMPTY$2) {
    return true;
  }
  return reduce$2(self, true, (acc, cause) => {
    switch (cause._tag) {
      case OP_EMPTY$2:
        {
          return some(acc);
        }
      case OP_DIE:
      case OP_FAIL$1:
      case OP_INTERRUPT:
        {
          return some(false);
        }
      default:
        {
          return none$4();
        }
    }
  });
};
/** @internal */
const isInterrupted = self => isSome(interruptOption(self));
/** @internal */
const isInterruptedOnly = self => reduceWithContext(undefined, IsInterruptedOnlyCauseReducer)(self);
/** @internal */
const failures = self => reverse$1(reduce$2(self, empty$i(), (list, cause) => cause._tag === OP_FAIL$1 ? some(pipe(list, prepend$1(cause.error))) : none$4()));
/** @internal */
const defects = self => reverse$1(reduce$2(self, empty$i(), (list, cause) => cause._tag === OP_DIE ? some(pipe(list, prepend$1(cause.defect))) : none$4()));
/** @internal */
const interruptors = self => reduce$2(self, empty$f(), (set, cause) => cause._tag === OP_INTERRUPT ? some(pipe(set, add$2(cause.fiberId))) : none$4());
/** @internal */
const failureOption = self => find(self, cause => cause._tag === OP_FAIL$1 ? some(cause.error) : none$4());
/** @internal */
const failureOrCause = self => {
  const option = failureOption(self);
  switch (option._tag) {
    case "None":
      {
        // no `E` inside this `Cause`, so it can be safely cast to `never`
        return right(self);
      }
    case "Some":
      {
        return left(option.value);
      }
  }
};
/** @internal */
const interruptOption = self => find(self, cause => cause._tag === OP_INTERRUPT ? some(cause.fiberId) : none$4());
/** @internal */
const keepDefectsAndElectFailures = self => match$2(self, {
  onEmpty: none$4(),
  onFail: failure => some(die$1(failure)),
  onDie: defect => some(die$1(defect)),
  onInterrupt: () => none$4(),
  onSequential: (left, right) => {
    if (isSome(left) && isSome(right)) {
      return some(sequential$2(left.value, right.value));
    }
    if (isSome(left) && isNone(right)) {
      return some(left.value);
    }
    if (isNone(left) && isSome(right)) {
      return some(right.value);
    }
    return none$4();
  },
  onParallel: (left, right) => {
    if (isSome(left) && isSome(right)) {
      return some(parallel$2(left.value, right.value));
    }
    if (isSome(left) && isNone(right)) {
      return some(left.value);
    }
    if (isNone(left) && isSome(right)) {
      return some(right.value);
    }
    return none$4();
  }
});
/** @internal */
const stripFailures = self => match$2(self, {
  onEmpty: empty$e,
  onFail: () => empty$e,
  onDie: defect => die$1(defect),
  onInterrupt: fiberId => interrupt(fiberId),
  onSequential: sequential$2,
  onParallel: parallel$2
});
/** @internal */
const electFailures = self => match$2(self, {
  onEmpty: empty$e,
  onFail: failure => die$1(failure),
  onDie: defect => die$1(defect),
  onInterrupt: fiberId => interrupt(fiberId),
  onSequential: (left, right) => sequential$2(left, right),
  onParallel: (left, right) => parallel$2(left, right)
});
/** @internal */
const causeEquals = (left, right) => {
  let leftStack = of$1(left);
  let rightStack = of$1(right);
  while (isNonEmpty(leftStack) && isNonEmpty(rightStack)) {
    const [leftParallel, leftSequential] = pipe(headNonEmpty(leftStack), reduce$2([empty$f(), empty$i()], ([parallel, sequential], cause) => {
      const [par, seq] = evaluateCause(cause);
      return some([pipe(parallel, union(par)), pipe(sequential, appendAll$1(seq))]);
    }));
    const [rightParallel, rightSequential] = pipe(headNonEmpty(rightStack), reduce$2([empty$f(), empty$i()], ([parallel, sequential], cause) => {
      const [par, seq] = evaluateCause(cause);
      return some([pipe(parallel, union(par)), pipe(sequential, appendAll$1(seq))]);
    }));
    if (!equals$2(leftParallel, rightParallel)) {
      return false;
    }
    leftStack = leftSequential;
    rightStack = rightSequential;
  }
  return true;
};
// -----------------------------------------------------------------------------
// Flattening
// -----------------------------------------------------------------------------
/**
 * Flattens a cause to a sequence of sets of causes, where each set represents
 * causes that fail in parallel and sequential sets represent causes that fail
 * after each other.
 *
 * @internal
 */
const flattenCause = cause => {
  return flattenCauseLoop(of$1(cause), empty$i());
};
/** @internal */
const flattenCauseLoop = (causes, flattened) => {
  // eslint-disable-next-line no-constant-condition
  while (1) {
    const [parallel, sequential] = pipe(causes, reduce$6([empty$f(), empty$i()], ([parallel, sequential], cause) => {
      const [par, seq] = evaluateCause(cause);
      return [pipe(parallel, union(par)), pipe(sequential, appendAll$1(seq))];
    }));
    const updated = size$1(parallel) > 0 ? pipe(flattened, prepend$1(parallel)) : flattened;
    if (isEmpty$3(sequential)) {
      return reverse$1(updated);
    }
    causes = sequential;
    flattened = updated;
  }
  throw new Error(getBugErrorMessage("Cause.flattenCauseLoop"));
};
// -----------------------------------------------------------------------------
// Finding
// -----------------------------------------------------------------------------
/** @internal */
const find = /*#__PURE__*/dual(2, (self, pf) => {
  const stack = [self];
  while (stack.length > 0) {
    const item = stack.pop();
    const option = pf(item);
    switch (option._tag) {
      case "None":
        {
          switch (item._tag) {
            case OP_SEQUENTIAL$1:
            case OP_PARALLEL$1:
              {
                stack.push(item.right);
                stack.push(item.left);
                break;
              }
          }
          break;
        }
      case "Some":
        {
          return option;
        }
    }
  }
  return none$4();
});
// -----------------------------------------------------------------------------
// Evaluation
// -----------------------------------------------------------------------------
/**
 * Takes one step in evaluating a cause, returning a set of causes that fail
 * in parallel and a list of causes that fail sequentially after those causes.
 *
 * @internal
 */
const evaluateCause = self => {
  let cause = self;
  const stack = [];
  let _parallel = empty$f();
  let _sequential = empty$i();
  while (cause !== undefined) {
    switch (cause._tag) {
      case OP_EMPTY$2:
        {
          if (stack.length === 0) {
            return [_parallel, _sequential];
          }
          cause = stack.pop();
          break;
        }
      case OP_FAIL$1:
        {
          _parallel = add$2(_parallel, make$o(cause._tag, cause.error));
          if (stack.length === 0) {
            return [_parallel, _sequential];
          }
          cause = stack.pop();
          break;
        }
      case OP_DIE:
        {
          _parallel = add$2(_parallel, make$o(cause._tag, cause.defect));
          if (stack.length === 0) {
            return [_parallel, _sequential];
          }
          cause = stack.pop();
          break;
        }
      case OP_INTERRUPT:
        {
          _parallel = add$2(_parallel, make$o(cause._tag, cause.fiberId));
          if (stack.length === 0) {
            return [_parallel, _sequential];
          }
          cause = stack.pop();
          break;
        }
      case OP_SEQUENTIAL$1:
        {
          switch (cause.left._tag) {
            case OP_EMPTY$2:
              {
                cause = cause.right;
                break;
              }
            case OP_SEQUENTIAL$1:
              {
                cause = sequential$2(cause.left.left, sequential$2(cause.left.right, cause.right));
                break;
              }
            case OP_PARALLEL$1:
              {
                cause = parallel$2(sequential$2(cause.left.left, cause.right), sequential$2(cause.left.right, cause.right));
                break;
              }
            default:
              {
                _sequential = prepend$1(_sequential, cause.right);
                cause = cause.left;
                break;
              }
          }
          break;
        }
      case OP_PARALLEL$1:
        {
          stack.push(cause.right);
          cause = cause.left;
          break;
        }
    }
  }
  throw new Error(getBugErrorMessage("Cause.evaluateCauseLoop"));
};
/** @internal */
const IsInterruptedOnlyCauseReducer = {
  emptyCase: constTrue,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: constTrue,
  sequentialCase: (_, left, right) => left && right,
  parallelCase: (_, left, right) => left && right
};
const OP_SEQUENTIAL_CASE = "SequentialCase";
const OP_PARALLEL_CASE = "ParallelCase";
/** @internal */
const match$2 = /*#__PURE__*/dual(2, (self, {
  onDie,
  onEmpty,
  onFail,
  onInterrupt,
  onParallel,
  onSequential
}) => {
  return reduceWithContext(self, undefined, {
    emptyCase: () => onEmpty,
    failCase: (_, error) => onFail(error),
    dieCase: (_, defect) => onDie(defect),
    interruptCase: (_, fiberId) => onInterrupt(fiberId),
    sequentialCase: (_, left, right) => onSequential(left, right),
    parallelCase: (_, left, right) => onParallel(left, right)
  });
});
/** @internal */
const reduce$2 = /*#__PURE__*/dual(3, (self, zero, pf) => {
  let accumulator = zero;
  let cause = self;
  const causes = [];
  while (cause !== undefined) {
    const option = pf(accumulator, cause);
    accumulator = isSome(option) ? option.value : accumulator;
    switch (cause._tag) {
      case OP_SEQUENTIAL$1:
        {
          causes.push(cause.right);
          cause = cause.left;
          break;
        }
      case OP_PARALLEL$1:
        {
          causes.push(cause.right);
          cause = cause.left;
          break;
        }
      default:
        {
          cause = undefined;
          break;
        }
    }
    if (cause === undefined && causes.length > 0) {
      cause = causes.pop();
    }
  }
  return accumulator;
});
/** @internal */
const reduceWithContext = /*#__PURE__*/dual(3, (self, context, reducer) => {
  const input = [self];
  const output = [];
  while (input.length > 0) {
    const cause = input.pop();
    switch (cause._tag) {
      case OP_EMPTY$2:
        {
          output.push(right(reducer.emptyCase(context)));
          break;
        }
      case OP_FAIL$1:
        {
          output.push(right(reducer.failCase(context, cause.error)));
          break;
        }
      case OP_DIE:
        {
          output.push(right(reducer.dieCase(context, cause.defect)));
          break;
        }
      case OP_INTERRUPT:
        {
          output.push(right(reducer.interruptCase(context, cause.fiberId)));
          break;
        }
      case OP_SEQUENTIAL$1:
        {
          input.push(cause.right);
          input.push(cause.left);
          output.push(left({
            _tag: OP_SEQUENTIAL_CASE
          }));
          break;
        }
      case OP_PARALLEL$1:
        {
          input.push(cause.right);
          input.push(cause.left);
          output.push(left({
            _tag: OP_PARALLEL_CASE
          }));
          break;
        }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either = output.pop();
    switch (either._tag) {
      case "Left":
        {
          switch (either.left._tag) {
            case OP_SEQUENTIAL_CASE:
              {
                const left = accumulator.pop();
                const right = accumulator.pop();
                const value = reducer.sequentialCase(context, left, right);
                accumulator.push(value);
                break;
              }
            case OP_PARALLEL_CASE:
              {
                const left = accumulator.pop();
                const right = accumulator.pop();
                const value = reducer.parallelCase(context, left, right);
                accumulator.push(value);
                break;
              }
          }
          break;
        }
      case "Right":
        {
          accumulator.push(either.right);
          break;
        }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
// -----------------------------------------------------------------------------
// Pretty Printing
// -----------------------------------------------------------------------------
/** @internal */
const pretty = (cause, options) => {
  if (isInterruptedOnly(cause)) {
    return "All fibers interrupted without errors.";
  }
  return prettyErrors(cause).map(function (e) {
    if (options?.renderErrorCause !== true || e.cause === undefined) {
      return e.stack;
    }
    return `${e.stack} {\n${renderErrorCause(e.cause, "  ")}\n}`;
  }).join("\n");
};
const renderErrorCause = (cause, prefix) => {
  const lines = cause.stack.split("\n");
  let stack = `${prefix}[cause]: ${lines[0]}`;
  for (let i = 1, len = lines.length; i < len; i++) {
    stack += `\n${prefix}${lines[i]}`;
  }
  if (cause.cause) {
    stack += ` {\n${renderErrorCause(cause.cause, `${prefix}  `)}\n${prefix}}`;
  }
  return stack;
};
class PrettyError extends globalThis.Error {
  span = undefined;
  constructor(originalError) {
    const originalErrorIsObject = typeof originalError === "object" && originalError !== null;
    const prevLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 1;
    super(prettyErrorMessage(originalError), originalErrorIsObject && "cause" in originalError && typeof originalError.cause !== "undefined" ? {
      cause: new PrettyError(originalError.cause)
    } : undefined);
    if (this.message === "") {
      this.message = "An error has occurred";
    }
    Error.stackTraceLimit = prevLimit;
    this.name = originalError instanceof Error ? originalError.name : "Error";
    if (originalErrorIsObject) {
      if (spanSymbol$1 in originalError) {
        this.span = originalError[spanSymbol$1];
      }
      Object.keys(originalError).forEach(key => {
        if (!(key in this)) {
          // @ts-expect-error
          this[key] = originalError[key];
        }
      });
    }
    this.stack = prettyErrorStack(`${this.name}: ${this.message}`, originalError instanceof Error && originalError.stack ? originalError.stack : "", this.span);
  }
}
/**
 * A utility function for generating human-readable error messages from a generic error of type `unknown`.
 *
 * Rules:
 *
 * 1) If the input `u` is already a string, it's considered a message.
 * 2) If `u` is an Error instance with a message defined, it uses the message.
 * 3) If `u` has a user-defined `toString()` method, it uses that method.
 * 4) Otherwise, it uses `Inspectable.stringifyCircular` to produce a string representation and uses it as the error message,
 *   with "Error" added as a prefix.
 *
 * @internal
 */
const prettyErrorMessage = u => {
  // 1)
  if (typeof u === "string") {
    return u;
  }
  // 2)
  if (typeof u === "object" && u !== null && u instanceof Error) {
    return u.message;
  }
  // 3)
  try {
    if (hasProperty(u, "toString") && isFunction(u["toString"]) && u["toString"] !== Object.prototype.toString && u["toString"] !== globalThis.Array.prototype.toString) {
      return u["toString"]();
    }
  } catch {
    // something's off, rollback to json
  }
  // 4)
  return stringifyCircular(u);
};
const locationRegex = /\((.*)\)/g;
/** @internal */
const spanToTrace = /*#__PURE__*/globalValue("effect/Tracer/spanToTrace", () => new WeakMap());
const prettyErrorStack = (message, stack, span) => {
  const out = [message];
  const lines = stack.startsWith(message) ? stack.slice(message.length).split("\n") : stack.split("\n");
  for (let i = 1; i < lines.length; i++) {
    if (lines[i].includes("Generator.next")) {
      break;
    }
    if (lines[i].includes("effect_internal_function")) {
      out.pop();
      break;
    }
    out.push(lines[i].replace(/at .*effect_instruction_i.*\((.*)\)/, "at $1").replace(/EffectPrimitive\.\w+/, "<anonymous>"));
  }
  if (span) {
    let current = span;
    let i = 0;
    while (current && current._tag === "Span" && i < 10) {
      const stackFn = spanToTrace.get(current);
      if (typeof stackFn === "function") {
        const stack = stackFn();
        if (typeof stack === "string") {
          const locationMatchAll = stack.matchAll(locationRegex);
          let match = false;
          for (const [, location] of locationMatchAll) {
            match = true;
            out.push(`    at ${current.name} (${location})`);
          }
          if (!match) {
            out.push(`    at ${current.name} (${stack.replace(/^at /, "")})`);
          }
        } else {
          out.push(`    at ${current.name}`);
        }
      } else {
        out.push(`    at ${current.name}`);
      }
      current = getOrUndefined(current.parent);
      i++;
    }
  }
  return out.join("\n");
};
const spanSymbol$1 = /*#__PURE__*/Symbol.for("effect/SpanAnnotation");
/** @internal */
const prettyErrors = cause => reduceWithContext(cause, undefined, {
  emptyCase: () => [],
  dieCase: (_, unknownError) => {
    return [new PrettyError(unknownError)];
  },
  failCase: (_, error) => {
    return [new PrettyError(error)];
  },
  interruptCase: () => [],
  parallelCase: (_, l, r) => [...l, ...r],
  sequentialCase: (_, l, r) => [...l, ...r]
});

/** @internal */
const TagTypeId = /*#__PURE__*/Symbol.for("effect/Context/Tag");
/** @internal */
const ReferenceTypeId = /*#__PURE__*/Symbol.for("effect/Context/Reference");
/** @internal */
const STMSymbolKey = "effect/STM";
/** @internal */
const STMTypeId = /*#__PURE__*/Symbol.for(STMSymbolKey);
/** @internal */
const TagProto = {
  ...EffectPrototype$1,
  _op: "Tag",
  [STMTypeId]: effectVariance,
  [TagTypeId]: {
    _Service: _ => _,
    _Identifier: _ => _
  },
  toString() {
    return format$4(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Tag",
      key: this.key,
      stack: this.stack
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  of(self) {
    return self;
  },
  context(self) {
    return make$k(this, self);
  }
};
const ReferenceProto = {
  ...TagProto,
  [ReferenceTypeId]: ReferenceTypeId
};
/** @internal */
const makeGenericTag = key => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  const tag = Object.create(TagProto);
  Object.defineProperty(tag, "stack", {
    get() {
      return creationError.stack;
    }
  });
  tag.key = key;
  return tag;
};
/** @internal */
const Reference$1 = () => (id, options) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  function ReferenceClass() {}
  Object.setPrototypeOf(ReferenceClass, ReferenceProto);
  ReferenceClass.key = id;
  ReferenceClass.defaultValue = options.defaultValue;
  Object.defineProperty(ReferenceClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return ReferenceClass;
};
/** @internal */
const TypeId$9 = /*#__PURE__*/Symbol.for("effect/Context");
/** @internal */
const ContextProto = {
  [TypeId$9]: {
    _Services: _ => _
  },
  [symbol](that) {
    if (isContext(that)) {
      if (this.unsafeMap.size === that.unsafeMap.size) {
        for (const k of this.unsafeMap.keys()) {
          if (!that.unsafeMap.has(k) || !equals$2(this.unsafeMap.get(k), that.unsafeMap.get(k))) {
            return false;
          }
        }
        return true;
      }
    }
    return false;
  },
  [symbol$1]() {
    return cached(this, number$1(this.unsafeMap.size));
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toString() {
    return format$4(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Context",
      services: Array.from(this.unsafeMap).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
/** @internal */
const makeContext = unsafeMap => {
  const context = Object.create(ContextProto);
  context.unsafeMap = unsafeMap;
  return context;
};
const serviceNotFoundError = tag => {
  const error = new Error(`Service not found${tag.key ? `: ${String(tag.key)}` : ""}`);
  if (tag.stack) {
    const lines = tag.stack.split("\n");
    if (lines.length > 2) {
      const afterAt = lines[2].match(/at (.*)/);
      if (afterAt) {
        error.message = error.message + ` (defined at ${afterAt[1]})`;
      }
    }
  }
  if (error.stack) {
    const lines = error.stack.split("\n");
    lines.splice(1, 3);
    error.stack = lines.join("\n");
  }
  return error;
};
/** @internal */
const isContext = u => hasProperty(u, TypeId$9);
/** @internal */
const isReference = u => hasProperty(u, ReferenceTypeId);
const _empty$3 = /*#__PURE__*/makeContext( /*#__PURE__*/new Map());
/** @internal */
const empty$d = () => _empty$3;
/** @internal */
const make$k = (tag, service) => makeContext(new Map([[tag.key, service]]));
/** @internal */
const add$1 = /*#__PURE__*/dual(3, (self, tag, service) => {
  const map = new Map(self.unsafeMap);
  map.set(tag.key, service);
  return makeContext(map);
});
const defaultValueCache = /*#__PURE__*/globalValue("effect/Context/defaultValueCache", () => new Map());
const getDefaultValue = tag => {
  if (defaultValueCache.has(tag.key)) {
    return defaultValueCache.get(tag.key);
  }
  const value = tag.defaultValue();
  defaultValueCache.set(tag.key, value);
  return value;
};
/** @internal */
const unsafeGetReference = (self, tag) => {
  return self.unsafeMap.has(tag.key) ? self.unsafeMap.get(tag.key) : getDefaultValue(tag);
};
/** @internal */
const unsafeGet$1 = /*#__PURE__*/dual(2, (self, tag) => {
  if (!self.unsafeMap.has(tag.key)) {
    if (ReferenceTypeId in tag) return getDefaultValue(tag);
    throw serviceNotFoundError(tag);
  }
  return self.unsafeMap.get(tag.key);
});
/** @internal */
const get$8 = unsafeGet$1;
/** @internal */
const getOption$1 = /*#__PURE__*/dual(2, (self, tag) => {
  if (!self.unsafeMap.has(tag.key)) {
    return isReference(tag) ? some$1(getDefaultValue(tag)) : none$5;
  }
  return some$1(self.unsafeMap.get(tag.key));
});
/** @internal */
const merge$2 = /*#__PURE__*/dual(2, (self, that) => {
  const map = new Map(self.unsafeMap);
  for (const [tag, s] of that.unsafeMap) {
    map.set(tag, s);
  }
  return makeContext(map);
});

/**
 * Creates a new `Tag` instance with an optional key parameter.
 *
 * @param key - A key that will be used to compare tags.
 *
 * @example
 * ```ts
 * import { Context } from "effect"
 *
 * assert.strictEqual(Context.GenericTag("PORT").key === Context.GenericTag("PORT").key, true)
 * ```
 *
 * @since 2.0.0
 * @category constructors
 */
const GenericTag = makeGenericTag;
/**
 * Returns an empty `Context`.
 *
 * @example
 * ```ts
 * import { Context } from "effect"
 *
 * assert.strictEqual(Context.isContext(Context.empty()), true)
 * ```
 *
 * @since 2.0.0
 * @category constructors
 */
const empty$c = empty$d;
/**
 * Creates a new `Context` with a single service associated to the tag.
 *
 * @example
 * ```ts
 * import { Context } from "effect"
 *
 * const Port = Context.GenericTag<{ PORT: number }>("Port")
 *
 * const Services = Context.make(Port, { PORT: 8080 })
 *
 * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })
 * ```
 *
 * @since 2.0.0
 * @category constructors
 */
const make$j = make$k;
/**
 * Adds a service to a given `Context`.
 *
 * @example
 * ```ts
 * import { Context, pipe } from "effect"
 *
 * const Port = Context.GenericTag<{ PORT: number }>("Port")
 * const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")
 *
 * const someContext = Context.make(Port, { PORT: 8080 })
 *
 * const Services = pipe(
 *   someContext,
 *   Context.add(Timeout, { TIMEOUT: 5000 })
 * )
 *
 * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })
 * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })
 * ```
 *
 * @since 2.0.0
 */
const add = add$1;
/**
 * Get a service from the context that corresponds to the given tag.
 *
 * @param self - The `Context` to search for the service.
 * @param tag - The `Tag` of the service to retrieve.
 *
 * @example
 * ```ts
 * import { pipe, Context } from "effect"
 *
 * const Port = Context.GenericTag<{ PORT: number }>("Port")
 * const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")
 *
 * const Services = pipe(
 *   Context.make(Port, { PORT: 8080 }),
 *   Context.add(Timeout, { TIMEOUT: 5000 })
 * )
 *
 * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })
 * ```
 *
 * @since 2.0.0
 * @category getters
 */
const get$7 = get$8;
/**
 * Get a service from the context that corresponds to the given tag.
 * This function is unsafe because if the tag is not present in the context, a runtime error will be thrown.
 *
 * For a safer version see {@link getOption}.
 *
 * @param self - The `Context` to search for the service.
 * @param tag - The `Tag` of the service to retrieve.
 *
 * @example
 * ```ts
 * import { Context } from "effect"
 *
 * const Port = Context.GenericTag<{ PORT: number }>("Port")
 * const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")
 *
 * const Services = Context.make(Port, { PORT: 8080 })
 *
 * assert.deepStrictEqual(Context.unsafeGet(Services, Port), { PORT: 8080 })
 * assert.throws(() => Context.unsafeGet(Services, Timeout))
 * ```
 *
 * @since 2.0.0
 * @category unsafe
 */
const unsafeGet = unsafeGet$1;
/**
 * Get the value associated with the specified tag from the context wrapped in an `Option` object. If the tag is not
 * found, the `Option` object will be `None`.
 *
 * @param self - The `Context` to search for the service.
 * @param tag - The `Tag` of the service to retrieve.
 *
 * @example
 * ```ts
 * import { Context, Option } from "effect"
 *
 * const Port = Context.GenericTag<{ PORT: number }>("Port")
 * const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")
 *
 * const Services = Context.make(Port, { PORT: 8080 })
 *
 * assert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))
 * assert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())
 * ```
 *
 * @since 2.0.0
 * @category getters
 */
const getOption = getOption$1;
/**
 * Merges two `Context`s, returning a new `Context` containing the services of both.
 *
 * @param self - The first `Context` to merge.
 * @param that - The second `Context` to merge.
 *
 * @example
 * ```ts
 * import { Context } from "effect"
 *
 * const Port = Context.GenericTag<{ PORT: number }>("Port")
 * const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")
 *
 * const firstContext = Context.make(Port, { PORT: 8080 })
 * const secondContext = Context.make(Timeout, { TIMEOUT: 5000 })
 *
 * const Services = Context.merge(firstContext, secondContext)
 *
 * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })
 * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })
 * ```
 *
 * @since 2.0.0
 */
const merge$1 = merge$2;
/**
 * Creates a context tag with a default value.
 *
 * **Details**
 *
 * `Context.Reference` allows you to create a tag that can hold a value. You can
 * provide a default value for the service, which will automatically be used
 * when the context is accessed, or override it with a custom implementation
 * when needed.
 *
 * @example
 * ```ts
 * // Title: Declaring a Tag with a default value
 * import { Context, Effect } from "effect"
 *
 * class SpecialNumber extends Context.Reference<SpecialNumber>()(
 *   "SpecialNumber",
 *   { defaultValue: () => 2048 }
 * ) {}
 *
 * //      ┌─── Effect<void, never, never>
 * //      ▼
 * const program = Effect.gen(function* () {
 *   const specialNumber = yield* SpecialNumber
 *   console.log(`The special number is ${specialNumber}`)
 * })
 *
 * // No need to provide the SpecialNumber implementation
 * Effect.runPromise(program)
 * // Output: The special number is 2048
 * ```
 *
 * @example
 * ```ts
 * // Title: Overriding the default value
 * import { Context, Effect } from "effect"
 *
 * class SpecialNumber extends Context.Reference<SpecialNumber>()(
 *   "SpecialNumber",
 *   { defaultValue: () => 2048 }
 * ) {}
 *
 * const program = Effect.gen(function* () {
 *   const specialNumber = yield* SpecialNumber
 *   console.log(`The special number is ${specialNumber}`)
 * })
 *
 * Effect.runPromise(program.pipe(Effect.provideService(SpecialNumber, -1)))
 * // Output: The special number is -1
 * ```
 *
 * @since 3.11.0
 * @category constructors
 * @experimental
 */
const Reference = Reference$1;

/**
 * @since 2.0.0
 */
const TypeId$8 = /*#__PURE__*/Symbol.for("effect/Duration");
const bigint0$2 = /*#__PURE__*/BigInt(0);
const bigint24 = /*#__PURE__*/BigInt(24);
const bigint60 = /*#__PURE__*/BigInt(60);
const bigint1e3 = /*#__PURE__*/BigInt(1_000);
const bigint1e6 = /*#__PURE__*/BigInt(1_000_000);
const bigint1e9 = /*#__PURE__*/BigInt(1_000_000_000);
const DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;
/**
 * @since 2.0.0
 */
const decode = input => {
  if (isDuration(input)) {
    return input;
  } else if (isNumber(input)) {
    return millis(input);
  } else if (isBigInt(input)) {
    return nanos(input);
  } else if (Array.isArray(input)) {
    if (input.length === 2 && isNumber(input[0]) && isNumber(input[1])) {
      return nanos(BigInt(input[0]) * bigint1e9 + BigInt(input[1]));
    }
  } else if (isString(input)) {
    DURATION_REGEX.lastIndex = 0; // Reset the lastIndex before each use
    const match = DURATION_REGEX.exec(input);
    if (match) {
      const [_, valueStr, unit] = match;
      const value = Number(valueStr);
      switch (unit) {
        case "nano":
        case "nanos":
          return nanos(BigInt(valueStr));
        case "micro":
        case "micros":
          return micros(BigInt(valueStr));
        case "milli":
        case "millis":
          return millis(value);
        case "second":
        case "seconds":
          return seconds(value);
        case "minute":
        case "minutes":
          return minutes(value);
        case "hour":
        case "hours":
          return hours(value);
        case "day":
        case "days":
          return days(value);
        case "week":
        case "weeks":
          return weeks(value);
      }
    }
  }
  throw new Error("Invalid DurationInput");
};
const zeroValue = {
  _tag: "Millis",
  millis: 0
};
const infinityValue = {
  _tag: "Infinity"
};
const DurationProto = {
  [TypeId$8]: TypeId$8,
  [symbol$1]() {
    return cached(this, structure(this.value));
  },
  [symbol](that) {
    return isDuration(that) && equals$1(this, that);
  },
  toString() {
    return `Duration(${format$3(this)})`;
  },
  toJSON() {
    switch (this.value._tag) {
      case "Millis":
        return {
          _id: "Duration",
          _tag: "Millis",
          millis: this.value.millis
        };
      case "Nanos":
        return {
          _id: "Duration",
          _tag: "Nanos",
          hrtime: toHrTime(this)
        };
      case "Infinity":
        return {
          _id: "Duration",
          _tag: "Infinity"
        };
    }
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
const make$i = input => {
  const duration = Object.create(DurationProto);
  if (isNumber(input)) {
    if (isNaN(input) || input <= 0) {
      duration.value = zeroValue;
    } else if (!Number.isFinite(input)) {
      duration.value = infinityValue;
    } else if (!Number.isInteger(input)) {
      duration.value = {
        _tag: "Nanos",
        nanos: BigInt(Math.round(input * 1_000_000))
      };
    } else {
      duration.value = {
        _tag: "Millis",
        millis: input
      };
    }
  } else if (input <= bigint0$2) {
    duration.value = zeroValue;
  } else {
    duration.value = {
      _tag: "Nanos",
      nanos: input
    };
  }
  return duration;
};
/**
 * @since 2.0.0
 * @category guards
 */
const isDuration = u => hasProperty(u, TypeId$8);
/**
 * @since 2.0.0
 * @category constructors
 */
const zero$1 = /*#__PURE__*/make$i(0);
/**
 * @since 2.0.0
 * @category constructors
 */
const infinity = /*#__PURE__*/make$i(Infinity);
/**
 * @since 2.0.0
 * @category constructors
 */
const nanos = nanos => make$i(nanos);
/**
 * @since 2.0.0
 * @category constructors
 */
const micros = micros => make$i(micros * bigint1e3);
/**
 * @since 2.0.0
 * @category constructors
 */
const millis = millis => make$i(millis);
/**
 * @since 2.0.0
 * @category constructors
 */
const seconds = seconds => make$i(seconds * 1000);
/**
 * @since 2.0.0
 * @category constructors
 */
const minutes = minutes => make$i(minutes * 60_000);
/**
 * @since 2.0.0
 * @category constructors
 */
const hours = hours => make$i(hours * 3_600_000);
/**
 * @since 2.0.0
 * @category constructors
 */
const days = days => make$i(days * 86_400_000);
/**
 * @since 2.0.0
 * @category constructors
 */
const weeks = weeks => make$i(weeks * 604_800_000);
/**
 * @since 2.0.0
 * @category getters
 */
const toMillis = self => match$1(self, {
  onMillis: millis => millis,
  onNanos: nanos => Number(nanos) / 1_000_000
});
/**
 * Get the duration in nanoseconds as a bigint.
 *
 * If the duration is infinite, returns `Option.none()`
 *
 * @since 2.0.0
 * @category getters
 */
const toNanos = self => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      return none$4();
    case "Nanos":
      return some(_self.value.nanos);
    case "Millis":
      return some(BigInt(Math.round(_self.value.millis * 1_000_000)));
  }
};
/**
 * Get the duration in nanoseconds as a bigint.
 *
 * If the duration is infinite, it throws an error.
 *
 * @since 2.0.0
 * @category getters
 */
const unsafeToNanos = self => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      throw new Error("Cannot convert infinite duration to nanos");
    case "Nanos":
      return _self.value.nanos;
    case "Millis":
      return BigInt(Math.round(_self.value.millis * 1_000_000));
  }
};
/**
 * @since 2.0.0
 * @category getters
 */
const toHrTime = self => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      return [Infinity, 0];
    case "Nanos":
      return [Number(_self.value.nanos / bigint1e9), Number(_self.value.nanos % bigint1e9)];
    case "Millis":
      return [Math.floor(_self.value.millis / 1000), Math.round(_self.value.millis % 1000 * 1_000_000)];
  }
};
/**
 * @since 2.0.0
 * @category pattern matching
 */
const match$1 = /*#__PURE__*/dual(2, (self, options) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Nanos":
      return options.onNanos(_self.value.nanos);
    case "Infinity":
      return options.onMillis(Infinity);
    case "Millis":
      return options.onMillis(_self.value.millis);
  }
});
/**
 * @since 2.0.0
 * @category pattern matching
 */
const matchWith = /*#__PURE__*/dual(3, (self, that, options) => {
  const _self = decode(self);
  const _that = decode(that);
  if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") {
    return options.onMillis(toMillis(_self), toMillis(_that));
  } else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
    const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1_000_000));
    const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1_000_000));
    return options.onNanos(selfNanos, thatNanos);
  }
  return options.onMillis(_self.value.millis, _that.value.millis);
});
/**
 * @category instances
 * @since 2.0.0
 */
const Equivalence$1 = (self, that) => matchWith(self, that, {
  onMillis: (self, that) => self === that,
  onNanos: (self, that) => self === that
});
/**
 * @since 2.0.0
 * @category predicates
 */
const greaterThanOrEqualTo$1 = /*#__PURE__*/dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self, that) => self >= that,
  onNanos: (self, that) => self >= that
}));
/**
 * @since 2.0.0
 * @category predicates
 */
const equals$1 = /*#__PURE__*/dual(2, (self, that) => Equivalence$1(decode(self), decode(that)));
/**
 * Converts a `Duration` to its parts.
 *
 * @since 3.8.0
 * @category conversions
 */
const parts = self => {
  const duration = decode(self);
  if (duration.value._tag === "Infinity") {
    return {
      days: Infinity,
      hours: Infinity,
      minutes: Infinity,
      seconds: Infinity,
      millis: Infinity,
      nanos: Infinity
    };
  }
  const nanos = unsafeToNanos(duration);
  const ms = nanos / bigint1e6;
  const sec = ms / bigint1e3;
  const min = sec / bigint60;
  const hr = min / bigint60;
  const days = hr / bigint24;
  return {
    days: Number(days),
    hours: Number(hr % bigint24),
    minutes: Number(min % bigint60),
    seconds: Number(sec % bigint60),
    millis: Number(ms % bigint1e3),
    nanos: Number(nanos % bigint1e6)
  };
};
/**
 * Converts a `Duration` to a human readable string.
 *
 * @since 2.0.0
 * @category conversions
 * @example
 * ```ts
 * import { Duration } from "effect"
 *
 * Duration.format(Duration.millis(1000)) // "1s"
 * Duration.format(Duration.millis(1001)) // "1s 1ms"
 * ```
 */
const format$3 = self => {
  const duration = decode(self);
  if (duration.value._tag === "Infinity") {
    return "Infinity";
  }
  const fragments = parts(duration);
  const pieces = [];
  if (fragments.days !== 0) {
    pieces.push(`${fragments.days}d`);
  }
  if (fragments.hours !== 0) {
    pieces.push(`${fragments.hours}h`);
  }
  if (fragments.minutes !== 0) {
    pieces.push(`${fragments.minutes}m`);
  }
  if (fragments.seconds !== 0) {
    pieces.push(`${fragments.seconds}s`);
  }
  if (fragments.millis !== 0) {
    pieces.push(`${fragments.millis}ms`);
  }
  if (fragments.nanos !== 0) {
    pieces.push(`${fragments.nanos}ns`);
  }
  return pieces.join(" ");
};

/**
 * @since 2.0.0
 */
const TypeId$7 = /*#__PURE__*/Symbol.for("effect/MutableRef");
const MutableRefProto = {
  [TypeId$7]: TypeId$7,
  toString() {
    return format$4(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableRef",
      current: toJSON(this.current)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
/**
 * @since 2.0.0
 * @category constructors
 */
const make$h = value => {
  const ref = Object.create(MutableRefProto);
  ref.current = value;
  return ref;
};
/**
 * @since 2.0.0
 * @category general
 */
const get$6 = self => self.current;
/**
 * @since 2.0.0
 * @category general
 */
const set$2 = /*#__PURE__*/dual(2, (self, value) => {
  self.current = value;
  return self;
});

/** @internal */
const FiberIdSymbolKey = "effect/FiberId";
/** @internal */
const FiberIdTypeId = /*#__PURE__*/Symbol.for(FiberIdSymbolKey);
/** @internal */
const OP_NONE = "None";
/** @internal */
const OP_RUNTIME = "Runtime";
/** @internal */
const OP_COMPOSITE = "Composite";
const emptyHash = /*#__PURE__*/string(`${FiberIdSymbolKey}-${OP_NONE}`);
/** @internal */
let None$2 = class None {
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_NONE;
  id = -1;
  startTimeMillis = -1;
  [symbol$1]() {
    return emptyHash;
  }
  [symbol](that) {
    return isFiberId$1(that) && that._tag === OP_NONE;
  }
  toString() {
    return format$4(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
/** @internal */
class Runtime {
  id;
  startTimeMillis;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_RUNTIME;
  constructor(id, startTimeMillis) {
    this.id = id;
    this.startTimeMillis = startTimeMillis;
  }
  [symbol$1]() {
    return cached(this, string(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`));
  }
  [symbol](that) {
    return isFiberId$1(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;
  }
  toString() {
    return format$4(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      id: this.id,
      startTimeMillis: this.startTimeMillis
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
}
/** @internal */
class Composite {
  left;
  right;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_COMPOSITE;
  constructor(left, right) {
    this.left = left;
    this.right = right;
  }
  _hash;
  [symbol$1]() {
    return pipe(string(`${FiberIdSymbolKey}-${this._tag}`), combine$5(hash(this.left)), combine$5(hash(this.right)), cached(this));
  }
  [symbol](that) {
    return isFiberId$1(that) && that._tag === OP_COMPOSITE && equals$2(this.left, that.left) && equals$2(this.right, that.right);
  }
  toString() {
    return format$4(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      left: toJSON(this.left),
      right: toJSON(this.right)
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
}
/** @internal */
const none$3 = /*#__PURE__*/new None$2();
/** @internal */
const runtime$1 = (id, startTimeMillis) => {
  return new Runtime(id, startTimeMillis);
};
/** @internal */
const composite$1 = (left, right) => {
  return new Composite(left, right);
};
/** @internal */
const isFiberId$1 = self => hasProperty(self, FiberIdTypeId);
/** @internal */
const ids = self => {
  switch (self._tag) {
    case OP_NONE:
      {
        return empty$f();
      }
    case OP_RUNTIME:
      {
        return make$l(self.id);
      }
    case OP_COMPOSITE:
      {
        return pipe(ids(self.left), union(ids(self.right)));
      }
  }
};
const _fiberCounter = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for("effect/Fiber/Id/_fiberCounter"), () => make$h(0));
/** @internal */
const threadName$1 = self => {
  const identifiers = Array.from(ids(self)).map(n => `#${n}`).join(",");
  return identifiers;
};
/** @internal */
const unsafeMake$4 = () => {
  const id = get$6(_fiberCounter);
  pipe(_fiberCounter, set$2(id + 1));
  return new Runtime(id, Date.now());
};

/**
 * @since 2.0.0
 * @category constructors
 */
const none$2 = none$3;
/**
 * @since 2.0.0
 * @category constructors
 */
const runtime = runtime$1;
/**
 * @since 2.0.0
 * @category constructors
 */
const composite = composite$1;
/**
 * Returns `true` if the specified unknown value is a `FiberId`, `false`
 * otherwise.
 *
 * @since 2.0.0
 * @category refinements
 */
const isFiberId = isFiberId$1;
/**
 * Creates a string representing the name of the current thread of execution
 * represented by the specified `FiberId`.
 *
 * @since 2.0.0
 * @category destructors
 */
const threadName = threadName$1;
/**
 * Unsafely creates a new `FiberId`.
 *
 * @since 2.0.0
 * @category unsafe
 */
const unsafeMake$3 = unsafeMake$4;

/**
 * @since 2.0.0
 */
/**
 * Creates a new `HashMap`.
 *
 * @since 2.0.0
 * @category constructors
 */
const empty$b = empty$h;
/**
 * Creates a new `HashMap` from an iterable collection of key/value pairs.
 *
 * @since 2.0.0
 * @category constructors
 */
const fromIterable$1 = fromIterable$4;
/**
 * Checks if the `HashMap` contains any entries.
 *
 * @since 2.0.0
 * @category elements
 */
const isEmpty = isEmpty$2;
/**
 * Safely lookup the value for the specified key in the `HashMap` using the
 * internal hashing function.
 *
 * @since 2.0.0
 * @category elements
 */
const get$5 = get$9;
/**
 * Sets the specified key to the specified value using the internal hashing
 * function.
 *
 * @since 2.0.0
 */
const set$1 = set$3;
/**
 * Returns an `IterableIterator` of the keys within the `HashMap`.
 *
 * @since 2.0.0
 * @category getters
 */
const keys = keys$1;
/**
 * Set or remove the specified key in the `HashMap` using the specified
 * update function. The value of the specified key will be computed using the
 * provided hash.
 *
 * The update function will be invoked with the current value of the key if it
 * exists, or `None` if no such value exists.
 *
 * @since 2.0.0
 */
const modifyAt = modifyAt$1;
/**
 * Maps over the entries of the `HashMap` using the specified function.
 *
 * @since 2.0.0
 * @category mapping
 */
const map$3 = map$4;
/**
 * Reduces the specified state over the entries of the `HashMap`.
 *
 * @since 2.0.0
 * @category folding
 */
const reduce$1 = reduce$5;

/**
 * A data type for immutable linked lists representing ordered collections of elements of type `A`.
 *
 * This data type is optimal for last-in-first-out (LIFO), stack-like access patterns. If you need another access pattern, for example, random access or FIFO, consider using a collection more suited to this than `List`.
 *
 * **Performance**
 *
 * - Time: `List` has `O(1)` prepend and head/tail access. Most other operations are `O(n)` on the number of elements in the list. This includes the index-based lookup of elements, `length`, `append` and `reverse`.
 * - Space: `List` implements structural sharing of the tail list. This means that many operations are either zero- or constant-memory cost.
 *
 * @since 2.0.0
 */
/**
 * This file is ported from
 *
 * Scala (https://www.scala-lang.org)
 *
 * Copyright EPFL and Lightbend, Inc.
 *
 * Licensed under Apache License 2.0
 * (http://www.apache.org/licenses/LICENSE-2.0).
 */
/**
 * @since 2.0.0
 * @category symbol
 */
const TypeId$6 = /*#__PURE__*/Symbol.for("effect/List");
/**
 * Converts the specified `List` to an `Array`.
 *
 * @category conversions
 * @since 2.0.0
 */
const toArray$1 = self => fromIterable$6(self);
/**
 * @category equivalence
 * @since 2.0.0
 */
const getEquivalence = isEquivalent => mapInput$1(getEquivalence$2(isEquivalent), toArray$1);
const _equivalence = /*#__PURE__*/getEquivalence(equals$2);
const ConsProto = {
  [TypeId$6]: TypeId$6,
  _tag: "Cons",
  toString() {
    return format$4(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Cons",
      values: toArray$1(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol](that) {
    return isList(that) && this._tag === that._tag && _equivalence(this, that);
  },
  [symbol$1]() {
    return cached(this, array(toArray$1(this)));
  },
  [Symbol.iterator]() {
    let done = false;
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    let self = this;
    return {
      next() {
        if (done) {
          return this.return();
        }
        if (self._tag === "Nil") {
          done = true;
          return this.return();
        }
        const value = self.head;
        self = self.tail;
        return {
          done,
          value
        };
      },
      return(value) {
        if (!done) {
          done = true;
        }
        return {
          done: true,
          value
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
const makeCons = (head, tail) => {
  const cons = Object.create(ConsProto);
  cons.head = head;
  cons.tail = tail;
  return cons;
};
const NilHash = /*#__PURE__*/string("Nil");
const NilProto = {
  [TypeId$6]: TypeId$6,
  _tag: "Nil",
  toString() {
    return format$4(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Nil"
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol$1]() {
    return NilHash;
  },
  [symbol](that) {
    return isList(that) && this._tag === that._tag;
  },
  [Symbol.iterator]() {
    return {
      next() {
        return {
          done: true,
          value: undefined
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
const _Nil = /*#__PURE__*/Object.create(NilProto);
/**
 * Returns `true` if the specified value is a `List`, `false` otherwise.
 *
 * @since 2.0.0
 * @category refinements
 */
const isList = u => hasProperty(u, TypeId$6);
/**
 * Returns `true` if the specified value is a `List.Nil<A>`, `false` otherwise.
 *
 * @since 2.0.0
 * @category refinements
 */
const isNil = self => self._tag === "Nil";
/**
 * Returns `true` if the specified value is a `List.Cons<A>`, `false` otherwise.
 *
 * @since 2.0.0
 * @category refinements
 */
const isCons = self => self._tag === "Cons";
/**
 * Constructs a new empty `List<A>`.
 *
 * @since 2.0.0
 * @category constructors
 */
const nil = () => _Nil;
/**
 * Constructs a new `List.Cons<A>` from the specified `head` and `tail` values.
 *
 * @since 2.0.0
 * @category constructors
 */
const cons = (head, tail) => makeCons(head, tail);
/**
 * Constructs a new empty `List<A>`.
 *
 * Alias of {@link nil}.
 *
 * @since 2.0.0
 * @category constructors
 */
const empty$a = nil;
/**
 * Constructs a new `List<A>` from the specified value.
 *
 * @since 2.0.0
 * @category constructors
 */
const of = value => makeCons(value, _Nil);
/**
 * Concatenates two lists, combining their elements.
 * If either list is non-empty, the result is also a non-empty list.
 *
 * @example
 * ```ts
 * import { List } from "effect"
 *
 * assert.deepStrictEqual(
 *   List.make(1, 2).pipe(List.appendAll(List.make("a", "b")), List.toArray),
 *   [1, 2, "a", "b"]
 * )
 * ```
 *
 * @category concatenating
 * @since 2.0.0
 */
const appendAll = /*#__PURE__*/dual(2, (self, that) => prependAll(that, self));
/**
 * Prepends the specified element to the beginning of the list.
 *
 * @category concatenating
 * @since 2.0.0
 */
const prepend = /*#__PURE__*/dual(2, (self, element) => cons(element, self));
/**
 * Prepends the specified prefix list to the beginning of the specified list.
 * If either list is non-empty, the result is also a non-empty list.
 *
 * @example
 * ```ts
 * import { List } from "effect"
 *
 * assert.deepStrictEqual(
 *   List.make(1, 2).pipe(List.prependAll(List.make("a", "b")), List.toArray),
 *   ["a", "b", 1, 2]
 * )
 * ```
 *
 * @category concatenating
 * @since 2.0.0
 */
const prependAll = /*#__PURE__*/dual(2, (self, prefix) => {
  if (isNil(self)) {
    return prefix;
  } else if (isNil(prefix)) {
    return self;
  } else {
    const result = makeCons(prefix.head, self);
    let curr = result;
    let that = prefix.tail;
    while (!isNil(that)) {
      const temp = makeCons(that.head, self);
      curr.tail = temp;
      curr = temp;
      that = that.tail;
    }
    return result;
  }
});
/**
 * Folds over the elements of the list using the specified function, using the
 * specified initial value.
 *
 * @since 2.0.0
 * @category folding
 */
const reduce = /*#__PURE__*/dual(3, (self, zero, f) => {
  let acc = zero;
  let these = self;
  while (!isNil(these)) {
    acc = f(acc, these.head);
    these = these.tail;
  }
  return acc;
});
/**
 * Returns a new list with the elements of the specified list in reverse order.
 *
 * @since 2.0.0
 * @category elements
 */
const reverse = self => {
  let result = empty$a();
  let these = self;
  while (!isNil(these)) {
    result = prepend(result, these.head);
    these = these.tail;
  }
  return result;
};

/** @internal */
const Structural = /*#__PURE__*/function () {
  function Structural(args) {
    if (args) {
      Object.assign(this, args);
    }
  }
  Structural.prototype = StructuralPrototype;
  return Structural;
}();

/** @internal */
const ChunkPatchTypeId = /*#__PURE__*/Symbol.for("effect/DifferChunkPatch");
function variance$6(a) {
  return a;
}
({
  ...Structural.prototype,
  [ChunkPatchTypeId]: {
    _Value: variance$6,
    _Patch: variance$6
  }
});

/** @internal */
const ContextPatchTypeId = /*#__PURE__*/Symbol.for("effect/DifferContextPatch");
function variance$5(a) {
  return a;
}
/** @internal */
const PatchProto$2 = {
  ...Structural.prototype,
  [ContextPatchTypeId]: {
    _Value: variance$5,
    _Patch: variance$5
  }
};
const EmptyProto$2 = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto$2), {
  _tag: "Empty"
});
const _empty$2 = /*#__PURE__*/Object.create(EmptyProto$2);
/**
 * @internal
 */
const empty$9 = () => _empty$2;
const AndThenProto$2 = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto$2), {
  _tag: "AndThen"
});
const makeAndThen$2 = (first, second) => {
  const o = Object.create(AndThenProto$2);
  o.first = first;
  o.second = second;
  return o;
};
const AddServiceProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto$2), {
  _tag: "AddService"
});
const makeAddService = (key, service) => {
  const o = Object.create(AddServiceProto);
  o.key = key;
  o.service = service;
  return o;
};
const RemoveServiceProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto$2), {
  _tag: "RemoveService"
});
const makeRemoveService = key => {
  const o = Object.create(RemoveServiceProto);
  o.key = key;
  return o;
};
const UpdateServiceProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto$2), {
  _tag: "UpdateService"
});
const makeUpdateService = (key, update) => {
  const o = Object.create(UpdateServiceProto);
  o.key = key;
  o.update = update;
  return o;
};
/** @internal */
const diff$6 = (oldValue, newValue) => {
  const missingServices = new Map(oldValue.unsafeMap);
  let patch = empty$9();
  for (const [tag, newService] of newValue.unsafeMap.entries()) {
    if (missingServices.has(tag)) {
      const old = missingServices.get(tag);
      missingServices.delete(tag);
      if (!equals$2(old, newService)) {
        patch = combine$4(makeUpdateService(tag, () => newService))(patch);
      }
    } else {
      missingServices.delete(tag);
      patch = combine$4(makeAddService(tag, newService))(patch);
    }
  }
  for (const [tag] of missingServices.entries()) {
    patch = combine$4(makeRemoveService(tag))(patch);
  }
  return patch;
};
/** @internal */
const combine$4 = /*#__PURE__*/dual(2, (self, that) => makeAndThen$2(self, that));
/** @internal */
const patch$7 = /*#__PURE__*/dual(2, (self, context) => {
  if (self._tag === "Empty") {
    return context;
  }
  let wasServiceUpdated = false;
  let patches = of$1(self);
  const updatedContext = new Map(context.unsafeMap);
  while (isNonEmpty(patches)) {
    const head = headNonEmpty(patches);
    const tail = tailNonEmpty(patches);
    switch (head._tag) {
      case "Empty":
        {
          patches = tail;
          break;
        }
      case "AddService":
        {
          updatedContext.set(head.key, head.service);
          patches = tail;
          break;
        }
      case "AndThen":
        {
          patches = prepend$1(prepend$1(tail, head.second), head.first);
          break;
        }
      case "RemoveService":
        {
          updatedContext.delete(head.key);
          patches = tail;
          break;
        }
      case "UpdateService":
        {
          updatedContext.set(head.key, head.update(updatedContext.get(head.key)));
          wasServiceUpdated = true;
          patches = tail;
          break;
        }
    }
  }
  if (!wasServiceUpdated) {
    return makeContext(updatedContext);
  }
  const map = new Map();
  for (const [tag] of context.unsafeMap) {
    if (updatedContext.has(tag)) {
      map.set(tag, updatedContext.get(tag));
      updatedContext.delete(tag);
    }
  }
  for (const [tag, s] of updatedContext) {
    map.set(tag, s);
  }
  return makeContext(map);
});

/** @internal */
const HashMapPatchTypeId = /*#__PURE__*/Symbol.for("effect/DifferHashMapPatch");
function variance$4(a) {
  return a;
}
/** @internal */
({
  ...Structural.prototype,
  [HashMapPatchTypeId]: {
    _Value: variance$4,
    _Key: variance$4,
    _Patch: variance$4
  }
});

/** @internal */
const HashSetPatchTypeId = /*#__PURE__*/Symbol.for("effect/DifferHashSetPatch");
function variance$3(a) {
  return a;
}
/** @internal */
const PatchProto$1 = {
  ...Structural.prototype,
  [HashSetPatchTypeId]: {
    _Value: variance$3,
    _Key: variance$3,
    _Patch: variance$3
  }
};
const EmptyProto$1 = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto$1), {
  _tag: "Empty"
});
const _empty$1 = /*#__PURE__*/Object.create(EmptyProto$1);
/** @internal */
const empty$8 = () => _empty$1;
const AndThenProto$1 = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto$1), {
  _tag: "AndThen"
});
/** @internal */
const makeAndThen$1 = (first, second) => {
  const o = Object.create(AndThenProto$1);
  o.first = first;
  o.second = second;
  return o;
};
const AddProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto$1), {
  _tag: "Add"
});
/** @internal */
const makeAdd = value => {
  const o = Object.create(AddProto);
  o.value = value;
  return o;
};
const RemoveProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto$1), {
  _tag: "Remove"
});
/** @internal */
const makeRemove = value => {
  const o = Object.create(RemoveProto);
  o.value = value;
  return o;
};
/** @internal */
const diff$5 = (oldValue, newValue) => {
  const [removed, patch] = reduce$3([oldValue, empty$8()], ([set, patch], value) => {
    if (has$1(value)(set)) {
      return [remove(value)(set), patch];
    }
    return [set, combine$3(makeAdd(value))(patch)];
  })(newValue);
  return reduce$3(patch, (patch, value) => combine$3(makeRemove(value))(patch))(removed);
};
/** @internal */
const combine$3 = /*#__PURE__*/dual(2, (self, that) => makeAndThen$1(self, that));
/** @internal */
const patch$6 = /*#__PURE__*/dual(2, (self, oldValue) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let set = oldValue;
  let patches = of$1(self);
  while (isNonEmpty(patches)) {
    const head = headNonEmpty(patches);
    const tail = tailNonEmpty(patches);
    switch (head._tag) {
      case "Empty":
        {
          patches = tail;
          break;
        }
      case "AndThen":
        {
          patches = prepend$1(head.first)(prepend$1(head.second)(tail));
          break;
        }
      case "Add":
        {
          set = add$2(head.value)(set);
          patches = tail;
          break;
        }
      case "Remove":
        {
          set = remove(head.value)(set);
          patches = tail;
        }
    }
  }
  return set;
});

/** @internal */
const OrPatchTypeId = /*#__PURE__*/Symbol.for("effect/DifferOrPatch");
function variance$2(a) {
  return a;
}
/** @internal */
({
  ...Structural.prototype,
  [OrPatchTypeId]: {
    _Value: variance$2,
    _Key: variance$2,
    _Patch: variance$2
  }
});

/** @internal */
const ReadonlyArrayPatchTypeId = /*#__PURE__*/Symbol.for("effect/DifferReadonlyArrayPatch");
function variance$1(a) {
  return a;
}
const PatchProto = {
  ...Structural.prototype,
  [ReadonlyArrayPatchTypeId]: {
    _Value: variance$1,
    _Patch: variance$1
  }
};
const EmptyProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {
  _tag: "Empty"
});
const _empty = /*#__PURE__*/Object.create(EmptyProto);
/**
 * @internal
 */
const empty$7 = () => _empty;
const AndThenProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {
  _tag: "AndThen"
});
const makeAndThen = (first, second) => {
  const o = Object.create(AndThenProto);
  o.first = first;
  o.second = second;
  return o;
};
const AppendProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {
  _tag: "Append"
});
const makeAppend = values => {
  const o = Object.create(AppendProto);
  o.values = values;
  return o;
};
const SliceProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {
  _tag: "Slice"
});
const makeSlice = (from, until) => {
  const o = Object.create(SliceProto);
  o.from = from;
  o.until = until;
  return o;
};
const UpdateProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {
  _tag: "Update"
});
const makeUpdate = (index, patch) => {
  const o = Object.create(UpdateProto);
  o.index = index;
  o.patch = patch;
  return o;
};
/** @internal */
const diff$4 = options => {
  let i = 0;
  let patch = empty$7();
  while (i < options.oldValue.length && i < options.newValue.length) {
    const oldElement = options.oldValue[i];
    const newElement = options.newValue[i];
    const valuePatch = options.differ.diff(oldElement, newElement);
    if (!equals$2(valuePatch, options.differ.empty)) {
      patch = combine$2(patch, makeUpdate(i, valuePatch));
    }
    i = i + 1;
  }
  if (i < options.oldValue.length) {
    patch = combine$2(patch, makeSlice(0, i));
  }
  if (i < options.newValue.length) {
    patch = combine$2(patch, makeAppend(drop$1(i)(options.newValue)));
  }
  return patch;
};
/** @internal */
const combine$2 = /*#__PURE__*/dual(2, (self, that) => makeAndThen(self, that));
/** @internal */
const patch$5 = /*#__PURE__*/dual(3, (self, oldValue, differ) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let readonlyArray = oldValue.slice();
  let patches = of$2(self);
  while (isNonEmptyArray(patches)) {
    const head = headNonEmpty$1(patches);
    const tail = tailNonEmpty$1(patches);
    switch (head._tag) {
      case "Empty":
        {
          patches = tail;
          break;
        }
      case "AndThen":
        {
          tail.unshift(head.first, head.second);
          patches = tail;
          break;
        }
      case "Append":
        {
          for (const value of head.values) {
            readonlyArray.push(value);
          }
          patches = tail;
          break;
        }
      case "Slice":
        {
          readonlyArray = readonlyArray.slice(head.from, head.until);
          patches = tail;
          break;
        }
      case "Update":
        {
          readonlyArray[head.index] = differ.patch(head.patch, readonlyArray[head.index]);
          patches = tail;
          break;
        }
    }
  }
  return readonlyArray;
});

/** @internal */
const DifferTypeId = /*#__PURE__*/Symbol.for("effect/Differ");
/** @internal */
const DifferProto = {
  [DifferTypeId]: {
    _P: identity,
    _V: identity
  }
};
/** @internal */
const make$g = params => {
  const differ = Object.create(DifferProto);
  differ.empty = params.empty;
  differ.diff = params.diff;
  differ.combine = params.combine;
  differ.patch = params.patch;
  return differ;
};
/** @internal */
const environment$1 = () => make$g({
  empty: empty$9(),
  combine: (first, second) => combine$4(second)(first),
  diff: (oldValue, newValue) => diff$6(oldValue, newValue),
  patch: (patch, oldValue) => patch$7(oldValue)(patch)
});
/** @internal */
const hashSet = () => make$g({
  empty: empty$8(),
  combine: (first, second) => combine$3(second)(first),
  diff: (oldValue, newValue) => diff$5(oldValue, newValue),
  patch: (patch, oldValue) => patch$6(oldValue)(patch)
});
/** @internal */
const readonlyArray = differ => make$g({
  empty: empty$7(),
  combine: (first, second) => combine$2(first, second),
  diff: (oldValue, newValue) => diff$4({
    oldValue,
    newValue,
    differ
  }),
  patch: (patch, oldValue) => patch$5(patch, oldValue, differ)
});
/** @internal */
const update$1 = () => updateWith((_, a) => a);
/** @internal */
const updateWith = f => make$g({
  empty: identity,
  combine: (first, second) => {
    if (first === identity) {
      return second;
    }
    if (second === identity) {
      return first;
    }
    return a => second(first(a));
  },
  diff: (oldValue, newValue) => {
    if (equals$2(oldValue, newValue)) {
      return identity;
    }
    return constant(newValue);
  },
  patch: (patch, oldValue) => f(oldValue, patch(oldValue))
});

/** @internal */
const BIT_MASK = 0xff;
/** @internal */
const BIT_SHIFT = 0x08;
/** @internal */
const active = patch => patch & BIT_MASK;
/** @internal */
const enabled = patch => patch >> BIT_SHIFT & BIT_MASK;
/** @internal */
const make$f = (active, enabled) => (active & BIT_MASK) + ((enabled & active & BIT_MASK) << BIT_SHIFT);
/** @internal */
const empty$6 = /*#__PURE__*/make$f(0, 0);
/** @internal */
const enable$2 = flag => make$f(flag, flag);
/** @internal */
const disable$1 = flag => make$f(flag, 0);
/** @internal */
const exclude$1 = /*#__PURE__*/dual(2, (self, flag) => make$f(active(self) & ~flag, enabled(self)));
/** @internal */
const andThen = /*#__PURE__*/dual(2, (self, that) => self | that);
/** @internal */
const invert = n => ~n >>> 0 & BIT_MASK;

/** @internal */
const None$1 = 0;
/** @internal */
const Interruption = 1 << 0;
/** @internal */
const OpSupervision = 1 << 1;
/** @internal */
const RuntimeMetrics = 1 << 2;
/** @internal */
const WindDown = 1 << 4;
/** @internal */
const CooperativeYielding = 1 << 5;
/** @internal */
const cooperativeYielding = self => isEnabled(self, CooperativeYielding);
/** @internal */
const enable$1 = /*#__PURE__*/dual(2, (self, flag) => self | flag);
/** @internal */
const interruptible$2 = self => interruption(self) && !windDown(self);
/** @internal */
const interruption = self => isEnabled(self, Interruption);
/** @internal */
const isEnabled = /*#__PURE__*/dual(2, (self, flag) => (self & flag) !== 0);
/** @internal */
const make$e = (...flags) => flags.reduce((a, b) => a | b, 0);
/** @internal */
const none$1 = /*#__PURE__*/make$e(None$1);
/** @internal */
const runtimeMetrics = self => isEnabled(self, RuntimeMetrics);
const windDown = self => isEnabled(self, WindDown);
/** @internal */
const diff$3 = /*#__PURE__*/dual(2, (self, that) => make$f(self ^ that, that));
/** @internal */
const patch$4 = /*#__PURE__*/dual(2, (self, patch) => self & (invert(active(patch)) | enabled(patch)) | active(patch) & enabled(patch));
/** @internal */
const differ$1 = /*#__PURE__*/make$g({
  empty: empty$6,
  diff: (oldValue, newValue) => diff$3(oldValue, newValue),
  combine: (first, second) => andThen(second)(first),
  patch: (_patch, oldValue) => patch$4(oldValue, _patch)
});

/**
 * @since 2.0.0
 */
/**
 * Creates a `RuntimeFlagsPatch` describing enabling the provided `RuntimeFlag`.
 *
 * @since 2.0.0
 * @category constructors
 */
const enable = enable$2;
/**
 * Creates a `RuntimeFlagsPatch` describing disabling the provided `RuntimeFlag`.
 *
 * @since 2.0.0
 * @category constructors
 */
const disable = disable$1;
/**
 * Creates a `RuntimeFlagsPatch` which describes exclusion of the specified
 * `RuntimeFlag` from the set of `RuntimeFlags`.
 *
 * @category utils
 * @since 2.0.0
 */
const exclude = exclude$1;

/**
 * Combines this collection of blocked requests with the specified collection
 * of blocked requests, in parallel.
 *
 * @internal
 */
const par = (self, that) => ({
  _tag: "Par",
  left: self,
  right: that
});
/**
 * Combines this collection of blocked requests with the specified collection
 * of blocked requests, in sequence.
 *
 * @internal
 */
const seq = (self, that) => ({
  _tag: "Seq",
  left: self,
  right: that
});
/**
 * Flattens a collection of blocked requests into a collection of pipelined
 * and batched requests that can be submitted for execution.
 *
 * @internal
 */
const flatten$1 = self => {
  let current = of(self);
  let updated = empty$a();
  // eslint-disable-next-line no-constant-condition
  while (1) {
    const [parallel, sequential] = reduce(current, [parallelCollectionEmpty(), empty$a()], ([parallel, sequential], blockedRequest) => {
      const [par, seq] = step$1(blockedRequest);
      return [parallelCollectionCombine(parallel, par), appendAll(sequential, seq)];
    });
    updated = merge(updated, parallel);
    if (isNil(sequential)) {
      return reverse(updated);
    }
    current = sequential;
  }
  throw new Error("BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues");
};
/**
 * Takes one step in evaluating a collection of blocked requests, returning a
 * collection of blocked requests that can be performed in parallel and a list
 * of blocked requests that must be performed sequentially after those
 * requests.
 */
const step$1 = requests => {
  let current = requests;
  let parallel = parallelCollectionEmpty();
  let stack = empty$a();
  let sequential = empty$a();
  // eslint-disable-next-line no-constant-condition
  while (1) {
    switch (current._tag) {
      case "Empty":
        {
          if (isNil(stack)) {
            return [parallel, sequential];
          }
          current = stack.head;
          stack = stack.tail;
          break;
        }
      case "Par":
        {
          stack = cons(current.right, stack);
          current = current.left;
          break;
        }
      case "Seq":
        {
          const left = current.left;
          const right = current.right;
          switch (left._tag) {
            case "Empty":
              {
                current = right;
                break;
              }
            case "Par":
              {
                const l = left.left;
                const r = left.right;
                current = par(seq(l, right), seq(r, right));
                break;
              }
            case "Seq":
              {
                const l = left.left;
                const r = left.right;
                current = seq(l, seq(r, right));
                break;
              }
            case "Single":
              {
                current = left;
                sequential = cons(right, sequential);
                break;
              }
          }
          break;
        }
      case "Single":
        {
          parallel = parallelCollectionAdd(parallel, current);
          if (isNil(stack)) {
            return [parallel, sequential];
          }
          current = stack.head;
          stack = stack.tail;
          break;
        }
    }
  }
  throw new Error("BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues");
};
/**
 * Merges a collection of requests that must be executed sequentially with a
 * collection of requests that can be executed in parallel. If the collections
 * are both from the same single data source then the requests can be
 * pipelined while preserving ordering guarantees.
 */
const merge = (sequential, parallel) => {
  if (isNil(sequential)) {
    return of(parallelCollectionToSequentialCollection(parallel));
  }
  if (parallelCollectionIsEmpty(parallel)) {
    return sequential;
  }
  const seqHeadKeys = sequentialCollectionKeys(sequential.head);
  const parKeys = parallelCollectionKeys(parallel);
  if (seqHeadKeys.length === 1 && parKeys.length === 1 && equals$2(seqHeadKeys[0], parKeys[0])) {
    return cons(sequentialCollectionCombine(sequential.head, parallelCollectionToSequentialCollection(parallel)), sequential.tail);
  }
  return cons(parallelCollectionToSequentialCollection(parallel), sequential);
};
/** @internal */
const RequestBlockParallelTypeId = /*#__PURE__*/Symbol.for("effect/RequestBlock/RequestBlockParallel");
const parallelVariance = {
  /* c8 ignore next */
  _R: _ => _
};
class ParallelImpl {
  map;
  [RequestBlockParallelTypeId] = parallelVariance;
  constructor(map) {
    this.map = map;
  }
}
/** @internal */
const parallelCollectionEmpty = () => new ParallelImpl(empty$b());
/** @internal */
const parallelCollectionAdd = (self, blockedRequest) => new ParallelImpl(modifyAt(self.map, blockedRequest.dataSource, _ => orElseSome(map$6(_, append(blockedRequest.blockedRequest)), () => of$1(blockedRequest.blockedRequest))));
/** @internal */
const parallelCollectionCombine = (self, that) => new ParallelImpl(reduce$1(self.map, that.map, (map, value, key) => set$1(map, key, match$3(get$5(map, key), {
  onNone: () => value,
  onSome: other => appendAll$1(value, other)
}))));
/** @internal */
const parallelCollectionIsEmpty = self => isEmpty(self.map);
/** @internal */
const parallelCollectionKeys = self => Array.from(keys(self.map));
/** @internal */
const parallelCollectionToSequentialCollection = self => sequentialCollectionMake(map$3(self.map, x => of$1(x)));
// TODO
// /** @internal */
// export const parallelCollectionToChunk = <R>(
//   self: ParallelCollection<R>
// ): Array<[RequestResolver.RequestResolver<unknown, R>, Array<Request.Entry<unknown>>]> => Array.from(self.map) as any
/** @internal */
const SequentialCollectionTypeId = /*#__PURE__*/Symbol.for("effect/RequestBlock/RequestBlockSequential");
const sequentialVariance = {
  /* c8 ignore next */
  _R: _ => _
};
class SequentialImpl {
  map;
  [SequentialCollectionTypeId] = sequentialVariance;
  constructor(map) {
    this.map = map;
  }
}
/** @internal */
const sequentialCollectionMake = map => new SequentialImpl(map);
/** @internal */
const sequentialCollectionCombine = (self, that) => new SequentialImpl(reduce$1(that.map, self.map, (map, value, key) => set$1(map, key, match$3(get$5(map, key), {
  onNone: () => empty$i(),
  onSome: a => appendAll$1(a, value)
}))));
/** @internal */
const sequentialCollectionKeys = self => Array.from(keys(self.map));
/** @internal */
const sequentialCollectionToChunk = self => Array.from(self.map);

/** @internal */
const OP_STATE_PENDING = "Pending";
/** @internal */
const OP_STATE_DONE = "Done";

/** @internal */
const DeferredSymbolKey = "effect/Deferred";
/** @internal */
const DeferredTypeId = /*#__PURE__*/Symbol.for(DeferredSymbolKey);
/** @internal */
const deferredVariance = {
  /* c8 ignore next */
  _E: _ => _,
  /* c8 ignore next */
  _A: _ => _
};
/** @internal */
const pending = joiners => {
  return {
    _tag: OP_STATE_PENDING,
    joiners
  };
};
/** @internal */
const done$2 = effect => {
  return {
    _tag: OP_STATE_DONE,
    effect
  };
};

/** @internal */
class SingleShotGen {
  self;
  called = false;
  constructor(self) {
    this.self = self;
  }
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  throw(e) {
    throw e;
  }
  [Symbol.iterator]() {
    return new SingleShotGen(this.self);
  }
}

// -----------------------------------------------------------------------------
// Effect
// -----------------------------------------------------------------------------
/**
 * @internal
 */
const blocked = (blockedRequests, _continue) => {
  const effect = new EffectPrimitive("Blocked");
  effect.effect_instruction_i0 = blockedRequests;
  effect.effect_instruction_i1 = _continue;
  return effect;
};
/**
 * @internal
 */
const runRequestBlock = blockedRequests => {
  const effect = new EffectPrimitive("RunBlocked");
  effect.effect_instruction_i0 = blockedRequests;
  return effect;
};
/** @internal */
const EffectTypeId = /*#__PURE__*/Symbol.for("effect/Effect");
/** @internal */
class RevertFlags {
  patch;
  op;
  _op = OP_REVERT_FLAGS;
  constructor(patch, op) {
    this.patch = patch;
    this.op = op;
  }
}
class EffectPrimitive {
  _op;
  effect_instruction_i0 = undefined;
  effect_instruction_i1 = undefined;
  effect_instruction_i2 = undefined;
  trace = undefined;
  [EffectTypeId] = effectVariance;
  constructor(_op) {
    this._op = _op;
  }
  [symbol](that) {
    return this === that;
  }
  [symbol$1]() {
    return cached(this, random(this));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Effect",
      _op: this._op,
      effect_instruction_i0: toJSON(this.effect_instruction_i0),
      effect_instruction_i1: toJSON(this.effect_instruction_i1),
      effect_instruction_i2: toJSON(this.effect_instruction_i2)
    };
  }
  toString() {
    return format$4(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  }
}
/** @internal */
class EffectPrimitiveFailure {
  _op;
  effect_instruction_i0 = undefined;
  effect_instruction_i1 = undefined;
  effect_instruction_i2 = undefined;
  trace = undefined;
  [EffectTypeId] = effectVariance;
  constructor(_op) {
    this._op = _op;
    // @ts-expect-error
    this._tag = _op;
  }
  [symbol](that) {
    return exitIsExit(that) && that._op === "Failure" &&
    // @ts-expect-error
    equals$2(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol$1]() {
    return pipe(
    // @ts-expect-error
    string(this._tag),
    // @ts-expect-error
    combine$5(hash(this.effect_instruction_i0)), cached(this));
  }
  get cause() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      cause: this.cause.toJSON()
    };
  }
  toString() {
    return format$4(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  }
}
/** @internal */
class EffectPrimitiveSuccess {
  _op;
  effect_instruction_i0 = undefined;
  effect_instruction_i1 = undefined;
  effect_instruction_i2 = undefined;
  trace = undefined;
  [EffectTypeId] = effectVariance;
  constructor(_op) {
    this._op = _op;
    // @ts-expect-error
    this._tag = _op;
  }
  [symbol](that) {
    return exitIsExit(that) && that._op === "Success" &&
    // @ts-expect-error
    equals$2(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol$1]() {
    return pipe(
    // @ts-expect-error
    string(this._tag),
    // @ts-expect-error
    combine$5(hash(this.effect_instruction_i0)), cached(this));
  }
  get value() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      value: toJSON(this.value)
    };
  }
  toString() {
    return format$4(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  }
}
/** @internal */
const isEffect$1 = u => hasProperty(u, EffectTypeId);
/* @internal */
const withFiberRuntime = withRuntime => {
  const effect = new EffectPrimitive(OP_WITH_RUNTIME);
  effect.effect_instruction_i0 = withRuntime;
  return effect;
};
/* @internal */
const acquireUseRelease = /*#__PURE__*/dual(3, (acquire, use, release) => uninterruptibleMask$1(restore => flatMap$3(acquire, a => flatMap$3(exit(suspend$2(() => restore(use(a)))), exit => {
  return suspend$2(() => release(a, exit)).pipe(matchCauseEffect$1({
    onFailure: cause => {
      switch (exit._tag) {
        case OP_FAILURE:
          return failCause$1(sequential$2(exit.effect_instruction_i0, cause));
        case OP_SUCCESS:
          return failCause$1(cause);
      }
    },
    onSuccess: () => exit
  }));
}))));
/* @internal */
const as = /*#__PURE__*/dual(2, (self, value) => flatMap$3(self, () => succeed$3(value)));
/* @internal */
const asVoid = self => as(self, undefined);
/* @internal */
const custom = function () {
  const wrapper = new EffectPrimitive(OP_COMMIT);
  switch (arguments.length) {
    case 2:
      {
        wrapper.effect_instruction_i0 = arguments[0];
        wrapper.commit = arguments[1];
        break;
      }
    case 3:
      {
        wrapper.effect_instruction_i0 = arguments[0];
        wrapper.effect_instruction_i1 = arguments[1];
        wrapper.commit = arguments[2];
        break;
      }
    case 4:
      {
        wrapper.effect_instruction_i0 = arguments[0];
        wrapper.effect_instruction_i1 = arguments[1];
        wrapper.effect_instruction_i2 = arguments[2];
        wrapper.commit = arguments[3];
        break;
      }
    default:
      {
        throw new Error(getBugErrorMessage("you're not supposed to end up here"));
      }
  }
  return wrapper;
};
/* @internal */
const unsafeAsync = (register, blockingOn = none$2) => {
  const effect = new EffectPrimitive(OP_ASYNC);
  let cancelerRef = undefined;
  effect.effect_instruction_i0 = resume => {
    cancelerRef = register(resume);
  };
  effect.effect_instruction_i1 = blockingOn;
  return onInterrupt(effect, _ => isEffect$1(cancelerRef) ? cancelerRef : void_$1);
};
/* @internal */
const asyncInterrupt = (register, blockingOn = none$2) => suspend$2(() => unsafeAsync(register, blockingOn));
const async_ = (resume, blockingOn = none$2) => {
  return custom(resume, function () {
    let backingResume = undefined;
    let pendingEffect = undefined;
    function proxyResume(effect) {
      if (backingResume) {
        backingResume(effect);
      } else if (pendingEffect === undefined) {
        pendingEffect = effect;
      }
    }
    const effect = new EffectPrimitive(OP_ASYNC);
    effect.effect_instruction_i0 = resume => {
      backingResume = resume;
      if (pendingEffect) {
        resume(pendingEffect);
      }
    };
    effect.effect_instruction_i1 = blockingOn;
    let cancelerRef = undefined;
    let controllerRef = undefined;
    if (this.effect_instruction_i0.length !== 1) {
      controllerRef = new AbortController();
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef.signal));
    } else {
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume));
    }
    return cancelerRef || controllerRef ? onInterrupt(effect, _ => {
      if (controllerRef) {
        controllerRef.abort();
      }
      return cancelerRef ?? void_$1;
    }) : effect;
  });
};
/* @internal */
const catchAll$1 = /*#__PURE__*/dual(2, (self, f) => matchEffect$1(self, {
  onFailure: f,
  onSuccess: succeed$3
}));
const spanSymbol = /*#__PURE__*/Symbol.for("effect/SpanAnnotation");
const originalSymbol = /*#__PURE__*/Symbol.for("effect/OriginalAnnotation");
/* @internal */
const capture = (obj, span) => {
  if (isSome(span)) {
    return new Proxy(obj, {
      has(target, p) {
        return p === spanSymbol || p === originalSymbol || p in target;
      },
      get(target, p) {
        if (p === spanSymbol) {
          return span.value;
        }
        if (p === originalSymbol) {
          return obj;
        }
        // @ts-expect-error
        return target[p];
      }
    });
  }
  return obj;
};
/* @internal */
const die = defect => isObject(defect) && !(spanSymbol in defect) ? withFiberRuntime(fiber => failCause$1(die$1(capture(defect, currentSpanFromFiber(fiber))))) : failCause$1(die$1(defect));
/* @internal */
const dieMessage = message => failCauseSync(() => die$1(new RuntimeException(message)));
/* @internal */
const either$1 = self => matchEffect$1(self, {
  onFailure: e => succeed$3(left(e)),
  onSuccess: a => succeed$3(right(a))
});
/* @internal */
const exit = self => matchCause(self, {
  onFailure: exitFailCause$1,
  onSuccess: exitSucceed$1
});
/* @internal */
const fail$1 = error => isObject(error) && !(spanSymbol in error) ? withFiberRuntime(fiber => failCause$1(fail$2(capture(error, currentSpanFromFiber(fiber))))) : failCause$1(fail$2(error));
/* @internal */
const failSync = evaluate => flatMap$3(sync(evaluate), fail$1);
/* @internal */
const failCause$1 = cause => {
  const effect = new EffectPrimitiveFailure(OP_FAILURE);
  effect.effect_instruction_i0 = cause;
  return effect;
};
/* @internal */
const failCauseSync = evaluate => flatMap$3(sync(evaluate), failCause$1);
/* @internal */
const fiberId = /*#__PURE__*/withFiberRuntime(state => succeed$3(state.id()));
/* @internal */
const fiberIdWith = f => withFiberRuntime(state => f(state.id()));
/* @internal */
const flatMap$3 = /*#__PURE__*/dual(2, (self, f) => {
  const effect = new EffectPrimitive(OP_ON_SUCCESS);
  effect.effect_instruction_i0 = self;
  effect.effect_instruction_i1 = f;
  return effect;
});
/* @internal */
const step = self => {
  const effect = new EffectPrimitive("OnStep");
  effect.effect_instruction_i0 = self;
  return effect;
};
/* @internal */
const flatten = self => flatMap$3(self, identity);
/* @internal */
const matchCause = /*#__PURE__*/dual(2, (self, options) => matchCauseEffect$1(self, {
  onFailure: cause => succeed$3(options.onFailure(cause)),
  onSuccess: a => succeed$3(options.onSuccess(a))
}));
/* @internal */
const matchCauseEffect$1 = /*#__PURE__*/dual(2, (self, options) => {
  const effect = new EffectPrimitive(OP_ON_SUCCESS_AND_FAILURE);
  effect.effect_instruction_i0 = self;
  effect.effect_instruction_i1 = options.onFailure;
  effect.effect_instruction_i2 = options.onSuccess;
  return effect;
});
/* @internal */
const matchEffect$1 = /*#__PURE__*/dual(2, (self, options) => matchCauseEffect$1(self, {
  onFailure: cause => {
    const defects$1 = defects(cause);
    if (defects$1.length > 0) {
      return failCause$1(electFailures(cause));
    }
    const failures$1 = failures(cause);
    if (failures$1.length > 0) {
      return options.onFailure(unsafeHead(failures$1));
    }
    return failCause$1(cause);
  },
  onSuccess: options.onSuccess
}));
/* @internal */
const forEachSequential = /*#__PURE__*/dual(2, (self, f) => suspend$2(() => {
  const arr = fromIterable$6(self);
  const ret = allocate(arr.length);
  let i = 0;
  return as(whileLoop({
    while: () => i < arr.length,
    body: () => f(arr[i], i),
    step: b => {
      ret[i++] = b;
    }
  }), ret);
}));
/* @internal */
const forEachSequentialDiscard = /*#__PURE__*/dual(2, (self, f) => suspend$2(() => {
  const arr = fromIterable$6(self);
  let i = 0;
  return whileLoop({
    while: () => i < arr.length,
    body: () => f(arr[i], i),
    step: () => {
      i++;
    }
  });
}));
/* @internal */
const interruptible$1 = self => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = enable(Interruption);
  effect.effect_instruction_i1 = () => self;
  return effect;
};
/* @internal */
const map$2 = /*#__PURE__*/dual(2, (self, f) => flatMap$3(self, a => sync(() => f(a))));
/* @internal */
const mapBoth = /*#__PURE__*/dual(2, (self, options) => matchEffect$1(self, {
  onFailure: e => failSync(() => options.onFailure(e)),
  onSuccess: a => sync(() => options.onSuccess(a))
}));
/* @internal */
const mapError$2 = /*#__PURE__*/dual(2, (self, f) => matchCauseEffect$1(self, {
  onFailure: cause => {
    const either = failureOrCause(cause);
    switch (either._tag) {
      case "Left":
        {
          return failSync(() => f(either.left));
        }
      case "Right":
        {
          return failCause$1(either.right);
        }
    }
  },
  onSuccess: succeed$3
}));
/* @internal */
const onExit$1 = /*#__PURE__*/dual(2, (self, cleanup) => uninterruptibleMask$1(restore => matchCauseEffect$1(restore(self), {
  onFailure: cause1 => {
    const result = exitFailCause$1(cause1);
    return matchCauseEffect$1(cleanup(result), {
      onFailure: cause2 => exitFailCause$1(sequential$2(cause1, cause2)),
      onSuccess: () => result
    });
  },
  onSuccess: success => {
    const result = exitSucceed$1(success);
    return zipRight(cleanup(result), result);
  }
})));
/* @internal */
const onInterrupt = /*#__PURE__*/dual(2, (self, cleanup) => onExit$1(self, exitMatch({
  onFailure: cause => isInterruptedOnly(cause) ? asVoid(cleanup(interruptors(cause))) : void_$1,
  onSuccess: () => void_$1
})));
/* @internal */
const orElse$1 = /*#__PURE__*/dual(2, (self, that) => attemptOrElse(self, that, succeed$3));
/* @internal */
const succeed$3 = value => {
  const effect = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect.effect_instruction_i0 = value;
  return effect;
};
/* @internal */
const suspend$2 = evaluate => {
  const effect = new EffectPrimitive(OP_COMMIT);
  effect.commit = evaluate;
  return effect;
};
/* @internal */
const sync = thunk => {
  const effect = new EffectPrimitive(OP_SYNC);
  effect.effect_instruction_i0 = thunk;
  return effect;
};
/* @internal */
const tap = /*#__PURE__*/dual(args => args.length === 3 || args.length === 2 && !(isObject(args[1]) && "onlyEffect" in args[1]), (self, f) => flatMap$3(self, a => {
  const b = typeof f === "function" ? f(a) : f;
  if (isEffect$1(b)) {
    return as(b, a);
  } else if (isPromiseLike(b)) {
    return unsafeAsync(resume => {
      b.then(_ => resume(succeed$3(a)), e => resume(fail$1(new UnknownException(e))));
    });
  }
  return succeed$3(a);
}));
/* @internal */
const transplant = f => withFiberRuntime(state => {
  const scopeOverride = state.getFiberRef(currentForkScopeOverride);
  const scope = pipe(scopeOverride, getOrElse(() => state.scope()));
  return f(fiberRefLocally(currentForkScopeOverride, some(scope)));
});
/* @internal */
const attemptOrElse = /*#__PURE__*/dual(3, (self, that, onSuccess) => matchCauseEffect$1(self, {
  onFailure: cause => {
    const defects$1 = defects(cause);
    if (defects$1.length > 0) {
      return failCause$1(getOrThrow(keepDefectsAndElectFailures(cause)));
    }
    return that();
  },
  onSuccess
}));
/* @internal */
const uninterruptible = self => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = disable(Interruption);
  effect.effect_instruction_i1 = () => self;
  return effect;
};
/* @internal */
const uninterruptibleMask$1 = f => custom(f, function () {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = disable(Interruption);
  effect.effect_instruction_i1 = oldFlags => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible$1)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
  return effect;
});
const void_$1 = /*#__PURE__*/succeed$3(undefined);
/* @internal */
const updateRuntimeFlags = patch => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = patch;
  effect.effect_instruction_i1 = undefined;
  return effect;
};
/* @internal */
const whileLoop = options => {
  const effect = new EffectPrimitive(OP_WHILE);
  effect.effect_instruction_i0 = options.while;
  effect.effect_instruction_i1 = options.body;
  effect.effect_instruction_i2 = options.step;
  return effect;
};
/* @internal */
const yieldNow$2 = options => {
  const effect = new EffectPrimitive(OP_YIELD);
  return typeof options?.priority !== "undefined" ? withSchedulingPriority(effect, options.priority) : effect;
};
/* @internal */
const zip = /*#__PURE__*/dual(2, (self, that) => flatMap$3(self, a => map$2(that, b => [a, b])));
/* @internal */
const zipLeft = /*#__PURE__*/dual(2, (self, that) => flatMap$3(self, a => as(that, a)));
/* @internal */
const zipRight = /*#__PURE__*/dual(2, (self, that) => flatMap$3(self, () => that));
/* @internal */
const never = /*#__PURE__*/asyncInterrupt(() => {
  const interval = setInterval(() => {
    //
  }, 2 ** 31 - 1);
  return sync(() => clearInterval(interval));
});
// -----------------------------------------------------------------------------
// Fiber
// -----------------------------------------------------------------------------
/* @internal */
const interruptFiber = self => flatMap$3(fiberId, fiberId => pipe(self, interruptAsFiber(fiberId)));
/* @internal */
const interruptAsFiber = /*#__PURE__*/dual(2, (self, fiberId) => flatMap$3(self.interruptAsFork(fiberId), () => self.await));
// -----------------------------------------------------------------------------
// LogLevel
// -----------------------------------------------------------------------------
/** @internal */
const logLevelAll = {
  _tag: "All",
  syslog: 0,
  label: "ALL",
  ordinal: Number.MIN_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
/** @internal */
const logLevelFatal = {
  _tag: "Fatal",
  syslog: 2,
  label: "FATAL",
  ordinal: 50000,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
/** @internal */
const logLevelError = {
  _tag: "Error",
  syslog: 3,
  label: "ERROR",
  ordinal: 40000,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
/** @internal */
const logLevelWarning = {
  _tag: "Warning",
  syslog: 4,
  label: "WARN",
  ordinal: 30000,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
/** @internal */
const logLevelInfo = {
  _tag: "Info",
  syslog: 6,
  label: "INFO",
  ordinal: 20000,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
/** @internal */
const logLevelDebug = {
  _tag: "Debug",
  syslog: 7,
  label: "DEBUG",
  ordinal: 10000,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
/** @internal */
const logLevelTrace = {
  _tag: "Trace",
  syslog: 7,
  label: "TRACE",
  ordinal: 0,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
/** @internal */
const logLevelNone = {
  _tag: "None",
  syslog: 7,
  label: "OFF",
  ordinal: Number.MAX_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
// -----------------------------------------------------------------------------
// FiberRef
// -----------------------------------------------------------------------------
/** @internal */
const FiberRefSymbolKey = "effect/FiberRef";
/** @internal */
const FiberRefTypeId = /*#__PURE__*/Symbol.for(FiberRefSymbolKey);
const fiberRefVariance = {
  /* c8 ignore next */
  _A: _ => _
};
/* @internal */
const fiberRefGet = self => withFiberRuntime(fiber => exitSucceed$1(fiber.getFiberRef(self)));
/* @internal */
const fiberRefGetWith = /*#__PURE__*/dual(2, (self, f) => flatMap$3(fiberRefGet(self), f));
/* @internal */
const fiberRefSet = /*#__PURE__*/dual(2, (self, value) => fiberRefModify(self, () => [undefined, value]));
/* @internal */
const fiberRefModify = /*#__PURE__*/dual(2, (self, f) => withFiberRuntime(state => {
  const [b, a] = f(state.getFiberRef(self));
  state.setFiberRef(self, a);
  return succeed$3(b);
}));
/* @internal */
const fiberRefLocally = /*#__PURE__*/dual(3, (use, self, value) => acquireUseRelease(zipLeft(fiberRefGet(self), fiberRefSet(self, value)), () => use, oldValue => fiberRefSet(self, oldValue)));
/** @internal */
const fiberRefUnsafeMake = (initial, options) => fiberRefUnsafeMakePatch(initial, {
  differ: update$1(),
  fork: options?.fork ?? identity,
  join: options?.join
});
/** @internal */
const fiberRefUnsafeMakeHashSet = initial => {
  const differ = hashSet();
  return fiberRefUnsafeMakePatch(initial, {
    differ,
    fork: differ.empty
  });
};
/** @internal */
const fiberRefUnsafeMakeReadonlyArray = initial => {
  const differ = readonlyArray(update$1());
  return fiberRefUnsafeMakePatch(initial, {
    differ,
    fork: differ.empty
  });
};
/** @internal */
const fiberRefUnsafeMakeContext = initial => {
  const differ = environment$1();
  return fiberRefUnsafeMakePatch(initial, {
    differ,
    fork: differ.empty
  });
};
/** @internal */
const fiberRefUnsafeMakePatch = (initial, options) => {
  const _fiberRef = {
    ...CommitPrototype$1,
    [FiberRefTypeId]: fiberRefVariance,
    initial,
    commit() {
      return fiberRefGet(this);
    },
    diff: (oldValue, newValue) => options.differ.diff(oldValue, newValue),
    combine: (first, second) => options.differ.combine(first, second),
    patch: patch => oldValue => options.differ.patch(patch, oldValue),
    fork: options.fork,
    join: options.join ?? ((_, n) => n)
  };
  return _fiberRef;
};
/** @internal */
const fiberRefUnsafeMakeRuntimeFlags = initial => fiberRefUnsafeMakePatch(initial, {
  differ: differ$1,
  fork: differ$1.empty
});
/** @internal */
const currentContext = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentContext"), () => fiberRefUnsafeMakeContext(empty$c()));
/** @internal */
const currentSchedulingPriority = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentSchedulingPriority"), () => fiberRefUnsafeMake(0));
/** @internal */
const currentMaxOpsBeforeYield = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentMaxOpsBeforeYield"), () => fiberRefUnsafeMake(2048));
/** @internal */
const currentLogAnnotations = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentLogAnnotation"), () => fiberRefUnsafeMake(empty$b()));
/** @internal */
const currentLogLevel = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentLogLevel"), () => fiberRefUnsafeMake(logLevelInfo));
/** @internal */
const currentLogSpan = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentLogSpan"), () => fiberRefUnsafeMake(empty$a()));
/** @internal */
const withSchedulingPriority = /*#__PURE__*/dual(2, (self, scheduler) => fiberRefLocally(self, currentSchedulingPriority, scheduler));
/** @internal */
const currentConcurrency = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentConcurrency"), () => fiberRefUnsafeMake("unbounded"));
/**
 * @internal
 */
const currentRequestBatching = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentRequestBatching"), () => fiberRefUnsafeMake(true));
/** @internal */
const currentUnhandledErrorLogLevel = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentUnhandledErrorLogLevel"), () => fiberRefUnsafeMake(some(logLevelDebug)));
/** @internal */
const currentMetricLabels = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentMetricLabels"), () => fiberRefUnsafeMakeReadonlyArray(empty$j()));
/** @internal */
const currentForkScopeOverride = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentForkScopeOverride"), () => fiberRefUnsafeMake(none$4(), {
  fork: () => none$4(),
  join: (parent, _) => parent
}));
/** @internal */
const currentInterruptedCause = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentInterruptedCause"), () => fiberRefUnsafeMake(empty$e, {
  fork: () => empty$e,
  join: (parent, _) => parent
}));
/* @internal */
const scopeAddFinalizer = (self, finalizer) => self.addFinalizer(() => asVoid(finalizer));
/* @internal */
const scopeClose = (self, exit) => self.close(exit);
/* @internal */
const scopeFork = (self, strategy) => self.fork(strategy);
// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------
/** @internal */
const YieldableError = /*#__PURE__*/function () {
  class YieldableError extends globalThis.Error {
    commit() {
      return fail$1(this);
    }
    toJSON() {
      return {
        ...this
      };
    }
    [NodeInspectSymbol]() {
      if (this.toString !== globalThis.Error.prototype.toString) {
        return this.stack ? `${this.toString()}\n${this.stack.split("\n").slice(1).join("\n")}` : this.toString();
      } else if ("Bun" in globalThis) {
        return pretty(fail$2(this), {
          renderErrorCause: true
        });
      }
      return this;
    }
  }
  Object.assign(YieldableError.prototype, StructuralCommitPrototype);
  return YieldableError;
}();
const makeException = (proto, tag) => {
  class Base extends YieldableError {
    _tag = tag;
  }
  Object.assign(Base.prototype, proto);
  Base.prototype.name = tag;
  return Base;
};
/** @internal */
const RuntimeExceptionTypeId = /*#__PURE__*/Symbol.for("effect/Cause/errors/RuntimeException");
/** @internal */
const RuntimeException = /*#__PURE__*/makeException({
  [RuntimeExceptionTypeId]: RuntimeExceptionTypeId
}, "RuntimeException");
/** @internal */
const InterruptedExceptionTypeId = /*#__PURE__*/Symbol.for("effect/Cause/errors/InterruptedException");
/** @internal */
const isInterruptedException = u => hasProperty(u, InterruptedExceptionTypeId);
/** @internal */
const NoSuchElementExceptionTypeId = /*#__PURE__*/Symbol.for("effect/Cause/errors/NoSuchElement");
/** @internal */
const NoSuchElementException = /*#__PURE__*/makeException({
  [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId
}, "NoSuchElementException");
/** @internal */
const UnknownExceptionTypeId = /*#__PURE__*/Symbol.for("effect/Cause/errors/UnknownException");
/** @internal */
const UnknownException = /*#__PURE__*/function () {
  class UnknownException extends YieldableError {
    cause;
    _tag = "UnknownException";
    error;
    constructor(cause, message) {
      super(message ?? "An unknown error occurred", {
        cause
      });
      this.cause = cause;
      this.error = cause;
    }
  }
  Object.assign(UnknownException.prototype, {
    [UnknownExceptionTypeId]: UnknownExceptionTypeId,
    name: "UnknownException"
  });
  return UnknownException;
}();
// -----------------------------------------------------------------------------
// Exit
// -----------------------------------------------------------------------------
/** @internal */
const exitIsExit = u => isEffect$1(u) && "_tag" in u && (u._tag === "Success" || u._tag === "Failure");
/** @internal */
const exitCollectAll = (exits, options) => exitCollectAllInternal(exits, options?.parallel ? parallel$2 : sequential$2);
/** @internal */
const exitDie$1 = defect => exitFailCause$1(die$1(defect));
/** @internal */
const exitFail = error => exitFailCause$1(fail$2(error));
/** @internal */
const exitFailCause$1 = cause => {
  const effect = new EffectPrimitiveFailure(OP_FAILURE);
  effect.effect_instruction_i0 = cause;
  return effect;
};
/** @internal */
const exitInterrupt$1 = fiberId => exitFailCause$1(interrupt(fiberId));
/** @internal */
const exitMap = /*#__PURE__*/dual(2, (self, f) => {
  switch (self._tag) {
    case OP_FAILURE:
      return exitFailCause$1(self.effect_instruction_i0);
    case OP_SUCCESS:
      return exitSucceed$1(f(self.effect_instruction_i0));
  }
});
/** @internal */
const exitMatch = /*#__PURE__*/dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      return onFailure(self.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self.effect_instruction_i0);
  }
});
/** @internal */
const exitSucceed$1 = value => {
  const effect = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect.effect_instruction_i0 = value;
  return effect;
};
/** @internal */
const exitVoid$1 = /*#__PURE__*/exitSucceed$1(undefined);
/** @internal */
const exitZipWith = /*#__PURE__*/dual(3, (self, that, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      {
        switch (that._tag) {
          case OP_SUCCESS:
            return exitFailCause$1(self.effect_instruction_i0);
          case OP_FAILURE:
            {
              return exitFailCause$1(onFailure(self.effect_instruction_i0, that.effect_instruction_i0));
            }
        }
      }
    case OP_SUCCESS:
      {
        switch (that._tag) {
          case OP_SUCCESS:
            return exitSucceed$1(onSuccess(self.effect_instruction_i0, that.effect_instruction_i0));
          case OP_FAILURE:
            return exitFailCause$1(that.effect_instruction_i0);
        }
      }
  }
});
const exitCollectAllInternal = (exits, combineCauses) => {
  const list = fromIterable$5(exits);
  if (!isNonEmpty(list)) {
    return none$4();
  }
  return pipe(tailNonEmpty(list), reduce$6(pipe(headNonEmpty(list), exitMap(of$1)), (accumulator, current) => pipe(accumulator, exitZipWith(current, {
    onSuccess: (list, value) => pipe(list, prepend$1(value)),
    onFailure: combineCauses
  }))), exitMap(reverse$1), exitMap(chunk => toReadonlyArray(chunk)), some);
};
// -----------------------------------------------------------------------------
// Deferred
// -----------------------------------------------------------------------------
/** @internal */
const deferredUnsafeMake = fiberId => {
  const _deferred = {
    ...CommitPrototype$1,
    [DeferredTypeId]: deferredVariance,
    state: make$h(pending([])),
    commit() {
      return deferredAwait(this);
    },
    blockingOn: fiberId
  };
  return _deferred;
};
/* @internal */
const deferredAwait = self => asyncInterrupt(resume => {
  const state = get$6(self.state);
  switch (state._tag) {
    case OP_STATE_DONE:
      {
        return resume(state.effect);
      }
    case OP_STATE_PENDING:
      {
        // we can push here as the internal state is mutable
        state.joiners.push(resume);
        return deferredInterruptJoiner(self, resume);
      }
  }
}, self.blockingOn);
/** @internal */
const deferredUnsafeDone = (self, effect) => {
  const state = get$6(self.state);
  if (state._tag === OP_STATE_PENDING) {
    set$2(self.state, done$2(effect));
    for (let i = 0, len = state.joiners.length; i < len; i++) {
      state.joiners[i](effect);
    }
  }
};
const deferredInterruptJoiner = (self, joiner) => sync(() => {
  const state = get$6(self.state);
  if (state._tag === OP_STATE_PENDING) {
    const index = state.joiners.indexOf(joiner);
    if (index >= 0) {
      // we can splice here as the internal state is mutable
      state.joiners.splice(index, 1);
    }
  }
});
// -----------------------------------------------------------------------------
// Context
// -----------------------------------------------------------------------------
const constContext = /*#__PURE__*/withFiberRuntime(fiber => exitSucceed$1(fiber.currentContext));
/* @internal */
const context = () => constContext;
/* @internal */
const contextWithEffect = f => flatMap$3(context(), f);
/* @internal */
const provideContext$1 = /*#__PURE__*/dual(2, (self, context) => fiberRefLocally(currentContext, context)(self));
/* @internal */
const mapInputContext = /*#__PURE__*/dual(2, (self, f) => contextWithEffect(context => provideContext$1(self, f(context))));
// -----------------------------------------------------------------------------
// Tracing
// -----------------------------------------------------------------------------
/** @internal */
const currentSpanFromFiber = fiber => {
  const span = fiber.currentSpan;
  return span !== undefined && span._tag === "Span" ? some(span) : none$4();
};

/** @internal */
const ClockSymbolKey = "effect/Clock";
/** @internal */
const ClockTypeId = /*#__PURE__*/Symbol.for(ClockSymbolKey);
/** @internal */
const clockTag = /*#__PURE__*/GenericTag("effect/Clock");
/** @internal */
const MAX_TIMER_MILLIS = 2 ** 31 - 1;
/** @internal */
const globalClockScheduler = {
  unsafeSchedule(task, duration) {
    const millis = toMillis(duration);
    // If the duration is greater than the value allowable by the JS timer
    // functions, treat the value as an infinite duration
    if (millis > MAX_TIMER_MILLIS) {
      return constFalse;
    }
    let completed = false;
    const handle = setTimeout(() => {
      completed = true;
      task();
    }, millis);
    return () => {
      clearTimeout(handle);
      return !completed;
    };
  }
};
const performanceNowNanos = /*#__PURE__*/function () {
  const bigint1e6 = /*#__PURE__*/BigInt(1_000_000);
  if (typeof performance === "undefined") {
    return () => BigInt(Date.now()) * bigint1e6;
  } else if (typeof performance.timeOrigin === "number" && performance.timeOrigin === 0) {
    return () => BigInt(Math.round(performance.now() * 1_000_000));
  }
  const origin = /*#__PURE__*/BigInt( /*#__PURE__*/Date.now()) * bigint1e6 - /*#__PURE__*/BigInt( /*#__PURE__*/Math.round( /*#__PURE__*/performance.now() * 1_000_000));
  return () => origin + BigInt(Math.round(performance.now() * 1_000_000));
}();
const processOrPerformanceNow = /*#__PURE__*/function () {
  const processHrtime = typeof process === "object" && "hrtime" in process && typeof process.hrtime.bigint === "function" ? process.hrtime : undefined;
  if (!processHrtime) {
    return performanceNowNanos;
  }
  const origin = /*#__PURE__*/performanceNowNanos() - /*#__PURE__*/processHrtime.bigint();
  return () => origin + processHrtime.bigint();
}();
/** @internal */
class ClockImpl {
  [ClockTypeId] = ClockTypeId;
  unsafeCurrentTimeMillis() {
    return Date.now();
  }
  unsafeCurrentTimeNanos() {
    return processOrPerformanceNow();
  }
  currentTimeMillis = /*#__PURE__*/sync(() => this.unsafeCurrentTimeMillis());
  currentTimeNanos = /*#__PURE__*/sync(() => this.unsafeCurrentTimeNanos());
  scheduler() {
    return succeed$3(globalClockScheduler);
  }
  sleep(duration) {
    return async_(resume => {
      const canceler = globalClockScheduler.unsafeSchedule(() => resume(void_$1), duration);
      return asVoid(sync(canceler));
    });
  }
}
/** @internal */
const make$d = () => new ClockImpl();

/** @internal */
const OP_AND = "And";
/** @internal */
const OP_OR = "Or";
/** @internal */
const OP_INVALID_DATA = "InvalidData";
/** @internal */
const OP_MISSING_DATA = "MissingData";
/** @internal */
const OP_SOURCE_UNAVAILABLE = "SourceUnavailable";
/** @internal */
const OP_UNSUPPORTED = "Unsupported";

/** @internal */
const ConfigErrorSymbolKey = "effect/ConfigError";
/** @internal */
const ConfigErrorTypeId = /*#__PURE__*/Symbol.for(ConfigErrorSymbolKey);
/** @internal */
const proto$1 = {
  _tag: "ConfigError",
  [ConfigErrorTypeId]: ConfigErrorTypeId
};
/** @internal */
const And = (self, that) => {
  const error = Object.create(proto$1);
  error._op = OP_AND;
  error.left = self;
  error.right = that;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      return `${this.left} and ${this.right}`;
    }
  });
  return error;
};
/** @internal */
const Or = (self, that) => {
  const error = Object.create(proto$1);
  error._op = OP_OR;
  error.left = self;
  error.right = that;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      return `${this.left} or ${this.right}`;
    }
  });
  return error;
};
/** @internal */
const InvalidData = (path, message, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto$1);
  error._op = OP_INVALID_DATA;
  error.path = path;
  error.message = message;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path = pipe(this.path, join$1(options.pathDelim));
      return `(Invalid data at ${path}: "${this.message}")`;
    }
  });
  return error;
};
/** @internal */
const MissingData = (path, message, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto$1);
  error._op = OP_MISSING_DATA;
  error.path = path;
  error.message = message;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path = pipe(this.path, join$1(options.pathDelim));
      return `(Missing data at ${path}: "${this.message}")`;
    }
  });
  return error;
};
/** @internal */
const SourceUnavailable = (path, message, cause, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto$1);
  error._op = OP_SOURCE_UNAVAILABLE;
  error.path = path;
  error.message = message;
  error.cause = cause;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path = pipe(this.path, join$1(options.pathDelim));
      return `(Source unavailable at ${path}: "${this.message}")`;
    }
  });
  return error;
};
/** @internal */
const Unsupported = (path, message, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto$1);
  error._op = OP_UNSUPPORTED;
  error.path = path;
  error.message = message;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path = pipe(this.path, join$1(options.pathDelim));
      return `(Unsupported operation at ${path}: "${this.message}")`;
    }
  });
  return error;
};
/** @internal */
const prefixed = /*#__PURE__*/dual(2, (self, prefix) => {
  switch (self._op) {
    case OP_AND:
      {
        return And(prefixed(self.left, prefix), prefixed(self.right, prefix));
      }
    case OP_OR:
      {
        return Or(prefixed(self.left, prefix), prefixed(self.right, prefix));
      }
    case OP_INVALID_DATA:
      {
        return InvalidData([...prefix, ...self.path], self.message);
      }
    case OP_MISSING_DATA:
      {
        return MissingData([...prefix, ...self.path], self.message);
      }
    case OP_SOURCE_UNAVAILABLE:
      {
        return SourceUnavailable([...prefix, ...self.path], self.message, self.cause);
      }
    case OP_UNSUPPORTED:
      {
        return Unsupported([...prefix, ...self.path], self.message);
      }
  }
});

/** @internal */
const empty$5 = {
  _tag: "Empty"
};
/** @internal */
const patch$3 = /*#__PURE__*/dual(2, (path, patch) => {
  let input = of(patch);
  let output = path;
  while (isCons(input)) {
    const patch = input.head;
    switch (patch._tag) {
      case "Empty":
        {
          input = input.tail;
          break;
        }
      case "AndThen":
        {
          input = cons(patch.first, cons(patch.second, input.tail));
          break;
        }
      case "MapName":
        {
          output = map$5(output, patch.f);
          input = input.tail;
          break;
        }
      case "Nested":
        {
          output = prepend$2(output, patch.name);
          input = input.tail;
          break;
        }
      case "Unnested":
        {
          const containsName = pipe(head(output), contains(patch.name));
          if (containsName) {
            output = tailNonEmpty$1(output);
            input = input.tail;
          } else {
            return left(MissingData(output, `Expected ${patch.name} to be in path in ConfigProvider#unnested`));
          }
          break;
        }
    }
  }
  return right(output);
});

/** @internal */
const OP_CONSTANT = "Constant";
/** @internal */
const OP_FAIL = "Fail";
/** @internal */
const OP_FALLBACK = "Fallback";
/** @internal */
const OP_DESCRIBED = "Described";
/** @internal */
const OP_LAZY = "Lazy";
/** @internal */
const OP_MAP_OR_FAIL = "MapOrFail";
/** @internal */
const OP_NESTED = "Nested";
/** @internal */
const OP_PRIMITIVE = "Primitive";
/** @internal */
const OP_SEQUENCE = "Sequence";
/** @internal */
const OP_HASHMAP = "HashMap";
/** @internal */
const OP_ZIP_WITH = "ZipWith";

const concat = (l, r) => [...l, ...r];
/** @internal */
const ConfigProviderSymbolKey = "effect/ConfigProvider";
/** @internal */
const ConfigProviderTypeId = /*#__PURE__*/Symbol.for(ConfigProviderSymbolKey);
/** @internal */
const configProviderTag = /*#__PURE__*/GenericTag("effect/ConfigProvider");
/** @internal */
const FlatConfigProviderSymbolKey = "effect/ConfigProviderFlat";
/** @internal */
const FlatConfigProviderTypeId = /*#__PURE__*/Symbol.for(FlatConfigProviderSymbolKey);
/** @internal */
const make$c = options => ({
  [ConfigProviderTypeId]: ConfigProviderTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options
});
/** @internal */
const makeFlat = options => ({
  [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,
  patch: options.patch,
  load: (path, config, split = true) => options.load(path, config, split),
  enumerateChildren: options.enumerateChildren
});
/** @internal */
const fromFlat = flat => make$c({
  load: config => flatMap$3(fromFlatLoop(flat, empty$j(), config, false), chunk => match$3(head(chunk), {
    onNone: () => fail$1(MissingData(empty$j(), `Expected a single value having structure: ${config}`)),
    onSome: succeed$3
  })),
  flattened: flat
});
/** @internal */
const fromEnv = config => {
  const {
    pathDelim,
    seqDelim
  } = Object.assign({}, {
    pathDelim: "_",
    seqDelim: ","
  }, config);
  const makePathString = path => pipe(path, join$1(pathDelim));
  const unmakePathString = pathString => pathString.split(pathDelim);
  const getEnv = () => typeof process !== "undefined" && "env" in process && typeof process.env === "object" ? process.env : {};
  const load = (path, primitive, split = true) => {
    const pathString = makePathString(path);
    const current = getEnv();
    const valueOpt = pathString in current ? some(current[pathString]) : none$4();
    return pipe(valueOpt, mapError$2(() => MissingData(path, `Expected ${pathString} to exist in the process context`)), flatMap$3(value => parsePrimitive(value, path, primitive, seqDelim, split)));
  };
  const enumerateChildren = path => sync(() => {
    const current = getEnv();
    const keys = Object.keys(current);
    const keyPaths = keys.map(value => unmakePathString(value.toUpperCase()));
    const filteredKeyPaths = keyPaths.filter(keyPath => {
      for (let i = 0; i < path.length; i++) {
        const pathComponent = pipe(path, unsafeGet$3(i));
        const currentElement = keyPath[i];
        if (currentElement === undefined || pathComponent !== currentElement) {
          return false;
        }
      }
      return true;
    }).flatMap(keyPath => keyPath.slice(path.length, path.length + 1));
    return fromIterable$2(filteredKeyPaths);
  });
  return fromFlat(makeFlat({
    load,
    enumerateChildren,
    patch: empty$5
  }));
};
const extend = (leftDef, rightDef, left, right) => {
  const leftPad = unfold(left.length, index => index >= right.length ? none$4() : some([leftDef(index), index + 1]));
  const rightPad = unfold(right.length, index => index >= left.length ? none$4() : some([rightDef(index), index + 1]));
  const leftExtension = concat(left, leftPad);
  const rightExtension = concat(right, rightPad);
  return [leftExtension, rightExtension];
};
const appendConfigPath = (path, config) => {
  let op = config;
  if (op._tag === "Nested") {
    const out = path.slice();
    while (op._tag === "Nested") {
      out.push(op.name);
      op = op.config;
    }
    return out;
  }
  return path;
};
const fromFlatLoop = (flat, prefix, config, split) => {
  const op = config;
  switch (op._tag) {
    case OP_CONSTANT:
      {
        return succeed$3(of$2(op.value));
      }
    case OP_DESCRIBED:
      {
        return suspend$2(() => fromFlatLoop(flat, prefix, op.config, split));
      }
    case OP_FAIL:
      {
        return fail$1(MissingData(prefix, op.message));
      }
    case OP_FALLBACK:
      {
        return pipe(suspend$2(() => fromFlatLoop(flat, prefix, op.first, split)), catchAll$1(error1 => {
          if (op.condition(error1)) {
            return pipe(fromFlatLoop(flat, prefix, op.second, split), catchAll$1(error2 => fail$1(Or(error1, error2))));
          }
          return fail$1(error1);
        }));
      }
    case OP_LAZY:
      {
        return suspend$2(() => fromFlatLoop(flat, prefix, op.config(), split));
      }
    case OP_MAP_OR_FAIL:
      {
        return suspend$2(() => pipe(fromFlatLoop(flat, prefix, op.original, split), flatMap$3(forEachSequential(a => pipe(op.mapOrFail(a), mapError$2(prefixed(appendConfigPath(prefix, op.original))))))));
      }
    case OP_NESTED:
      {
        return suspend$2(() => fromFlatLoop(flat, concat(prefix, of$2(op.name)), op.config, split));
      }
    case OP_PRIMITIVE:
      {
        return pipe(patch$3(prefix, flat.patch), flatMap$3(prefix => pipe(flat.load(prefix, op, split), flatMap$3(values => {
          if (values.length === 0) {
            const name = pipe(last(prefix), getOrElse(() => "<n/a>"));
            return fail$1(MissingData([], `Expected ${op.description} with name ${name}`));
          }
          return succeed$3(values);
        }))));
      }
    case OP_SEQUENCE:
      {
        return pipe(patch$3(prefix, flat.patch), flatMap$3(patchedPrefix => pipe(flat.enumerateChildren(patchedPrefix), flatMap$3(indicesFrom), flatMap$3(indices => {
          if (indices.length === 0) {
            return suspend$2(() => map$2(fromFlatLoop(flat, prefix, op.config, true), of$2));
          }
          return pipe(forEachSequential(indices, index => fromFlatLoop(flat, append$1(prefix, `[${index}]`), op.config, true)), map$2(chunkChunk => {
            const flattened = flatten$3(chunkChunk);
            if (flattened.length === 0) {
              return of$2(empty$j());
            }
            return of$2(flattened);
          }));
        }))));
      }
    case OP_HASHMAP:
      {
        return suspend$2(() => pipe(patch$3(prefix, flat.patch), flatMap$3(prefix => pipe(flat.enumerateChildren(prefix), flatMap$3(keys => {
          return pipe(keys, forEachSequential(key => fromFlatLoop(flat, concat(prefix, of$2(key)), op.valueConfig, split)), map$2(matrix => {
            if (matrix.length === 0) {
              return of$2(empty$b());
            }
            return pipe(transpose(matrix), map$5(values => fromIterable$1(zip$1(fromIterable$6(keys), values))));
          }));
        })))));
      }
    case OP_ZIP_WITH:
      {
        return suspend$2(() => pipe(fromFlatLoop(flat, prefix, op.left, split), either$1, flatMap$3(left => pipe(fromFlatLoop(flat, prefix, op.right, split), either$1, flatMap$3(right$1 => {
          if (isLeft(left) && isLeft(right$1)) {
            return fail$1(And(left.left, right$1.left));
          }
          if (isLeft(left) && isRight(right$1)) {
            return fail$1(left.left);
          }
          if (isRight(left) && isLeft(right$1)) {
            return fail$1(right$1.left);
          }
          if (isRight(left) && isRight(right$1)) {
            const path = pipe(prefix, join$1("."));
            const fail = fromFlatLoopFail(prefix, path);
            const [lefts, rights] = extend(fail, fail, pipe(left.right, map$5(right)), pipe(right$1.right, map$5(right)));
            return pipe(lefts, zip$1(rights), forEachSequential(([left, right]) => pipe(zip(left, right), map$2(([left, right]) => op.zip(left, right)))));
          }
          throw new Error("BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues");
        })))));
      }
  }
};
const fromFlatLoopFail = (prefix, path) => index => left(MissingData(prefix, `The element at index ${index} in a sequence at path "${path}" was missing`));
const splitPathString = (text, delim) => {
  const split = text.split(new RegExp(`\\s*${escape(delim)}\\s*`));
  return split;
};
const parsePrimitive = (text, path, primitive, delimiter, split) => {
  if (!split) {
    return pipe(primitive.parse(text), mapBoth({
      onFailure: prefixed(path),
      onSuccess: of$2
    }));
  }
  return pipe(splitPathString(text, delimiter), forEachSequential(char => primitive.parse(char.trim())), mapError$2(prefixed(path)));
};
const transpose = array => {
  return Object.keys(array[0]).map(column => array.map(row => row[column]));
};
const indicesFrom = quotedIndices => pipe(forEachSequential(quotedIndices, parseQuotedIndex), mapBoth({
  onFailure: () => empty$j(),
  onSuccess: sort(Order$1)
}), either$1, map$2(merge$3));
const QUOTED_INDEX_REGEX = /^(\[(\d+)\])$/;
const parseQuotedIndex = str => {
  const match = str.match(QUOTED_INDEX_REGEX);
  if (match !== null) {
    const matchedIndex = match[2];
    return pipe(matchedIndex !== undefined && matchedIndex.length > 0 ? some(matchedIndex) : none$4(), flatMap$5(parseInteger));
  }
  return none$4();
};
const parseInteger = str => {
  const parsedIndex = Number.parseInt(str);
  return Number.isNaN(parsedIndex) ? none$4() : some(parsedIndex);
};

/** @internal */
const TypeId$5 = /*#__PURE__*/Symbol.for("effect/Console");
/** @internal */
const consoleTag = /*#__PURE__*/GenericTag("effect/Console");
/** @internal */
const defaultConsole = {
  [TypeId$5]: TypeId$5,
  assert(condition, ...args) {
    return sync(() => {
      console.assert(condition, ...args);
    });
  },
  clear: /*#__PURE__*/sync(() => {
    console.clear();
  }),
  count(label) {
    return sync(() => {
      console.count(label);
    });
  },
  countReset(label) {
    return sync(() => {
      console.countReset(label);
    });
  },
  debug(...args) {
    return sync(() => {
      console.debug(...args);
    });
  },
  dir(item, options) {
    return sync(() => {
      console.dir(item, options);
    });
  },
  dirxml(...args) {
    return sync(() => {
      console.dirxml(...args);
    });
  },
  error(...args) {
    return sync(() => {
      console.error(...args);
    });
  },
  group(options) {
    return options?.collapsed ? sync(() => console.groupCollapsed(options?.label)) : sync(() => console.group(options?.label));
  },
  groupEnd: /*#__PURE__*/sync(() => {
    console.groupEnd();
  }),
  info(...args) {
    return sync(() => {
      console.info(...args);
    });
  },
  log(...args) {
    return sync(() => {
      console.log(...args);
    });
  },
  table(tabularData, properties) {
    return sync(() => {
      console.table(tabularData, properties);
    });
  },
  time(label) {
    return sync(() => console.time(label));
  },
  timeEnd(label) {
    return sync(() => console.timeEnd(label));
  },
  timeLog(label, ...args) {
    return sync(() => {
      console.timeLog(label, ...args);
    });
  },
  trace(...args) {
    return sync(() => {
      console.trace(...args);
    });
  },
  warn(...args) {
    return sync(() => {
      console.warn(...args);
    });
  },
  unsafe: console
};

/** @internal */
const RandomSymbolKey = "effect/Random";
/** @internal */
const RandomTypeId = /*#__PURE__*/Symbol.for(RandomSymbolKey);
/** @internal */
const randomTag = /*#__PURE__*/GenericTag("effect/Random");
/** @internal */
class RandomImpl {
  seed;
  [RandomTypeId] = RandomTypeId;
  PRNG;
  constructor(seed) {
    this.seed = seed;
    this.PRNG = new PCGRandom(seed);
  }
  get next() {
    return sync(() => this.PRNG.number());
  }
  get nextBoolean() {
    return map$2(this.next, n => n > 0.5);
  }
  get nextInt() {
    return sync(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER));
  }
  nextRange(min, max) {
    return map$2(this.next, n => (max - min) * n + min);
  }
  nextIntBetween(min, max) {
    return sync(() => this.PRNG.integer(max - min) + min);
  }
  shuffle(elements) {
    return shuffleWith(elements, n => this.nextIntBetween(0, n));
  }
}
const shuffleWith = (elements, nextIntBounded) => {
  return suspend$2(() => pipe(sync(() => Array.from(elements)), flatMap$3(buffer => {
    const numbers = [];
    for (let i = buffer.length; i >= 2; i = i - 1) {
      numbers.push(i);
    }
    return pipe(numbers, forEachSequentialDiscard(n => pipe(nextIntBounded(n), map$2(k => swap(buffer, n - 1, k)))), as(fromIterable$5(buffer)));
  })));
};
const swap = (buffer, index1, index2) => {
  const tmp = buffer[index1];
  buffer[index1] = buffer[index2];
  buffer[index2] = tmp;
  return buffer;
};
const make$b = seed => new RandomImpl(hash(seed));

/**
 * @since 2.0.0
 */
/** @internal */
const TracerTypeId = /*#__PURE__*/Symbol.for("effect/Tracer");
/** @internal */
const make$a = options => ({
  [TracerTypeId]: TracerTypeId,
  ...options
});
/** @internal */
const tracerTag = /*#__PURE__*/GenericTag("effect/Tracer");
/** @internal */
const spanTag = /*#__PURE__*/GenericTag("effect/ParentSpan");
const randomHexString = /*#__PURE__*/function () {
  const characters = "abcdef0123456789";
  const charactersLength = characters.length;
  return function (length) {
    let result = "";
    for (let i = 0; i < length; i++) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
  };
}();
/** @internal */
class NativeSpan {
  name;
  parent;
  context;
  links;
  startTime;
  kind;
  _tag = "Span";
  spanId;
  traceId = "native";
  sampled = true;
  status;
  attributes;
  events = [];
  constructor(name, parent, context, links, startTime, kind) {
    this.name = name;
    this.parent = parent;
    this.context = context;
    this.links = links;
    this.startTime = startTime;
    this.kind = kind;
    this.status = {
      _tag: "Started",
      startTime
    };
    this.attributes = new Map();
    this.traceId = parent._tag === "Some" ? parent.value.traceId : randomHexString(32);
    this.spanId = randomHexString(16);
  }
  end(endTime, exit) {
    this.status = {
      _tag: "Ended",
      endTime,
      exit,
      startTime: this.status.startTime
    };
  }
  attribute(key, value) {
    this.attributes.set(key, value);
  }
  event(name, startTime, attributes) {
    this.events.push([name, startTime, attributes ?? {}]);
  }
}
/** @internal */
const nativeTracer = /*#__PURE__*/make$a({
  span: (name, parent, context, links, startTime, kind) => new NativeSpan(name, parent, context, links, startTime, kind),
  context: f => f()
});

/** @internal */
const liveServices = /*#__PURE__*/pipe( /*#__PURE__*/empty$c(), /*#__PURE__*/add(clockTag, /*#__PURE__*/make$d()), /*#__PURE__*/add(consoleTag, defaultConsole), /*#__PURE__*/add(randomTag, /*#__PURE__*/make$b( /*#__PURE__*/Math.random())), /*#__PURE__*/add(configProviderTag, /*#__PURE__*/fromEnv()), /*#__PURE__*/add(tracerTag, nativeTracer));
/**
 * The `FiberRef` holding the default `Effect` services.
 *
 * @since 2.0.0
 * @category fiberRefs
 */
const currentServices = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for("effect/DefaultServices/currentServices"), () => fiberRefUnsafeMakeContext(liveServices));
/** @internal */
const defaultServicesWith = f => withFiberRuntime(fiber => f(fiber.currentDefaultServices));
/** @internal */
const configProviderWith = f => defaultServicesWith(services => f(services.unsafeMap.get(configProviderTag.key)));
/** @internal */
const config$1 = config => configProviderWith(_ => _.load(config));

/**
 * This module provides utility functions and type class instances for working with the `boolean` type in TypeScript.
 * It includes functions for basic boolean operations, as well as type class instances for
 * `Equivalence` and `Order`.
 *
 * @since 2.0.0
 */
/**
 * Negates the given boolean: `!self`
 *
 * @example
 * ```ts
 * import { not } from "effect/Boolean"
 *
 * assert.deepStrictEqual(not(true), false)
 * assert.deepStrictEqual(not(false), true)
 * ```
 *
 * @category combinators
 * @since 2.0.0
 */
const not = self => !self;

/**
 * @since 2.0.0
 * @category prototypes
 */
const EffectPrototype = EffectPrototype$1;
/**
 * @since 2.0.0
 * @category prototypes
 */
const CommitPrototype = CommitPrototype$1;
const Base = Base$1;
/**
 * @since 2.0.0
 * @category constructors
 */
class Class extends Base {}

/** @internal */
const OP_SEQUENTIAL = "Sequential";
/** @internal */
const OP_PARALLEL = "Parallel";
/** @internal */
const OP_PARALLEL_N = "ParallelN";
/** @internal */
const sequential$1 = {
  _tag: OP_SEQUENTIAL
};
/** @internal */
const parallel$1 = {
  _tag: OP_PARALLEL
};
/** @internal */
const parallelN$1 = parallelism => ({
  _tag: OP_PARALLEL_N,
  parallelism
});

/**
 * Execute effects sequentially.
 *
 * @since 2.0.0
 * @category constructors
 */
const sequential = sequential$1;
/**
 * Execute effects in parallel.
 *
 * @since 2.0.0
 * @category constructors
 */
const parallel = parallel$1;
/**
 * Execute effects in parallel, up to the specified number of concurrent fibers.
 *
 * @since 2.0.0
 * @category constructors
 */
const parallelN = parallelN$1;

/** @internal */
function unsafeMake$2(fiberRefLocals) {
  return new FiberRefsImpl(fiberRefLocals);
}
/** @internal */
function empty$4() {
  return unsafeMake$2(new Map());
}
/** @internal */
const FiberRefsSym = /*#__PURE__*/Symbol.for("effect/FiberRefs");
/** @internal */
class FiberRefsImpl {
  locals;
  [FiberRefsSym] = FiberRefsSym;
  constructor(locals) {
    this.locals = locals;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
/** @internal */
const findAncestor = (_ref, _parentStack, _childStack, _childModified = false) => {
  const ref = _ref;
  let parentStack = _parentStack;
  let childStack = _childStack;
  let childModified = _childModified;
  let ret = undefined;
  while (ret === undefined) {
    if (isNonEmptyReadonlyArray(parentStack) && isNonEmptyReadonlyArray(childStack)) {
      const parentFiberId = headNonEmpty$1(parentStack)[0];
      const parentAncestors = tailNonEmpty$1(parentStack);
      const childFiberId = headNonEmpty$1(childStack)[0];
      const childRefValue = headNonEmpty$1(childStack)[1];
      const childAncestors = tailNonEmpty$1(childStack);
      if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {
        childStack = childAncestors;
        childModified = true;
      } else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) {
        parentStack = parentAncestors;
      } else {
        if (parentFiberId.id < childFiberId.id) {
          childStack = childAncestors;
          childModified = true;
        } else if (parentFiberId.id > childFiberId.id) {
          parentStack = parentAncestors;
        } else {
          ret = [childRefValue, childModified];
        }
      }
    } else {
      ret = [ref.initial, true];
    }
  }
  return ret;
};
/** @internal */
const joinAs = /*#__PURE__*/dual(3, (self, fiberId, that) => {
  const parentFiberRefs = new Map(self.locals);
  that.locals.forEach((childStack, fiberRef) => {
    const childValue = childStack[0][1];
    if (!childStack[0][0][symbol](fiberId)) {
      if (!parentFiberRefs.has(fiberRef)) {
        if (equals$2(childValue, fiberRef.initial)) {
          return;
        }
        parentFiberRefs.set(fiberRef, [[fiberId, fiberRef.join(fiberRef.initial, childValue)]]);
        return;
      }
      const parentStack = parentFiberRefs.get(fiberRef);
      const [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack);
      if (wasModified) {
        const patch = fiberRef.diff(ancestor, childValue);
        const oldValue = parentStack[0][1];
        const newValue = fiberRef.join(oldValue, fiberRef.patch(patch)(oldValue));
        if (!equals$2(oldValue, newValue)) {
          let newStack;
          const parentFiberId = parentStack[0][0];
          if (parentFiberId[symbol](fiberId)) {
            newStack = [[parentFiberId, newValue], ...parentStack.slice(1)];
          } else {
            newStack = [[fiberId, newValue], ...parentStack];
          }
          parentFiberRefs.set(fiberRef, newStack);
        }
      }
    }
  });
  return new FiberRefsImpl(parentFiberRefs);
});
/** @internal */
const forkAs = /*#__PURE__*/dual(2, (self, childId) => {
  const map = new Map();
  unsafeForkAs(self, map, childId);
  return new FiberRefsImpl(map);
});
const unsafeForkAs = (self, map, fiberId) => {
  self.locals.forEach((stack, fiberRef) => {
    const oldValue = stack[0][1];
    const newValue = fiberRef.patch(fiberRef.fork)(oldValue);
    if (equals$2(oldValue, newValue)) {
      map.set(fiberRef, stack);
    } else {
      map.set(fiberRef, [[fiberId, newValue], ...stack]);
    }
  });
};
/** @internal */
const delete_ = /*#__PURE__*/dual(2, (self, fiberRef) => {
  const locals = new Map(self.locals);
  locals.delete(fiberRef);
  return new FiberRefsImpl(locals);
});
/** @internal */
const get$4 = /*#__PURE__*/dual(2, (self, fiberRef) => {
  if (!self.locals.has(fiberRef)) {
    return none$4();
  }
  return some(headNonEmpty$1(self.locals.get(fiberRef))[1]);
});
/** @internal */
const getOrDefault$1 = /*#__PURE__*/dual(2, (self, fiberRef) => pipe(get$4(self, fiberRef), getOrElse(() => fiberRef.initial)));
/** @internal */
const updateAs = /*#__PURE__*/dual(2, (self, {
  fiberId,
  fiberRef,
  value
}) => {
  if (self.locals.size === 0) {
    return new FiberRefsImpl(new Map([[fiberRef, [[fiberId, value]]]]));
  }
  const locals = new Map(self.locals);
  unsafeUpdateAs(locals, fiberId, fiberRef, value);
  return new FiberRefsImpl(locals);
});
const unsafeUpdateAs = (locals, fiberId, fiberRef, value) => {
  const oldStack = locals.get(fiberRef) ?? [];
  let newStack;
  if (isNonEmptyReadonlyArray(oldStack)) {
    const [currentId, currentValue] = headNonEmpty$1(oldStack);
    if (currentId[symbol](fiberId)) {
      if (equals$2(currentValue, value)) {
        return;
      } else {
        newStack = [[fiberId, value], ...oldStack.slice(1)];
      }
    } else {
      newStack = [[fiberId, value], ...oldStack];
    }
  } else {
    newStack = [[fiberId, value]];
  }
  locals.set(fiberRef, newStack);
};
/** @internal */
const updateManyAs$1 = /*#__PURE__*/dual(2, (self, {
  entries,
  forkAs
}) => {
  if (self.locals.size === 0) {
    return new FiberRefsImpl(new Map(entries));
  }
  const locals = new Map(self.locals);
  if (forkAs !== undefined) {
    unsafeForkAs(self, locals, forkAs);
  }
  entries.forEach(([fiberRef, values]) => {
    if (values.length === 1) {
      unsafeUpdateAs(locals, values[0][0], fiberRef, values[0][1]);
    } else {
      values.forEach(([fiberId, value]) => {
        unsafeUpdateAs(locals, fiberId, fiberRef, value);
      });
    }
  });
  return new FiberRefsImpl(locals);
});

/**
 * Gets the value of the specified `FiberRef` in this collection of `FiberRef`
 * values if it exists or the `initial` value of the `FiberRef` otherwise.
 *
 * @since 2.0.0
 * @category getters
 */
const getOrDefault = getOrDefault$1;
/**
 * Updates the values of the specified `FiberRef` & value pairs using the provided `FiberId`
 *
 * @since 2.0.0
 * @category utils
 */
const updateManyAs = updateManyAs$1;
/**
 * The empty collection of `FiberRef` values.
 *
 * @category constructors
 * @since 2.0.0
 */
const empty$3 = empty$4;

/** @internal */
const OP_EMPTY$1 = "Empty";
/** @internal */
const OP_ADD = "Add";
/** @internal */
const OP_REMOVE = "Remove";
/** @internal */
const OP_UPDATE = "Update";
/** @internal */
const OP_AND_THEN$1 = "AndThen";
/** @internal */
const empty$2 = {
  _tag: OP_EMPTY$1
};
/** @internal */
const diff$2 = (oldValue, newValue) => {
  const missingLocals = new Map(oldValue.locals);
  let patch = empty$2;
  for (const [fiberRef, pairs] of newValue.locals.entries()) {
    const newValue = headNonEmpty$1(pairs)[1];
    const old = missingLocals.get(fiberRef);
    if (old !== undefined) {
      const oldValue = headNonEmpty$1(old)[1];
      if (!equals$2(oldValue, newValue)) {
        patch = combine$1({
          _tag: OP_UPDATE,
          fiberRef,
          patch: fiberRef.diff(oldValue, newValue)
        })(patch);
      }
    } else {
      patch = combine$1({
        _tag: OP_ADD,
        fiberRef,
        value: newValue
      })(patch);
    }
    missingLocals.delete(fiberRef);
  }
  for (const [fiberRef] of missingLocals.entries()) {
    patch = combine$1({
      _tag: OP_REMOVE,
      fiberRef
    })(patch);
  }
  return patch;
};
/** @internal */
const combine$1 = /*#__PURE__*/dual(2, (self, that) => ({
  _tag: OP_AND_THEN$1,
  first: self,
  second: that
}));
/** @internal */
const patch$2 = /*#__PURE__*/dual(3, (self, fiberId, oldValue) => {
  let fiberRefs = oldValue;
  let patches = of$2(self);
  while (isNonEmptyReadonlyArray(patches)) {
    const head = headNonEmpty$1(patches);
    const tail = tailNonEmpty$1(patches);
    switch (head._tag) {
      case OP_EMPTY$1:
        {
          patches = tail;
          break;
        }
      case OP_ADD:
        {
          fiberRefs = updateAs(fiberRefs, {
            fiberId,
            fiberRef: head.fiberRef,
            value: head.value
          });
          patches = tail;
          break;
        }
      case OP_REMOVE:
        {
          fiberRefs = delete_(fiberRefs, head.fiberRef);
          patches = tail;
          break;
        }
      case OP_UPDATE:
        {
          const value = getOrDefault$1(fiberRefs, head.fiberRef);
          fiberRefs = updateAs(fiberRefs, {
            fiberId,
            fiberRef: head.fiberRef,
            value: head.fiberRef.patch(head.patch)(value)
          });
          patches = tail;
          break;
        }
      case OP_AND_THEN$1:
        {
          patches = prepend$2(head.first)(prepend$2(head.second)(tail));
          break;
        }
    }
  }
  return fiberRefs;
});

/**
 * Constructs a patch that describes the changes between the specified
 * collections of `FiberRef`
 *
 * @since 2.0.0
 * @category constructors
 */
const diff$1 = diff$2;
/**
 * Applies the changes described by this patch to the specified collection
 * of `FiberRef` values.
 *
 * @since 2.0.0
 * @category destructors
 */
const patch$1 = patch$2;

const FiberStatusSymbolKey = "effect/FiberStatus";
/** @internal */
const FiberStatusTypeId = /*#__PURE__*/Symbol.for(FiberStatusSymbolKey);
/** @internal */
const OP_DONE = "Done";
/** @internal */
const OP_RUNNING = "Running";
/** @internal */
const OP_SUSPENDED = "Suspended";
const DoneHash = /*#__PURE__*/string(`${FiberStatusSymbolKey}-${OP_DONE}`);
/** @internal */
class Done {
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_DONE;
  [symbol$1]() {
    return DoneHash;
  }
  [symbol](that) {
    return isFiberStatus(that) && that._tag === OP_DONE;
  }
}
/** @internal */
class Running {
  runtimeFlags;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_RUNNING;
  constructor(runtimeFlags) {
    this.runtimeFlags = runtimeFlags;
  }
  [symbol$1]() {
    return pipe(hash(FiberStatusSymbolKey), combine$5(hash(this._tag)), combine$5(hash(this.runtimeFlags)), cached(this));
  }
  [symbol](that) {
    return isFiberStatus(that) && that._tag === OP_RUNNING && this.runtimeFlags === that.runtimeFlags;
  }
}
/** @internal */
class Suspended {
  runtimeFlags;
  blockingOn;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_SUSPENDED;
  constructor(runtimeFlags, blockingOn) {
    this.runtimeFlags = runtimeFlags;
    this.blockingOn = blockingOn;
  }
  [symbol$1]() {
    return pipe(hash(FiberStatusSymbolKey), combine$5(hash(this._tag)), combine$5(hash(this.runtimeFlags)), combine$5(hash(this.blockingOn)), cached(this));
  }
  [symbol](that) {
    return isFiberStatus(that) && that._tag === OP_SUSPENDED && this.runtimeFlags === that.runtimeFlags && equals$2(this.blockingOn, that.blockingOn);
  }
}
/** @internal */
const done$1 = /*#__PURE__*/new Done();
/** @internal */
const running$1 = runtimeFlags => new Running(runtimeFlags);
/** @internal */
const suspended$1 = (runtimeFlags, blockingOn) => new Suspended(runtimeFlags, blockingOn);
/** @internal */
const isFiberStatus = u => hasProperty(u, FiberStatusTypeId);
/** @internal */
const isDone$1 = self => self._tag === OP_DONE;

/**
 * @since 2.0.0
 * @category constructors
 */
const done = done$1;
/**
 * @since 2.0.0
 * @category constructors
 */
const running = running$1;
/**
 * @since 2.0.0
 * @category constructors
 */
const suspended = suspended$1;
/**
 * Returns `true` if the specified `FiberStatus` is `Done`, `false` otherwise.
 *
 * @since 2.0.0
 * @category refinements
 */
const isDone = isDone$1;

/**
 * @since 2.0.0
 * @category constructors
 */
const All = logLevelAll;
/**
 * @since 2.0.0
 * @category constructors
 */
const Fatal = logLevelFatal;
/**
 * @since 2.0.0
 * @category constructors
 */
const Error$2 = logLevelError;
/**
 * @since 2.0.0
 * @category constructors
 */
const Warning = logLevelWarning;
/**
 * @since 2.0.0
 * @category constructors
 */
const Info = logLevelInfo;
/**
 * @since 2.0.0
 * @category constructors
 */
const Debug = logLevelDebug;
/**
 * @since 2.0.0
 * @category constructors
 */
const Trace = logLevelTrace;
/**
 * @since 2.0.0
 * @category constructors
 */
const None = logLevelNone;
/**
 * @since 2.0.0
 * @category instances
 */
const Order = /*#__PURE__*/pipe(Order$1, /*#__PURE__*/mapInput(level => level.ordinal));
/**
 * @since 2.0.0
 * @category ordering
 */
const greaterThan$1 = /*#__PURE__*/greaterThan$2(Order);
/**
 * @since 2.0.0
 * @category conversions
 */
const fromLiteral = literal => {
  switch (literal) {
    case "All":
      return All;
    case "Debug":
      return Debug;
    case "Error":
      return Error$2;
    case "Fatal":
      return Fatal;
    case "Info":
      return Info;
    case "Trace":
      return Trace;
    case "None":
      return None;
    case "Warning":
      return Warning;
  }
};

/**
 * A lightweight alternative to the `Effect` data type, with a subset of the functionality.
 *
 * @since 3.4.0
 * @experimental
 */
/**
 * @since 3.4.0
 * @experimental
 * @category type ids
 */
const TypeId$4 = /*#__PURE__*/Symbol.for("effect/Micro");
/**
 * @since 3.4.0
 * @experimental
 * @category MicroExit
 */
const MicroExitTypeId = /*#__PURE__*/Symbol.for("effect/Micro/MicroExit");
// ----------------------------------------------------------------------------
// MicroCause
// ----------------------------------------------------------------------------
/**
 * @since 3.4.6
 * @experimental
 * @category MicroCause
 */
const MicroCauseTypeId = /*#__PURE__*/Symbol.for("effect/Micro/MicroCause");
const microCauseVariance = {
  _E: identity
};
class MicroCauseImpl extends globalThis.Error {
  _tag;
  traces;
  [MicroCauseTypeId];
  constructor(_tag, originalError, traces) {
    const causeName = `MicroCause.${_tag}`;
    let name;
    let message;
    let stack;
    if (originalError instanceof globalThis.Error) {
      name = `(${causeName}) ${originalError.name}`;
      message = originalError.message;
      const messageLines = message.split("\n").length;
      stack = originalError.stack ? `(${causeName}) ${originalError.stack.split("\n").slice(0, messageLines + 3).join("\n")}` : `${name}: ${message}`;
    } else {
      name = causeName;
      message = toStringUnknown(originalError, 0);
      stack = `${name}: ${message}`;
    }
    if (traces.length > 0) {
      stack += `\n    ${traces.join("\n    ")}`;
    }
    super(message);
    this._tag = _tag;
    this.traces = traces;
    this[MicroCauseTypeId] = microCauseVariance;
    this.name = name;
    this.stack = stack;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toString() {
    return this.stack;
  }
  [NodeInspectSymbol]() {
    return this.stack;
  }
}
class Die extends MicroCauseImpl {
  defect;
  constructor(defect, traces = []) {
    super("Die", defect, traces);
    this.defect = defect;
  }
}
/**
 * @since 3.4.6
 * @experimental
 * @category MicroCause
 */
const causeDie = (defect, traces = []) => new Die(defect, traces);
class Interrupt extends MicroCauseImpl {
  constructor(traces = []) {
    super("Interrupt", "interrupted", traces);
  }
}
/**
 * @since 3.4.6
 * @experimental
 * @category MicroCause
 */
const causeInterrupt = (traces = []) => new Interrupt(traces);
/**
 * @since 3.4.6
 * @experimental
 * @category MicroCause
 */
const causeIsInterrupt = self => self._tag === "Interrupt";
// ----------------------------------------------------------------------------
// MicroFiber
// ----------------------------------------------------------------------------
/**
 * @since 3.11.0
 * @experimental
 * @category MicroFiber
 */
const MicroFiberTypeId = /*#__PURE__*/Symbol.for("effect/Micro/MicroFiber");
const fiberVariance$1 = {
  _A: identity,
  _E: identity
};
class MicroFiberImpl {
  context;
  interruptible;
  [MicroFiberTypeId];
  _stack = [];
  _observers = [];
  _exit;
  _children;
  currentOpCount = 0;
  constructor(context, interruptible = true) {
    this.context = context;
    this.interruptible = interruptible;
    this[MicroFiberTypeId] = fiberVariance$1;
  }
  getRef(ref) {
    return unsafeGetReference(this.context, ref);
  }
  addObserver(cb) {
    if (this._exit) {
      cb(this._exit);
      return constVoid;
    }
    this._observers.push(cb);
    return () => {
      const index = this._observers.indexOf(cb);
      if (index >= 0) {
        this._observers.splice(index, 1);
      }
    };
  }
  _interrupted = false;
  unsafeInterrupt() {
    if (this._exit) {
      return;
    }
    this._interrupted = true;
    if (this.interruptible) {
      this.evaluate(exitInterrupt);
    }
  }
  unsafePoll() {
    return this._exit;
  }
  evaluate(effect) {
    if (this._exit) {
      return;
    } else if (this._yielded !== undefined) {
      const yielded = this._yielded;
      this._yielded = undefined;
      yielded();
    }
    const exit = this.runLoop(effect);
    if (exit === Yield) {
      return;
    }
    // the interruptChildren middlware is added in Micro.fork, so it can be
    // tree-shaken if not used
    const interruptChildren = fiberMiddleware.interruptChildren && fiberMiddleware.interruptChildren(this);
    if (interruptChildren !== undefined) {
      return this.evaluate(flatMap$2(interruptChildren, () => exit));
    }
    this._exit = exit;
    for (let i = 0; i < this._observers.length; i++) {
      this._observers[i](exit);
    }
    this._observers.length = 0;
  }
  runLoop(effect) {
    let yielding = false;
    let current = effect;
    this.currentOpCount = 0;
    try {
      while (true) {
        this.currentOpCount++;
        if (!yielding && this.getRef(CurrentScheduler).shouldYield(this)) {
          yielding = true;
          const prev = current;
          current = flatMap$2(yieldNow$1, () => prev);
        }
        current = current[evaluate](this);
        if (current === Yield) {
          const yielded = this._yielded;
          if (MicroExitTypeId in yielded) {
            this._yielded = undefined;
            return yielded;
          }
          return Yield;
        }
      }
    } catch (error) {
      if (!hasProperty(current, evaluate)) {
        return exitDie(`MicroFiber.runLoop: Not a valid effect: ${String(current)}`);
      }
      return exitDie(error);
    }
  }
  getCont(symbol) {
    while (true) {
      const op = this._stack.pop();
      if (!op) return undefined;
      const cont = op[ensureCont] && op[ensureCont](this);
      if (cont) return {
        [symbol]: cont
      };
      if (op[symbol]) return op;
    }
  }
  // cancel the yielded operation, or for the yielded exit value
  _yielded = undefined;
  yieldWith(value) {
    this._yielded = value;
    return Yield;
  }
  children() {
    return this._children ??= new Set();
  }
}
const fiberMiddleware = /*#__PURE__*/globalValue("effect/Micro/fiberMiddleware", () => ({
  interruptChildren: undefined
}));
const identifier = /*#__PURE__*/Symbol.for("effect/Micro/identifier");
const args = /*#__PURE__*/Symbol.for("effect/Micro/args");
const evaluate = /*#__PURE__*/Symbol.for("effect/Micro/evaluate");
const successCont = /*#__PURE__*/Symbol.for("effect/Micro/successCont");
const failureCont = /*#__PURE__*/Symbol.for("effect/Micro/failureCont");
const ensureCont = /*#__PURE__*/Symbol.for("effect/Micro/ensureCont");
const Yield = /*#__PURE__*/Symbol.for("effect/Micro/Yield");
const microVariance = {
  _A: identity,
  _E: identity,
  _R: identity
};
const MicroProto = {
  ...EffectPrototype,
  _op: "Micro",
  [TypeId$4]: microVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  [Symbol.iterator]() {
    return new SingleShotGen$1(new YieldWrap(this));
  },
  toJSON() {
    return {
      _id: "Micro",
      op: this[identifier],
      ...(args in this ? {
        args: this[args]
      } : undefined)
    };
  },
  toString() {
    return format$4(this);
  },
  [NodeInspectSymbol]() {
    return format$4(this);
  }
};
function defaultEvaluate(_fiber) {
  return exitDie(`Micro.evaluate: Not implemented`);
}
const makePrimitiveProto = options => ({
  ...MicroProto,
  [identifier]: options.op,
  [evaluate]: options.eval ?? defaultEvaluate,
  [successCont]: options.contA,
  [failureCont]: options.contE,
  [ensureCont]: options.ensure
});
const makePrimitive = options => {
  const Proto = makePrimitiveProto(options);
  return function () {
    const self = Object.create(Proto);
    self[args] = options.single === false ? arguments : arguments[0];
    return self;
  };
};
const makeExit = options => {
  const Proto = {
    ...makePrimitiveProto(options),
    [MicroExitTypeId]: MicroExitTypeId,
    _tag: options.op,
    get [options.prop]() {
      return this[args];
    },
    toJSON() {
      return {
        _id: "MicroExit",
        _tag: options.op,
        [options.prop]: this[args]
      };
    },
    [symbol](that) {
      return isMicroExit(that) && that._tag === options.op && equals$2(this[args], that[args]);
    },
    [symbol$1]() {
      return cached(this, combine$5(string(options.op))(hash(this[args])));
    }
  };
  return function (value) {
    const self = Object.create(Proto);
    self[args] = value;
    self[successCont] = undefined;
    self[failureCont] = undefined;
    self[ensureCont] = undefined;
    return self;
  };
};
/**
 * Creates a `Micro` effect that will succeed with the specified constant value.
 *
 * @since 3.4.0
 * @experimental
 * @category constructors
 */
const succeed$2 = /*#__PURE__*/makeExit({
  op: "Success",
  prop: "value",
  eval(fiber) {
    const cont = fiber.getCont(successCont);
    return cont ? cont[successCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
/**
 * Creates a `Micro` effect that will fail with the specified `MicroCause`.
 *
 * @since 3.4.6
 * @experimental
 * @category constructors
 */
const failCause = /*#__PURE__*/makeExit({
  op: "Failure",
  prop: "cause",
  eval(fiber) {
    let cont = fiber.getCont(failureCont);
    while (causeIsInterrupt(this[args]) && cont && fiber.interruptible) {
      cont = fiber.getCont(failureCont);
    }
    return cont ? cont[failureCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
/**
 * Pause the execution of the current `Micro` effect, and resume it on the next
 * scheduler tick.
 *
 * @since 3.4.0
 * @experimental
 * @category constructors
 */
const yieldNowWith = /*#__PURE__*/makePrimitive({
  op: "Yield",
  eval(fiber) {
    let resumed = false;
    fiber.getRef(CurrentScheduler).scheduleTask(() => {
      if (resumed) return;
      fiber.evaluate(exitVoid);
    }, this[args] ?? 0);
    return fiber.yieldWith(() => {
      resumed = true;
    });
  }
});
/**
 * Pause the execution of the current `Micro` effect, and resume it on the next
 * scheduler tick.
 *
 * @since 3.4.0
 * @experimental
 * @category constructors
 */
const yieldNow$1 = /*#__PURE__*/yieldNowWith(0);
const void_ = /*#__PURE__*/succeed$2(undefined);
/**
 * Create a `Micro` effect using the current `MicroFiber`.
 *
 * @since 3.4.0
 * @experimental
 * @category constructors
 */
const withMicroFiber = /*#__PURE__*/makePrimitive({
  op: "WithMicroFiber",
  eval(fiber) {
    return this[args](fiber);
  }
});
/**
 * Map the success value of this `Micro` effect to another `Micro` effect, then
 * flatten the result.
 *
 * @since 3.4.0
 * @experimental
 * @category mapping & sequencing
 */
const flatMap$2 = /*#__PURE__*/dual(2, (self, f) => {
  const onSuccess = Object.create(OnSuccessProto);
  onSuccess[args] = self;
  onSuccess[successCont] = f;
  return onSuccess;
});
const OnSuccessProto = /*#__PURE__*/makePrimitiveProto({
  op: "OnSuccess",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
/**
 * @since 3.4.6
 * @experimental
 * @category MicroExit
 */
const isMicroExit = u => hasProperty(u, MicroExitTypeId);
/**
 * @since 3.4.6
 * @experimental
 * @category MicroExit
 */
const exitSucceed = succeed$2;
/**
 * @since 3.4.6
 * @experimental
 * @category MicroExit
 */
const exitFailCause = failCause;
/**
 * @since 3.4.6
 * @experimental
 * @category MicroExit
 */
const exitInterrupt = /*#__PURE__*/exitFailCause( /*#__PURE__*/causeInterrupt());
/**
 * @since 3.4.6
 * @experimental
 * @category MicroExit
 */
const exitDie = defect => exitFailCause(causeDie(defect));
/**
 * @since 3.4.6
 * @experimental
 * @category MicroExit
 */
const exitVoid = /*#__PURE__*/exitSucceed(undefined);
const setImmediate$1 = "setImmediate" in globalThis ? globalThis.setImmediate : f => setTimeout(f, 0);
/**
 * @since 3.5.9
 * @experimental
 * @category scheduler
 */
class MicroSchedulerDefault {
  tasks = [];
  running = false;
  /**
   * @since 3.5.9
   */
  scheduleTask(task, _priority) {
    this.tasks.push(task);
    if (!this.running) {
      this.running = true;
      setImmediate$1(this.afterScheduled);
    }
  }
  /**
   * @since 3.5.9
   */
  afterScheduled = () => {
    this.running = false;
    this.runTasks();
  };
  /**
   * @since 3.5.9
   */
  runTasks() {
    const tasks = this.tasks;
    this.tasks = [];
    for (let i = 0, len = tasks.length; i < len; i++) {
      tasks[i]();
    }
  }
  /**
   * @since 3.5.9
   */
  shouldYield(fiber) {
    return fiber.currentOpCount >= fiber.getRef(MaxOpsBeforeYield);
  }
  /**
   * @since 3.5.9
   */
  flush() {
    while (this.tasks.length > 0) {
      this.runTasks();
    }
  }
}
/**
 * Update the Context with the given mapping function.
 *
 * @since 3.11.0
 * @experimental
 * @category environment
 */
const updateContext = /*#__PURE__*/dual(2, (self, f) => withMicroFiber(fiber => {
  const prev = fiber.context;
  fiber.context = f(prev);
  return onExit(self, () => {
    fiber.context = prev;
    return void_;
  });
}));
/**
 * Merge the given `Context` with the current context.
 *
 * @since 3.4.0
 * @experimental
 * @category environment
 */
const provideContext = /*#__PURE__*/dual(2, (self, provided) => updateContext(self, merge$1(provided)));
// ========================================================================
// References
// ========================================================================
/**
 * @since 3.11.0
 * @experimental
 * @category references
 */
class MaxOpsBeforeYield extends /*#__PURE__*/Reference()("effect/Micro/currentMaxOpsBeforeYield", {
  defaultValue: () => 2048
}) {}
/**
 * @since 3.11.0
 * @experimental
 * @category environment refs
 */
class CurrentScheduler extends /*#__PURE__*/Reference()("effect/Micro/currentScheduler", {
  defaultValue: () => new MicroSchedulerDefault()
}) {}
// ----------------------------------------------------------------------------
// pattern matching
// ----------------------------------------------------------------------------
/**
 * @since 3.4.6
 * @experimental
 * @category pattern matching
 */
const matchCauseEffect = /*#__PURE__*/dual(2, (self, options) => {
  const primitive = Object.create(OnSuccessAndFailureProto);
  primitive[args] = self;
  primitive[successCont] = options.onSuccess;
  primitive[failureCont] = options.onFailure;
  return primitive;
});
const OnSuccessAndFailureProto = /*#__PURE__*/makePrimitiveProto({
  op: "OnSuccessAndFailure",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
/**
 * When the `Micro` effect is completed, run the given finalizer effect with the
 * `MicroExit` of the executed effect.
 *
 * @since 3.4.6
 * @experimental
 * @category resources & finalization
 */
const onExit = /*#__PURE__*/dual(2, (self, f) => uninterruptibleMask(restore => matchCauseEffect(restore(self), {
  onFailure: cause => flatMap$2(f(exitFailCause(cause)), () => failCause(cause)),
  onSuccess: a => flatMap$2(f(exitSucceed(a)), () => succeed$2(a))
})));
const setInterruptible = /*#__PURE__*/makePrimitive({
  op: "SetInterruptible",
  ensure(fiber) {
    fiber.interruptible = this[args];
    if (fiber._interrupted && fiber.interruptible) {
      return () => exitInterrupt;
    }
  }
});
/**
 * Flag the effect as interruptible, which means that when the effect is
 * interrupted, it will be interrupted immediately.
 *
 * @since 3.4.0
 * @experimental
 * @category flags
 */
const interruptible = self => withMicroFiber(fiber => {
  if (fiber.interruptible) return self;
  fiber.interruptible = true;
  fiber._stack.push(setInterruptible(false));
  if (fiber._interrupted) return exitInterrupt;
  return self;
});
/**
 * Wrap the given `Micro` effect in an uninterruptible region, preventing the
 * effect from being aborted.
 *
 * You can use the `restore` function to restore a `Micro` effect to the
 * interruptibility state before the `uninterruptibleMask` was applied.
 *
 * @example
 * ```ts
 * import * as Micro from "effect/Micro"
 *
 * Micro.uninterruptibleMask((restore) =>
 *   Micro.sleep(1000).pipe( // uninterruptible
 *     Micro.andThen(restore(Micro.sleep(1000))) // interruptible
 *   )
 * )
 * ```
 *
 * @since 3.4.0
 * @experimental
 * @category interruption
 */
const uninterruptibleMask = f => withMicroFiber(fiber => {
  if (!fiber.interruptible) return f(identity);
  fiber.interruptible = false;
  fiber._stack.push(setInterruptible(true));
  return f(interruptible);
});
// ----------------------------------------------------------------------------
// execution
// ----------------------------------------------------------------------------
/**
 * Execute the `Micro` effect and return a `MicroFiber` that can be awaited, joined,
 * or aborted.
 *
 * You can listen for the result by adding an observer using the handle's
 * `addObserver` method.
 *
 * @example
 * ```ts
 * import * as Micro from "effect/Micro"
 *
 * const handle = Micro.succeed(42).pipe(
 *   Micro.delay(1000),
 *   Micro.runFork
 * )
 *
 * handle.addObserver((exit) => {
 *   console.log(exit)
 * })
 * ```
 *
 * @since 3.4.0
 * @experimental
 * @category execution
 */
const runFork = (effect, options) => {
  const fiber = new MicroFiberImpl(CurrentScheduler.context(new MicroSchedulerDefault()));
  fiber.evaluate(effect);
  return fiber;
};

/** @internal */
const get$3 = self => self.get;

/**
 * @since 2.0.0
 */
/**
 * @since 2.0.0
 * @category utils
 */
class PriorityBuckets {
  /**
   * @since 2.0.0
   */
  buckets = [];
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    const length = this.buckets.length;
    let bucket = undefined;
    let index = 0;
    for (; index < length; index++) {
      if (this.buckets[index][0] <= priority) {
        bucket = this.buckets[index];
      } else {
        break;
      }
    }
    if (bucket && bucket[0] === priority) {
      bucket[1].push(task);
    } else if (index === length) {
      this.buckets.push([priority, [task]]);
    } else {
      this.buckets.splice(index, 0, [priority, [task]]);
    }
  }
}
/**
 * @since 2.0.0
 * @category constructors
 */
class MixedScheduler {
  maxNextTickBeforeTimer;
  /**
   * @since 2.0.0
   */
  running = false;
  /**
   * @since 2.0.0
   */
  tasks = /*#__PURE__*/new PriorityBuckets();
  constructor(
  /**
   * @since 2.0.0
   */
  maxNextTickBeforeTimer) {
    this.maxNextTickBeforeTimer = maxNextTickBeforeTimer;
  }
  /**
   * @since 2.0.0
   */
  starveInternal(depth) {
    const tasks = this.tasks.buckets;
    this.tasks.buckets = [];
    for (const [_, toRun] of tasks) {
      for (let i = 0; i < toRun.length; i++) {
        toRun[i]();
      }
    }
    if (this.tasks.buckets.length === 0) {
      this.running = false;
    } else {
      this.starve(depth);
    }
  }
  /**
   * @since 2.0.0
   */
  starve(depth = 0) {
    if (depth >= this.maxNextTickBeforeTimer) {
      setTimeout(() => this.starveInternal(0), 0);
    } else {
      Promise.resolve(undefined).then(() => this.starveInternal(depth + 1));
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    this.tasks.scheduleTask(task, priority);
    if (!this.running) {
      this.running = true;
      this.starve();
    }
  }
}
/**
 * @since 2.0.0
 * @category schedulers
 */
const defaultScheduler = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for("effect/Scheduler/defaultScheduler"), () => new MixedScheduler(2048));
/**
 * @since 2.0.0
 * @category constructors
 */
class SyncScheduler {
  /**
   * @since 2.0.0
   */
  tasks = /*#__PURE__*/new PriorityBuckets();
  /**
   * @since 2.0.0
   */
  deferred = false;
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    if (this.deferred) {
      defaultScheduler.scheduleTask(task, priority);
    } else {
      this.tasks.scheduleTask(task, priority);
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  /**
   * @since 2.0.0
   */
  flush() {
    while (this.tasks.buckets.length > 0) {
      const tasks = this.tasks.buckets;
      this.tasks.buckets = [];
      for (const [_, toRun] of tasks) {
        for (let i = 0; i < toRun.length; i++) {
          toRun[i]();
        }
      }
    }
    this.deferred = true;
  }
}
/** @internal */
const currentScheduler = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentScheduler"), () => fiberRefUnsafeMake(defaultScheduler));

/** @internal */
const currentRequestMap = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentRequestMap"), () => fiberRefUnsafeMake(new Map()));

/** @internal */
const match = (concurrency, sequential, unbounded, bounded) => {
  switch (concurrency) {
    case undefined:
      return sequential();
    case "unbounded":
      return unbounded();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, concurrency => concurrency === "unbounded" ? unbounded() : concurrency > 1 ? bounded(concurrency) : sequential());
    default:
      return concurrency > 1 ? bounded(concurrency) : sequential();
  }
};

/** @internal */
/**
 * Sanitize a given string by replacing spaces, equal signs, and double quotes with underscores.
 *
 * @internal
 */
const formatLabel = key => key.replace(/[\s="]/g, "_");
/** @internal */
const render = now => self => {
  const label = formatLabel(self.label);
  return `${label}=${now - self.startTime}ms`;
};

/** @internal */
const MetricLabelSymbolKey = "effect/MetricLabel";
/** @internal */
const MetricLabelTypeId = /*#__PURE__*/Symbol.for(MetricLabelSymbolKey);
/** @internal */
class MetricLabelImpl {
  key;
  value;
  [MetricLabelTypeId] = MetricLabelTypeId;
  _hash;
  constructor(key, value) {
    this.key = key;
    this.value = value;
    this._hash = string(MetricLabelSymbolKey + this.key + this.value);
  }
  [symbol$1]() {
    return this._hash;
  }
  [symbol](that) {
    return isMetricLabel(that) && this.key === that.key && this.value === that.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
/** @internal */
const make$9 = (key, value) => {
  return new MetricLabelImpl(key, value);
};
/** @internal */
const isMetricLabel = u => hasProperty(u, MetricLabelTypeId);

/** @internal */
const OP_INTERRUPT_SIGNAL = "InterruptSignal";
/** @internal */
const OP_STATEFUL = "Stateful";
/** @internal */
const OP_RESUME = "Resume";
/** @internal */
const OP_YIELD_NOW = "YieldNow";
/** @internal */
const interruptSignal = cause => ({
  _tag: OP_INTERRUPT_SIGNAL,
  cause
});
/** @internal */
const stateful = onFiber => ({
  _tag: OP_STATEFUL,
  onFiber
});
/** @internal */
const resume = effect => ({
  _tag: OP_RESUME,
  effect
});
/** @internal */
const yieldNow = () => ({
  _tag: OP_YIELD_NOW
});

/** @internal */
const FiberScopeSymbolKey = "effect/FiberScope";
/** @internal */
const FiberScopeTypeId = /*#__PURE__*/Symbol.for(FiberScopeSymbolKey);
/** @internal */
class Global {
  [FiberScopeTypeId] = FiberScopeTypeId;
  fiberId = none$2;
  roots = /*#__PURE__*/new Set();
  add(_runtimeFlags, child) {
    this.roots.add(child);
    child.addObserver(() => {
      this.roots.delete(child);
    });
  }
}
/** @internal */
class Local {
  fiberId;
  parent;
  [FiberScopeTypeId] = FiberScopeTypeId;
  constructor(fiberId, parent) {
    this.fiberId = fiberId;
    this.parent = parent;
  }
  add(_runtimeFlags, child) {
    this.parent.tell(stateful(parentFiber => {
      parentFiber.addChild(child);
      child.addObserver(() => {
        parentFiber.removeChild(child);
      });
    }));
  }
}
/** @internal */
const unsafeMake$1 = fiber => {
  return new Local(fiber.id(), fiber);
};
/** @internal */
const globalScope = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for("effect/FiberScope/Global"), () => new Global());

/** @internal */
const FiberSymbolKey = "effect/Fiber";
/** @internal */
const FiberTypeId = /*#__PURE__*/Symbol.for(FiberSymbolKey);
/** @internal */
const fiberVariance = {
  /* c8 ignore next */
  _E: _ => _,
  /* c8 ignore next */
  _A: _ => _
};
/** @internal */
const fiberProto = {
  [FiberTypeId]: fiberVariance,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
/** @internal */
const RuntimeFiberSymbolKey = "effect/Fiber";
/** @internal */
const RuntimeFiberTypeId = /*#__PURE__*/Symbol.for(RuntimeFiberSymbolKey);
/** @internal */
const join = self => zipLeft(flatten(self.await), self.inheritAll);
/** @internal */
({
  ...CommitPrototype$1,
  commit() {
    return join(this);
  },
  ...fiberProto,
  id: () => none$2,
  await: never,
  children: /*#__PURE__*/succeed$3([]),
  inheritAll: never,
  poll: /*#__PURE__*/succeed$3( /*#__PURE__*/none$4()),
  interruptAsFork: () => never
});
/** @internal */
const currentFiberURI = "effect/FiberCurrent";

/** @internal */
const LoggerSymbolKey = "effect/Logger";
/** @internal */
const LoggerTypeId = /*#__PURE__*/Symbol.for(LoggerSymbolKey);
const loggerVariance = {
  /* c8 ignore next */
  _Message: _ => _,
  /* c8 ignore next */
  _Output: _ => _
};
/** @internal */
const makeLogger = log => ({
  [LoggerTypeId]: loggerVariance,
  log,
  pipe() {
    return pipeArguments(this, arguments);
  }
});
/**
 * Match strings that do not contain any whitespace characters, double quotes,
 * or equal signs.
 *
 * @internal
 */
const textOnly = /^[^\s"=]*$/;
/**
 * Used by both {@link stringLogger} and {@link logfmtLogger} to render a log
 * message.
 *
 * @internal
 */
const format$2 = (quoteValue, whitespace) => ({
  annotations,
  cause,
  date,
  fiberId,
  logLevel,
  message,
  spans
}) => {
  const formatValue = value => value.match(textOnly) ? value : quoteValue(value);
  const format = (label, value) => `${formatLabel(label)}=${formatValue(value)}`;
  const append = (label, value) => " " + format(label, value);
  let out = format("timestamp", date.toISOString());
  out += append("level", logLevel.label);
  out += append("fiber", threadName$1(fiberId));
  const messages = ensure(message);
  for (let i = 0; i < messages.length; i++) {
    out += append("message", toStringUnknown(messages[i], whitespace));
  }
  if (!isEmptyType(cause)) {
    out += append("cause", pretty(cause, {
      renderErrorCause: true
    }));
  }
  for (const span of spans) {
    out += " " + render(date.getTime())(span);
  }
  for (const [label, value] of annotations) {
    out += append(label, toStringUnknown(value, whitespace));
  }
  return out;
};
/** @internal */
const escapeDoubleQuotes = s => `"${s.replace(/\\([\s\S])|(")/g, "\\$1$2")}"`;
/** @internal */
const stringLogger = /*#__PURE__*/makeLogger( /*#__PURE__*/format$2(escapeDoubleQuotes));
const hasProcessStdout = typeof process === "object" && process !== null && typeof process.stdout === "object" && process.stdout !== null;
hasProcessStdout && process.stdout.isTTY === true;

/** @internal */
const MetricBoundariesSymbolKey = "effect/MetricBoundaries";
/** @internal */
const MetricBoundariesTypeId = /*#__PURE__*/Symbol.for(MetricBoundariesSymbolKey);
/** @internal */
class MetricBoundariesImpl {
  values;
  [MetricBoundariesTypeId] = MetricBoundariesTypeId;
  constructor(values) {
    this.values = values;
    this._hash = pipe(string(MetricBoundariesSymbolKey), combine$5(array(this.values)));
  }
  _hash;
  [symbol$1]() {
    return this._hash;
  }
  [symbol](u) {
    return isMetricBoundaries(u) && equals$2(this.values, u.values);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
/** @internal */
const isMetricBoundaries = u => hasProperty(u, MetricBoundariesTypeId);
/** @internal */
const fromIterable = iterable => {
  const values = pipe(iterable, appendAll$2(of$1(Number.POSITIVE_INFINITY)), dedupe);
  return new MetricBoundariesImpl(values);
};
/** @internal */
const exponential = options => pipe(makeBy(options.count - 1, i => options.start * Math.pow(options.factor, i)), unsafeFromArray, fromIterable);

/** @internal */
const MetricKeyTypeSymbolKey = "effect/MetricKeyType";
/** @internal */
const MetricKeyTypeTypeId = /*#__PURE__*/Symbol.for(MetricKeyTypeSymbolKey);
/** @internal */
const CounterKeyTypeSymbolKey = "effect/MetricKeyType/Counter";
/** @internal */
const CounterKeyTypeTypeId = /*#__PURE__*/Symbol.for(CounterKeyTypeSymbolKey);
/** @internal */
const FrequencyKeyTypeSymbolKey = "effect/MetricKeyType/Frequency";
/** @internal */
const FrequencyKeyTypeTypeId = /*#__PURE__*/Symbol.for(FrequencyKeyTypeSymbolKey);
/** @internal */
const GaugeKeyTypeSymbolKey = "effect/MetricKeyType/Gauge";
/** @internal */
const GaugeKeyTypeTypeId = /*#__PURE__*/Symbol.for(GaugeKeyTypeSymbolKey);
/** @internal */
const HistogramKeyTypeSymbolKey = "effect/MetricKeyType/Histogram";
/** @internal */
const HistogramKeyTypeTypeId = /*#__PURE__*/Symbol.for(HistogramKeyTypeSymbolKey);
/** @internal */
const SummaryKeyTypeSymbolKey = "effect/MetricKeyType/Summary";
/** @internal */
const SummaryKeyTypeTypeId = /*#__PURE__*/Symbol.for(SummaryKeyTypeSymbolKey);
const metricKeyTypeVariance = {
  /* c8 ignore next */
  _In: _ => _,
  /* c8 ignore next */
  _Out: _ => _
};
/** @internal */
class CounterKeyType {
  incremental;
  bigint;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [CounterKeyTypeTypeId] = CounterKeyTypeTypeId;
  constructor(incremental, bigint) {
    this.incremental = incremental;
    this.bigint = bigint;
    this._hash = string(CounterKeyTypeSymbolKey);
  }
  _hash;
  [symbol$1]() {
    return this._hash;
  }
  [symbol](that) {
    return isCounterKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
/** @internal */
class HistogramKeyType {
  boundaries;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [HistogramKeyTypeTypeId] = HistogramKeyTypeTypeId;
  constructor(boundaries) {
    this.boundaries = boundaries;
    this._hash = pipe(string(HistogramKeyTypeSymbolKey), combine$5(hash(this.boundaries)));
  }
  _hash;
  [symbol$1]() {
    return this._hash;
  }
  [symbol](that) {
    return isHistogramKey(that) && equals$2(this.boundaries, that.boundaries);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
/** @internal */
const counter$4 = options => new CounterKeyType(options?.incremental ?? false, options?.bigint ?? false);
/** @internal */
const histogram$4 = boundaries => {
  return new HistogramKeyType(boundaries);
};
/** @internal */
const isCounterKey = u => hasProperty(u, CounterKeyTypeTypeId);
/** @internal */
const isFrequencyKey = u => hasProperty(u, FrequencyKeyTypeTypeId);
/** @internal */
const isGaugeKey = u => hasProperty(u, GaugeKeyTypeTypeId);
/** @internal */
const isHistogramKey = u => hasProperty(u, HistogramKeyTypeTypeId);
/** @internal */
const isSummaryKey = u => hasProperty(u, SummaryKeyTypeTypeId);

/** @internal */
const MetricKeySymbolKey = "effect/MetricKey";
/** @internal */
const MetricKeyTypeId = /*#__PURE__*/Symbol.for(MetricKeySymbolKey);
const metricKeyVariance = {
  /* c8 ignore next */
  _Type: _ => _
};
const arrayEquivilence = /*#__PURE__*/getEquivalence$2(equals$2);
/** @internal */
class MetricKeyImpl {
  name;
  keyType;
  description;
  tags;
  [MetricKeyTypeId] = metricKeyVariance;
  constructor(name, keyType, description, tags = []) {
    this.name = name;
    this.keyType = keyType;
    this.description = description;
    this.tags = tags;
    this._hash = pipe(string(this.name + this.description), combine$5(hash(this.keyType)), combine$5(array(this.tags)));
  }
  _hash;
  [symbol$1]() {
    return this._hash;
  }
  [symbol](u) {
    return isMetricKey(u) && this.name === u.name && equals$2(this.keyType, u.keyType) && equals$2(this.description, u.description) && arrayEquivilence(this.tags, u.tags);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
/** @internal */
const isMetricKey = u => hasProperty(u, MetricKeyTypeId);
/** @internal */
const counter$3 = (name, options) => new MetricKeyImpl(name, counter$4(options), fromNullable(options?.description));
/** @internal */
const histogram$3 = (name, boundaries, description) => new MetricKeyImpl(name, histogram$4(boundaries), fromNullable(description));
/** @internal */
const taggedWithLabels$1 = /*#__PURE__*/dual(2, (self, extraTags) => extraTags.length === 0 ? self : new MetricKeyImpl(self.name, self.keyType, self.description, union$2(self.tags, extraTags)));

const TypeId$3 = /*#__PURE__*/Symbol.for("effect/MutableHashMap");
const MutableHashMapProto = {
  [TypeId$3]: TypeId$3,
  [Symbol.iterator]() {
    return new MutableHashMapIterator(this);
  },
  toString() {
    return format$4(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableHashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
class MutableHashMapIterator {
  self;
  referentialIterator;
  bucketIterator;
  constructor(self) {
    this.self = self;
    this.referentialIterator = self.referential[Symbol.iterator]();
  }
  next() {
    if (this.bucketIterator !== undefined) {
      return this.bucketIterator.next();
    }
    const result = this.referentialIterator.next();
    if (result.done) {
      this.bucketIterator = new BucketIterator(this.self.buckets.values());
      return this.next();
    }
    return result;
  }
  [Symbol.iterator]() {
    return new MutableHashMapIterator(this.self);
  }
}
class BucketIterator {
  backing;
  constructor(backing) {
    this.backing = backing;
  }
  currentBucket;
  next() {
    if (this.currentBucket === undefined) {
      const result = this.backing.next();
      if (result.done) {
        return result;
      }
      this.currentBucket = result.value[Symbol.iterator]();
    }
    const result = this.currentBucket.next();
    if (result.done) {
      this.currentBucket = undefined;
      return this.next();
    }
    return result;
  }
}
/**
 * @since 2.0.0
 * @category constructors
 */
const empty$1 = () => {
  const self = Object.create(MutableHashMapProto);
  self.referential = new Map();
  self.buckets = new Map();
  self.bucketsSize = 0;
  return self;
};
/**
 * @since 2.0.0
 * @category elements
 */
const get$2 = /*#__PURE__*/dual(2, (self, key) => {
  if (isEqual(key) === false) {
    return self.referential.has(key) ? some(self.referential.get(key)) : none$4();
  }
  const hash = key[symbol$1]();
  const bucket = self.buckets.get(hash);
  if (bucket === undefined) {
    return none$4();
  }
  return getFromBucket(self, bucket, key);
});
const getFromBucket = (self, bucket, key, remove = false) => {
  for (let i = 0, len = bucket.length; i < len; i++) {
    if (key[symbol](bucket[i][0])) {
      const value = bucket[i][1];
      if (remove) {
        bucket.splice(i, 1);
        self.bucketsSize--;
      }
      return some(value);
    }
  }
  return none$4();
};
/**
 * @since 2.0.0
 * @category elements
 */
const has = /*#__PURE__*/dual(2, (self, key) => isSome(get$2(self, key)));
/**
 * @since 2.0.0
 */
const set = /*#__PURE__*/dual(3, (self, key, value) => {
  if (isEqual(key) === false) {
    self.referential.set(key, value);
    return self;
  }
  const hash = key[symbol$1]();
  const bucket = self.buckets.get(hash);
  if (bucket === undefined) {
    self.buckets.set(hash, [[key, value]]);
    self.bucketsSize++;
    return self;
  }
  removeFromBucket(self, bucket, key);
  bucket.push([key, value]);
  self.bucketsSize++;
  return self;
});
const removeFromBucket = (self, bucket, key) => {
  for (let i = 0, len = bucket.length; i < len; i++) {
    if (key[symbol](bucket[i][0])) {
      bucket.splice(i, 1);
      self.bucketsSize--;
      return;
    }
  }
};

/** @internal */
const MetricStateSymbolKey = "effect/MetricState";
/** @internal */
const MetricStateTypeId = /*#__PURE__*/Symbol.for(MetricStateSymbolKey);
/** @internal */
const CounterStateSymbolKey = "effect/MetricState/Counter";
/** @internal */
const CounterStateTypeId = /*#__PURE__*/Symbol.for(CounterStateSymbolKey);
/** @internal */
const FrequencyStateSymbolKey = "effect/MetricState/Frequency";
/** @internal */
const FrequencyStateTypeId = /*#__PURE__*/Symbol.for(FrequencyStateSymbolKey);
/** @internal */
const GaugeStateSymbolKey = "effect/MetricState/Gauge";
/** @internal */
const GaugeStateTypeId = /*#__PURE__*/Symbol.for(GaugeStateSymbolKey);
/** @internal */
const HistogramStateSymbolKey = "effect/MetricState/Histogram";
/** @internal */
const HistogramStateTypeId = /*#__PURE__*/Symbol.for(HistogramStateSymbolKey);
/** @internal */
const SummaryStateSymbolKey = "effect/MetricState/Summary";
/** @internal */
const SummaryStateTypeId = /*#__PURE__*/Symbol.for(SummaryStateSymbolKey);
const metricStateVariance = {
  /* c8 ignore next */
  _A: _ => _
};
/** @internal */
class CounterState {
  count;
  [MetricStateTypeId] = metricStateVariance;
  [CounterStateTypeId] = CounterStateTypeId;
  constructor(count) {
    this.count = count;
  }
  [symbol$1]() {
    return pipe(hash(CounterStateSymbolKey), combine$5(hash(this.count)), cached(this));
  }
  [symbol](that) {
    return isCounterState(that) && this.count === that.count;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
const arrayEquals = /*#__PURE__*/getEquivalence$2(equals$2);
/** @internal */
class FrequencyState {
  occurrences;
  [MetricStateTypeId] = metricStateVariance;
  [FrequencyStateTypeId] = FrequencyStateTypeId;
  constructor(occurrences) {
    this.occurrences = occurrences;
  }
  _hash;
  [symbol$1]() {
    return pipe(string(FrequencyStateSymbolKey), combine$5(array(fromIterable$6(this.occurrences.entries()))), cached(this));
  }
  [symbol](that) {
    return isFrequencyState(that) && arrayEquals(fromIterable$6(this.occurrences.entries()), fromIterable$6(that.occurrences.entries()));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
/** @internal */
class GaugeState {
  value;
  [MetricStateTypeId] = metricStateVariance;
  [GaugeStateTypeId] = GaugeStateTypeId;
  constructor(value) {
    this.value = value;
  }
  [symbol$1]() {
    return pipe(hash(GaugeStateSymbolKey), combine$5(hash(this.value)), cached(this));
  }
  [symbol](u) {
    return isGaugeState(u) && this.value === u.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
/** @internal */
class HistogramState {
  buckets;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [HistogramStateTypeId] = HistogramStateTypeId;
  constructor(buckets, count, min, max, sum) {
    this.buckets = buckets;
    this.count = count;
    this.min = min;
    this.max = max;
    this.sum = sum;
  }
  [symbol$1]() {
    return pipe(hash(HistogramStateSymbolKey), combine$5(hash(this.buckets)), combine$5(hash(this.count)), combine$5(hash(this.min)), combine$5(hash(this.max)), combine$5(hash(this.sum)), cached(this));
  }
  [symbol](that) {
    return isHistogramState(that) && equals$2(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
/** @internal */
class SummaryState {
  error;
  quantiles;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [SummaryStateTypeId] = SummaryStateTypeId;
  constructor(error, quantiles, count, min, max, sum) {
    this.error = error;
    this.quantiles = quantiles;
    this.count = count;
    this.min = min;
    this.max = max;
    this.sum = sum;
  }
  [symbol$1]() {
    return pipe(hash(SummaryStateSymbolKey), combine$5(hash(this.error)), combine$5(hash(this.quantiles)), combine$5(hash(this.count)), combine$5(hash(this.min)), combine$5(hash(this.max)), combine$5(hash(this.sum)), cached(this));
  }
  [symbol](that) {
    return isSummaryState(that) && this.error === that.error && equals$2(this.quantiles, that.quantiles) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
/** @internal */
const counter$2 = count => new CounterState(count);
/** @internal */
const frequency$1 = occurrences => {
  return new FrequencyState(occurrences);
};
/** @internal */
const gauge$1 = count => new GaugeState(count);
/** @internal */
const histogram$2 = options => new HistogramState(options.buckets, options.count, options.min, options.max, options.sum);
/** @internal */
const summary$1 = options => new SummaryState(options.error, options.quantiles, options.count, options.min, options.max, options.sum);
/** @internal */
const isCounterState = u => hasProperty(u, CounterStateTypeId);
/**
 * @since 2.0.0
 * @category refinements
 */
const isFrequencyState = u => hasProperty(u, FrequencyStateTypeId);
/**
 * @since 2.0.0
 * @category refinements
 */
const isGaugeState = u => hasProperty(u, GaugeStateTypeId);
/**
 * @since 2.0.0
 * @category refinements
 */
const isHistogramState = u => hasProperty(u, HistogramStateTypeId);
/**
 * @since 2.0.0
 * @category refinements
 */
const isSummaryState = u => hasProperty(u, SummaryStateTypeId);

/** @internal */
const MetricHookSymbolKey = "effect/MetricHook";
/** @internal */
const MetricHookTypeId = /*#__PURE__*/Symbol.for(MetricHookSymbolKey);
const metricHookVariance = {
  /* c8 ignore next */
  _In: _ => _,
  /* c8 ignore next */
  _Out: _ => _
};
/** @internal */
const make$8 = options => ({
  [MetricHookTypeId]: metricHookVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options
});
const bigint0$1 = /*#__PURE__*/BigInt(0);
/** @internal */
const counter$1 = key => {
  let sum = key.keyType.bigint ? bigint0$1 : 0;
  const canUpdate = key.keyType.incremental ? key.keyType.bigint ? value => value >= bigint0$1 : value => value >= 0 : _value => true;
  const update = value => {
    if (canUpdate(value)) {
      sum = sum + value;
    }
  };
  return make$8({
    get: () => counter$2(sum),
    update,
    modify: update
  });
};
/** @internal */
const frequency = key => {
  const values = new Map();
  for (const word of key.keyType.preregisteredWords) {
    values.set(word, 0);
  }
  const update = word => {
    const slotCount = values.get(word) ?? 0;
    values.set(word, slotCount + 1);
  };
  return make$8({
    get: () => frequency$1(values),
    update,
    modify: update
  });
};
/** @internal */
const gauge = (_key, startAt) => {
  let value = startAt;
  return make$8({
    get: () => gauge$1(value),
    update: v => {
      value = v;
    },
    modify: v => {
      value = value + v;
    }
  });
};
/** @internal */
const histogram$1 = key => {
  const bounds = key.keyType.boundaries.values;
  const size = bounds.length;
  const values = new Uint32Array(size + 1);
  const boundaries = new Float32Array(size);
  let count = 0;
  let sum = 0;
  let min = Number.MAX_VALUE;
  let max = Number.MIN_VALUE;
  pipe(bounds, sort(Order$1), map$5((n, i) => {
    boundaries[i] = n;
  }));
  // Insert the value into the right bucket with a binary search
  const update = value => {
    let from = 0;
    let to = size;
    while (from !== to) {
      const mid = Math.floor(from + (to - from) / 2);
      const boundary = boundaries[mid];
      if (value <= boundary) {
        to = mid;
      } else {
        from = mid;
      }
      // The special case when to / from have a distance of one
      if (to === from + 1) {
        if (value <= boundaries[from]) {
          to = from;
        } else {
          from = to;
        }
      }
    }
    values[from] = values[from] + 1;
    count = count + 1;
    sum = sum + value;
    if (value < min) {
      min = value;
    }
    if (value > max) {
      max = value;
    }
  };
  const getBuckets = () => {
    const builder = allocate(size);
    let cumulated = 0;
    for (let i = 0; i < size; i++) {
      const boundary = boundaries[i];
      const value = values[i];
      cumulated = cumulated + value;
      builder[i] = [boundary, cumulated];
    }
    return builder;
  };
  return make$8({
    get: () => histogram$2({
      buckets: getBuckets(),
      count,
      min,
      max,
      sum
    }),
    update,
    modify: update
  });
};
/** @internal */
const summary = key => {
  const {
    error,
    maxAge,
    maxSize,
    quantiles
  } = key.keyType;
  const sortedQuantiles = pipe(quantiles, sort(Order$1));
  const values = allocate(maxSize);
  let head = 0;
  let count = 0;
  let sum = 0;
  let min = Number.MAX_VALUE;
  let max = Number.MIN_VALUE;
  // Just before the snapshot we filter out all values older than maxAge
  const snapshot = now => {
    const builder = [];
    // If the buffer is not full yet it contains valid items at the 0..last
    // indices and null values at the rest of the positions.
    //
    // If the buffer is already full then all elements contains a valid
    // measurement with timestamp.
    //
    // At any given point in time we can enumerate all the non-null elements in
    // the buffer and filter them by timestamp to get a valid view of a time
    // window.
    //
    // The order does not matter because it gets sorted before passing to
    // `calculateQuantiles`.
    let i = 0;
    while (i !== maxSize - 1) {
      const item = values[i];
      if (item != null) {
        const [t, v] = item;
        const age = millis(now - t);
        if (greaterThanOrEqualTo$1(age, zero$1) && age <= maxAge) {
          builder.push(v);
        }
      }
      i = i + 1;
    }
    return calculateQuantiles(error, sortedQuantiles, sort(builder, Order$1));
  };
  const observe = (value, timestamp) => {
    if (maxSize > 0) {
      head = head + 1;
      const target = head % maxSize;
      values[target] = [timestamp, value];
    }
    count = count + 1;
    sum = sum + value;
    if (value < min) {
      min = value;
    }
    if (value > max) {
      max = value;
    }
  };
  return make$8({
    get: () => summary$1({
      error,
      quantiles: snapshot(Date.now()),
      count,
      min,
      max,
      sum
    }),
    update: ([value, timestamp]) => observe(value, timestamp),
    modify: ([value, timestamp]) => observe(value, timestamp)
  });
};
/** @internal */
const calculateQuantiles = (error, sortedQuantiles, sortedSamples) => {
  // The number of samples examined
  const sampleCount = sortedSamples.length;
  if (!isNonEmptyReadonlyArray(sortedQuantiles)) {
    return empty$j();
  }
  const head = sortedQuantiles[0];
  const tail = sortedQuantiles.slice(1);
  const resolvedHead = resolveQuantile(error, sampleCount, none$4(), 0, head, sortedSamples);
  const resolved = of$2(resolvedHead);
  tail.forEach(quantile => {
    resolved.push(resolveQuantile(error, sampleCount, resolvedHead.value, resolvedHead.consumed, quantile, resolvedHead.rest));
  });
  return map$5(resolved, rq => [rq.quantile, rq.value]);
};
/** @internal */
const resolveQuantile = (error, sampleCount, current, consumed, quantile, rest) => {
  let error_1 = error;
  let sampleCount_1 = sampleCount;
  let current_1 = current;
  let consumed_1 = consumed;
  let quantile_1 = quantile;
  let rest_1 = rest;
  let error_2 = error;
  let sampleCount_2 = sampleCount;
  let current_2 = current;
  let consumed_2 = consumed;
  let quantile_2 = quantile;
  let rest_2 = rest;
  // eslint-disable-next-line no-constant-condition
  while (1) {
    // If the remaining list of samples is empty, there is nothing more to resolve
    if (!isNonEmptyReadonlyArray(rest_1)) {
      return {
        quantile: quantile_1,
        value: none$4(),
        consumed: consumed_1,
        rest: []
      };
    }
    // If the quantile is the 100% quantile, we can take the maximum of all the
    // remaining values as the result
    if (quantile_1 === 1) {
      return {
        quantile: quantile_1,
        value: some(lastNonEmpty(rest_1)),
        consumed: consumed_1 + rest_1.length,
        rest: []
      };
    }
    // Split into two chunks - the first chunk contains all elements of the same
    // value as the chunk head
    const sameHead = span(rest_1, n => n <= rest_1[0]);
    // How many elements do we want to accept for this quantile
    const desired = quantile_1 * sampleCount_1;
    // The error margin
    const allowedError = error_1 / 2 * desired;
    // Taking into account the elements consumed from the samples so far and the
    // number of same elements at the beginning of the chunk, calculate the number
    // of elements we would have if we selected the current head as result
    const candConsumed = consumed_1 + sameHead[0].length;
    const candError = Math.abs(candConsumed - desired);
    // If we haven't got enough elements yet, recurse
    if (candConsumed < desired - allowedError) {
      error_2 = error_1;
      sampleCount_2 = sampleCount_1;
      current_2 = head(rest_1);
      consumed_2 = candConsumed;
      quantile_2 = quantile_1;
      rest_2 = sameHead[1];
      error_1 = error_2;
      sampleCount_1 = sampleCount_2;
      current_1 = current_2;
      consumed_1 = consumed_2;
      quantile_1 = quantile_2;
      rest_1 = rest_2;
      continue;
    }
    // If we have too many elements, select the previous value and hand back the
    // the rest as leftover
    if (candConsumed > desired + allowedError) {
      return {
        quantile: quantile_1,
        value: current_1,
        consumed: consumed_1,
        rest: rest_1
      };
    }
    // If we are in the target interval, select the current head and hand back the leftover after dropping all elements
    // from the sample chunk that are equal to the current head
    switch (current_1._tag) {
      case "None":
        {
          error_2 = error_1;
          sampleCount_2 = sampleCount_1;
          current_2 = head(rest_1);
          consumed_2 = candConsumed;
          quantile_2 = quantile_1;
          rest_2 = sameHead[1];
          error_1 = error_2;
          sampleCount_1 = sampleCount_2;
          current_1 = current_2;
          consumed_1 = consumed_2;
          quantile_1 = quantile_2;
          rest_1 = rest_2;
          continue;
        }
      case "Some":
        {
          const prevError = Math.abs(desired - current_1.value);
          if (candError < prevError) {
            error_2 = error_1;
            sampleCount_2 = sampleCount_1;
            current_2 = head(rest_1);
            consumed_2 = candConsumed;
            quantile_2 = quantile_1;
            rest_2 = sameHead[1];
            error_1 = error_2;
            sampleCount_1 = sampleCount_2;
            current_1 = current_2;
            consumed_1 = consumed_2;
            quantile_1 = quantile_2;
            rest_1 = rest_2;
            continue;
          }
          return {
            quantile: quantile_1,
            value: some(current_1.value),
            consumed: consumed_1,
            rest: rest_1
          };
        }
    }
  }
  throw new Error("BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues");
};

/** @internal */
const MetricPairSymbolKey = "effect/MetricPair";
/** @internal */
const MetricPairTypeId = /*#__PURE__*/Symbol.for(MetricPairSymbolKey);
const metricPairVariance = {
  /* c8 ignore next */
  _Type: _ => _
};
/** @internal */
const unsafeMake = (metricKey, metricState) => {
  return {
    [MetricPairTypeId]: metricPairVariance,
    metricKey,
    metricState,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
};

/** @internal */
const MetricRegistrySymbolKey = "effect/MetricRegistry";
/** @internal */
const MetricRegistryTypeId = /*#__PURE__*/Symbol.for(MetricRegistrySymbolKey);
/** @internal */
class MetricRegistryImpl {
  [MetricRegistryTypeId] = MetricRegistryTypeId;
  map = /*#__PURE__*/empty$1();
  snapshot() {
    const result = [];
    for (const [key, hook] of this.map) {
      result.push(unsafeMake(key, hook.get()));
    }
    return result;
  }
  get(key) {
    const hook = pipe(this.map, get$2(key), getOrUndefined);
    if (hook == null) {
      if (isCounterKey(key.keyType)) {
        return this.getCounter(key);
      }
      if (isGaugeKey(key.keyType)) {
        return this.getGauge(key);
      }
      if (isFrequencyKey(key.keyType)) {
        return this.getFrequency(key);
      }
      if (isHistogramKey(key.keyType)) {
        return this.getHistogram(key);
      }
      if (isSummaryKey(key.keyType)) {
        return this.getSummary(key);
      }
      throw new Error("BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues");
    } else {
      return hook;
    }
  }
  getCounter(key) {
    let value = pipe(this.map, get$2(key), getOrUndefined);
    if (value == null) {
      const counter = counter$1(key);
      if (!pipe(this.map, has(key))) {
        pipe(this.map, set(key, counter));
      }
      value = counter;
    }
    return value;
  }
  getFrequency(key) {
    let value = pipe(this.map, get$2(key), getOrUndefined);
    if (value == null) {
      const frequency$1 = frequency(key);
      if (!pipe(this.map, has(key))) {
        pipe(this.map, set(key, frequency$1));
      }
      value = frequency$1;
    }
    return value;
  }
  getGauge(key) {
    let value = pipe(this.map, get$2(key), getOrUndefined);
    if (value == null) {
      const gauge$1 = gauge(key, key.keyType.bigint ? BigInt(0) : 0);
      if (!pipe(this.map, has(key))) {
        pipe(this.map, set(key, gauge$1));
      }
      value = gauge$1;
    }
    return value;
  }
  getHistogram(key) {
    let value = pipe(this.map, get$2(key), getOrUndefined);
    if (value == null) {
      const histogram = histogram$1(key);
      if (!pipe(this.map, has(key))) {
        pipe(this.map, set(key, histogram));
      }
      value = histogram;
    }
    return value;
  }
  getSummary(key) {
    let value = pipe(this.map, get$2(key), getOrUndefined);
    if (value == null) {
      const summary$1 = summary(key);
      if (!pipe(this.map, has(key))) {
        pipe(this.map, set(key, summary$1));
      }
      value = summary$1;
    }
    return value;
  }
}
/** @internal */
const make$7 = () => {
  return new MetricRegistryImpl();
};

/** @internal */
const MetricSymbolKey = "effect/Metric";
/** @internal */
const MetricTypeId = /*#__PURE__*/Symbol.for(MetricSymbolKey);
const metricVariance = {
  /* c8 ignore next */
  _Type: _ => _,
  /* c8 ignore next */
  _In: _ => _,
  /* c8 ignore next */
  _Out: _ => _
};
/** @internal */
const globalMetricRegistry = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for("effect/Metric/globalMetricRegistry"), () => make$7());
/** @internal */
const make$6 = function (keyType, unsafeUpdate, unsafeValue, unsafeModify) {
  const metric = Object.assign(effect => tap(effect, a => update(metric, a)), {
    [MetricTypeId]: metricVariance,
    keyType,
    unsafeUpdate,
    unsafeValue,
    unsafeModify,
    register() {
      this.unsafeValue([]);
      return this;
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  });
  return metric;
};
/** @internal */
const counter = (name, options) => fromMetricKey(counter$3(name, options));
/** @internal */
const fromMetricKey = key => {
  let untaggedHook;
  const hookCache = new WeakMap();
  const hook = extraTags => {
    if (extraTags.length === 0) {
      if (untaggedHook !== undefined) {
        return untaggedHook;
      }
      untaggedHook = globalMetricRegistry.get(key);
      return untaggedHook;
    }
    let hook = hookCache.get(extraTags);
    if (hook !== undefined) {
      return hook;
    }
    hook = globalMetricRegistry.get(taggedWithLabels$1(key, extraTags));
    hookCache.set(extraTags, hook);
    return hook;
  };
  return make$6(key.keyType, (input, extraTags) => hook(extraTags).update(input), extraTags => hook(extraTags).get(), (input, extraTags) => hook(extraTags).modify(input));
};
/** @internal */
const histogram = (name, boundaries, description) => fromMetricKey(histogram$3(name, boundaries, description));
/** @internal */
const tagged = /*#__PURE__*/dual(3, (self, key, value) => taggedWithLabels(self, [make$9(key, value)]));
/** @internal */
const taggedWithLabels = /*#__PURE__*/dual(2, (self, extraTags) => {
  return make$6(self.keyType, (input, extraTags1) => self.unsafeUpdate(input, union$2(extraTags, extraTags1)), extraTags1 => self.unsafeValue(union$2(extraTags, extraTags1)), (input, extraTags1) => self.unsafeModify(input, union$2(extraTags, extraTags1)));
});
/* @internal */
const update = /*#__PURE__*/dual(2, (self, input) => fiberRefGetWith(currentMetricLabels, tags => sync(() => self.unsafeUpdate(input, tags))));

/** @internal */
const RequestSymbolKey = "effect/Request";
/** @internal */
const RequestTypeId = /*#__PURE__*/Symbol.for(RequestSymbolKey);
const requestVariance = {
  /* c8 ignore next */
  _E: _ => _,
  /* c8 ignore next */
  _A: _ => _
};
({
  ...StructuralPrototype,
  [RequestTypeId]: requestVariance
});
/** @internal */
const complete = /*#__PURE__*/dual(2, (self, result) => fiberRefGetWith(currentRequestMap, map => sync(() => {
  if (map.has(self)) {
    const entry = map.get(self);
    if (!entry.state.completed) {
      entry.state.completed = true;
      deferredUnsafeDone(entry.result, result);
    }
  }
})));

/** @internal */
const SupervisorSymbolKey = "effect/Supervisor";
/** @internal */
const SupervisorTypeId = /*#__PURE__*/Symbol.for(SupervisorSymbolKey);
/** @internal */
const supervisorVariance = {
  /* c8 ignore next */
  _T: _ => _
};
/** @internal */
class ProxySupervisor {
  underlying;
  value0;
  [SupervisorTypeId] = supervisorVariance;
  constructor(underlying, value0) {
    this.underlying = underlying;
    this.value0 = value0;
  }
  get value() {
    return this.value0;
  }
  onStart(context, effect, parent, fiber) {
    this.underlying.onStart(context, effect, parent, fiber);
  }
  onEnd(value, fiber) {
    this.underlying.onEnd(value, fiber);
  }
  onEffect(fiber, effect) {
    this.underlying.onEffect(fiber, effect);
  }
  onSuspend(fiber) {
    this.underlying.onSuspend(fiber);
  }
  onResume(fiber) {
    this.underlying.onResume(fiber);
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map$2(f)));
  }
  zip(right) {
    return new Zip(this, right);
  }
}
/** @internal */
class Zip {
  left;
  right;
  _tag = "Zip";
  [SupervisorTypeId] = supervisorVariance;
  constructor(left, right) {
    this.left = left;
    this.right = right;
  }
  get value() {
    return zip(this.left.value, this.right.value);
  }
  onStart(context, effect, parent, fiber) {
    this.left.onStart(context, effect, parent, fiber);
    this.right.onStart(context, effect, parent, fiber);
  }
  onEnd(value, fiber) {
    this.left.onEnd(value, fiber);
    this.right.onEnd(value, fiber);
  }
  onEffect(fiber, effect) {
    this.left.onEffect(fiber, effect);
    this.right.onEffect(fiber, effect);
  }
  onSuspend(fiber) {
    this.left.onSuspend(fiber);
    this.right.onSuspend(fiber);
  }
  onResume(fiber) {
    this.left.onResume(fiber);
    this.right.onResume(fiber);
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map$2(f)));
  }
  zip(right) {
    return new Zip(this, right);
  }
}
/** @internal */
const isZip = self => hasProperty(self, SupervisorTypeId) && isTagged(self, "Zip");
/** @internal */
class Const {
  effect;
  [SupervisorTypeId] = supervisorVariance;
  constructor(effect) {
    this.effect = effect;
  }
  get value() {
    return this.effect;
  }
  onStart(_context, _effect, _parent, _fiber) {
    //
  }
  onEnd(_value, _fiber) {
    //
  }
  onEffect(_fiber, _effect) {
    //
  }
  onSuspend(_fiber) {
    //
  }
  onResume(_fiber) {
    //
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map$2(f)));
  }
  zip(right) {
    return new Zip(this, right);
  }
  onRun(execution, _fiber) {
    return execution();
  }
}
/** @internal */
const fromEffect = effect => {
  return new Const(effect);
};
/** @internal */
const none = /*#__PURE__*/globalValue("effect/Supervisor/none", () => fromEffect(void_$1));

/**
 * Constructs a new `Differ`.
 *
 * @since 2.0.0
 * @category constructors
 */
const make$5 = make$g;

/** @internal */
const OP_EMPTY = "Empty";
/** @internal */
const OP_ADD_SUPERVISOR = "AddSupervisor";
/** @internal */
const OP_REMOVE_SUPERVISOR = "RemoveSupervisor";
/** @internal */
const OP_AND_THEN = "AndThen";
/**
 * The empty `SupervisorPatch`.
 *
 * @internal
 */
const empty = {
  _tag: OP_EMPTY
};
/**
 * Combines two patches to produce a new patch that describes applying the
 * updates from this patch and then the updates from the specified patch.
 *
 * @internal
 */
const combine = (self, that) => {
  return {
    _tag: OP_AND_THEN,
    first: self,
    second: that
  };
};
/**
 * Applies a `SupervisorPatch` to a `Supervisor` to produce a new `Supervisor`.
 *
 * @internal
 */
const patch = (self, supervisor) => {
  return patchLoop(supervisor, of$1(self));
};
/** @internal */
const patchLoop = (_supervisor, _patches) => {
  let supervisor = _supervisor;
  let patches = _patches;
  while (isNonEmpty(patches)) {
    const head = headNonEmpty(patches);
    switch (head._tag) {
      case OP_EMPTY:
        {
          patches = tailNonEmpty(patches);
          break;
        }
      case OP_ADD_SUPERVISOR:
        {
          supervisor = supervisor.zip(head.supervisor);
          patches = tailNonEmpty(patches);
          break;
        }
      case OP_REMOVE_SUPERVISOR:
        {
          supervisor = removeSupervisor(supervisor, head.supervisor);
          patches = tailNonEmpty(patches);
          break;
        }
      case OP_AND_THEN:
        {
          patches = prepend$1(head.first)(prepend$1(head.second)(tailNonEmpty(patches)));
          break;
        }
    }
  }
  return supervisor;
};
/** @internal */
const removeSupervisor = (self, that) => {
  if (equals$2(self, that)) {
    return none;
  } else {
    if (isZip(self)) {
      return removeSupervisor(self.left, that).zip(removeSupervisor(self.right, that));
    } else {
      return self;
    }
  }
};
/** @internal */
const toSet = self => {
  if (equals$2(self, none)) {
    return empty$f();
  } else {
    if (isZip(self)) {
      return pipe(toSet(self.left), union(toSet(self.right)));
    } else {
      return make$l(self);
    }
  }
};
/** @internal */
const diff = (oldValue, newValue) => {
  if (equals$2(oldValue, newValue)) {
    return empty;
  }
  const oldSupervisors = toSet(oldValue);
  const newSupervisors = toSet(newValue);
  const added = pipe(newSupervisors, difference(oldSupervisors), reduce$3(empty, (patch, supervisor) => combine(patch, {
    _tag: OP_ADD_SUPERVISOR,
    supervisor
  })));
  const removed = pipe(oldSupervisors, difference(newSupervisors), reduce$3(empty, (patch, supervisor) => combine(patch, {
    _tag: OP_REMOVE_SUPERVISOR,
    supervisor
  })));
  return combine(added, removed);
};
/** @internal */
const differ = /*#__PURE__*/make$5({
  empty,
  patch,
  combine,
  diff
});

/** @internal */
const fiberStarted = /*#__PURE__*/counter("effect_fiber_started", {
  incremental: true
});
/** @internal */
const fiberActive = /*#__PURE__*/counter("effect_fiber_active");
/** @internal */
const fiberSuccesses = /*#__PURE__*/counter("effect_fiber_successes", {
  incremental: true
});
/** @internal */
const fiberFailures = /*#__PURE__*/counter("effect_fiber_failures", {
  incremental: true
});
/** @internal */
const fiberLifetimes = /*#__PURE__*/tagged( /*#__PURE__*/histogram("effect_fiber_lifetimes", /*#__PURE__*/exponential({
  start: 0.5,
  factor: 2,
  count: 35
})), "time_unit", "milliseconds");
/** @internal */
const EvaluationSignalContinue = "Continue";
/** @internal */
const EvaluationSignalDone = "Done";
/** @internal */
const EvaluationSignalYieldNow = "Yield";
const runtimeFiberVariance = {
  /* c8 ignore next */
  _E: _ => _,
  /* c8 ignore next */
  _A: _ => _
};
const absurd = _ => {
  throw new Error(`BUG: FiberRuntime - ${toStringUnknown(_)} - please report an issue at https://github.com/Effect-TS/effect/issues`);
};
const YieldedOp = /*#__PURE__*/Symbol.for("effect/internal/fiberRuntime/YieldedOp");
const yieldedOpChannel = /*#__PURE__*/globalValue("effect/internal/fiberRuntime/yieldedOpChannel", () => ({
  currentOp: null
}));
const contOpSuccess = {
  [OP_ON_SUCCESS]: (_, cont, value) => {
    return internalCall(() => cont.effect_instruction_i1(value));
  },
  ["OnStep"]: (_, _cont, value) => {
    return exitSucceed$1(exitSucceed$1(value));
  },
  [OP_ON_SUCCESS_AND_FAILURE]: (_, cont, value) => {
    return internalCall(() => cont.effect_instruction_i2(value));
  },
  [OP_REVERT_FLAGS]: (self, cont, value) => {
    self.patchRuntimeFlags(self.currentRuntimeFlags, cont.patch);
    if (interruptible$2(self.currentRuntimeFlags) && self.isInterrupted()) {
      return exitFailCause$1(self.getInterruptedCause());
    } else {
      return exitSucceed$1(value);
    }
  },
  [OP_WHILE]: (self, cont, value) => {
    internalCall(() => cont.effect_instruction_i2(value));
    if (internalCall(() => cont.effect_instruction_i0())) {
      self.pushStack(cont);
      return internalCall(() => cont.effect_instruction_i1());
    } else {
      return void_$1;
    }
  },
  [OP_ITERATOR]: (self, cont, value) => {
    const state = internalCall(() => cont.effect_instruction_i0.next(value));
    if (state.done) return exitSucceed$1(state.value);
    self.pushStack(cont);
    return yieldWrapGet(state.value);
  }
};
const drainQueueWhileRunningTable = {
  [OP_INTERRUPT_SIGNAL]: (self, runtimeFlags, cur, message) => {
    self.processNewInterruptSignal(message.cause);
    return interruptible$2(runtimeFlags) ? exitFailCause$1(message.cause) : cur;
  },
  [OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {
    throw new Error("It is illegal to have multiple concurrent run loops in a single fiber");
  },
  [OP_STATEFUL]: (self, runtimeFlags, cur, message) => {
    message.onFiber(self, running(runtimeFlags));
    return cur;
  },
  [OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => {
    return flatMap$3(yieldNow$2(), () => cur);
  }
};
/**
 * Executes all requests, submitting requests to each data source in parallel.
 */
const runBlockedRequests = self => forEachSequentialDiscard(flatten$1(self), requestsByRequestResolver => forEachConcurrentDiscard(sequentialCollectionToChunk(requestsByRequestResolver), ([dataSource, sequential]) => {
  const map = new Map();
  const arr = [];
  for (const block of sequential) {
    arr.push(toReadonlyArray(block));
    for (const entry of block) {
      map.set(entry.request, entry);
    }
  }
  const flat = arr.flat();
  return fiberRefLocally(invokeWithInterrupt(dataSource.runAll(arr), flat, () => flat.forEach(entry => {
    entry.listeners.interrupted = true;
  })), currentRequestMap, map);
}, false, false));
const _version = /*#__PURE__*/getCurrentVersion();
/** @internal */
class FiberRuntime extends Class {
  [FiberTypeId] = fiberVariance;
  [RuntimeFiberTypeId] = runtimeFiberVariance;
  _fiberRefs;
  _fiberId;
  _queue = /*#__PURE__*/new Array();
  _children = null;
  _observers = /*#__PURE__*/new Array();
  _running = false;
  _stack = [];
  _asyncInterruptor = null;
  _asyncBlockingOn = null;
  _exitValue = null;
  _steps = [];
  _isYielding = false;
  currentRuntimeFlags;
  currentOpCount = 0;
  currentSupervisor;
  currentScheduler;
  currentTracer;
  currentSpan;
  currentContext;
  currentDefaultServices;
  constructor(fiberId, fiberRefs0, runtimeFlags0) {
    super();
    this.currentRuntimeFlags = runtimeFlags0;
    this._fiberId = fiberId;
    this._fiberRefs = fiberRefs0;
    if (runtimeMetrics(runtimeFlags0)) {
      const tags = this.getFiberRef(currentMetricLabels);
      fiberStarted.unsafeUpdate(1, tags);
      fiberActive.unsafeUpdate(1, tags);
    }
    this.refreshRefCache();
  }
  commit() {
    return join(this);
  }
  /**
   * The identity of the fiber.
   */
  id() {
    return this._fiberId;
  }
  /**
   * Begins execution of the effect associated with this fiber on in the
   * background. This can be called to "kick off" execution of a fiber after
   * it has been created.
   */
  resume(effect) {
    this.tell(resume(effect));
  }
  /**
   * The status of the fiber.
   */
  get status() {
    return this.ask((_, status) => status);
  }
  /**
   * Gets the fiber runtime flags.
   */
  get runtimeFlags() {
    return this.ask((state, status) => {
      if (isDone(status)) {
        return state.currentRuntimeFlags;
      }
      return status.runtimeFlags;
    });
  }
  /**
   * Returns the current `FiberScope` for the fiber.
   */
  scope() {
    return unsafeMake$1(this);
  }
  /**
   * Retrieves the immediate children of the fiber.
   */
  get children() {
    return this.ask(fiber => Array.from(fiber.getChildren()));
  }
  /**
   * Gets the fiber's set of children.
   */
  getChildren() {
    if (this._children === null) {
      this._children = new Set();
    }
    return this._children;
  }
  /**
   * Retrieves the interrupted cause of the fiber, which will be `Cause.empty`
   * if the fiber has not been interrupted.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getInterruptedCause() {
    return this.getFiberRef(currentInterruptedCause);
  }
  /**
   * Retrieves the whole set of fiber refs.
   */
  fiberRefs() {
    return this.ask(fiber => fiber.getFiberRefs());
  }
  /**
   * Returns an effect that will contain information computed from the fiber
   * state and status while running on the fiber.
   *
   * This allows the outside world to interact safely with mutable fiber state
   * without locks or immutable data.
   */
  ask(f) {
    return suspend$2(() => {
      const deferred = deferredUnsafeMake(this._fiberId);
      this.tell(stateful((fiber, status) => {
        deferredUnsafeDone(deferred, sync(() => f(fiber, status)));
      }));
      return deferredAwait(deferred);
    });
  }
  /**
   * Adds a message to be processed by the fiber on the fiber.
   */
  tell(message) {
    this._queue.push(message);
    if (!this._running) {
      this._running = true;
      this.drainQueueLaterOnExecutor();
    }
  }
  get await() {
    return async_(resume => {
      const cb = exit => resume(succeed$3(exit));
      this.tell(stateful((fiber, _) => {
        if (fiber._exitValue !== null) {
          cb(this._exitValue);
        } else {
          fiber.addObserver(cb);
        }
      }));
      return sync(() => this.tell(stateful((fiber, _) => {
        fiber.removeObserver(cb);
      })));
    }, this.id());
  }
  get inheritAll() {
    return withFiberRuntime((parentFiber, parentStatus) => {
      const parentFiberId = parentFiber.id();
      const parentFiberRefs = parentFiber.getFiberRefs();
      const parentRuntimeFlags = parentStatus.runtimeFlags;
      const childFiberRefs = this.getFiberRefs();
      const updatedFiberRefs = joinAs(parentFiberRefs, parentFiberId, childFiberRefs);
      parentFiber.setFiberRefs(updatedFiberRefs);
      const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags);
      const patch = pipe(diff$3(parentRuntimeFlags, updatedRuntimeFlags),
      // Do not inherit WindDown or Interruption!
      exclude(Interruption), exclude(WindDown));
      return updateRuntimeFlags(patch);
    });
  }
  /**
   * Tentatively observes the fiber, but returns immediately if it is not
   * already done.
   */
  get poll() {
    return sync(() => fromNullable(this._exitValue));
  }
  /**
   * Unsafely observes the fiber, but returns immediately if it is not
   * already done.
   */
  unsafePoll() {
    return this._exitValue;
  }
  /**
   * In the background, interrupts the fiber as if interrupted from the specified fiber.
   */
  interruptAsFork(fiberId) {
    return sync(() => this.tell(interruptSignal(interrupt(fiberId))));
  }
  /**
   * In the background, interrupts the fiber as if interrupted from the specified fiber.
   */
  unsafeInterruptAsFork(fiberId) {
    this.tell(interruptSignal(interrupt(fiberId)));
  }
  /**
   * Adds an observer to the list of observers.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addObserver(observer) {
    if (this._exitValue !== null) {
      observer(this._exitValue);
    } else {
      this._observers.push(observer);
    }
  }
  /**
   * Removes the specified observer from the list of observers that will be
   * notified when the fiber exits.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  removeObserver(observer) {
    this._observers = this._observers.filter(o => o !== observer);
  }
  /**
   * Retrieves all fiber refs of the fiber.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getFiberRefs() {
    this.setFiberRef(currentRuntimeFlags, this.currentRuntimeFlags);
    return this._fiberRefs;
  }
  /**
   * Deletes the specified fiber ref.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  unsafeDeleteFiberRef(fiberRef) {
    this._fiberRefs = delete_(this._fiberRefs, fiberRef);
  }
  /**
   * Retrieves the state of the fiber ref, or else its initial value.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getFiberRef(fiberRef) {
    if (this._fiberRefs.locals.has(fiberRef)) {
      return this._fiberRefs.locals.get(fiberRef)[0][1];
    }
    return fiberRef.initial;
  }
  /**
   * Sets the fiber ref to the specified value.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  setFiberRef(fiberRef, value) {
    this._fiberRefs = updateAs(this._fiberRefs, {
      fiberId: this._fiberId,
      fiberRef,
      value
    });
    this.refreshRefCache();
  }
  refreshRefCache() {
    this.currentDefaultServices = this.getFiberRef(currentServices);
    this.currentTracer = this.currentDefaultServices.unsafeMap.get(tracerTag.key);
    this.currentSupervisor = this.getFiberRef(currentSupervisor);
    this.currentScheduler = this.getFiberRef(currentScheduler);
    this.currentContext = this.getFiberRef(currentContext);
    this.currentSpan = this.currentContext.unsafeMap.get(spanTag.key);
  }
  /**
   * Wholesale replaces all fiber refs of this fiber.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  setFiberRefs(fiberRefs) {
    this._fiberRefs = fiberRefs;
    this.refreshRefCache();
  }
  /**
   * Adds a reference to the specified fiber inside the children set.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addChild(child) {
    this.getChildren().add(child);
  }
  /**
   * Removes a reference to the specified fiber inside the children set.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  removeChild(child) {
    this.getChildren().delete(child);
  }
  /**
   * Transfers all children of this fiber that are currently running to the
   * specified fiber scope.
   *
   * **NOTE**: This method must be invoked by the fiber itself after it has
   * evaluated the effects but prior to exiting.
   */
  transferChildren(scope) {
    const children = this._children;
    // Clear the children of the current fiber
    this._children = null;
    if (children !== null && children.size > 0) {
      for (const child of children) {
        // If the child is still running, add it to the scope
        if (child._exitValue === null) {
          scope.add(this.currentRuntimeFlags, child);
        }
      }
    }
  }
  /**
   * On the current thread, executes all messages in the fiber's inbox. This
   * method may return before all work is done, in the event the fiber executes
   * an asynchronous operation.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueOnCurrentThread() {
    let recurse = true;
    while (recurse) {
      let evaluationSignal = EvaluationSignalContinue;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        while (evaluationSignal === EvaluationSignalContinue) {
          evaluationSignal = this._queue.length === 0 ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);
        }
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
      }
      // Maybe someone added something to the queue between us checking, and us
      // giving up the drain. If so, we need to restart the draining, but only
      // if we beat everyone else to the restart:
      if (this._queue.length > 0 && !this._running) {
        this._running = true;
        if (evaluationSignal === EvaluationSignalYieldNow) {
          this.drainQueueLaterOnExecutor();
          recurse = false;
        } else {
          recurse = true;
        }
      } else {
        recurse = false;
      }
    }
  }
  /**
   * Schedules the execution of all messages in the fiber's inbox.
   *
   * This method will return immediately after the scheduling
   * operation is completed, but potentially before such messages have been
   * executed.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueLaterOnExecutor() {
    this.currentScheduler.scheduleTask(this.run, this.getFiberRef(currentSchedulingPriority));
  }
  /**
   * Drains the fiber's message queue while the fiber is actively running,
   * returning the next effect to execute, which may be the input effect if no
   * additional effect needs to be executed.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueWhileRunning(runtimeFlags, cur0) {
    let cur = cur0;
    while (this._queue.length > 0) {
      const message = this._queue.splice(0, 1)[0];
      // @ts-expect-error
      cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags, cur, message);
    }
    return cur;
  }
  /**
   * Determines if the fiber is interrupted.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  isInterrupted() {
    return !isEmpty$1(this.getFiberRef(currentInterruptedCause));
  }
  /**
   * Adds an interruptor to the set of interruptors that are interrupting this
   * fiber.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addInterruptedCause(cause) {
    const oldSC = this.getFiberRef(currentInterruptedCause);
    this.setFiberRef(currentInterruptedCause, sequential$2(oldSC, cause));
  }
  /**
   * Processes a new incoming interrupt signal.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  processNewInterruptSignal(cause) {
    this.addInterruptedCause(cause);
    this.sendInterruptSignalToAllChildren();
  }
  /**
   * Interrupts all children of the current fiber, returning an effect that will
   * await the exit of the children. This method will return null if the fiber
   * has no children.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  sendInterruptSignalToAllChildren() {
    if (this._children === null || this._children.size === 0) {
      return false;
    }
    let told = false;
    for (const child of this._children) {
      child.tell(interruptSignal(interrupt(this.id())));
      told = true;
    }
    return told;
  }
  /**
   * Interrupts all children of the current fiber, returning an effect that will
   * await the exit of the children. This method will return null if the fiber
   * has no children.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  interruptAllChildren() {
    if (this.sendInterruptSignalToAllChildren()) {
      const it = this._children.values();
      this._children = null;
      let isDone = false;
      const body = () => {
        const next = it.next();
        if (!next.done) {
          return asVoid(next.value.await);
        } else {
          return sync(() => {
            isDone = true;
          });
        }
      };
      return whileLoop({
        while: () => !isDone,
        body,
        step: () => {
          //
        }
      });
    }
    return null;
  }
  reportExitValue(exit) {
    if (runtimeMetrics(this.currentRuntimeFlags)) {
      const tags = this.getFiberRef(currentMetricLabels);
      const startTimeMillis = this.id().startTimeMillis;
      const endTimeMillis = Date.now();
      fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags);
      fiberActive.unsafeUpdate(-1, tags);
      switch (exit._tag) {
        case OP_SUCCESS:
          {
            fiberSuccesses.unsafeUpdate(1, tags);
            break;
          }
        case OP_FAILURE:
          {
            fiberFailures.unsafeUpdate(1, tags);
            break;
          }
      }
    }
    if (exit._tag === "Failure") {
      const level = this.getFiberRef(currentUnhandledErrorLogLevel);
      if (!isInterruptedOnly(exit.cause) && level._tag === "Some") {
        this.log("Fiber terminated with an unhandled error", exit.cause, level);
      }
    }
  }
  setExitValue(exit) {
    this._exitValue = exit;
    this.reportExitValue(exit);
    for (let i = this._observers.length - 1; i >= 0; i--) {
      this._observers[i](exit);
    }
    this._observers = [];
  }
  getLoggers() {
    return this.getFiberRef(currentLoggers);
  }
  log(message, cause, overrideLogLevel) {
    const logLevel = isSome(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(currentLogLevel);
    const minimumLogLevel = this.getFiberRef(currentMinimumLogLevel);
    if (greaterThan$1(minimumLogLevel, logLevel)) {
      return;
    }
    const spans = this.getFiberRef(currentLogSpan);
    const annotations = this.getFiberRef(currentLogAnnotations);
    const loggers = this.getLoggers();
    const contextMap = this.getFiberRefs();
    if (size$1(loggers) > 0) {
      const clockService = get$7(this.getFiberRef(currentServices), clockTag);
      const date = new Date(clockService.unsafeCurrentTimeMillis());
      withRedactableContext(contextMap, () => {
        for (const logger of loggers) {
          logger.log({
            fiberId: this.id(),
            logLevel,
            message,
            cause,
            context: contextMap,
            spans,
            annotations,
            date
          });
        }
      });
    }
  }
  /**
   * Evaluates a single message on the current thread, while the fiber is
   * suspended. This method should only be called while evaluation of the
   * fiber's effect is suspended due to an asynchronous operation.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  evaluateMessageWhileSuspended(message) {
    switch (message._tag) {
      case OP_YIELD_NOW:
        {
          return EvaluationSignalYieldNow;
        }
      case OP_INTERRUPT_SIGNAL:
        {
          this.processNewInterruptSignal(message.cause);
          if (this._asyncInterruptor !== null) {
            this._asyncInterruptor(exitFailCause$1(message.cause));
            this._asyncInterruptor = null;
          }
          return EvaluationSignalContinue;
        }
      case OP_RESUME:
        {
          this._asyncInterruptor = null;
          this._asyncBlockingOn = null;
          this.evaluateEffect(message.effect);
          return EvaluationSignalContinue;
        }
      case OP_STATEFUL:
        {
          message.onFiber(this, this._exitValue !== null ? done : suspended(this.currentRuntimeFlags, this._asyncBlockingOn));
          return EvaluationSignalContinue;
        }
      default:
        {
          return absurd(message);
        }
    }
  }
  /**
   * Evaluates an effect until completion, potentially asynchronously.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  evaluateEffect(effect0) {
    this.currentSupervisor.onResume(this);
    try {
      let effect = interruptible$2(this.currentRuntimeFlags) && this.isInterrupted() ? exitFailCause$1(this.getInterruptedCause()) : effect0;
      while (effect !== null) {
        const eff = effect;
        const exit = this.runLoop(eff);
        if (exit === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          yieldedOpChannel.currentOp = null;
          if (op._op === OP_YIELD) {
            if (cooperativeYielding(this.currentRuntimeFlags)) {
              this.tell(yieldNow());
              this.tell(resume(exitVoid$1));
              effect = null;
            } else {
              effect = exitVoid$1;
            }
          } else if (op._op === OP_ASYNC) {
            // Terminate this evaluation, async resumption will continue evaluation:
            effect = null;
          }
        } else {
          this.currentRuntimeFlags = pipe(this.currentRuntimeFlags, enable$1(WindDown));
          const interruption = this.interruptAllChildren();
          if (interruption !== null) {
            effect = flatMap$3(interruption, () => exit);
          } else {
            if (this._queue.length === 0) {
              // No more messages to process, so we will allow the fiber to end life:
              this.setExitValue(exit);
            } else {
              // There are messages, possibly added by the final op executed by
              // the fiber. To be safe, we should execute those now before we
              // allow the fiber to end life:
              this.tell(resume(exit));
            }
            effect = null;
          }
        }
      }
    } finally {
      this.currentSupervisor.onSuspend(this);
    }
  }
  /**
   * Begins execution of the effect associated with this fiber on the current
   * thread. This can be called to "kick off" execution of a fiber after it has
   * been created, in hopes that the effect can be executed synchronously.
   *
   * This is not the normal way of starting a fiber, but it is useful when the
   * express goal of executing the fiber is to synchronously produce its exit.
   */
  start(effect) {
    if (!this._running) {
      this._running = true;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        this.evaluateEffect(effect);
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
        // Because we're special casing `start`, we have to be responsible
        // for spinning up the fiber if there were new messages added to
        // the queue between the completion of the effect and the transition
        // to the not running state.
        if (this._queue.length > 0) {
          this.drainQueueLaterOnExecutor();
        }
      }
    } else {
      this.tell(resume(effect));
    }
  }
  /**
   * Begins execution of the effect associated with this fiber on in the
   * background, and on the correct thread pool. This can be called to "kick
   * off" execution of a fiber after it has been created, in hopes that the
   * effect can be executed synchronously.
   */
  startFork(effect) {
    this.tell(resume(effect));
  }
  /**
   * Takes the current runtime flags, patches them to return the new runtime
   * flags, and then makes any changes necessary to fiber state based on the
   * specified patch.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  patchRuntimeFlags(oldRuntimeFlags, patch) {
    const newRuntimeFlags = patch$4(oldRuntimeFlags, patch);
    globalThis[currentFiberURI] = this;
    this.currentRuntimeFlags = newRuntimeFlags;
    return newRuntimeFlags;
  }
  /**
   * Initiates an asynchronous operation, by building a callback that will
   * resume execution, and then feeding that callback to the registration
   * function, handling error cases and repeated resumptions appropriately.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  initiateAsync(runtimeFlags, asyncRegister) {
    let alreadyCalled = false;
    const callback = effect => {
      if (!alreadyCalled) {
        alreadyCalled = true;
        this.tell(resume(effect));
      }
    };
    if (interruptible$2(runtimeFlags)) {
      this._asyncInterruptor = callback;
    }
    try {
      asyncRegister(callback);
    } catch (e) {
      callback(failCause$1(die$1(e)));
    }
  }
  pushStack(cont) {
    this._stack.push(cont);
    if (cont._op === "OnStep") {
      this._steps.push({
        refs: this.getFiberRefs(),
        flags: this.currentRuntimeFlags
      });
    }
  }
  popStack() {
    const item = this._stack.pop();
    if (item) {
      if (item._op === "OnStep") {
        this._steps.pop();
      }
      return item;
    }
    return;
  }
  getNextSuccessCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_FAILURE) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  getNextFailCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_SUCCESS && frame._op !== OP_WHILE && frame._op !== OP_ITERATOR) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  [OP_TAG](op) {
    return sync(() => unsafeGet(this.currentContext, op));
  }
  ["Left"](op) {
    return fail$1(op.left);
  }
  ["None"](_) {
    return fail$1(new NoSuchElementException());
  }
  ["Right"](op) {
    return exitSucceed$1(op.right);
  }
  ["Some"](op) {
    return exitSucceed$1(op.value);
  }
  ["Micro"](op) {
    return unsafeAsync(microResume => {
      let resume = microResume;
      const fiber = runFork(provideContext(op, this.currentContext));
      fiber.addObserver(exit => {
        if (exit._tag === "Success") {
          return resume(exitSucceed$1(exit.value));
        }
        switch (exit.cause._tag) {
          case "Interrupt":
            {
              return resume(exitFailCause$1(interrupt(none$2)));
            }
          case "Fail":
            {
              return resume(fail$1(exit.cause.error));
            }
          case "Die":
            {
              return resume(die(exit.cause.defect));
            }
        }
      });
      return unsafeAsync(abortResume => {
        resume = _ => {
          abortResume(void_$1);
        };
        fiber.unsafeInterrupt();
      });
    });
  }
  [OP_SYNC](op) {
    const value = internalCall(() => op.effect_instruction_i0());
    const cont = this.getNextSuccessCont();
    if (cont !== undefined) {
      if (!(cont._op in contOpSuccess)) {
        // @ts-expect-error
        absurd(cont);
      }
      // @ts-expect-error
      return contOpSuccess[cont._op](this, cont, value);
    } else {
      yieldedOpChannel.currentOp = exitSucceed$1(value);
      return YieldedOp;
    }
  }
  [OP_SUCCESS](op) {
    const oldCur = op;
    const cont = this.getNextSuccessCont();
    if (cont !== undefined) {
      if (!(cont._op in contOpSuccess)) {
        // @ts-expect-error
        absurd(cont);
      }
      // @ts-expect-error
      return contOpSuccess[cont._op](this, cont, oldCur.effect_instruction_i0);
    } else {
      yieldedOpChannel.currentOp = oldCur;
      return YieldedOp;
    }
  }
  [OP_FAILURE](op) {
    const cause = op.effect_instruction_i0;
    const cont = this.getNextFailCont();
    if (cont !== undefined) {
      switch (cont._op) {
        case OP_ON_FAILURE:
        case OP_ON_SUCCESS_AND_FAILURE:
          {
            if (!(interruptible$2(this.currentRuntimeFlags) && this.isInterrupted())) {
              return internalCall(() => cont.effect_instruction_i1(cause));
            } else {
              return exitFailCause$1(stripFailures(cause));
            }
          }
        case "OnStep":
          {
            if (!(interruptible$2(this.currentRuntimeFlags) && this.isInterrupted())) {
              return exitSucceed$1(exitFailCause$1(cause));
            } else {
              return exitFailCause$1(stripFailures(cause));
            }
          }
        case OP_REVERT_FLAGS:
          {
            this.patchRuntimeFlags(this.currentRuntimeFlags, cont.patch);
            if (interruptible$2(this.currentRuntimeFlags) && this.isInterrupted()) {
              return exitFailCause$1(sequential$2(cause, this.getInterruptedCause()));
            } else {
              return exitFailCause$1(cause);
            }
          }
        default:
          {
            absurd(cont);
          }
      }
    } else {
      yieldedOpChannel.currentOp = exitFailCause$1(cause);
      return YieldedOp;
    }
  }
  [OP_WITH_RUNTIME](op) {
    return internalCall(() => op.effect_instruction_i0(this, running(this.currentRuntimeFlags)));
  }
  ["Blocked"](op) {
    const refs = this.getFiberRefs();
    const flags = this.currentRuntimeFlags;
    if (this._steps.length > 0) {
      const frames = [];
      const snap = this._steps[this._steps.length - 1];
      let frame = this.popStack();
      while (frame && frame._op !== "OnStep") {
        frames.push(frame);
        frame = this.popStack();
      }
      this.setFiberRefs(snap.refs);
      this.currentRuntimeFlags = snap.flags;
      const patchRefs = diff$1(snap.refs, refs);
      const patchFlags = diff$3(snap.flags, flags);
      return exitSucceed$1(blocked(op.effect_instruction_i0, withFiberRuntime(newFiber => {
        while (frames.length > 0) {
          newFiber.pushStack(frames.pop());
        }
        newFiber.setFiberRefs(patch$1(newFiber.id(), newFiber.getFiberRefs())(patchRefs));
        newFiber.currentRuntimeFlags = patch$4(patchFlags)(newFiber.currentRuntimeFlags);
        return op.effect_instruction_i1;
      })));
    }
    return uninterruptibleMask$1(restore => flatMap$3(forkDaemon(runRequestBlock(op.effect_instruction_i0)), () => restore(op.effect_instruction_i1)));
  }
  ["RunBlocked"](op) {
    return runBlockedRequests(op.effect_instruction_i0);
  }
  [OP_UPDATE_RUNTIME_FLAGS](op) {
    const updateFlags = op.effect_instruction_i0;
    const oldRuntimeFlags = this.currentRuntimeFlags;
    const newRuntimeFlags = patch$4(oldRuntimeFlags, updateFlags);
    // One more chance to short circuit: if we're immediately going
    // to interrupt. Interruption will cause immediate reversion of
    // the flag, so as long as we "peek ahead", there's no need to
    // set them to begin with.
    if (interruptible$2(newRuntimeFlags) && this.isInterrupted()) {
      return exitFailCause$1(this.getInterruptedCause());
    } else {
      // Impossible to short circuit, so record the changes
      this.patchRuntimeFlags(this.currentRuntimeFlags, updateFlags);
      if (op.effect_instruction_i1) {
        // Since we updated the flags, we need to revert them
        const revertFlags = diff$3(newRuntimeFlags, oldRuntimeFlags);
        this.pushStack(new RevertFlags(revertFlags, op));
        return internalCall(() => op.effect_instruction_i1(oldRuntimeFlags));
      } else {
        return exitVoid$1;
      }
    }
  }
  [OP_ON_SUCCESS](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  ["OnStep"](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_SUCCESS_AND_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ASYNC](op) {
    this._asyncBlockingOn = op.effect_instruction_i1;
    this.initiateAsync(this.currentRuntimeFlags, op.effect_instruction_i0);
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_YIELD](op) {
    this._isYielding = false;
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_WHILE](op) {
    const check = op.effect_instruction_i0;
    const body = op.effect_instruction_i1;
    if (check()) {
      this.pushStack(op);
      return body();
    } else {
      return exitVoid$1;
    }
  }
  [OP_ITERATOR](op) {
    return contOpSuccess[OP_ITERATOR](this, op, undefined);
  }
  [OP_COMMIT](op) {
    return internalCall(() => op.commit());
  }
  /**
   * The main run-loop for evaluating effects.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  runLoop(effect0) {
    let cur = effect0;
    this.currentOpCount = 0;
    while (true) {
      if ((this.currentRuntimeFlags & OpSupervision) !== 0) {
        this.currentSupervisor.onEffect(this, cur);
      }
      if (this._queue.length > 0) {
        cur = this.drainQueueWhileRunning(this.currentRuntimeFlags, cur);
      }
      if (!this._isYielding) {
        this.currentOpCount += 1;
        const shouldYield = this.currentScheduler.shouldYield(this);
        if (shouldYield !== false) {
          this._isYielding = true;
          this.currentOpCount = 0;
          const oldCur = cur;
          cur = flatMap$3(yieldNow$2({
            priority: shouldYield
          }), () => oldCur);
        }
      }
      try {
        // @ts-expect-error
        cur = this.currentTracer.context(() => {
          if (_version !== cur[EffectTypeId]._V) {
            return dieMessage(`Cannot execute an Effect versioned ${cur[EffectTypeId]._V} with a Runtime of version ${getCurrentVersion()}`);
          }
          // @ts-expect-error
          return this[cur._op](cur);
        }, this);
        if (cur === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          if (op._op === OP_YIELD || op._op === OP_ASYNC) {
            return YieldedOp;
          }
          yieldedOpChannel.currentOp = null;
          return op._op === OP_SUCCESS || op._op === OP_FAILURE ? op : exitFailCause$1(die$1(op));
        }
      } catch (e) {
        if (cur !== YieldedOp && !hasProperty(cur, "_op") || !(cur._op in this)) {
          cur = dieMessage(`Not a valid effect: ${toStringUnknown(cur)}`);
        } else if (isInterruptedException(e)) {
          cur = exitFailCause$1(sequential$2(die$1(e), interrupt(none$2)));
        } else {
          cur = die(e);
        }
      }
    }
  }
  run = () => {
    this.drainQueueOnCurrentThread();
  };
}
// circular with Logger
/** @internal */
const currentMinimumLogLevel = /*#__PURE__*/globalValue("effect/FiberRef/currentMinimumLogLevel", () => fiberRefUnsafeMake(fromLiteral("Info")));
/** @internal */
const loggerWithConsoleLog = self => makeLogger(opts => {
  const services = getOrDefault(opts.context, currentServices);
  get$7(services, consoleTag).unsafe.log(self.log(opts));
});
/** @internal */
const defaultLogger = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for("effect/Logger/defaultLogger"), () => loggerWithConsoleLog(stringLogger));
/** @internal */
const tracerLogger = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for("effect/Logger/tracerLogger"), () => makeLogger(({
  annotations,
  cause,
  context,
  fiberId,
  logLevel,
  message
}) => {
  const span = getOption(getOrDefault$1(context, currentContext), spanTag);
  if (span._tag === "None" || span.value._tag === "ExternalSpan") {
    return;
  }
  const clockService = unsafeGet(getOrDefault$1(context, currentServices), clockTag);
  const attributes = {};
  for (const [key, value] of annotations) {
    attributes[key] = value;
  }
  attributes["effect.fiberId"] = threadName(fiberId);
  attributes["effect.logLevel"] = logLevel.label;
  if (cause !== null && cause._tag !== "Empty") {
    attributes["effect.cause"] = pretty(cause, {
      renderErrorCause: true
    });
  }
  span.value.event(toStringUnknown(Array.isArray(message) ? message[0] : message), clockService.unsafeCurrentTimeNanos(), attributes);
}));
/** @internal */
const currentLoggers = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for("effect/FiberRef/currentLoggers"), () => fiberRefUnsafeMakeHashSet(make$l(defaultLogger, tracerLogger)));
/* @internal */
const forEach$1 = /*#__PURE__*/dual(args => isIterable(args[0]), (self, f, options) => withFiberRuntime(r => {
  const isRequestBatchingEnabled = options?.batching === true || options?.batching === "inherit" && r.getFiberRef(currentRequestBatching);
  if (options?.discard) {
    return match(options.concurrency, () => finalizersMaskInternal(sequential, options?.concurrentFinalizers)(restore => isRequestBatchingEnabled ? forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), true, false, 1) : forEachSequentialDiscard(self, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel, options?.concurrentFinalizers)(restore => forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false)), n => finalizersMaskInternal(parallelN(n), options?.concurrentFinalizers)(restore => forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false, n)));
  }
  return match(options?.concurrency, () => finalizersMaskInternal(sequential, options?.concurrentFinalizers)(restore => isRequestBatchingEnabled ? forEachParN(self, 1, (a, i) => restore(f(a, i)), true) : forEachSequential(self, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel, options?.concurrentFinalizers)(restore => forEachParUnbounded(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)), n => finalizersMaskInternal(parallelN(n), options?.concurrentFinalizers)(restore => forEachParN(self, n, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)));
}));
/* @internal */
const forEachParUnbounded = (self, f, batching) => suspend$2(() => {
  const as = fromIterable$6(self);
  const array = new Array(as.length);
  const fn = (a, i) => flatMap$3(f(a, i), b => sync(() => array[i] = b));
  return zipRight(forEachConcurrentDiscard(as, fn, batching, false), succeed$3(array));
});
/** @internal */
const forEachConcurrentDiscard = (self, f, batching, processAll, n) => uninterruptibleMask$1(restore => transplant(graft => withFiberRuntime(parent => {
  let todos = Array.from(self).reverse();
  let target = todos.length;
  if (target === 0) {
    return void_$1;
  }
  let counter = 0;
  let interrupted = false;
  const fibersCount = n ? Math.min(todos.length, n) : todos.length;
  const fibers = new Set();
  const results = new Array();
  const interruptAll = () => fibers.forEach(fiber => {
    fiber.currentScheduler.scheduleTask(() => {
      fiber.unsafeInterruptAsFork(parent.id());
    }, 0);
  });
  const startOrder = new Array();
  const joinOrder = new Array();
  const residual = new Array();
  const collectExits = () => {
    const exits = results.filter(({
      exit
    }) => exit._tag === "Failure").sort((a, b) => a.index < b.index ? -1 : a.index === b.index ? 0 : 1).map(({
      exit
    }) => exit);
    if (exits.length === 0) {
      exits.push(exitVoid$1);
    }
    return exits;
  };
  const runFiber = (eff, interruptImmediately = false) => {
    const runnable = uninterruptible(graft(eff));
    const fiber = unsafeForkUnstarted(runnable, parent, parent.currentRuntimeFlags, globalScope);
    parent.currentScheduler.scheduleTask(() => {
      if (interruptImmediately) {
        fiber.unsafeInterruptAsFork(parent.id());
      }
      fiber.resume(runnable);
    }, 0);
    return fiber;
  };
  const onInterruptSignal = () => {
    if (!processAll) {
      target -= todos.length;
      todos = [];
    }
    interrupted = true;
    interruptAll();
  };
  const stepOrExit = batching ? step : exit;
  const processingFiber = runFiber(async_(resume => {
    const pushResult = (res, index) => {
      if (res._op === "Blocked") {
        residual.push(res);
      } else {
        results.push({
          index,
          exit: res
        });
        if (res._op === "Failure" && !interrupted) {
          onInterruptSignal();
        }
      }
    };
    const next = () => {
      if (todos.length > 0) {
        const a = todos.pop();
        let index = counter++;
        const returnNextElement = () => {
          const a = todos.pop();
          index = counter++;
          return flatMap$3(yieldNow$2(), () => flatMap$3(stepOrExit(restore(f(a, index))), onRes));
        };
        const onRes = res => {
          if (todos.length > 0) {
            pushResult(res, index);
            if (todos.length > 0) {
              return returnNextElement();
            }
          }
          return succeed$3(res);
        };
        const todo = flatMap$3(stepOrExit(restore(f(a, index))), onRes);
        const fiber = runFiber(todo);
        startOrder.push(fiber);
        fibers.add(fiber);
        if (interrupted) {
          fiber.currentScheduler.scheduleTask(() => {
            fiber.unsafeInterruptAsFork(parent.id());
          }, 0);
        }
        fiber.addObserver(wrapped => {
          let exit;
          if (wrapped._op === "Failure") {
            exit = wrapped;
          } else {
            exit = wrapped.effect_instruction_i0;
          }
          joinOrder.push(fiber);
          fibers.delete(fiber);
          pushResult(exit, index);
          if (results.length === target) {
            resume(succeed$3(getOrElse(exitCollectAll(collectExits(), {
              parallel: true
            }), () => exitVoid$1)));
          } else if (residual.length + results.length === target) {
            const requests = residual.map(blocked => blocked.effect_instruction_i0).reduce(par);
            resume(succeed$3(blocked(requests, forEachConcurrentDiscard([getOrElse(exitCollectAll(collectExits(), {
              parallel: true
            }), () => exitVoid$1), ...residual.map(blocked => blocked.effect_instruction_i1)], i => i, batching, true, n))));
          } else {
            next();
          }
        });
      }
    };
    for (let i = 0; i < fibersCount; i++) {
      next();
    }
  }));
  return asVoid(onExit$1(flatten(restore(join(processingFiber))), exitMatch({
    onFailure: () => {
      onInterruptSignal();
      const target = residual.length + 1;
      const concurrency = Math.min(typeof n === "number" ? n : residual.length, residual.length);
      const toPop = Array.from(residual);
      return async_(cb => {
        const exits = [];
        let count = 0;
        let index = 0;
        const check = (index, hitNext) => exit => {
          exits[index] = exit;
          count++;
          if (count === target) {
            cb(getOrThrow(exitCollectAll(exits, {
              parallel: true
            })));
          }
          if (toPop.length > 0 && hitNext) {
            next();
          }
        };
        const next = () => {
          runFiber(toPop.pop(), true).addObserver(check(index, true));
          index++;
        };
        processingFiber.addObserver(check(index, false));
        index++;
        for (let i = 0; i < concurrency; i++) {
          next();
        }
      });
    },
    onSuccess: () => forEachSequential(joinOrder, f => f.inheritAll)
  })));
})));
/* @internal */
const forEachParN = (self, n, f, batching) => suspend$2(() => {
  const as = fromIterable$6(self);
  const array = new Array(as.length);
  const fn = (a, i) => map$2(f(a, i), b => array[i] = b);
  return zipRight(forEachConcurrentDiscard(as, fn, batching, false, n), succeed$3(array));
});
/* @internal */
const forkDaemon = self => forkWithScopeOverride(self, globalScope);
/** @internal */
const unsafeFork$1 = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);
  childFiber.resume(effect);
  return childFiber;
};
/** @internal */
const unsafeForkUnstarted = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);
  return childFiber;
};
/** @internal */
const unsafeMakeChildFiber = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childId = unsafeMake$3();
  const parentFiberRefs = parentFiber.getFiberRefs();
  const childFiberRefs = forkAs(parentFiberRefs, childId);
  const childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags);
  const childContext = getOrDefault$1(childFiberRefs, currentContext);
  const supervisor = childFiber.currentSupervisor;
  supervisor.onStart(childContext, effect, some(parentFiber), childFiber);
  childFiber.addObserver(exit => supervisor.onEnd(exit, childFiber));
  const parentScope = overrideScope !== null ? overrideScope : pipe(parentFiber.getFiberRef(currentForkScopeOverride), getOrElse(() => parentFiber.scope()));
  parentScope.add(parentRuntimeFlags, childFiber);
  return childFiber;
};
/* @internal */
const forkWithScopeOverride = (self, scopeOverride) => withFiberRuntime((parentFiber, parentStatus) => succeed$3(unsafeFork$1(self, parentFiber, parentStatus.runtimeFlags, scopeOverride)));
/* @internal */
const parallelFinalizers = self => contextWithEffect(context => match$3(getOption(context, scopeTag), {
  onNone: () => self,
  onSome: scope => {
    switch (scope.strategy._tag) {
      case "Parallel":
        return self;
      case "Sequential":
      case "ParallelN":
        return flatMap$3(scopeFork(scope, parallel), inner => scopeExtend(self, inner));
    }
  }
}));
/* @internal */
const parallelNFinalizers = parallelism => self => contextWithEffect(context => match$3(getOption(context, scopeTag), {
  onNone: () => self,
  onSome: scope => {
    if (scope.strategy._tag === "ParallelN" && scope.strategy.parallelism === parallelism) {
      return self;
    }
    return flatMap$3(scopeFork(scope, parallelN(parallelism)), inner => scopeExtend(self, inner));
  }
}));
/* @internal */
const finalizersMaskInternal = (strategy, concurrentFinalizers) => self => contextWithEffect(context => match$3(getOption(context, scopeTag), {
  onNone: () => self(identity),
  onSome: scope => {
    if (concurrentFinalizers === true) {
      const patch = strategy._tag === "Parallel" ? parallelFinalizers : strategy._tag === "Sequential" ? sequentialFinalizers : parallelNFinalizers(strategy.parallelism);
      switch (scope.strategy._tag) {
        case "Parallel":
          return patch(self(parallelFinalizers));
        case "Sequential":
          return patch(self(sequentialFinalizers));
        case "ParallelN":
          return patch(self(parallelNFinalizers(scope.strategy.parallelism)));
      }
    } else {
      return self(identity);
    }
  }
}));
/* @internal */
const sequentialFinalizers = self => contextWithEffect(context => match$3(getOption(context, scopeTag), {
  onNone: () => self,
  onSome: scope => {
    switch (scope.strategy._tag) {
      case "Sequential":
        return self;
      case "Parallel":
      case "ParallelN":
        return flatMap$3(scopeFork(scope, sequential), inner => scopeExtend(self, inner));
    }
  }
}));
// circular with Scope
/** @internal */
const scopeTag = /*#__PURE__*/GenericTag("effect/Scope");
/* @internal */
const scopeExtend = /*#__PURE__*/dual(2, (effect, scope) => mapInputContext(effect,
// @ts-expect-error
merge$1(make$j(scopeTag, scope))));
// circular with Supervisor
/** @internal */
const fiberRefUnsafeMakeSupervisor = initial => fiberRefUnsafeMakePatch(initial, {
  differ: differ,
  fork: empty
});
/** @internal */
const currentRuntimeFlags = /*#__PURE__*/fiberRefUnsafeMakeRuntimeFlags(none$1);
/** @internal */
const currentSupervisor = /*#__PURE__*/fiberRefUnsafeMakeSupervisor(none);
/** @internal */
const invokeWithInterrupt = (self, entries, onInterrupt) => fiberIdWith(id => flatMap$3(flatMap$3(forkDaemon(interruptible$1(self)), processing => async_(cb => {
  const counts = entries.map(_ => _.listeners.count);
  const checkDone = () => {
    if (counts.every(count => count === 0)) {
      if (entries.every(_ => {
        if (_.result.state.current._tag === "Pending") {
          return true;
        } else if (_.result.state.current._tag === "Done" && exitIsExit(_.result.state.current.effect) && _.result.state.current.effect._tag === "Failure" && isInterrupted(_.result.state.current.effect.cause)) {
          return true;
        } else {
          return false;
        }
      })) {
        cleanup.forEach(f => f());
        onInterrupt?.();
        cb(interruptFiber(processing));
      }
    }
  };
  processing.addObserver(exit => {
    cleanup.forEach(f => f());
    cb(exit);
  });
  const cleanup = entries.map((r, i) => {
    const observer = count => {
      counts[i] = count;
      checkDone();
    };
    r.listeners.addObserver(observer);
    return () => r.listeners.removeObserver(observer);
  });
  checkDone();
  return sync(() => {
    cleanup.forEach(f => f());
  });
})), () => suspend$2(() => {
  const residual = entries.flatMap(entry => {
    if (!entry.state.completed) {
      return [entry];
    }
    return [];
  });
  return forEachSequentialDiscard(residual, entry => complete(entry.request, exitInterrupt$1(id)));
})));

/**
 * @since 2.0.0
 */
/**
 * Closes this scope with the specified exit value, running all finalizers that
 * have been added to the scope.
 *
 * @since 2.0.0
 * @category destructors
 */
const close = scopeClose;
/**
 * Forks a new child scope with the specified execution strategy. The child scope
 * will automatically be closed when this scope is closed.
 *
 * @since 2.0.0
 * @category utils
 */
const fork = scopeFork;

// circular with Layer
/** @internal */
const TypeId$2 = /*#__PURE__*/Symbol.for("effect/ManagedRuntime");

/** @internal */
const unsafeFork = runtime => (self, options) => {
  const fiberId = unsafeMake$3();
  const fiberRefUpdates = [[currentContext, [[fiberId, runtime.context]]]];
  if (options?.scheduler) {
    fiberRefUpdates.push([currentScheduler, [[fiberId, options.scheduler]]]);
  }
  let fiberRefs = updateManyAs(runtime.fiberRefs, {
    entries: fiberRefUpdates,
    forkAs: fiberId
  });
  if (options?.updateRefs) {
    fiberRefs = options.updateRefs(fiberRefs, fiberId);
  }
  const fiberRuntime = new FiberRuntime(fiberId, fiberRefs, runtime.runtimeFlags);
  let effect = self;
  if (options?.scope) {
    effect = flatMap$3(fork(options.scope, sequential$1), closeableScope => zipRight(scopeAddFinalizer(closeableScope, fiberIdWith(id => equals$2(id, fiberRuntime.id()) ? void_$1 : interruptAsFiber(fiberRuntime, id))), onExit$1(self, exit => close(closeableScope, exit))));
  }
  const supervisor = fiberRuntime.currentSupervisor;
  // we can compare by reference here as _supervisor.none is wrapped with globalValue
  if (supervisor !== none) {
    supervisor.onStart(runtime.context, effect, none$4(), fiberRuntime);
    fiberRuntime.addObserver(exit => supervisor.onEnd(exit, fiberRuntime));
  }
  globalScope.add(runtime.runtimeFlags, fiberRuntime);
  // Only an explicit false will prevent immediate execution
  if (options?.immediate === false) {
    fiberRuntime.resume(effect);
  } else {
    fiberRuntime.start(effect);
  }
  return fiberRuntime;
};
/** @internal */
const unsafeRunSync = runtime => effect => {
  const result = unsafeRunSyncExit(runtime)(effect);
  if (result._tag === "Failure") {
    throw fiberFailure(result.effect_instruction_i0);
  } else {
    return result.effect_instruction_i0;
  }
};
class AsyncFiberExceptionImpl extends Error {
  fiber;
  _tag = "AsyncFiberException";
  constructor(fiber) {
    super(`Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`);
    this.fiber = fiber;
    this.name = this._tag;
    this.stack = this.message;
  }
}
const asyncFiberException = fiber => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error = new AsyncFiberExceptionImpl(fiber);
  Error.stackTraceLimit = limit;
  return error;
};
/** @internal */
const FiberFailureId = /*#__PURE__*/Symbol.for("effect/Runtime/FiberFailure");
/** @internal */
const FiberFailureCauseId = /*#__PURE__*/Symbol.for("effect/Runtime/FiberFailure/Cause");
class FiberFailureImpl extends Error {
  [FiberFailureId];
  [FiberFailureCauseId];
  constructor(cause) {
    super();
    this[FiberFailureId] = FiberFailureId;
    this[FiberFailureCauseId] = cause;
    const prettyErrors$1 = prettyErrors(cause);
    if (prettyErrors$1.length > 0) {
      const head = prettyErrors$1[0];
      this.name = head.name;
      this.message = head.message;
      this.stack = head.stack;
    }
    this.name = `(FiberFailure) ${this.name}`;
    if (this.message === undefined || this.message.length === 0) {
      this.message = "An error has occurred";
    }
  }
  toJSON() {
    return {
      _id: "FiberFailure",
      cause: this[FiberFailureCauseId].toJSON()
    };
  }
  toString() {
    return "(FiberFailure) " + (this.stack ?? this.message);
  }
  [NodeInspectSymbol]() {
    return this.toString();
  }
}
/** @internal */
const fiberFailure = cause => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error = new FiberFailureImpl(cause);
  Error.stackTraceLimit = limit;
  return error;
};
const fastPath = effect => {
  const op = effect;
  switch (op._op) {
    case "Failure":
    case "Success":
      {
        // @ts-expect-error
        return op;
      }
    case "Left":
      {
        return exitFail(op.left);
      }
    case "Right":
      {
        return exitSucceed$1(op.right);
      }
    case "Some":
      {
        return exitSucceed$1(op.value);
      }
    case "None":
      {
        // @ts-expect-error
        return exitFail(NoSuchElementException());
      }
  }
};
/** @internal */
const unsafeRunSyncExit = runtime => effect => {
  const op = fastPath(effect);
  if (op) {
    return op;
  }
  const scheduler = new SyncScheduler();
  const fiberRuntime = unsafeFork(runtime)(effect, {
    scheduler
  });
  scheduler.flush();
  const result = fiberRuntime.unsafePoll();
  if (result) {
    return result;
  }
  return exitDie$1(capture(asyncFiberException(fiberRuntime), currentSpanFromFiber(fiberRuntime)));
};
/** @internal */
class RuntimeImpl {
  context;
  runtimeFlags;
  fiberRefs;
  constructor(context, runtimeFlags, fiberRefs) {
    this.context = context;
    this.runtimeFlags = runtimeFlags;
    this.fiberRefs = fiberRefs;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
/** @internal */
const make$4 = options => new RuntimeImpl(options.context, options.runtimeFlags, options.fiberRefs);
/** @internal */
const defaultRuntimeFlags = /*#__PURE__*/make$e(Interruption, CooperativeYielding, RuntimeMetrics);
/** @internal */
const defaultRuntime = /*#__PURE__*/make$4({
  context: /*#__PURE__*/empty$c(),
  runtimeFlags: defaultRuntimeFlags,
  fiberRefs: /*#__PURE__*/empty$3()
});
/** @internal */
const unsafeRunSyncEffect = /*#__PURE__*/unsafeRunSync(defaultRuntime);

/**
 * Checks if a given value is an `Effect` value.
 *
 * **When to Use**
 *
 * This function can be useful for checking the type of a value before
 * attempting to operate on it as an `Effect` value. For example, you could use
 * `Effect.isEffect` to check the type of a value before using it as an argument
 * to a function that expects an `Effect` value.
 *
 * @since 2.0.0
 * @category Guards
 */
const isEffect = isEffect$1;
/**
 * Executes an effectful operation for each element in an `Iterable`.
 *
 * **Details**
 *
 * This function applies a provided operation to each element in the iterable,
 * producing a new effect that returns an array of results.
 *
 * If any effect fails, the iteration stops immediately (short-circuiting), and
 * the error is propagated.
 *
 * **Concurrency**
 *
 * The `concurrency` option controls how many operations are performed
 * concurrently. By default, the operations are performed sequentially.
 *
 * **Discarding Results**
 *
 * If the `discard` option is set to `true`, the intermediate results are not
 * collected, and the final result of the operation is `void`.
 *
 * @see {@link all} for combining multiple effects into one.
 *
 * @example
 * ```ts
 * // Title: Applying Effects to Iterable Elements
 * import { Effect, Console } from "effect"
 *
 * const result = Effect.forEach([1, 2, 3, 4, 5], (n, index) =>
 *   Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2))
 * )
 *
 * // Effect.runPromise(result).then(console.log)
 * // Output:
 * // Currently at index 0
 * // Currently at index 1
 * // Currently at index 2
 * // Currently at index 3
 * // Currently at index 4
 * // [ 2, 4, 6, 8, 10 ]
 * ```
 *
 * @example
 * // Title: Using discard to Ignore Results
 * import { Effect, Console } from "effect"
 *
 * // Apply effects but discard the results
 * const result = Effect.forEach(
 *   [1, 2, 3, 4, 5],
 *   (n, index) =>
 *     Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2)),
 *   { discard: true }
 * )
 *
 * // Effect.runPromise(result).then(console.log)
 * // Output:
 * // Currently at index 0
 * // Currently at index 1
 * // Currently at index 2
 * // Currently at index 3
 * // Currently at index 4
 * // undefined
 *
 * @since 2.0.0
 * @category Looping
 */
const forEach = forEach$1;
/**
 * Creates an `Effect` that always succeeds with a given value.
 *
 * **When to Use**
 *
 * Use this function when you need an effect that completes successfully with a
 * specific value without any errors or external dependencies.
 *
 * @see {@link fail} to create an effect that represents a failure.
 *
 * @example
 * ```ts
 * // Title: Creating a Successful Effect
 * import { Effect } from "effect"
 *
 * // Creating an effect that represents a successful scenario
 * //
 * //      ┌─── Effect<number, never, never>
 * //      ▼
 * const success = Effect.succeed(42)
 * ```
 *
 * @since 2.0.0
 * @category Creating Effects
 */
const succeed$1 = succeed$3;
/**
 * Delays the creation of an `Effect` until it is actually needed.
 *
 * **Details**
 *
 * The `Effect.suspend` function takes a thunk that represents the effect and
 * wraps it in a suspended effect. This means the effect will not be created
 * until it is explicitly needed, which is helpful in various scenarios:
 * - **Lazy Evaluation**: Helps optimize performance by deferring computations,
 *   especially when the effect might not be needed, or when its computation is
 *   expensive. This also ensures that any side effects or scoped captures are
 *   re-executed on each invocation.
 * - **Handling Circular Dependencies**: Useful in managing circular
 *   dependencies, such as recursive functions that need to avoid eager
 *   evaluation to prevent stack overflow.
 * - **Unifying Return Types**: Can help TypeScript unify return types in
 *   situations where multiple branches of logic return different effects,
 *   simplifying type inference.
 *
 * **When to Use**
 *
 * Use this function when you need to defer the evaluation of an effect until it
 * is required. This is particularly useful for optimizing expensive
 * computations, managing circular dependencies, or resolving type inference
 * issues.
 *
 * @example
 * ```ts
 * // Title: Lazy Evaluation with Side Effects
 * import { Effect } from "effect"
 *
 * let i = 0
 *
 * const bad = Effect.succeed(i++)
 *
 * const good = Effect.suspend(() => Effect.succeed(i++))
 *
 * console.log(Effect.runSync(bad)) // Output: 0
 * console.log(Effect.runSync(bad)) // Output: 0
 *
 * console.log(Effect.runSync(good)) // Output: 1
 * console.log(Effect.runSync(good)) // Output: 2
 * ```
 *
 * @example
 * // Title: Recursive Fibonacci
 * import { Effect } from "effect"
 *
 * const blowsUp = (n: number): Effect.Effect<number> =>
 *   n < 2
 *     ? Effect.succeed(1)
 *     : Effect.zipWith(blowsUp(n - 1), blowsUp(n - 2), (a, b) => a + b)
 *
 * // console.log(Effect.runSync(blowsUp(32)))
 * // crash: JavaScript heap out of memory
 *
 * const allGood = (n: number): Effect.Effect<number> =>
 *   n < 2
 *     ? Effect.succeed(1)
 *     : Effect.zipWith(
 *         Effect.suspend(() => allGood(n - 1)),
 *         Effect.suspend(() => allGood(n - 2)),
 *         (a, b) => a + b
 *       )
 *
 * console.log(Effect.runSync(allGood(32)))
 * // Output: 3524578
 *
 * @example
 * // Title: Using Effect.suspend to Help TypeScript Infer Types
 * import { Effect } from "effect"
 *
 * //   Without suspend, TypeScript may struggle with type inference.
 * //   Inferred type:
 * //     (a: number, b: number) =>
 * //       Effect<never, Error, never> | Effect<number, never, never>
 * const withoutSuspend = (a: number, b: number) =>
 *   b === 0
 *     ? Effect.fail(new Error("Cannot divide by zero"))
 *     : Effect.succeed(a / b)
 *
 * //   Using suspend to unify return types.
 * //   Inferred type:
 * //     (a: number, b: number) => Effect<number, Error, never>
 * const withSuspend = (a: number, b: number) =>
 *   Effect.suspend(() =>
 *     b === 0
 *       ? Effect.fail(new Error("Cannot divide by zero"))
 *       : Effect.succeed(a / b)
 *   )
 *
 * @since 2.0.0
 * @category Creating Effects
 */
const suspend$1 = suspend$2;
const _void = void_$1;
/**
 * Handles all errors in an effect by providing a fallback effect.
 *
 * **Details**
 *
 * This function catches any errors that may occur during the execution of an
 * effect and allows you to handle them by specifying a fallback effect. This
 * ensures that the program continues without failing by recovering from errors
 * using the provided fallback logic.
 *
 * **Note**: This function only handles recoverable errors. It will not recover
 * from unrecoverable defects.
 *
 * @see {@link catchAllCause} for a version that can recover from both
 * recoverable and unrecoverable errors.
 *
 * @example
 * ```ts
 * // Title: Providing Recovery Logic for Recoverable Errors
 * import { Effect, Random } from "effect"
 *
 * class HttpError {
 *   readonly _tag = "HttpError"
 * }
 *
 * class ValidationError {
 *   readonly _tag = "ValidationError"
 * }
 *
 * //      ┌─── Effect<string, HttpError | ValidationError, never>
 * //      ▼
 * const program = Effect.gen(function* () {
 *   const n1 = yield* Random.next
 *   const n2 = yield* Random.next
 *   if (n1 < 0.5) {
 *     yield* Effect.fail(new HttpError())
 *   }
 *   if (n2 < 0.5) {
 *     yield* Effect.fail(new ValidationError())
 *   }
 *   return "some result"
 * })
 *
 * //      ┌─── Effect<string, never, never>
 * //      ▼
 * const recovered = program.pipe(
 *   Effect.catchAll((error) =>
 *     Effect.succeed(`Recovering from ${error._tag}`)
 *   )
 * )
 * ```
 *
 * @since 2.0.0
 * @category Error handling
 */
const catchAll = catchAll$1;
/**
 * Transforms the value inside an effect by applying a function to it.
 *
 * **Syntax**
 *
 * ```ts
 * const mappedEffect = pipe(myEffect, Effect.map(transformation))
 * // or
 * const mappedEffect = Effect.map(myEffect, transformation)
 * // or
 * const mappedEffect = myEffect.pipe(Effect.map(transformation))
 * ```
 *
 * **Details**
 *
 * `map` takes a function and applies it to the value contained within an
 * effect, creating a new effect with the transformed value.
 *
 * It's important to note that effects are immutable, meaning that the original
 * effect is not modified. Instead, a new effect is returned with the updated
 * value.
 *
 * @see {@link mapError} for a version that operates on the error channel.
 * @see {@link mapBoth} for a version that operates on both channels.
 * @see {@link flatMap} or {@link andThen} for a version that can return a new effect.
 *
 * @example
 * ```ts
 * // Title: Adding a Service Charge
 * import { pipe, Effect } from "effect"
 *
 * const addServiceCharge = (amount: number) => amount + 1
 *
 * const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))
 *
 * const finalAmount = pipe(
 *   fetchTransactionAmount,
 *   Effect.map(addServiceCharge)
 * )
 *
 * // Effect.runPromise(finalAmount).then(console.log)
 * // Output: 101
 * ```
 * @since 2.0.0
 * @category Mapping
 */
const map$1 = map$2;
/**
 * Transforms or modifies the error produced by an effect without affecting its
 * success value.
 *
 * **When to Use**
 *
 * This function is helpful when you want to enhance the error with additional
 * information, change the error type, or apply custom error handling while
 * keeping the original behavior of the effect's success values intact. It only
 * operates on the error channel and leaves the success channel unchanged.
 *
 * @see {@link map} for a version that operates on the success channel.
 * @see {@link mapBoth} for a version that operates on both channels.
 * @see {@link orElseFail} if you want to replace the error with a new one.
 *
 * @example
 * ```ts
 * import { Effect } from "effect"
 *
 * //      ┌─── Effect<number, string, never>
 * //      ▼
 * const simulatedTask = Effect.fail("Oh no!").pipe(Effect.as(1))
 *
 * //      ┌─── Effect<number, Error, never>
 * //      ▼
 * const mapped = Effect.mapError(
 *   simulatedTask,
 *   (message) => new Error(message)
 * )
 * ```
 *
 * @since 2.0.0
 * @category Mapping
 */
const mapError$1 = mapError$2;
/**
 * Encapsulates both success and failure of an `Effect` into an `Either` type.
 *
 * **Details**
 *
 * This function converts an effect that may fail into an effect that always
 * succeeds, wrapping the outcome in an `Either` type. The result will be
 * `Either.Left` if the effect fails, containing the error, or `Either.Right` if
 * it succeeds, containing the result.
 *
 * Using this function, you can handle errors explicitly without causing the
 * effect to fail. This can be especially useful in scenarios where you want to
 * chain effects and deal with success and failure in the same logical flow.
 *
 * The resulting effect cannot fail directly because failures are represented
 * inside the `Either` type.
 *
 * @see {@link option} for a version that uses `Option` instead.
 * @see {@link exit} for a version that uses `Exit` instead.
 *
 * @example
 * ```ts
 * import { Effect, Either, Random } from "effect"
 *
 * class HttpError {
 *   readonly _tag = "HttpError"
 * }
 *
 * class ValidationError {
 *   readonly _tag = "ValidationError"
 * }
 *
 * //      ┌─── Effect<string, HttpError | ValidationError, never>
 * //      ▼
 * const program = Effect.gen(function* () {
 *   const n1 = yield* Random.next
 *   const n2 = yield* Random.next
 *   if (n1 < 0.5) {
 *     yield* Effect.fail(new HttpError())
 *   }
 *   if (n2 < 0.5) {
 *     yield* Effect.fail(new ValidationError())
 *   }
 *   return "some result"
 * })
 *
 * //      ┌─── Effect<string, never, never>
 * //      ▼
 * const recovered = Effect.gen(function* () {
 *   //      ┌─── Either<string, HttpError | ValidationError>
 *   //      ▼
 *   const failureOrSuccess = yield* Effect.either(program)
 *   return Either.match(failureOrSuccess, {
 *     onLeft: (error) => `Recovering from ${error._tag}`,
 *     onRight: (value) => value // Do nothing in case of success
 *   })
 * })
 * ```
 *
 * @since 2.0.0
 * @category Outcome Encapsulation
 */
const either = either$1;
/**
 * Chains effects to produce new `Effect` instances, useful for combining
 * operations that depend on previous results.
 *
 * **Syntax**
 * ```ts
 * const flatMappedEffect = pipe(myEffect, Effect.flatMap(transformation))
 * // or
 * const flatMappedEffect = Effect.flatMap(myEffect, transformation)
 * // or
 * const flatMappedEffect = myEffect.pipe(Effect.flatMap(transformation))
 * ```
 *
 * **Details**
 *
 * `flatMap` lets you sequence effects so that the result of one effect can be
 * used in the next step. It is similar to `flatMap` used with arrays but works
 * specifically with `Effect` instances, allowing you to avoid deeply nested
 * effect structures.
 *
 * Since effects are immutable, `flatMap` always returns a new effect instead of
 * changing the original one.
 *
 * **When to Use**
 *
 * Use `flatMap` when you need to chain multiple effects, ensuring that each
 * step produces a new `Effect` while flattening any nested effects that may
 * occur.
 *
 * @see {@link tap} for a version that ignores the result of the effect.
 *
 * @example
 * ```ts
 * import { pipe, Effect } from "effect"
 *
 * // Function to apply a discount safely to a transaction amount
 * const applyDiscount = (
 *   total: number,
 *   discountRate: number
 * ): Effect.Effect<number, Error> =>
 *   discountRate === 0
 *     ? Effect.fail(new Error("Discount rate cannot be zero"))
 *     : Effect.succeed(total - (total * discountRate) / 100)
 *
 * // Simulated asynchronous task to fetch a transaction amount from database
 * const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))
 *
 * // Chaining the fetch and discount application using `flatMap`
 * const finalAmount = pipe(
 *   fetchTransactionAmount,
 *   Effect.flatMap((amount) => applyDiscount(amount, 5))
 * )
 *
 * // Effect.runPromise(finalAmount).then(console.log)
 * // Output: 95
 * ```
 *
 * @since 2.0.0
 * @category Sequencing
 */
const flatMap$1 = flatMap$3;
/**
 * Handles both success and failure cases of an effect, allowing for additional
 * side effects.
 *
 * **Details**
 *
 * The `matchEffect` function is similar to {@link match}, but it enables you to
 * perform side effects in the handlers for both success and failure outcomes.
 *
 * **When to Use**
 *
 * This is useful when you need to execute additional actions, like logging or
 * notifying users, based on whether an effect succeeds or fails.
 *
 * @see {@link match} if you don't need side effects and only want to handle the
 * result or failure.
 *
 * @example
 * ```ts
 * // Title: Handling Both Success and Failure Cases with Side Effects
 * import { Effect } from "effect"
 *
 * const success: Effect.Effect<number, Error> = Effect.succeed(42)
 * const failure: Effect.Effect<number, Error> = Effect.fail(
 *   new Error("Uh oh!")
 * )
 *
 * const program1 = Effect.matchEffect(success, {
 *   onFailure: (error) =>
 *     Effect.succeed(`failure: ${error.message}`).pipe(
 *       Effect.tap(Effect.log)
 *     ),
 *   onSuccess: (value) =>
 *     Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))
 * })
 *
 * console.log(Effect.runSync(program1))
 * // Output:
 * // timestamp=... level=INFO fiber=#0 message="success: 42"
 * // success: 42
 *
 * const program2 = Effect.matchEffect(failure, {
 *   onFailure: (error) =>
 *     Effect.succeed(`failure: ${error.message}`).pipe(
 *       Effect.tap(Effect.log)
 *     ),
 *   onSuccess: (value) =>
 *     Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))
 * })
 *
 * console.log(Effect.runSync(program2))
 * // Output:
 * // timestamp=... level=INFO fiber=#1 message="failure: Uh oh!"
 * // failure: Uh oh!
 * ```
 *
 * @since 2.0.0
 * @category Matching
 */
const matchEffect = matchEffect$1;
/**
 * Attempts one effect, and if it fails, falls back to another effect.
 *
 * **Details**
 *
 * This function allows you to try executing an effect, and if it fails
 * (produces an error), a fallback effect is executed instead. The fallback
 * effect is defined as a lazy argument, meaning it will only be evaluated if
 * the first effect fails. This provides a way to recover from errors by
 * specifying an alternative path of execution.
 *
 * The error type of the resulting effect will be that of the fallback effect,
 * as the first effect's error is replaced when the fallback is executed.
 *
 * @see {@link catchAll} if you need to access the error in the fallback effect.
 *
 * @example
 * ```ts
 * import { Effect } from "effect"
 *
 * const success = Effect.succeed("success")
 * const failure = Effect.fail("failure")
 * const fallback = Effect.succeed("fallback")
 *
 * // Try the success effect first, fallback is not used
 * const program1 = Effect.orElse(success, () => fallback)
 * console.log(Effect.runSync(program1))
 * // Output: "success"
 *
 * // Try the failure effect first, fallback is used
 * const program2 = Effect.orElse(failure, () => fallback)
 * console.log(Effect.runSync(program2))
 * // Output: "fallback"
 * ```
 *
 * @since 2.0.0
 * @category Fallback
 */
const orElse = orElse$1;
/**
 * Executes an effect synchronously, running it immediately and returning the
 * result.
 *
 * **Details**
 *
 * This function evaluates the provided effect synchronously, returning its
 * result directly. It is ideal for effects that do not fail or include
 * asynchronous operations. If the effect does fail or involves async tasks, it
 * will throw an error. Execution stops at the point of failure or asynchronous
 * operation, making it unsuitable for effects that require asynchronous
 * handling.
 *
 * **Important**: Attempting to run effects that involve asynchronous operations
 * or failures will result in exceptions being thrown, so use this function with
 * care for purely synchronous and error-free effects.
 *
 * **When to Use**
 *
 * Use this function when:
 * - You are sure that the effect will not fail or involve asynchronous
 *   operations.
 * - You need a direct, synchronous result from the effect.
 * - You are working within a context where asynchronous effects are not
 *   allowed.
 *
 * Avoid using this function for effects that can fail or require asynchronous
 * handling. For such cases, consider using {@link runPromise} or
 * {@link runSyncExit}.
 *
 * @see {@link runSyncExit} for a version that returns an `Exit` type instead of
 * throwing an error.
 *
 * @example
 * ```ts
 * // Title: Synchronous Logging
 * import { Effect } from "effect"
 *
 * const program = Effect.sync(() => {
 *   console.log("Hello, World!")
 *   return 1
 * })
 *
 * const result = Effect.runSync(program)
 * // Output: Hello, World!
 *
 * console.log(result)
 * // Output: 1
 * ```
 *
 * @example
 * // Title: Incorrect Usage with Failing or Async Effects
 * import { Effect } from "effect"
 *
 * try {
 *   // Attempt to run an effect that fails
 *   Effect.runSync(Effect.fail("my error"))
 * } catch (e) {
 *   console.error(e)
 * }
 * // Output:
 * // (FiberFailure) Error: my error
 *
 * try {
 *   // Attempt to run an effect that involves async work
 *   Effect.runSync(Effect.promise(() => Promise.resolve(1)))
 * } catch (e) {
 *   console.error(e)
 * }
 * // Output:
 * // (FiberFailure) AsyncFiberException: Fiber #0 cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work
 *
 * @since 2.0.0
 * @category Running Effects
 */
const runSync = unsafeRunSyncEffect;

/**
 * @since 0.67.0
 */
const make$3 = (value, forest = []) => ({
  value,
  forest
});
/**
 * @category formatting
 * @since 0.67.0
 */
const formatIssue = issue => map$1(go$1(issue), tree => drawTree(tree));
/**
 * @category formatting
 * @since 0.67.0
 */
const formatIssueSync = issue => runSync(formatIssue(issue));
const drawTree = tree => tree.value + draw("\n", tree.forest);
const draw = (indentation, forest) => {
  let r = "";
  const len = forest.length;
  let tree;
  for (let i = 0; i < len; i++) {
    tree = forest[i];
    const isLast = i === len - 1;
    r += indentation + (isLast ? "└" : "├") + "─ " + tree.value;
    r += draw(indentation + (len > 1 && !isLast ? "│  " : "   "), tree.forest);
  }
  return r;
};
const formatTransformationKind = kind => {
  switch (kind) {
    case "Encoded":
      return "Encoded side transformation failure";
    case "Transformation":
      return "Transformation process failure";
    case "Type":
      return "Type side transformation failure";
  }
};
const formatRefinementKind = kind => {
  switch (kind) {
    case "From":
      return "From side refinement failure";
    case "Predicate":
      return "Predicate refinement failure";
  }
};
const getInnerMessage = issue => {
  switch (issue._tag) {
    case "Refinement":
      {
        if (issue.kind === "From") {
          return getMessage(issue.error);
        }
        break;
      }
    case "Transformation":
      {
        return getMessage(issue.error);
      }
  }
  return none$4();
};
const getCurrentMessage = issue => getMessageAnnotation(issue.ast).pipe(flatMap$1(annotation => {
  const out = annotation(issue);
  return isString(out) ? succeed$1({
    message: out,
    override: false
  }) : isEffect(out) ? map$1(out, message => ({
    message,
    override: false
  })) : isString(out.message) ? succeed$1({
    message: out.message,
    override: out.override
  }) : map$1(out.message, message => ({
    message,
    override: out.override
  }));
}));
/** @internal */
const getMessage = issue => {
  const current = getCurrentMessage(issue);
  return getInnerMessage(issue).pipe(flatMap$1(inner => map$1(current, current => current.override ? current.message : inner)), catchAll(() => flatMap$1(current, current => {
    if (!current.override && (issue._tag === "Refinement" && issue.kind !== "Predicate" || issue._tag === "Transformation" && issue.kind !== "Transformation")) {
      return none$4();
    }
    return succeed$1(current.message);
  })));
};
const getParseIssueTitleAnnotation = issue => filterMap(getParseIssueTitleAnnotation$1(issue.ast), annotation => fromNullable(annotation(issue)));
/** @internal */
const formatTypeMessage = e => getMessage(e).pipe(orElse(() => getParseIssueTitleAnnotation(e)), orElse(() => e.message), catchAll(() => succeed$1(`Expected ${e.ast.toString(true)}, actual ${formatUnknown(e.actual)}`)));
const getParseIssueTitle = issue => getOrElse(getParseIssueTitleAnnotation(issue), () => String(issue.ast));
/** @internal */
const formatForbiddenMessage = e => getOrElse(e.message, () => "is forbidden");
const getTree = (issue, onFailure) => matchEffect(getMessage(issue), {
  onFailure,
  onSuccess: message => succeed$1(make$3(message))
});
const go$1 = e => {
  switch (e._tag) {
    case "Type":
      return map$1(formatTypeMessage(e), make$3);
    case "Forbidden":
      return succeed$1(make$3(getParseIssueTitle(e), [make$3(formatForbiddenMessage(e))]));
    case "Unexpected":
      return succeed$1(make$3(`is unexpected, expected ${e.ast.toString(true)}`));
    case "Missing":
      return succeed$1(make$3("is missing"));
    case "Union":
      return getTree(e, () => map$1(forEach(e.errors, e => {
        switch (e._tag) {
          case "Member":
            return map$1(go$1(e.error), tree => make$3(`Union member`, [tree]));
          default:
            return go$1(e);
        }
      }), forest => make$3(getParseIssueTitle(e), forest)));
    case "TupleType":
      return getTree(e, () => map$1(forEach(e.errors, index => map$1(go$1(index.error), tree => make$3(`[${formatPropertyKey$1(index.index)}]`, [tree]))), forest => make$3(getParseIssueTitle(e), forest)));
    case "TypeLiteral":
      return getTree(e, () => map$1(forEach(e.errors, key => map$1(go$1(key.error), tree => make$3(`[${formatPropertyKey$1(key.key)}]`, [tree]))), forest => make$3(getParseIssueTitle(e), forest)));
    case "Transformation":
      return getTree(e, () => map$1(go$1(e.error), tree => make$3(getParseIssueTitle(e), [make$3(formatTransformationKind(e.kind), [tree])])));
    case "Refinement":
      return getTree(e, () => map$1(go$1(e.error), tree => make$3(getParseIssueTitle(e), [make$3(formatRefinementKind(e.kind), [tree])])));
    case "Declaration":
      return getTree(e, () => {
        const error = e.error;
        const shouldSkipDefaultMessage = error._tag === "Type" && error.ast === e.ast;
        return shouldSkipDefaultMessage ? go$1(error) : map$1(go$1(error), tree => make$3(getParseIssueTitle(e), [tree]));
      });
  }
};

/**
 * Provides a constructor for a Case Class.
 *
 * @since 2.0.0
 * @category constructors
 */
const Error$1 = /*#__PURE__*/function () {
  const plainArgsSymbol = /*#__PURE__*/Symbol.for("effect/Data/Error/plainArgs");
  return class Base extends YieldableError {
    constructor(args) {
      super(args?.message, args?.cause ? {
        cause: args.cause
      } : undefined);
      if (args) {
        Object.assign(this, args);
        Object.defineProperty(this, plainArgsSymbol, {
          value: args,
          enumerable: false
        });
      }
    }
    toJSON() {
      return {
        ...this[plainArgsSymbol],
        ...this
      };
    }
  };
}();
/**
 * @since 2.0.0
 * @category constructors
 */
const TaggedError = tag => {
  class Base extends Error$1 {
    _tag = tag;
  }
  Base.prototype.name = tag;
  return Base;
};

/**
 * @since 0.67.0
 */
/**
 * Error that occurs when a declaration has an error.
 *
 * @category model
 * @since 0.67.0
 */
class Declaration {
  ast;
  actual;
  error;
  /**
   * @since 0.67.0
   */
  _tag = "Declaration";
  constructor(ast, actual, error) {
    this.ast = ast;
    this.actual = actual;
    this.error = error;
  }
}
/**
 * Error that occurs when a refinement has an error.
 *
 * @category model
 * @since 0.67.0
 */
class Refinement {
  ast;
  actual;
  kind;
  error;
  /**
   * @since 0.67.0
   */
  _tag = "Refinement";
  constructor(ast, actual, kind, error) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.error = error;
  }
}
/**
 * Error that occurs when an array or tuple has an error.
 *
 * @category model
 * @since 0.67.0
 */
class TupleType {
  ast;
  actual;
  errors;
  output;
  /**
   * @since 0.67.0
   */
  _tag = "TupleType";
  constructor(ast, actual, errors, output = []) {
    this.ast = ast;
    this.actual = actual;
    this.errors = errors;
    this.output = output;
  }
}
/**
 * The `Index` error indicates that there was an error at a specific index in an array or tuple.
 *
 * @category model
 * @since 0.67.0
 */
class Index {
  index;
  error;
  /**
   * @since 0.67.0
   */
  _tag = "Index";
  constructor(index, error) {
    this.index = index;
    this.error = error;
  }
}
/**
 * Error that occurs when a type literal or record has an error.
 *
 * @category model
 * @since 0.67.0
 */
class TypeLiteral {
  ast;
  actual;
  errors;
  output;
  /**
   * @since 0.67.0
   */
  _tag = "TypeLiteral";
  constructor(ast, actual, errors, output = {}) {
    this.ast = ast;
    this.actual = actual;
    this.errors = errors;
    this.output = output;
  }
}
/**
 * The `Key` variant of the `ParseIssue` type represents an error that occurs when a key in a type literal or record is invalid.
 *
 * @category model
 * @since 0.67.0
 */
let Key$2 = class Key {
  key;
  error;
  /**
   * @since 0.67.0
   */
  _tag = "Key";
  constructor(key, error) {
    this.key = key;
    this.error = error;
  }
};
/**
 * Error that occurs when an unexpected key or index is present.
 *
 * @category model
 * @since 0.67.0
 */
class Unexpected {
  ast;
  /**
   * @since 0.67.0
   */
  _tag = "Unexpected";
  constructor(ast) {
    this.ast = ast;
  }
}
/**
 * Error that occurs when a transformation has an error.
 *
 * @category model
 * @since 0.67.0
 */
class Transformation {
  ast;
  actual;
  kind;
  error;
  /**
   * @since 0.67.0
   */
  _tag = "Transformation";
  constructor(ast, actual, kind, error) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.error = error;
  }
}
/**
 * The `Type` variant of the `ParseIssue` type represents an error that occurs when the `actual` value is not of the expected type.
 * The `ast` field specifies the expected type, and the `actual` field contains the value that caused the error.
 *
 * @category model
 * @since 0.67.0
 */
class Type {
  ast;
  actual;
  /**
   * @since 0.67.0
   */
  _tag = "Type";
  /**
   * @since 0.67.0
   */
  message;
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = fromNullable(message);
  }
}
/**
 * The `Forbidden` variant of the `ParseIssue` type represents a forbidden operation, such as when encountering an Effect that is not allowed to execute (e.g., using `runSync`).
 *
 * @category model
 * @since 0.67.0
 */
class Forbidden {
  ast;
  actual;
  /**
   * @since 0.67.0
   */
  _tag = "Forbidden";
  /**
   * @since 0.67.0
   */
  message;
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = fromNullable(message);
  }
}
/**
 * Error that occurs when a required key or index is missing.
 *
 * @category model
 * @since 0.67.0
 */
class Missing {
  /**
   * @since 0.67.0
   */
  _tag = "Missing";
}
/**
 * @category constructors
 * @since 0.67.0
 */
const missing = /*#__PURE__*/new Missing();
/**
 * Error that occurs when a member in a union has an error.
 *
 * @category model
 * @since 0.67.0
 */
class Member {
  ast;
  error;
  /**
   * @since 0.67.0
   */
  _tag = "Member";
  constructor(ast, error) {
    this.ast = ast;
    this.error = error;
  }
}
/**
 * Error that occurs when a union has an error.
 *
 * @category model
 * @since 0.67.0
 */
let Union$1 = class Union {
  ast;
  actual;
  errors;
  /**
   * @since 0.67.0
   */
  _tag = "Union";
  constructor(ast, actual, errors) {
    this.ast = ast;
    this.actual = actual;
    this.errors = errors;
  }
};
/**
 * @since 0.67.0
 */
class ParseError extends TaggedError("ParseError") {
  get message() {
    return this.toString();
  }
  /**
   * @since 0.67.0
   */
  toString() {
    return formatIssueSync(this.error);
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _id: "ParseError",
      message: this.toString()
    };
  }
  /**
   * @since 0.67.0
   */
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
}
/**
 * @category constructors
 * @since 0.67.0
 */
const succeed = right;
/**
 * @category constructors
 * @since 0.67.0
 */
const fail = left;
/**
 * @category constructors
 * @since 0.67.0
 */
const fromOption = fromOption$1;
/**
 * @category optimisation
 * @since 0.67.0
 */
const flatMap = /*#__PURE__*/dual(2, (self, f) => {
  const s = self;
  if (s["_tag"] === "Left") {
    return s;
  }
  if (s["_tag"] === "Right") {
    return f(s.right);
  }
  return flatMap$1(self, f);
});
/**
 * @category optimisation
 * @since 0.67.0
 */
const map = /*#__PURE__*/dual(2, (self, f) => {
  const s = self;
  if (s["_tag"] === "Left") {
    return s;
  }
  if (s["_tag"] === "Right") {
    return right(f(s.right));
  }
  return map$1(self, f);
});
/**
 * @category optimisation
 * @since 0.67.0
 */
const mapError = /*#__PURE__*/dual(2, (self, f) => {
  const s = self;
  if (s["_tag"] === "Left") {
    return left(f(s.left));
  }
  if (s["_tag"] === "Right") {
    return s;
  }
  return mapError$1(self, f);
});
/**
 * @category optimisation
 * @since 0.67.0
 */
const eitherOrUndefined = self => {
  const s = self;
  if (s["_tag"] === "Left" || s["_tag"] === "Right") {
    return s;
  }
};
/** @internal */
const mergeParseOptions = (options, overrideOptions) => {
  if (overrideOptions === undefined || isNumber(overrideOptions)) {
    return options;
  }
  if (options === undefined) {
    return overrideOptions;
  }
  const out = {};
  out.errors = overrideOptions.errors ?? options.errors;
  out.onExcessProperty = overrideOptions.onExcessProperty ?? options.onExcessProperty;
  return out;
};
const getEither = (ast, isDecoding, options) => {
  const parser = goMemo(ast, isDecoding);
  return (u, overrideOptions) => parser(u, mergeParseOptions(options, overrideOptions));
};
const getSync = (ast, isDecoding, options) => {
  const parser = getEither(ast, isDecoding, options);
  return (input, overrideOptions) => getOrThrowWith$1(parser(input, overrideOptions), issue => new Error(formatIssueSync(issue), {
    cause: issue
  }));
};
const getEffect = (ast, isDecoding, options) => {
  const parser = goMemo(ast, isDecoding);
  return (input, overrideOptions) => parser(input, {
    ...mergeParseOptions(options, overrideOptions),
    isEffectAllowed: true
  });
};
/**
 * @category decoding
 * @since 0.67.0
 */
const decodeUnknownSync = (schema, options) => getSync(schema.ast, true, options);
/**
 * @category decoding
 * @since 0.67.0
 */
const decodeUnknown = (schema, options) => getEffect(schema.ast, true, options);
/**
 * @category encoding
 * @since 0.67.0
 */
const encodeUnknownSync = (schema, options) => getSync(schema.ast, false, options);
/**
 * @category encoding
 * @since 0.67.0
 */
const encodeUnknown = (schema, options) => getEffect(schema.ast, false, options);
/**
 * @category decoding
 * @since 0.67.0
 */
const decodeSync = decodeUnknownSync;
/**
 * @category validation
 * @since 0.67.0
 */
const validateSync = (schema, options) => getSync(typeAST(schema.ast), true, options);
/**
 * By default the option `exact` is set to `true`.
 *
 * @category validation
 * @since 0.67.0
 */
const is = (schema, options) => {
  const parser = goMemo(typeAST(schema.ast), true);
  return (u, overrideOptions) => isRight(parser(u, {
    exact: true,
    ...mergeParseOptions(options, overrideOptions)
  }));
};
/**
 * @category encoding
 * @since 0.67.0
 */
const encodeSync = encodeUnknownSync;
const decodeMemoMap = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for("@effect/schema/Parser/decodeMemoMap"), () => new WeakMap());
const encodeMemoMap = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for("@effect/schema/Parser/encodeMemoMap"), () => new WeakMap());
const goMemo = (ast, isDecoding) => {
  const memoMap = isDecoding ? decodeMemoMap : encodeMemoMap;
  const memo = memoMap.get(ast);
  if (memo) {
    return memo;
  }
  const parser = go(ast, isDecoding);
  memoMap.set(ast, parser);
  return parser;
};
const getConcurrency = ast => getOrUndefined(getConcurrencyAnnotation(ast));
const getBatching = ast => getOrUndefined(getBatchingAnnotation(ast));
const go = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Refinement":
      {
        if (isDecoding) {
          const from = goMemo(ast.from, true);
          return (i, options) => handleForbidden(flatMap(mapError(from(i, options), e => new Refinement(ast, i, "From", e)), a => match$3(ast.filter(a, options ?? defaultParseOption, ast), {
            onNone: () => right(a),
            onSome: e => left(new Refinement(ast, i, "Predicate", e))
          })), ast, i, options);
        } else {
          const from = goMemo(typeAST(ast), true);
          const to = goMemo(dropRightRefinement(ast.from), false);
          return (i, options) => handleForbidden(flatMap(from(i, options), a => to(a, options)), ast, i, options);
        }
      }
    case "Transformation":
      {
        const transform = getFinalTransformation(ast.transformation, isDecoding);
        const from = isDecoding ? goMemo(ast.from, true) : goMemo(ast.to, false);
        const to = isDecoding ? goMemo(ast.to, true) : goMemo(ast.from, false);
        return (i1, options) => handleForbidden(flatMap(mapError(from(i1, options), e => new Transformation(ast, i1, isDecoding ? "Encoded" : "Type", e)), a => flatMap(mapError(transform(a, options ?? defaultParseOption, ast), e => new Transformation(ast, i1, "Transformation", e)), i2 => mapError(to(i2, options), e => new Transformation(ast, i1, isDecoding ? "Type" : "Encoded", e)))), ast, i1, options);
      }
    case "Declaration":
      {
        const parse = isDecoding ? ast.decodeUnknown(...ast.typeParameters) : ast.encodeUnknown(...ast.typeParameters);
        return (i, options) => handleForbidden(mapError(parse(i, options ?? defaultParseOption, ast), e => new Declaration(ast, i, e)), ast, i, options);
      }
    case "Literal":
      return fromRefinement(ast, u => u === ast.literal);
    case "UniqueSymbol":
      return fromRefinement(ast, u => u === ast.symbol);
    case "UndefinedKeyword":
      return fromRefinement(ast, isUndefined);
    case "VoidKeyword":
      return fromRefinement(ast, isUndefined);
    case "NeverKeyword":
      return fromRefinement(ast, isNever);
    case "UnknownKeyword":
    case "AnyKeyword":
      return right;
    case "StringKeyword":
      return fromRefinement(ast, isString);
    case "NumberKeyword":
      return fromRefinement(ast, isNumber);
    case "BooleanKeyword":
      return fromRefinement(ast, isBoolean);
    case "BigIntKeyword":
      return fromRefinement(ast, isBigInt);
    case "SymbolKeyword":
      return fromRefinement(ast, isSymbol);
    case "ObjectKeyword":
      return fromRefinement(ast, isObject);
    case "Enums":
      return fromRefinement(ast, u => ast.enums.some(([_, value]) => value === u));
    case "TemplateLiteral":
      {
        const regex = getTemplateLiteralRegExp(ast);
        return fromRefinement(ast, u => isString(u) && regex.test(u));
      }
    case "TupleType":
      {
        const elements = ast.elements.map(e => goMemo(e.type, isDecoding));
        const rest = ast.rest.map(ast => goMemo(ast, isDecoding));
        let requiredLen = ast.elements.filter(e => !e.isOptional).length;
        if (ast.rest.length > 0) {
          requiredLen += ast.rest.length - 1;
        }
        const expectedAST = Union$2.make(ast.elements.map((_, i) => new Literal$1(i)));
        const concurrency = getConcurrency(ast);
        const batching = getBatching(ast);
        return (input, options) => {
          if (!isArray(input)) {
            return left(new Type(ast, input));
          }
          const allErrors = options?.errors === "all";
          const es = [];
          let stepKey = 0;
          // ---------------------------------------------
          // handle missing indexes
          // ---------------------------------------------
          const len = input.length;
          for (let i = len; i <= requiredLen - 1; i++) {
            const e = new Index(i, missing);
            if (allErrors) {
              es.push([stepKey++, e]);
              continue;
            } else {
              return left(new TupleType(ast, input, [e]));
            }
          }
          // ---------------------------------------------
          // handle excess indexes
          // ---------------------------------------------
          if (ast.rest.length === 0) {
            for (let i = ast.elements.length; i <= len - 1; i++) {
              const e = new Index(i, new Unexpected(expectedAST));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left(new TupleType(ast, input, [e]));
              }
            }
          }
          const output = [];
          let i = 0;
          let queue = undefined;
          // ---------------------------------------------
          // handle elements
          // ---------------------------------------------
          for (; i < elements.length; i++) {
            if (len < i + 1) {
              if (ast.elements[i].isOptional) {
                // the input element is missing
                continue;
              }
            } else {
              const parser = elements[i];
              const te = parser(input[i], options);
              const eu = eitherOrUndefined(te);
              if (eu) {
                if (isLeft(eu)) {
                  // the input element is present but is not valid
                  const e = new Index(i, eu.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left(new TupleType(ast, input, [e], sortByIndex(output)));
                  }
                }
                output.push([stepKey++, eu.right]);
              } else {
                const nk = stepKey++;
                const index = i;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es,
                  output
                }) => flatMap$1(either(te), t => {
                  if (isLeft(t)) {
                    // the input element is present but is not valid
                    const e = new Index(index, t.left);
                    if (allErrors) {
                      es.push([nk, e]);
                      return _void;
                    } else {
                      return left(new TupleType(ast, input, [e], sortByIndex(output)));
                    }
                  }
                  output.push([nk, t.right]);
                  return _void;
                }));
              }
            }
          }
          // ---------------------------------------------
          // handle rest element
          // ---------------------------------------------
          if (isNonEmptyReadonlyArray(rest)) {
            const [head, ...tail] = rest;
            for (; i < len - tail.length; i++) {
              const te = head(input[i], options);
              const eu = eitherOrUndefined(te);
              if (eu) {
                if (isLeft(eu)) {
                  const e = new Index(i, eu.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left(new TupleType(ast, input, [e], sortByIndex(output)));
                  }
                } else {
                  output.push([stepKey++, eu.right]);
                }
              } else {
                const nk = stepKey++;
                const index = i;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es,
                  output
                }) => flatMap$1(either(te), t => {
                  if (isLeft(t)) {
                    const e = new Index(index, t.left);
                    if (allErrors) {
                      es.push([nk, e]);
                      return _void;
                    } else {
                      return left(new TupleType(ast, input, [e], sortByIndex(output)));
                    }
                  } else {
                    output.push([nk, t.right]);
                    return _void;
                  }
                }));
              }
            }
            // ---------------------------------------------
            // handle post rest elements
            // ---------------------------------------------
            for (let j = 0; j < tail.length; j++) {
              i += j;
              if (len < i + 1) {
                continue;
              } else {
                const te = tail[j](input[i], options);
                const eu = eitherOrUndefined(te);
                if (eu) {
                  if (isLeft(eu)) {
                    // the input element is present but is not valid
                    const e = new Index(i, eu.left);
                    if (allErrors) {
                      es.push([stepKey++, e]);
                      continue;
                    } else {
                      return left(new TupleType(ast, input, [e], sortByIndex(output)));
                    }
                  }
                  output.push([stepKey++, eu.right]);
                } else {
                  const nk = stepKey++;
                  const index = i;
                  if (!queue) {
                    queue = [];
                  }
                  queue.push(({
                    es,
                    output
                  }) => flatMap$1(either(te), t => {
                    if (isLeft(t)) {
                      // the input element is present but is not valid
                      const e = new Index(index, t.left);
                      if (allErrors) {
                        es.push([nk, e]);
                        return _void;
                      } else {
                        return left(new TupleType(ast, input, [e], sortByIndex(output)));
                      }
                    }
                    output.push([nk, t.right]);
                    return _void;
                  }));
                }
              }
            }
          }
          // ---------------------------------------------
          // compute result
          // ---------------------------------------------
          const computeResult = ({
            es,
            output
          }) => isNonEmptyArray(es) ? left(new TupleType(ast, input, sortByIndex(es), sortByIndex(output))) : right(sortByIndex(output));
          if (queue && queue.length > 0) {
            const cqueue = queue;
            return suspend$1(() => {
              const state = {
                es: copy$1(es),
                output: copy$1(output)
              };
              return flatMap$1(forEach(cqueue, f => f(state), {
                concurrency,
                batching,
                discard: true
              }), () => computeResult(state));
            });
          }
          return computeResult({
            output,
            es
          });
        };
      }
    case "TypeLiteral":
      {
        if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
          return fromRefinement(ast, isNotNullable);
        }
        const propertySignatures = [];
        const expectedKeysMap = {};
        const expectedKeys = [];
        for (const ps of ast.propertySignatures) {
          propertySignatures.push([goMemo(ps.type, isDecoding), ps]);
          expectedKeysMap[ps.name] = null;
          expectedKeys.push(ps.name);
        }
        const indexSignatures = ast.indexSignatures.map(is => [goMemo(is.parameter, isDecoding), goMemo(is.type, isDecoding), is.parameter]);
        const expectedAST = Union$2.make(ast.indexSignatures.map(is => is.parameter).concat(expectedKeys.map(key => isSymbol(key) ? new UniqueSymbol(key) : new Literal$1(key))));
        const expected = goMemo(expectedAST, isDecoding);
        const concurrency = getConcurrency(ast);
        const batching = getBatching(ast);
        return (input, options) => {
          if (!isRecord(input)) {
            return left(new Type(ast, input));
          }
          const allErrors = options?.errors === "all";
          const es = [];
          let stepKey = 0;
          // ---------------------------------------------
          // handle excess properties
          // ---------------------------------------------
          const onExcessPropertyError = options?.onExcessProperty === "error";
          const onExcessPropertyPreserve = options?.onExcessProperty === "preserve";
          const output = {};
          let inputKeys;
          if (onExcessPropertyError || onExcessPropertyPreserve) {
            inputKeys = ownKeys(input);
            for (const key of inputKeys) {
              const eu = eitherOrUndefined(expected(key, options));
              if (isLeft(eu)) {
                // key is unexpected
                if (onExcessPropertyError) {
                  const e = new Key$2(key, new Unexpected(expectedAST));
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left(new TypeLiteral(ast, input, [e], output));
                  }
                } else {
                  // preserve key
                  output[key] = input[key];
                }
              }
            }
          }
          let queue = undefined;
          const isExact = options?.exact === true;
          for (let i = 0; i < propertySignatures.length; i++) {
            const ps = propertySignatures[i][1];
            const name = ps.name;
            const hasKey = Object.prototype.hasOwnProperty.call(input, name);
            if (!hasKey) {
              if (ps.isOptional) {
                continue;
              } else if (isExact) {
                const e = new Key$2(name, missing);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left(new TypeLiteral(ast, input, [e], output));
                }
              }
            }
            const parser = propertySignatures[i][0];
            const te = parser(input[name], options);
            const eu = eitherOrUndefined(te);
            if (eu) {
              if (isLeft(eu)) {
                const e = new Key$2(name, hasKey ? eu.left : missing);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left(new TypeLiteral(ast, input, [e], output));
                }
              }
              output[name] = eu.right;
            } else {
              const nk = stepKey++;
              const index = name;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es,
                output
              }) => flatMap$1(either(te), t => {
                if (isLeft(t)) {
                  const e = new Key$2(index, hasKey ? t.left : missing);
                  if (allErrors) {
                    es.push([nk, e]);
                    return _void;
                  } else {
                    return left(new TypeLiteral(ast, input, [e], output));
                  }
                }
                output[index] = t.right;
                return _void;
              }));
            }
          }
          // ---------------------------------------------
          // handle index signatures
          // ---------------------------------------------
          for (let i = 0; i < indexSignatures.length; i++) {
            const indexSignature = indexSignatures[i];
            const parameter = indexSignature[0];
            const type = indexSignature[1];
            const keys = getKeysForIndexSignature(input, indexSignature[2]);
            for (const key of keys) {
              // ---------------------------------------------
              // handle keys
              // ---------------------------------------------
              const keu = eitherOrUndefined(parameter(key, options));
              if (keu && isRight(keu)) {
                // ---------------------------------------------
                // handle values
                // ---------------------------------------------
                const vpr = type(input[key], options);
                const veu = eitherOrUndefined(vpr);
                if (veu) {
                  if (isLeft(veu)) {
                    const e = new Key$2(key, veu.left);
                    if (allErrors) {
                      es.push([stepKey++, e]);
                      continue;
                    } else {
                      return left(new TypeLiteral(ast, input, [e], output));
                    }
                  } else {
                    if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                      output[key] = veu.right;
                    }
                  }
                } else {
                  const nk = stepKey++;
                  const index = key;
                  if (!queue) {
                    queue = [];
                  }
                  queue.push(({
                    es,
                    output
                  }) => flatMap$1(either(vpr), tv => {
                    if (isLeft(tv)) {
                      const e = new Key$2(index, tv.left);
                      if (allErrors) {
                        es.push([nk, e]);
                        return _void;
                      } else {
                        return left(new TypeLiteral(ast, input, [e], output));
                      }
                    } else {
                      if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                        output[key] = tv.right;
                      }
                      return _void;
                    }
                  }));
                }
              }
            }
          }
          // ---------------------------------------------
          // compute result
          // ---------------------------------------------
          const computeResult = ({
            es,
            output
          }) => {
            if (isNonEmptyArray(es)) {
              return left(new TypeLiteral(ast, input, sortByIndex(es), output));
            }
            if (options?.propertyOrder === "original") {
              // preserve input keys order
              const keys = inputKeys || ownKeys(input);
              for (const name of expectedKeys) {
                if (keys.indexOf(name) === -1) {
                  keys.push(name);
                }
              }
              const out = {};
              for (const key of keys) {
                if (Object.prototype.hasOwnProperty.call(output, key)) {
                  out[key] = output[key];
                }
              }
              return right(out);
            }
            return right(output);
          };
          if (queue && queue.length > 0) {
            const cqueue = queue;
            return suspend$1(() => {
              const state = {
                es: copy$1(es),
                output: Object.assign({}, output)
              };
              return flatMap$1(forEach(cqueue, f => f(state), {
                concurrency,
                batching,
                discard: true
              }), () => computeResult(state));
            });
          }
          return computeResult({
            es,
            output
          });
        };
      }
    case "Union":
      {
        const searchTree = getSearchTree(ast.types, isDecoding);
        const ownKeys$1 = ownKeys(searchTree.keys);
        const len = ownKeys$1.length;
        const map = new Map();
        for (let i = 0; i < ast.types.length; i++) {
          map.set(ast.types[i], goMemo(ast.types[i], isDecoding));
        }
        const concurrency = getConcurrency(ast) ?? 1;
        const batching = getBatching(ast);
        return (input, options) => {
          const es = [];
          let stepKey = 0;
          let candidates = [];
          if (len > 0) {
            // if there is at least one key then input must be an object
            if (isRecord(input)) {
              for (let i = 0; i < len; i++) {
                const name = ownKeys$1[i];
                const buckets = searchTree.keys[name].buckets;
                // for each property that should contain a literal, check if the input contains that property
                if (Object.prototype.hasOwnProperty.call(input, name)) {
                  const literal = String(input[name]);
                  // check that the value obtained from the input for the property corresponds to an existing bucket
                  if (Object.prototype.hasOwnProperty.call(buckets, literal)) {
                    // retrive the minimal set of candidates for decoding
                    candidates = candidates.concat(buckets[literal]);
                  } else {
                    const literals = Union$2.make(searchTree.keys[name].literals);
                    es.push([stepKey++, new TypeLiteral(new TypeLiteral$1([new PropertySignature(name, literals, false, true)], []), input, [new Key$2(name, new Type(literals, input[name]))])]);
                  }
                } else {
                  const literals = Union$2.make(searchTree.keys[name].literals);
                  es.push([stepKey++, new TypeLiteral(new TypeLiteral$1([new PropertySignature(name, literals, false, true)], []), input, [new Key$2(name, missing)])]);
                }
              }
            } else {
              es.push([stepKey++, new Type(ast, input)]);
            }
          }
          if (searchTree.otherwise.length > 0) {
            candidates = candidates.concat(searchTree.otherwise);
          }
          let queue = undefined;
          for (let i = 0; i < candidates.length; i++) {
            const candidate = candidates[i];
            const pr = map.get(candidate)(input, options);
            // the members of a union are ordered based on which one should be decoded first,
            // therefore if one member has added a task, all subsequent members must
            // also add a task to the queue even if they are synchronous
            const eu = !queue || queue.length === 0 ? eitherOrUndefined(pr) : undefined;
            if (eu) {
              if (isRight(eu)) {
                return right(eu.right);
              } else {
                es.push([stepKey++, new Member(candidate, eu.left)]);
              }
            } else {
              const nk = stepKey++;
              if (!queue) {
                queue = [];
              }
              queue.push(state => suspend$1(() => {
                if ("finalResult" in state) {
                  return _void;
                } else {
                  return flatMap$1(either(pr), t => {
                    if (isRight(t)) {
                      state.finalResult = right(t.right);
                    } else {
                      state.es.push([nk, new Member(candidate, t.left)]);
                    }
                    return _void;
                  });
                }
              }));
            }
          }
          // ---------------------------------------------
          // compute result
          // ---------------------------------------------
          const computeResult = es => isNonEmptyArray(es) ? es.length === 1 && es[0][1]._tag === "Type" ? left(es[0][1]) : left(new Union$1(ast, input, sortByIndex(es))) :
          // this should never happen
          left(new Type(neverKeyword, input));
          if (queue && queue.length > 0) {
            const cqueue = queue;
            return suspend$1(() => {
              const state = {
                es: copy$1(es)
              };
              return flatMap$1(forEach(cqueue, f => f(state), {
                concurrency,
                batching,
                discard: true
              }), () => {
                if ("finalResult" in state) {
                  return state.finalResult;
                }
                return computeResult(state.es);
              });
            });
          }
          return computeResult(es);
        };
      }
    case "Suspend":
      {
        const get = memoizeThunk(() => goMemo(annotations(ast.f(), ast.annotations), isDecoding));
        return (a, options) => get()(a, options);
      }
  }
};
const fromRefinement = (ast, refinement) => u => refinement(u) ? right(u) : left(new Type(ast, u));
/** @internal */
const getLiterals = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Declaration":
      {
        const annotation = getSurrogateAnnotation(ast);
        if (isSome(annotation)) {
          return getLiterals(annotation.value, isDecoding);
        }
        break;
      }
    case "TypeLiteral":
      {
        const out = [];
        for (let i = 0; i < ast.propertySignatures.length; i++) {
          const propertySignature = ast.propertySignatures[i];
          const type = isDecoding ? encodedAST(propertySignature.type) : typeAST(propertySignature.type);
          if (isLiteral(type) && !propertySignature.isOptional) {
            out.push([propertySignature.name, type]);
          }
        }
        return out;
      }
    case "Refinement":
      return getLiterals(ast.from, isDecoding);
    case "Suspend":
      return getLiterals(ast.f(), isDecoding);
    case "Transformation":
      return getLiterals(isDecoding ? ast.from : ast.to, isDecoding);
  }
  return [];
};
/**
 * The purpose of the algorithm is to narrow down the pool of possible candidates for decoding as much as possible.
 *
 * This function separates the schemas into two groups, `keys` and `otherwise`:
 *
 * - `keys`: the schema has at least one property with a literal value
 * - `otherwise`: the schema has no properties with a literal value
 *
 * If a schema has at least one property with a literal value, so it ends up in `keys`, first a namespace is created for
 * the name of the property containing the literal, and then within this namespace a "bucket" is created for the literal
 * value in which to store all the schemas that have the same property and literal value.
 *
 * @internal
 */
const getSearchTree = (members, isDecoding) => {
  const keys = {};
  const otherwise = [];
  for (let i = 0; i < members.length; i++) {
    const member = members[i];
    const tags = getLiterals(member, isDecoding);
    if (tags.length > 0) {
      for (let j = 0; j < tags.length; j++) {
        const [key, literal] = tags[j];
        const hash = String(literal.literal);
        keys[key] = keys[key] || {
          buckets: {},
          literals: []
        };
        const buckets = keys[key].buckets;
        if (Object.prototype.hasOwnProperty.call(buckets, hash)) {
          if (j < tags.length - 1) {
            continue;
          }
          buckets[hash].push(member);
          keys[key].literals.push(literal);
        } else {
          buckets[hash] = [member];
          keys[key].literals.push(literal);
          break;
        }
      }
    } else {
      otherwise.push(member);
    }
  }
  return {
    keys,
    otherwise
  };
};
const dropRightRefinement = ast => isRefinement(ast) ? dropRightRefinement(ast.from) : ast;
const handleForbidden = (effect, ast, actual, options) => {
  const eu = eitherOrUndefined(effect);
  if (eu) {
    return eu;
  }
  if (options?.isEffectAllowed === true) {
    return effect;
  }
  try {
    return runSync(either(effect));
  } catch (e) {
    return left(new Forbidden(ast, actual, "cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work"));
  }
};
function sortByIndex(es) {
  return es.sort(([a], [b]) => a > b ? 1 : a < b ? -1 : 0).map(([_, a]) => a);
}
// -------------------------------------------------------------------------------------
// transformations interpreter
// -------------------------------------------------------------------------------------
/** @internal */
const getFinalTransformation = (transformation, isDecoding) => {
  switch (transformation._tag) {
    case "FinalTransformation":
      return isDecoding ? transformation.decode : transformation.encode;
    case "ComposeTransformation":
      return right;
    case "TypeLiteralTransformation":
      return input => {
        let out = right(input);
        // ---------------------------------------------
        // handle property signature transformations
        // ---------------------------------------------
        for (const pst of transformation.propertySignatureTransformations) {
          const [from, to] = isDecoding ? [pst.from, pst.to] : [pst.to, pst.from];
          const transformation = isDecoding ? pst.decode : pst.encode;
          const f = input => {
            const o = transformation(Object.prototype.hasOwnProperty.call(input, from) ? some(input[from]) : none$4());
            delete input[from];
            if (isSome(o)) {
              input[to] = o.value;
            }
            return input;
          };
          out = map(out, f);
        }
        return out;
      };
  }
};

/**
 * @since 0.67.0
 */
/**
 * @category hooks
 * @since 0.67.0
 */
const EquivalenceHookId = /*#__PURE__*/Symbol.for("@effect/schema/EquivalenceHookId");

/**
 * @since 0.67.0
 */
/**
 * @category hooks
 * @since 0.67.0
 */
const PrettyHookId = /*#__PURE__*/Symbol.for("@effect/schema/PrettyHookId");

/**
 * This module provides utility functions and type class instances for working with the `BigDecimal` type in TypeScript.
 * It includes functions for basic arithmetic operations, as well as type class instances for `Equivalence` and `Order`.
 *
 * A `BigDecimal` allows storing any real number to arbitrary precision; which avoids common floating point errors
 * (such as 0.1 + 0.2 ≠ 0.3) at the cost of complexity.
 *
 * Internally, `BigDecimal` uses a `BigInt` object, paired with a 64-bit integer which determines the position of the
 * decimal point. Therefore, the precision *is not* actually arbitrary, but limited to 2<sup>63</sup> decimal places.
 *
 * It is not recommended to convert a floating point number to a decimal directly, as the floating point representation
 * may be unexpected.
 *
 * @since 2.0.0
 */
const FINITE_INT_REGEX = /^[+-]?\d+$/;
/**
 * @since 2.0.0
 * @category symbols
 */
const TypeId$1 = /*#__PURE__*/Symbol.for("effect/BigDecimal");
const BigDecimalProto = {
  [TypeId$1]: TypeId$1,
  [symbol$1]() {
    const normalized = normalize(this);
    return pipe(hash(normalized.value), combine$5(number$1(normalized.scale)), cached(this));
  },
  [symbol](that) {
    return isBigDecimal(that) && equals(this, that);
  },
  toString() {
    return `BigDecimal(${format$1(this)})`;
  },
  toJSON() {
    return {
      _id: "BigDecimal",
      value: String(this.value),
      scale: this.scale
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
/**
 * Checks if a given value is a `BigDecimal`.
 *
 * @param u - The value to check.
 *
 * @since 2.0.0
 * @category guards
 */
const isBigDecimal = u => hasProperty(u, TypeId$1);
/**
 * Creates a `BigDecimal` from a `bigint` value and a scale.
 *
 * @param value - The `bigint` value to create a `BigDecimal` from.
 * @param scale - The scale of the `BigDecimal`.
 *
 * @since 2.0.0
 * @category constructors
 */
const make$2 = (value, scale) => {
  const o = Object.create(BigDecimalProto);
  o.value = value;
  o.scale = scale;
  return o;
};
/**
 * Internal function used to create pre-normalized `BigDecimal`s.
 *
 * @internal
 */
const unsafeMakeNormalized = (value, scale) => {
  if (value !== bigint0 && value % bigint10 === bigint0) {
    throw new RangeError("Value must be normalized");
  }
  const o = make$2(value, scale);
  o.normalized = o;
  return o;
};
const bigint0 = /*#__PURE__*/BigInt(0);
const bigint10 = /*#__PURE__*/BigInt(10);
const zero = /*#__PURE__*/unsafeMakeNormalized(bigint0, 0);
/**
 * Normalizes a given `BigDecimal` by removing trailing zeros.
 *
 * @param self - The `BigDecimal` to normalize.
 *
 * @example
 * ```ts
 * import { normalize, make, unsafeFromString } from "effect/BigDecimal"
 *
 * assert.deepStrictEqual(normalize(unsafeFromString("123.00000")), normalize(make(123n, 0)))
 * assert.deepStrictEqual(normalize(unsafeFromString("12300000")), normalize(make(123n, -5)))
 * ```
 *
 * @since 2.0.0
 * @category scaling
 */
const normalize = self => {
  if (self.normalized === undefined) {
    if (self.value === bigint0) {
      self.normalized = zero;
    } else {
      const digits = `${self.value}`;
      let trail = 0;
      for (let i = digits.length - 1; i >= 0; i--) {
        if (digits[i] === "0") {
          trail++;
        } else {
          break;
        }
      }
      if (trail === 0) {
        self.normalized = self;
      }
      const value = BigInt(digits.substring(0, digits.length - trail));
      const scale = self.scale - trail;
      self.normalized = unsafeMakeNormalized(value, scale);
    }
  }
  return self.normalized;
};
/**
 * Scales a given `BigDecimal` to the specified scale.
 *
 * If the given scale is smaller than the current scale, the value will be rounded down to
 * the nearest integer.
 *
 * @param self - The `BigDecimal` to scale.
 * @param scale - The scale to scale to.
 *
 * @since 2.0.0
 * @category scaling
 */
const scale = /*#__PURE__*/dual(2, (self, scale) => {
  if (scale > self.scale) {
    return make$2(self.value * bigint10 ** BigInt(scale - self.scale), scale);
  }
  if (scale < self.scale) {
    return make$2(self.value / bigint10 ** BigInt(self.scale - scale), scale);
  }
  return self;
});
/**
 * Determines the absolute value of a given `BigDecimal`.
 *
 * @param n - The `BigDecimal` to determine the absolute value of.
 *
 * @example
 * ```ts
 * import { abs, unsafeFromString } from "effect/BigDecimal"
 *
 * assert.deepStrictEqual(abs(unsafeFromString("-5")), unsafeFromString("5"))
 * assert.deepStrictEqual(abs(unsafeFromString("0")), unsafeFromString("0"))
 * assert.deepStrictEqual(abs(unsafeFromString("5")), unsafeFromString("5"))
 * ```
 *
 * @since 2.0.0
 * @category math
 */
const abs = n => n.value < bigint0 ? make$2(-n.value, n.scale) : n;
/**
 * @category instances
 * @since 2.0.0
 */
const Equivalence = /*#__PURE__*/make$r((self, that) => {
  if (self.scale > that.scale) {
    return scale(that, self.scale).value === self.value;
  }
  if (self.scale < that.scale) {
    return scale(self, that.scale).value === that.value;
  }
  return self.value === that.value;
});
/**
 * Checks if two `BigDecimal`s are equal.
 *
 * @since 2.0.0
 * @category predicates
 */
const equals = /*#__PURE__*/dual(2, (self, that) => Equivalence(self, that));
/**
 * Creates a `BigDecimal` from a `number` value.
 *
 * It is not recommended to convert a floating point number to a decimal directly,
 * as the floating point representation may be unexpected.
 *
 * Throws a `RangeError` if the number is not finite (`NaN`, `+Infinity` or `-Infinity`).
 *
 * @param value - The `number` value to create a `BigDecimal` from.
 *
 * @example
 * ```ts
 * import { fromNumber, make } from "effect/BigDecimal"
 *
 * assert.deepStrictEqual(fromNumber(123), make(123n, 0))
 * assert.deepStrictEqual(fromNumber(123.456), make(123456n, 3))
 * ```
 *
 * @since 3.11.0
 * @category constructors
 */
const unsafeFromNumber = n => getOrThrowWith(safeFromNumber(n), () => new RangeError(`Number must be finite, got ${n}`));
/**
 * Creates a `BigDecimal` from a `number` value.
 *
 * It is not recommended to convert a floating point number to a decimal directly,
 * as the floating point representation may be unexpected.
 *
 * Throws a `RangeError` if the number is not finite (`NaN`, `+Infinity` or `-Infinity`).
 *
 * @param value - The `number` value to create a `BigDecimal` from.
 *
 * @since 2.0.0
 * @category constructors
 * @deprecated Use {@link unsafeFromNumber} instead.
 */
const fromNumber$2 = unsafeFromNumber;
/**
 * Creates a `BigDecimal` from a `number` value.
 *
 * It is not recommended to convert a floating point number to a decimal directly,
 * as the floating point representation may be unexpected.
 *
 * Returns `None` if the number is not finite (`NaN`, `+Infinity` or `-Infinity`).
 *
 * @param n - The `number` value to create a `BigDecimal` from.
 *
 * @example
 * ```ts
 * import { BigDecimal, Option } from "effect"
 *
 * assert.deepStrictEqual(BigDecimal.safeFromNumber(123), Option.some(BigDecimal.make(123n, 0)))
 * assert.deepStrictEqual(BigDecimal.safeFromNumber(123.456), Option.some(BigDecimal.make(123456n, 3)))
 * assert.deepStrictEqual(BigDecimal.safeFromNumber(Infinity), Option.none())
 * ```
 *
 * @since 3.11.0
 * @category constructors
 */
const safeFromNumber = n => {
  // TODO: Rename this to `fromNumber` after removing the current, unsafe implementation of `fromNumber`.
  if (!Number.isFinite(n)) {
    return none$4();
  }
  const string = `${n}`;
  if (string.includes("e")) {
    return fromString$4(string);
  }
  const [lead, trail = ""] = string.split(".");
  return some(make$2(BigInt(`${lead}${trail}`), trail.length));
};
/**
 * Parses a numerical `string` into a `BigDecimal`.
 *
 * @param s - The `string` to parse.
 *
 * @example
 * ```ts
 * import { BigDecimal, Option } from "effect"
 *
 * assert.deepStrictEqual(BigDecimal.fromString("123"), Option.some(BigDecimal.make(123n, 0)))
 * assert.deepStrictEqual(BigDecimal.fromString("123.456"), Option.some(BigDecimal.make(123456n, 3)))
 * assert.deepStrictEqual(BigDecimal.fromString("123.abc"), Option.none())
 * ```
 *
 * @since 2.0.0
 * @category constructors
 */
const fromString$4 = s => {
  if (s === "") {
    return some(zero);
  }
  let base;
  let exp;
  const seperator = s.search(/[eE]/);
  if (seperator !== -1) {
    const trail = s.slice(seperator + 1);
    base = s.slice(0, seperator);
    exp = Number(trail);
    if (base === "" || !Number.isSafeInteger(exp) || !FINITE_INT_REGEX.test(trail)) {
      return none$4();
    }
  } else {
    base = s;
    exp = 0;
  }
  let digits;
  let offset;
  const dot = base.search(/\./);
  if (dot !== -1) {
    const lead = base.slice(0, dot);
    const trail = base.slice(dot + 1);
    digits = `${lead}${trail}`;
    offset = trail.length;
  } else {
    digits = base;
    offset = 0;
  }
  if (!FINITE_INT_REGEX.test(digits)) {
    return none$4();
  }
  const scale = offset - exp;
  if (!Number.isSafeInteger(scale)) {
    return none$4();
  }
  return some(make$2(BigInt(digits), scale));
};
/**
 * Formats a given `BigDecimal` as a `string`.
 *
 * If the scale of the `BigDecimal` is greater than or equal to 16, the `BigDecimal` will
 * be formatted in scientific notation.
 *
 * @param n - The `BigDecimal` to format.
 *
 * @example
 * ```ts
 * import { format, unsafeFromString } from "effect/BigDecimal"
 *
 * assert.deepStrictEqual(format(unsafeFromString("-5")), "-5")
 * assert.deepStrictEqual(format(unsafeFromString("123.456")), "123.456")
 * assert.deepStrictEqual(format(unsafeFromString("-0.00000123")), "-0.00000123")
 * ```
 *
 * @since 2.0.0
 * @category conversions
 */
const format$1 = n => {
  const normalized = normalize(n);
  if (Math.abs(normalized.scale) >= 16) {
    return toExponential(normalized);
  }
  const negative = normalized.value < bigint0;
  const absolute = negative ? `${normalized.value}`.substring(1) : `${normalized.value}`;
  let before;
  let after;
  if (normalized.scale >= absolute.length) {
    before = "0";
    after = "0".repeat(normalized.scale - absolute.length) + absolute;
  } else {
    const location = absolute.length - normalized.scale;
    if (location > absolute.length) {
      const zeros = location - absolute.length;
      before = `${absolute}${"0".repeat(zeros)}`;
      after = "";
    } else {
      after = absolute.slice(location);
      before = absolute.slice(0, location);
    }
  }
  const complete = after === "" ? before : `${before}.${after}`;
  return negative ? `-${complete}` : complete;
};
/**
 * Formats a given `BigDecimal` as a `string` in scientific notation.
 *
 * @param n - The `BigDecimal` to format.
 *
 * @example
 * ```ts
 * import { toExponential, make } from "effect/BigDecimal"
 *
 * assert.deepStrictEqual(toExponential(make(123456n, -5)), "1.23456e+10")
 * ```
 *
 * @since 3.11.0
 * @category conversions
 */
const toExponential = n => {
  if (isZero(n)) {
    return "0e+0";
  }
  const normalized = normalize(n);
  const digits = `${abs(normalized).value}`;
  const head = digits.slice(0, 1);
  const tail = digits.slice(1);
  let output = `${isNegative(normalized) ? "-" : ""}${head}`;
  if (tail !== "") {
    output += `.${tail}`;
  }
  const exp = tail.length - normalized.scale;
  return `${output}e${exp >= 0 ? "+" : ""}${exp}`;
};
/**
 * Converts a `BigDecimal` to a `number`.
 *
 * This function will produce incorrect results if the `BigDecimal` exceeds the 64-bit range of a `number`.
 *
 * @param n - The `BigDecimal` to convert.
 *
 * @example
 * ```ts
 * import { unsafeToNumber, unsafeFromString } from "effect/BigDecimal"
 *
 * assert.deepStrictEqual(unsafeToNumber(unsafeFromString("123.456")), 123.456)
 * ```
 *
 * @since 2.0.0
 * @category conversions
 */
const unsafeToNumber = n => Number(format$1(n));
/**
 * Checks if a given `BigDecimal` is `0`.
 *
 * @param n - The `BigDecimal` to check.
 *
 * @example
 * ```ts
 * import { isZero, unsafeFromString } from "effect/BigDecimal"
 *
 * assert.deepStrictEqual(isZero(unsafeFromString("0")), true)
 * assert.deepStrictEqual(isZero(unsafeFromString("1")), false)
 * ```
 *
 * @since 2.0.0
 * @category predicates
 */
const isZero = n => n.value === bigint0;
/**
 * Checks if a given `BigDecimal` is negative.
 *
 * @param n - The `BigDecimal` to check.
 *
 * @example
 * ```ts
 * import { isNegative, unsafeFromString } from "effect/BigDecimal"
 *
 * assert.deepStrictEqual(isNegative(unsafeFromString("-1")), true)
 * assert.deepStrictEqual(isNegative(unsafeFromString("0")), false)
 * assert.deepStrictEqual(isNegative(unsafeFromString("1")), false)
 * ```
 *
 * @since 2.0.0
 * @category predicates
 */
const isNegative = n => n.value < bigint0;

/**
 * This module provides utility functions and type class instances for working with the `bigint` type in TypeScript.
 * It includes functions for basic arithmetic operations, as well as type class instances for
 * `Equivalence` and `Order`.
 *
 * @since 2.0.0
 */
/**
 * Takes a `bigint` and returns an `Option` of `number`.
 *
 * If the `bigint` is outside the safe integer range for JavaScript (`Number.MAX_SAFE_INTEGER`
 * and `Number.MIN_SAFE_INTEGER`), it returns `Option.none()`. Otherwise, it converts the `bigint`
 * to a number and returns `Option.some(number)`.
 *
 * @param b - The `bigint` to be converted to a `number`.
 *
 * @example
 * ```ts
 * import { BigInt as BI, Option } from "effect"
 *
 * assert.deepStrictEqual(BI.toNumber(BigInt(42)), Option.some(42))
 * assert.deepStrictEqual(BI.toNumber(BigInt(Number.MAX_SAFE_INTEGER) + BigInt(1)), Option.none())
 * assert.deepStrictEqual(BI.toNumber(BigInt(Number.MIN_SAFE_INTEGER) - BigInt(1)), Option.none())
 * ```
 *
 * @category conversions
 * @since 2.0.0
 */
const toNumber = b => {
  if (b > BigInt(Number.MAX_SAFE_INTEGER) || b < BigInt(Number.MIN_SAFE_INTEGER)) {
    return none$4();
  }
  return some(Number(b));
};
/**
 * Takes a string and returns an `Option` of `bigint`.
 *
 * If the string is empty or contains characters that cannot be converted into a `bigint`,
 * it returns `Option.none()`, otherwise, it returns `Option.some(bigint)`.
 *
 * @param s - The string to be converted to a `bigint`.
 *
 * @example
 * ```ts
 * import { BigInt as BI, Option } from "effect"
 *
 * assert.deepStrictEqual(BI.fromString("42"), Option.some(BigInt(42)))
 * assert.deepStrictEqual(BI.fromString(" "), Option.none())
 * assert.deepStrictEqual(BI.fromString("a"), Option.none())
 * ```
 *
 * @category conversions
 * @since 2.4.12
 */
const fromString$3 = s => {
  try {
    return s.trim() === "" ? none$4() : some(BigInt(s));
  } catch (_) {
    return none$4();
  }
};
/**
 * Takes a number and returns an `Option` of `bigint`.
 *
 * If the number is outside the safe integer range for JavaScript (`Number.MAX_SAFE_INTEGER`
 * and `Number.MIN_SAFE_INTEGER`), it returns `Option.none()`. Otherwise, it attempts to
 * convert the number to a `bigint` and returns `Option.some(bigint)`.
 *
 * @param n - The number to be converted to a `bigint`.
 *
 * @example
 * ```ts
 * import { BigInt as BI, Option } from "effect"
 *
 * assert.deepStrictEqual(BI.fromNumber(42), Option.some(BigInt(42)))
 * assert.deepStrictEqual(BI.fromNumber(Number.MAX_SAFE_INTEGER + 1), Option.none())
 * assert.deepStrictEqual(BI.fromNumber(Number.MIN_SAFE_INTEGER - 1), Option.none())
 * ```
 *
 * @category conversions
 * @since 2.4.12
 */
const fromNumber$1 = n => {
  if (n > Number.MAX_SAFE_INTEGER || n < Number.MIN_SAFE_INTEGER) {
    return none$4();
  }
  try {
    return some(BigInt(n));
  } catch (_) {
    return none$4();
  }
};

/** @internal */
const RedactedSymbolKey = "effect/Redacted";
/** @internal */
const redactedRegistry = /*#__PURE__*/globalValue("effect/Redacted/redactedRegistry", () => new WeakMap());
/** @internal */
const RedactedTypeId = /*#__PURE__*/Symbol.for(RedactedSymbolKey);
/** @internal */
const proto = {
  [RedactedTypeId]: {
    _A: _ => _
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toString() {
    return "<redacted>";
  },
  toJSON() {
    return "<redacted>";
  },
  [NodeInspectSymbol]() {
    return "<redacted>";
  },
  [symbol$1]() {
    return pipe(hash(RedactedSymbolKey), combine$5(hash(redactedRegistry.get(this))), cached(this));
  },
  [symbol](that) {
    return isRedacted(that) && equals$2(redactedRegistry.get(this), redactedRegistry.get(that));
  }
};
/** @internal */
const isRedacted = u => hasProperty(u, RedactedTypeId);

/**
 * @internal
 * @deprecated
 */
const SecretSymbolKey = "effect/Secret";
/**
 * @internal
 * @deprecated
 */
const SecretTypeId = /*#__PURE__*/Symbol.for(SecretSymbolKey);
/**
 * @internal
 * @deprecated
 */
const isSecret$1 = u => hasProperty(u, SecretTypeId);
/**
 * @internal
 * @deprecated
 */
const make$1 = bytes => {
  const secret = Object.create({
    ...proto,
    [SecretTypeId]: SecretTypeId
  });
  Object.defineProperty(secret, "toString", {
    enumerable: false,
    value() {
      return "Secret(<redacted>)";
    }
  });
  Object.defineProperty(secret, "toJSON", {
    enumerable: false,
    value() {
      return "<redacted>";
    }
  });
  Object.defineProperty(secret, "raw", {
    enumerable: false,
    value: bytes
  });
  redactedRegistry.set(secret, bytes.map(byte => String.fromCharCode(byte)).join(""));
  return secret;
};
/**
 * @internal
 * @deprecated
 */
const fromString$2 = text => {
  return make$1(text.split("").map(char => char.charCodeAt(0)));
};
/**
 * @internal
 * @deprecated
 */
const value$1 = self => {
  return self.raw.map(byte => String.fromCharCode(byte)).join("");
};

const ConfigSymbolKey = "effect/Config";
/** @internal */
const ConfigTypeId = /*#__PURE__*/Symbol.for(ConfigSymbolKey);
const configVariance = {
  /* c8 ignore next */
  _A: _ => _
};
({
  ...CommitPrototype$1,
  [ConfigTypeId]: configVariance,
  commit() {
    return config$1(this);
  }
});

/**
 * @since 2.0.0
 * @category refinements
 * @deprecated
 */
const isSecret = isSecret$1;
/**
 * @since 2.0.0
 * @category constructors
 * @deprecated
 */
const fromString$1 = fromString$2;
/**
 * @since 2.0.0
 * @category getters
 * @deprecated
 */
const value = value$1;

/**
 * @since 0.67.0
 */
/**
 * @since 0.67.0
 * @category symbol
 */
const TypeId = /*#__PURE__*/Symbol.for("@effect/schema/Schema");
/**
 * @category constructors
 * @since 0.67.0
 */
const make = ast => class SchemaClass {
  [TypeId] = variance;
  static Type;
  static Encoded;
  static [TypeId] = variance;
  static ast = ast;
  static annotations(annotations) {
    return make(mergeSchemaAnnotations(this.ast, annotations));
  }
  static pipe() {
    return pipeArguments(this, arguments);
  }
  static toString() {
    return String(ast);
  }
};
const variance = {
  /* c8 ignore next */
  _A: _ => _,
  /* c8 ignore next */
  _I: _ => _,
  /* c8 ignore next */
  _R: _ => _
};
const toASTAnnotations = annotations => {
  if (!annotations) {
    return {};
  }
  const out = {};
  // symbols are reserved for custom annotations
  const custom = Object.getOwnPropertySymbols(annotations);
  for (const sym of custom) {
    out[sym] = annotations[sym];
  }
  // string keys are reserved as /schema namespace
  if (annotations.typeId !== undefined) {
    const typeId = annotations.typeId;
    if (typeof typeId === "object") {
      out[TypeAnnotationId] = typeId.id;
      out[typeId.id] = typeId.annotation;
    } else {
      out[TypeAnnotationId] = typeId;
    }
  }
  const move = (from, to) => {
    if (annotations[from] !== undefined) {
      out[to] = annotations[from];
    }
  };
  move("message", MessageAnnotationId);
  move("identifier", IdentifierAnnotationId);
  move("title", TitleAnnotationId);
  move("description", DescriptionAnnotationId);
  move("examples", ExamplesAnnotationId);
  move("default", DefaultAnnotationId);
  move("documentation", DocumentationAnnotationId);
  move("jsonSchema", JSONSchemaAnnotationId);
  move("arbitrary", ArbitraryHookId);
  move("pretty", PrettyHookId);
  move("equivalence", EquivalenceHookId);
  move("concurrency", ConcurrencyAnnotationId);
  move("batching", BatchingAnnotationId);
  move("parseIssueTitle", ParseIssueTitleAnnotationId);
  return out;
};
const mergeSchemaAnnotations = (ast, annotations$1) => annotations(ast, toASTAnnotations(annotations$1));
/**
 * @category formatting
 * @since 0.67.0
 */
const format = schema => String(schema.ast);
/**
 * The `typeSchema` function allows you to extract the `Type` portion of a
 * schema, creating a new schema that conforms to the properties defined in the
 * original schema without considering the initial encoding or transformation
 * processes.
 *
 * @since 0.67.0
 */
const typeSchema = schema => make(typeAST(schema.ast));
/**
 * Tests if a value is a `Schema`.
 *
 * @category guards
 * @since 0.67.0
 */
const isSchema = u => hasProperty(u, TypeId) && isObject(u[TypeId]);
const getDefaultLiteralAST = literals => isMembers(literals) ? Union$2.make(mapMembers(literals, literal => new Literal$1(literal))) : new Literal$1(literals[0]);
const makeLiteralClass = (literals, ast = getDefaultLiteralAST(literals)) => class LiteralClass extends make(ast) {
  static annotations(annotations) {
    return makeLiteralClass(this.literals, mergeSchemaAnnotations(this.ast, annotations));
  }
  static literals = [...literals];
};
function Literal(...literals) {
  return isNonEmptyReadonlyArray(literals) ? makeLiteralClass(literals) : Never;
}
const getDefaultEnumsAST = enums => new Enums$1(Object.keys(enums).filter(key => typeof enums[enums[key]] !== "number").map(key => [key, enums[key]]));
const makeEnumsClass = (enums, ast = getDefaultEnumsAST(enums)) => class EnumsClass extends make(ast) {
  static annotations(annotations) {
    return makeEnumsClass(this.enums, mergeSchemaAnnotations(this.ast, annotations));
  }
  static enums = {
    ...enums
  };
};
/**
 * @category constructors
 * @since 0.67.0
 */
const Enums = enums => makeEnumsClass(enums);
/**
 * @category constructors
 * @since 0.67.0
 */
const TemplateLiteral = (...[head, ...tail]) => {
  let astOrs = getTemplateLiterals(getTemplateLiteralParameterAST(head));
  for (const span of tail) {
    astOrs = flatMap$4(astOrs, a => getTemplateLiterals(getTemplateLiteralParameterAST(span)).map(b => combineTemplateLiterals(a, b)));
  }
  return make(Union$2.make(astOrs.map(astOr => isString(astOr) ? new Literal$1(astOr) : astOr)));
};
const getTemplateLiteralParameterAST = span => isSchema(span) ? span.ast : new Literal$1(String(span));
const combineTemplateLiterals = (a, b) => {
  if (isString(a)) {
    return isString(b) ? a + b : new TemplateLiteral$1(a + b.head, b.spans);
  }
  if (isString(b)) {
    return new TemplateLiteral$1(a.head, modifyNonEmptyLast(a.spans, span => new TemplateLiteralSpan(span.type, span.literal + b)));
  }
  return new TemplateLiteral$1(a.head, appendAll$2(modifyNonEmptyLast(a.spans, span => new TemplateLiteralSpan(span.type, span.literal + String(b.head))), b.spans));
};
const getTemplateLiterals = ast => {
  switch (ast._tag) {
    case "Literal":
      return [String(ast.literal)];
    case "NumberKeyword":
    case "StringKeyword":
      return [new TemplateLiteral$1("", [new TemplateLiteralSpan(ast, "")])];
    case "Union":
      return flatMap$4(ast.types, getTemplateLiterals);
  }
  throw new Error(`unsupported template literal span (${ast})`);
};
const declareConstructor = (typeParameters, options, annotations) => make(new Declaration$1(typeParameters.map(tp => tp.ast), (...typeParameters) => options.decode(...typeParameters.map(make)), (...typeParameters) => options.encode(...typeParameters.map(make)), toASTAnnotations(annotations)));
const declarePrimitive = (is, annotations) => {
  const decodeUnknown = () => (input, _, ast) => is(input) ? succeed(input) : fail(new Type(ast, input));
  const encodeUnknown = decodeUnknown;
  return make(new Declaration$1([], decodeUnknown, encodeUnknown, toASTAnnotations(annotations)));
};
/**
 * The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.
 * This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.
 *
 * @category constructors
 * @since 0.67.0
 */
const declare = function () {
  if (Array.isArray(arguments[0])) {
    const typeParameters = arguments[0];
    const options = arguments[1];
    const annotations = arguments[2];
    return declareConstructor(typeParameters, options, annotations);
  }
  const is = arguments[0];
  const annotations = arguments[1];
  return declarePrimitive(is, annotations);
};
/**
 * @category primitives
 * @since 0.67.0
 */
class Undefined extends make(undefinedKeyword) {
  static annotations = super.annotations;
}
/**
 * @category primitives
 * @since 0.67.0
 */
class Void extends make(voidKeyword) {
  static annotations = super.annotations;
}
/**
 * @category primitives
 * @since 0.67.0
 */
class Null extends make($null) {
  static annotations = super.annotations;
}
/**
 * @category primitives
 * @since 0.67.0
 */
class Never extends make(neverKeyword) {
  static annotations = super.annotations;
}
/**
 * @category primitives
 * @since 0.67.0
 */
class Unknown extends make(unknownKeyword) {
  static annotations = super.annotations;
}
/**
 * @category primitives
 * @since 0.67.0
 */
class Any extends make(anyKeyword) {
  static annotations = super.annotations;
}
/**
 * @category primitives
 * @since 0.67.0
 */
class BigIntFromSelf extends make(bigIntKeyword) {
  static annotations = super.annotations;
}
/**
 * @category primitives
 * @since 0.67.0
 */
class SymbolFromSelf extends make(symbolKeyword) {
  static annotations = super.annotations;
}
/** @ignore */
class String$ extends make(stringKeyword) {
  static annotations = super.annotations;
}
/** @ignore */
class Number$ extends make(numberKeyword) {
  static annotations = super.annotations;
}
/** @ignore */
class Boolean$ extends make(booleanKeyword) {
  static annotations = super.annotations;
}
/** @ignore */
class Object$ extends make(objectKeyword) {
  static annotations = super.annotations;
}
const getDefaultUnionAST = members => Union$2.members(members.map(m => m.ast));
const makeUnionClass = (members, ast = getDefaultUnionAST(members)) => class UnionClass extends make(ast) {
  static annotations(annotations) {
    return makeUnionClass(this.members, mergeSchemaAnnotations(this.ast, annotations));
  }
  static members = [...members];
};
function Union(...members) {
  return isMembers(members) ? makeUnionClass(members) : isNonEmptyReadonlyArray(members) ? members[0] : Never;
}
/**
 * @category combinators
 * @since 0.67.0
 */
const NullOr = self => Union(self, Null);
/**
 * @category combinators
 * @since 0.67.0
 */
const UndefinedOr = self => Union(self, Undefined);
/**
 * @category combinators
 * @since 0.67.0
 */
const NullishOr = self => Union(self, Null, Undefined);
const getDefaultTupleTypeAST = (elements, rest) => new TupleType$1(elements.map(schema => isSchema(schema) ? new Element(schema.ast, false) : new Element(schema.optionalElement.ast, true)), rest.map(e => e.ast), true);
const makeTupleTypeClass = (elements, rest, ast = getDefaultTupleTypeAST(elements, rest)) => class TupleTypeClass extends make(ast) {
  static annotations(annotations) {
    return makeTupleTypeClass(this.elements, this.rest, mergeSchemaAnnotations(this.ast, annotations));
  }
  static elements = [...elements];
  static rest = [...rest];
};
function Tuple(...args) {
  return Array.isArray(args[0]) ? makeTupleTypeClass(args[0], args.slice(1)) : makeTupleTypeClass(args, []);
}
const makeArrayClass = (value, ast) => class ArrayClass extends makeTupleTypeClass([], [value], ast) {
  static annotations(annotations) {
    return makeArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations));
  }
  static value = value;
};
const Array$ = value => makeArrayClass(value);
const formatToken = isOptional => isOptional ? "\"?:\"" : "\":\"";
/**
 * @category PropertySignature
 * @since 0.67.0
 */
class PropertySignatureDeclaration {
  type;
  isOptional;
  isReadonly;
  annotations;
  defaultValue;
  /**
   * @since 0.67.0
   */
  _tag = "PropertySignatureDeclaration";
  constructor(type, isOptional, isReadonly, annotations, defaultValue) {
    this.type = type;
    this.isOptional = isOptional;
    this.isReadonly = isReadonly;
    this.annotations = annotations;
    this.defaultValue = defaultValue;
  }
  /**
   * @since 0.67.0
   */
  toString() {
    const token = formatToken(this.isOptional);
    const type = String(this.type);
    return `PropertySignature<${token}, ${type}, never, ${token}, ${type}>`;
  }
}
/**
 * @category PropertySignature
 * @since 0.67.0
 */
class FromPropertySignature {
  type;
  isOptional;
  isReadonly;
  annotations;
  fromKey;
  constructor(type, isOptional, isReadonly, annotations, fromKey) {
    this.type = type;
    this.isOptional = isOptional;
    this.isReadonly = isReadonly;
    this.annotations = annotations;
    this.fromKey = fromKey;
  }
}
/**
 * @category PropertySignature
 * @since 0.67.0
 */
class ToPropertySignature {
  type;
  isOptional;
  isReadonly;
  annotations;
  defaultValue;
  constructor(type, isOptional, isReadonly, annotations, defaultValue) {
    this.type = type;
    this.isOptional = isOptional;
    this.isReadonly = isReadonly;
    this.annotations = annotations;
    this.defaultValue = defaultValue;
  }
}
const formatPropertyKey = p => {
  if (p === undefined) {
    return "never";
  }
  if (isString(p)) {
    return JSON.stringify(p);
  }
  return String(p);
};
/**
 * @category PropertySignature
 * @since 0.67.0
 */
class PropertySignatureTransformation {
  from;
  to;
  decode;
  encode;
  /**
   * @since 0.67.0
   */
  _tag = "PropertySignatureTransformation";
  constructor(from, to, decode, encode) {
    this.from = from;
    this.to = to;
    this.decode = decode;
    this.encode = encode;
  }
  /**
   * @since 0.67.0
   */
  toString() {
    return `PropertySignature<${formatToken(this.to.isOptional)}, ${this.to.type}, ${formatPropertyKey(this.from.fromKey)}, ${formatToken(this.from.isOptional)}, ${this.from.type}>`;
  }
}
/**
 * @since 0.67.0
 * @category symbol
 */
const PropertySignatureTypeId = /*#__PURE__*/Symbol.for("@effect/schema/PropertySignature");
const mergeSignatureAnnotations = (ast, annotations) => {
  switch (ast._tag) {
    case "PropertySignatureDeclaration":
      {
        return new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, {
          ...ast.annotations,
          ...annotations
        }, ast.defaultValue);
      }
    case "PropertySignatureTransformation":
      {
        return new PropertySignatureTransformation(new FromPropertySignature(ast.from.type, ast.from.isOptional, ast.from.isReadonly, ast.from.annotations), new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {
          ...ast.to.annotations,
          ...annotations
        }, ast.to.defaultValue), ast.decode, ast.encode);
      }
  }
};
class PropertySignatureImpl {
  ast;
  [TypeId];
  [PropertySignatureTypeId] = null;
  _TypeToken;
  _Key;
  _EncodedToken;
  _HasDefault;
  constructor(ast) {
    this.ast = ast;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  annotations(annotations) {
    return new PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations)));
  }
  toString() {
    return String(this.ast);
  }
}
/**
 * @category PropertySignature
 * @since 0.67.15
 */
const makePropertySignature = ast => new PropertySignatureImpl(ast);
class PropertySignatureWithFromImpl extends PropertySignatureImpl {
  from;
  constructor(ast, from) {
    super(ast);
    this.from = from;
  }
  annotations(annotations) {
    return new PropertySignatureWithFromImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations)), this.from);
  }
}
/**
 * Lifts a `Schema` into a `PropertySignature`.
 *
 * @category PropertySignature
 * @since 0.67.0
 */
const propertySignature = self => new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(self.ast, false, true, {}, undefined), self);
/**
 * Enhances a property signature with a default constructor value.
 *
 * @category PropertySignature
 * @since 0.67.0
 */
const withConstructorDefault = /*#__PURE__*/dual(2, (self, defaultValue) => {
  const ast = self.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration":
      return makePropertySignature(new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, defaultValue));
    case "PropertySignatureTransformation":
      return makePropertySignature(new PropertySignatureTransformation(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, ast.to.annotations, defaultValue), ast.decode, ast.encode));
  }
});
/**
 * Enhances a property signature by specifying a different key for it in the Encoded type.
 *
 * @category PropertySignature
 * @since 0.67.0
 */
const fromKey = /*#__PURE__*/dual(2, (self, key) => {
  const ast = self.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration":
      {
        return makePropertySignature(new PropertySignatureTransformation(new FromPropertySignature(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, key), new ToPropertySignature(typeAST(ast.type), ast.isOptional, ast.isReadonly, {}, ast.defaultValue), identity, identity));
      }
    case "PropertySignatureTransformation":
      return makePropertySignature(new PropertySignatureTransformation(new FromPropertySignature(ast.from.type, ast.from.isOptional, ast.from.isReadonly, ast.from.annotations, key), ast.to, ast.decode, ast.encode));
  }
});
/**
 * Converts an optional property to a required one through a transformation `Option -> Type`.
 *
 * - `decode`: `none` as argument means the value is missing in the input.
 * - `encode`: `none` as return value means the value will be missing in the output.
 *
 * @category PropertySignature
 * @since 0.67.0
 */
const optionalToRequired = (from, to, options) => makePropertySignature(new PropertySignatureTransformation(new FromPropertySignature(from.ast, true, true, {}, undefined), new ToPropertySignature(to.ast, false, true, {}, undefined), o => some(options.decode(o)), flatMap$5(options.encode)));
/**
 * Converts an optional property to a required one through a transformation `Type -> Option`.
 *
 * - `decode`: `none` as return value means the value will be missing in the output.
 * - `encode`: `none` as argument means the value is missing in the input.
 *
 * @category PropertySignature
 * @since 0.67.15
 */
const requiredToOptional = (from, to, options) => makePropertySignature(new PropertySignatureTransformation(new FromPropertySignature(from.ast, false, true, {}, undefined), new ToPropertySignature(to.ast, true, true, {}, undefined), flatMap$5(options.decode), o => some(options.encode(o))));
/**
 * Converts an optional property to another optional property through a transformation `Option -> Option`.
 *
 * - `decode`:
 *   - `none` as argument means the value is missing in the input.
 *   - `none` as return value means the value will be missing in the output.
 * - `encode`:
 *   - `none` as argument means the value is missing in the input.
 *   - `none` as return value means the value will be missing in the output.
 *
 * @category PropertySignature
 * @since 0.67.0
 */
const optionalToOptional = (from, to, options) => makePropertySignature(new PropertySignatureTransformation(new FromPropertySignature(from.ast, true, true, {}, undefined), new ToPropertySignature(to.ast, true, true, {}, undefined), options.decode, options.encode));
const optionalPropertySignatureAST = (from, options) => {
  const isExact = options?.exact;
  const defaultValue = options?.default;
  const isNullable = options?.nullable;
  const asOption = options?.as == "Option";
  const asOptionEncode = options?.onNoneEncoding ? orElse$2(options.onNoneEncoding) : identity;
  if (isExact) {
    if (defaultValue) {
      if (isNullable) {
        return withConstructorDefault(optionalToRequired(NullOr(from), typeSchema(from), {
          decode: match$3({
            onNone: defaultValue,
            onSome: a => a === null ? defaultValue() : a
          }),
          encode: some
        }), defaultValue).ast;
      } else {
        return withConstructorDefault(optionalToRequired(from, typeSchema(from), {
          decode: match$3({
            onNone: defaultValue,
            onSome: identity
          }),
          encode: some
        }), defaultValue).ast;
      }
    } else if (asOption) {
      if (isNullable) {
        return optionalToRequired(NullOr(from), OptionFromSelf(typeSchema(from)), {
          decode: filter$2(isNotNull),
          encode: asOptionEncode
        }).ast;
      } else {
        return optionalToRequired(from, OptionFromSelf(typeSchema(from)), {
          decode: identity,
          encode: identity
        }).ast;
      }
    } else {
      if (isNullable) {
        return optionalToOptional(NullOr(from), typeSchema(from), {
          decode: filter$2(isNotNull),
          encode: identity
        }).ast;
      } else {
        return new PropertySignatureDeclaration(from.ast, true, true, {}, undefined);
      }
    }
  } else {
    if (defaultValue) {
      if (isNullable) {
        return withConstructorDefault(optionalToRequired(NullishOr(from), typeSchema(from), {
          decode: match$3({
            onNone: defaultValue,
            onSome: a => a == null ? defaultValue() : a
          }),
          encode: some
        }), defaultValue).ast;
      } else {
        return withConstructorDefault(optionalToRequired(UndefinedOr(from), typeSchema(from), {
          decode: match$3({
            onNone: defaultValue,
            onSome: a => a === undefined ? defaultValue() : a
          }),
          encode: some
        }), defaultValue).ast;
      }
    } else if (asOption) {
      if (isNullable) {
        return optionalToRequired(NullishOr(from), OptionFromSelf(typeSchema(from)), {
          decode: filter$2(a => a != null),
          encode: asOptionEncode
        }).ast;
      } else {
        return optionalToRequired(UndefinedOr(from), OptionFromSelf(typeSchema(from)), {
          decode: filter$2(isNotUndefined),
          encode: asOptionEncode
        }).ast;
      }
    } else {
      if (isNullable) {
        return optionalToOptional(NullishOr(from), UndefinedOr(typeSchema(from)), {
          decode: filter$2(isNotNull),
          encode: identity
        }).ast;
      } else {
        return new PropertySignatureDeclaration(UndefinedOr(from).ast, true, true, {}, undefined);
      }
    }
  }
};
/**
 * @category PropertySignature
 * @since 0.67.0
 */
const optional = /*#__PURE__*/dual(args => isSchema(args[0]), (from, options) => {
  // Note: `Schema.All extends S ? "you can't...` is used to prevent the case where `optional` is implicitly applied.
  // For example: `S.String.pipe(S.optional)` would result in `S.String` being inferred as `Schema.All`,
  // which is not the intended behavior. This is mostly an aesthetic consideration, so if it causes issues, we can remove it.
  return new PropertySignatureWithFromImpl(optionalPropertySignatureAST(from, options), from);
});
const isPropertySignature = u => hasProperty(u, PropertySignatureTypeId);
const getDefaultTypeLiteralAST = (fields, records) => {
  const ownKeys$1 = ownKeys(fields);
  const pss = [];
  if (ownKeys$1.length > 0) {
    const from = [];
    const to = [];
    const transformations = [];
    for (let i = 0; i < ownKeys$1.length; i++) {
      const key = ownKeys$1[i];
      const field = fields[key];
      if (isPropertySignature(field)) {
        const ast = field.ast;
        switch (ast._tag) {
          case "PropertySignatureDeclaration":
            {
              const type = ast.type;
              const isOptional = ast.isOptional;
              const toAnnotations = ast.annotations;
              from.push(new PropertySignature(key, type, isOptional, true));
              to.push(new PropertySignature(key, typeAST(type), isOptional, true, toAnnotations));
              pss.push(new PropertySignature(key, type, isOptional, true, toAnnotations));
              break;
            }
          case "PropertySignatureTransformation":
            {
              const fromKey = ast.from.fromKey ?? key;
              from.push(new PropertySignature(fromKey, ast.from.type, ast.from.isOptional, true, ast.from.annotations));
              to.push(new PropertySignature(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations));
              transformations.push(new PropertySignatureTransformation$1(fromKey, key, ast.decode, ast.encode));
              break;
            }
        }
      } else {
        from.push(new PropertySignature(key, field.ast, false, true));
        to.push(new PropertySignature(key, typeAST(field.ast), false, true));
        pss.push(new PropertySignature(key, field.ast, false, true));
      }
    }
    if (isNonEmptyReadonlyArray(transformations)) {
      const issFrom = [];
      const issTo = [];
      for (const r of records) {
        const {
          indexSignatures,
          propertySignatures
        } = record(r.key.ast, r.value.ast);
        propertySignatures.forEach(ps => {
          from.push(ps);
          to.push(new PropertySignature(ps.name, typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations));
        });
        indexSignatures.forEach(is => {
          issFrom.push(is);
          issTo.push(new IndexSignature(is.parameter, typeAST(is.type), is.isReadonly));
        });
      }
      return new Transformation$1(new TypeLiteral$1(from, issFrom, {
        [TitleAnnotationId]: "Struct (Encoded side)"
      }), new TypeLiteral$1(to, issTo, {
        [TitleAnnotationId]: "Struct (Type side)"
      }), new TypeLiteralTransformation(transformations));
    }
  }
  const iss = [];
  for (const r of records) {
    const {
      indexSignatures,
      propertySignatures
    } = record(r.key.ast, r.value.ast);
    propertySignatures.forEach(ps => pss.push(ps));
    indexSignatures.forEach(is => iss.push(is));
  }
  return new TypeLiteral$1(pss, iss);
};
const lazilyMergeDefaults = (fields, out) => {
  const ownKeys$1 = ownKeys(fields);
  for (const key of ownKeys$1) {
    const field = fields[key];
    if (out[key] === undefined && isPropertySignature(field)) {
      const ast = field.ast;
      const defaultValue = ast._tag === "PropertySignatureDeclaration" ? ast.defaultValue : ast.to.defaultValue;
      if (defaultValue !== undefined) {
        out[key] = defaultValue();
      }
    }
  }
  return out;
};
const makeTypeLiteralClass = (fields, records, ast = getDefaultTypeLiteralAST(fields, records)) => {
  return class TypeLiteralClass extends make(ast) {
    static annotations(annotations) {
      return makeTypeLiteralClass(this.fields, this.records, mergeSchemaAnnotations(this.ast, annotations));
    }
    static fields = {
      ...fields
    };
    static records = [...records];
    static make = (props, options) => {
      const propsWithDefaults = lazilyMergeDefaults(fields, {
        ...props
      });
      return getDisableValidationMakeOption(options) ? propsWithDefaults : validateSync(this)(propsWithDefaults);
    };
  };
};
function Struct(fields, ...records) {
  return makeTypeLiteralClass(fields, records);
}
/**
 * Creates a new schema with shallow mutability applied to its properties.
 *
 * @param schema - The original schema to make properties mutable (shallowly).
 *
 * @category combinators
 * @since 0.67.0
 */
const mutable = schema => make(mutable$1(schema.ast));
/**
 * @category constructors
 * @since 0.67.0
 */
const suspend = f => make(new Suspend(() => f().ast));
const makeRefineClass = (from, filter, ast) => class RefineClass extends make(ast) {
  static annotations(annotations) {
    return makeRefineClass(this.from, this.filter, mergeSchemaAnnotations(this.ast, annotations));
  }
  static from = from;
  static filter = filter;
  static make = (a, options) => {
    return getDisableValidationMakeOption(options) ? a : validateSync(this)(a);
  };
};
function filter$1(predicate, annotations) {
  return self => {
    function filter(a, options, ast) {
      const out = predicate(a, options, ast);
      if (isBoolean(out)) {
        return out ? none$4() : some(new Type(ast, a));
      }
      if (isString(out)) {
        return some(new Type(ast, a, out));
      }
      return out === undefined ? none$4() : some(out);
    }
    const ast = new Refinement$1(self.ast, filter, toASTAnnotations(annotations));
    return makeRefineClass(self, filter, ast);
  };
}
const makeTransformationClass = (from, to, ast) => class TransformationClass extends make(ast) {
  static annotations(annotations) {
    return makeTransformationClass(this.from, this.to, mergeSchemaAnnotations(this.ast, annotations));
  }
  static from = from;
  static to = to;
};
/**
 * Create a new `Schema` by transforming the input and output of an existing `Schema`
 * using the provided decoding functions.
 *
 * @category combinators
 * @since 0.67.0
 */
const transformOrFail = /*#__PURE__*/dual(args => isSchema(args[0]) && isSchema(args[1]), (from, to, options) => makeTransformationClass(from, to, new Transformation$1(from.ast, to.ast, new FinalTransformation(options.decode, options.encode))));
/**
 * Create a new `Schema` by transforming the input and output of an existing `Schema`
 * using the provided mapping functions.
 *
 * @category combinators
 * @since 0.67.0
 */
const transform = /*#__PURE__*/dual(args => isSchema(args[0]) && isSchema(args[1]), (from, to, options) => transformOrFail(from, to, {
  decode: fromA => succeed(options.decode(fromA)),
  encode: toI => succeed(options.encode(toI))
}));
/**
 * @category type id
 * @since 0.67.0
 */
const TrimmedTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/Trimmed");
/**
 * Verifies that a string contains no leading or trailing whitespaces.
 *
 * Note. This combinator does not make any transformations, it only validates.
 * If what you were looking for was a combinator to trim strings, then check out the `trim` combinator.
 *
 * @category string filters
 * @since 0.67.0
 */
const trimmed = annotations => self => self.pipe(filter$1(a => a === a.trim(), {
  typeId: TrimmedTypeId,
  description: "a string with no leading or trailing whitespace",
  jsonSchema: {
    pattern: "^\\S[\\s\\S]*\\S$|^\\S$|^$"
  },
  ...annotations
}));
/**
 * @category type id
 * @since 0.67.0
 */
const MinLengthTypeId = MinLengthTypeId$1;
/**
 * @category string filters
 * @since 0.67.0
 */
const minLength = (minLength, annotations) => self => self.pipe(filter$1(a => a.length >= minLength, {
  typeId: MinLengthTypeId,
  description: `a string at least ${minLength} character(s) long`,
  jsonSchema: {
    minLength
  },
  ...annotations
}));
/**
 * @category type id
 * @since 0.67.0
 */
const PatternTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/Pattern");
/**
 * @category string filters
 * @since 0.67.0
 */
const pattern = (regex, annotations) => self => {
  const pattern = regex.source;
  return self.pipe(filter$1(a => {
    // The following line ensures that `lastIndex` is reset to `0` in case the user has specified the `g` flag
    regex.lastIndex = 0;
    return regex.test(a);
  }, {
    typeId: {
      id: PatternTypeId,
      annotation: {
        regex
      }
    },
    description: `a string matching the pattern ${pattern}`,
    jsonSchema: {
      pattern
    },
    arbitrary: () => fc => fc.stringMatching(regex),
    ...annotations
  }));
};
/**
 * @category type id
 * @since 0.67.0
 */
const LowercasedTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/Lowercased");
/**
 * Verifies that a string is lowercased.
 *
 * @category string filters
 * @since 0.67.0
 */
const lowercased = annotations => self => self.pipe(filter$1(a => a === a.toLowerCase(), {
  typeId: LowercasedTypeId,
  description: "a lowercase string",
  ...annotations
}));
/**
 * @category string constructors
 * @since 0.67.0
 */
class Lowercased extends String$.pipe(lowercased({
  identifier: "Lowercased",
  title: "Lowercased"
})) {
  static annotations = super.annotations;
}
/**
 * @category type id
 * @since 0.67.0
 */
const UppercasedTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/Uppercased");
/**
 * Verifies that a string is uppercased.
 *
 * @category string filters
 * @since 0.67.0
 */
const uppercased = annotations => self => self.pipe(filter$1(a => a === a.toUpperCase(), {
  typeId: UppercasedTypeId,
  description: "an uppercase string",
  ...annotations
}));
/**
 * @category string constructors
 * @since 0.67.0
 */
class Uppercased extends String$.pipe(uppercased({
  identifier: "Uppercased",
  title: "Uppercased"
})) {
  static annotations = super.annotations;
}
/**
 * @category type id
 * @since 0.67.0
 */
const LengthTypeId = LengthTypeId$1;
/**
 * @category string filters
 * @since 0.67.0
 */
const length = (length, annotations) => self => {
  const minLength = isObject(length) ? Math.max(0, Math.floor(length.min)) : Math.max(0, Math.floor(length));
  const maxLength = isObject(length) ? Math.max(minLength, Math.floor(length.max)) : minLength;
  if (minLength !== maxLength) {
    return self.pipe(filter$1(a => a.length >= minLength && a.length <= maxLength, {
      typeId: LengthTypeId,
      description: `a string at least ${minLength} character(s) and at most ${maxLength} character(s) long`,
      jsonSchema: {
        minLength,
        maxLength
      },
      ...annotations
    }));
  }
  return self.pipe(filter$1(a => a.length === minLength, {
    typeId: LengthTypeId,
    description: minLength === 1 ? `a single character` : `a string ${minLength} character(s) long`,
    jsonSchema: {
      minLength,
      maxLength: minLength
    },
    ...annotations
  }));
};
/**
 * A schema representing a single character.
 *
 * @category string constructors
 * @since 0.67.0
 */
class Char extends String$.pipe(length(1, {
  identifier: "Char"
})) {
  static annotations = super.annotations;
}
/**
 * @category string filters
 * @since 0.67.0
 */
const nonEmpty = annotations => minLength(1, {
  description: "a non empty string",
  ...annotations
});
/**
 * This schema converts a string to lowercase.
 *
 * @category string transformations
 * @since 0.67.0
 */
class Lowercase extends transform(String$, Lowercased, {
  decode: s => s.toLowerCase(),
  encode: identity
}).annotations({
  identifier: "Lowercase"
}) {
  static annotations = super.annotations;
}
/**
 * This schema converts a string to uppercase.
 *
 * @category string transformations
 * @since 0.67.0
 */
class Uppercase extends transform(String$, Uppercased, {
  decode: s => s.toUpperCase(),
  encode: identity
}).annotations({
  identifier: "Uppercase"
}) {
  static annotations = super.annotations;
}
/**
 * @category string constructors
 * @since 0.67.0
 */
class Trimmed extends String$.pipe(trimmed({
  identifier: "Trimmed",
  title: "Trimmed"
})) {
  static annotations = super.annotations;
}
/**
 * This schema allows removing whitespaces from the beginning and end of a string.
 *
 * @category string transformations
 * @since 0.67.0
 */
class Trim extends transform(String$, Trimmed, {
  decode: s => s.trim(),
  encode: identity
}).annotations({
  identifier: "Trim"
}) {
  static annotations = super.annotations;
}
/**
 * @category string constructors
 * @since 0.67.0
 */
class NonEmpty extends String$.pipe(nonEmpty({
  identifier: "NonEmpty",
  title: "NonEmpty"
})) {
  static annotations = super.annotations;
}
/**
 * @category type id
 * @since 0.67.0
 */
const UUIDTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/UUID");
const uuidRegexp = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
/**
 * Represents a Universally Unique Identifier (UUID).
 *
 * This schema ensures that the provided string adheres to the standard UUID format.
 *
 * @category string constructors
 * @since 0.67.0
 */
class UUID extends String$.pipe(pattern(uuidRegexp, {
  typeId: UUIDTypeId,
  identifier: "UUID",
  title: "UUID",
  description: "a Universally Unique Identifier",
  arbitrary: () => fc => fc.uuid()
})) {
  static annotations = super.annotations;
}
/**
 * @category type id
 * @since 0.67.0
 */
const ULIDTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/ULID");
const ulidRegexp = /^[0-7][0-9A-HJKMNP-TV-Z]{25}$/i;
/**
 * Represents a Universally Unique Lexicographically Sortable Identifier (ULID).
 *
 * ULIDs are designed to be compact, URL-safe, and ordered, making them suitable for use as identifiers.
 * This schema ensures that the provided string adheres to the standard ULID format.
 *
 * @category string constructors
 * @since 0.67.0
 */
class ULID extends String$.pipe(pattern(ulidRegexp, {
  typeId: ULIDTypeId,
  identifier: "ULID",
  title: "ULID",
  description: "a Universally Unique Lexicographically Sortable Identifier",
  arbitrary: () => fc => fc.ulid()
})) {
  static annotations = super.annotations;
}
/**
 * @category type id
 * @since 0.67.0
 */
const FiniteTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/Finite");
/**
 * Ensures that the provided value is a finite number.
 *
 * This schema filters out non-finite numeric values, allowing only finite numbers to pass through.
 *
 * @category number filters
 * @since 0.67.0
 */
const finite = annotations => self => self.pipe(filter$1(a => Number.isFinite(a), {
  typeId: FiniteTypeId,
  description: "a finite number",
  ...annotations
}));
/**
 * @category type id
 * @since 0.67.0
 */
const GreaterThanTypeId = GreaterThanTypeId$1;
/**
 * This filter checks whether the provided number is greater than the specified minimum.
 *
 * @category number filters
 * @since 0.67.0
 */
const greaterThan = (min, annotations) => self => self.pipe(filter$1(a => a > min, {
  typeId: GreaterThanTypeId,
  description: "a positive number" ,
  jsonSchema: {
    exclusiveMinimum: min
  },
  ...annotations
}));
/**
 * @category type id
 * @since 0.67.0
 */
const GreaterThanOrEqualToTypeId = GreaterThanOrEqualToTypeId$1;
/**
 * This filter checks whether the provided number is greater than or equal to the specified minimum.
 *
 * @category number filters
 * @since 0.67.0
 */
const greaterThanOrEqualTo = (min, annotations) => self => self.pipe(filter$1(a => a >= min, {
  typeId: GreaterThanOrEqualToTypeId,
  description: "a non-negative number" ,
  jsonSchema: {
    minimum: min
  },
  ...annotations
}));
/**
 * @category type id
 * @since 0.67.0
 */
const IntTypeId = IntTypeId$1;
/**
 * @category number filters
 * @since 0.67.0
 */
const int = annotations => self => self.pipe(filter$1(a => Number.isSafeInteger(a), {
  typeId: IntTypeId,
  title: "integer",
  description: "an integer",
  jsonSchema: {
    type: "integer"
  },
  ...annotations
}));
/**
 * @category type id
 * @since 0.67.0
 */
const LessThanTypeId = LessThanTypeId$1;
/**
 * This filter checks whether the provided number is less than the specified maximum.
 *
 * @category number filters
 * @since 0.67.0
 */
const lessThan = (max, annotations) => self => self.pipe(filter$1(a => a < max, {
  typeId: LessThanTypeId,
  description: "a negative number" ,
  jsonSchema: {
    exclusiveMaximum: max
  },
  ...annotations
}));
/**
 * @category type id
 * @since 0.67.0
 */
const LessThanOrEqualToTypeId = LessThanOrEqualToTypeId$1;
/**
 * This schema checks whether the provided number is less than or equal to the specified maximum.
 *
 * @category number filters
 * @since 0.67.0
 */
const lessThanOrEqualTo = (max, annotations) => self => self.pipe(filter$1(a => a <= max, {
  typeId: LessThanOrEqualToTypeId,
  description: "a non-positive number" ,
  jsonSchema: {
    maximum: max
  },
  ...annotations
}));
/**
 * @category type id
 * @since 0.67.0
 */
const NonNaNTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/NonNaN");
/**
 * @category number filters
 * @since 0.67.0
 */
const nonNaN = annotations => self => self.pipe(filter$1(a => !Number.isNaN(a), {
  typeId: NonNaNTypeId,
  description: "a number excluding NaN",
  ...annotations
}));
/**
 * @category number filters
 * @since 0.67.0
 */
const positive = annotations => greaterThan(0, annotations);
/**
 * @category number filters
 * @since 0.67.0
 */
const negative = annotations => lessThan(0, annotations);
/**
 * @category number filters
 * @since 0.67.0
 */
const nonPositive = annotations => lessThanOrEqualTo(0, annotations);
/**
 * @category number filters
 * @since 0.67.0
 */
const nonNegative = annotations => greaterThanOrEqualTo(0, annotations);
/**
 * Transforms a `string` into a `number` by parsing the string using the `parse` function of the `effect/Number` module.
 *
 * It returns an error if the value can't be converted (for example when non-numeric characters are provided).
 *
 * The following special string values are supported: "NaN", "Infinity", "-Infinity".
 *
 * @category number transformations
 * @since 0.67.0
 */
const parseNumber = self => transformOrFail(self, Number$, {
  strict: false,
  decode: (s, _, ast) => fromOption(parse(s), () => new Type(ast, s)),
  encode: n => succeed(String(n))
});
/**
 * This schema transforms a `string` into a `number` by parsing the string using the `parse` function of the `effect/Number` module.
 *
 * It returns an error if the value can't be converted (for example when non-numeric characters are provided).
 *
 * The following special string values are supported: "NaN", "Infinity", "-Infinity".
 *
 * @category number constructors
 * @since 0.67.0
 */
class NumberFromString extends parseNumber(String$).annotations({
  identifier: "NumberFromString"
}) {
  static annotations = super.annotations;
}
/**
 * @category number constructors
 * @since 0.67.0
 */
class Finite extends Number$.pipe(finite({
  identifier: "Finite",
  title: "Finite"
})) {
  static annotations = super.annotations;
}
/**
 * @category number constructors
 * @since 0.67.0
 */
class Int extends Number$.pipe(int({
  identifier: "Int",
  title: "Int"
})) {
  static annotations = super.annotations;
}
/**
 * @category number constructors
 * @since 0.67.0
 */
class NonNaN extends Number$.pipe(nonNaN({
  identifier: "NonNaN",
  title: "NonNaN"
})) {
  static annotations = super.annotations;
}
/**
 * @category number constructors
 * @since 0.67.0
 */
class Positive extends Number$.pipe(positive({
  identifier: "Positive",
  title: "Positive"
})) {
  static annotations = super.annotations;
}
/**
 * @category number constructors
 * @since 0.67.0
 */
class Negative extends Number$.pipe(negative({
  identifier: "Negative",
  title: "Negative"
})) {
  static annotations = super.annotations;
}
/**
 * @category number constructors
 * @since 0.67.0
 */
class NonPositive extends Number$.pipe(nonPositive({
  identifier: "NonPositive",
  title: "NonPositive"
})) {
  static annotations = super.annotations;
}
/**
 * @category number constructors
 * @since 0.67.0
 */
class NonNegative extends Number$.pipe(nonNegative({
  identifier: "NonNegative",
  title: "NonNegative"
})) {
  static annotations = super.annotations;
}
/**
 * @category type id
 * @since 0.67.0
 */
const JsonNumberTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/JsonNumber");
/**
 * The `JsonNumber` is a schema for representing JSON numbers. It ensures that the provided value is a valid
 * number by filtering out `NaN` and `(+/-) Infinity`. This is useful when you want to validate and represent numbers in JSON
 * format.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * const is = S.is(S.JsonNumber)
 *
 * assert.deepStrictEqual(is(42), true)
 * assert.deepStrictEqual(is(Number.NaN), false)
 * assert.deepStrictEqual(is(Number.POSITIVE_INFINITY), false)
 * assert.deepStrictEqual(is(Number.NEGATIVE_INFINITY), false)
 *
 * @category number constructors
 * @since 0.67.0
 */
class JsonNumber extends Number$.pipe(filter$1(n => !Number.isNaN(n) && Number.isFinite(n), {
  typeId: JsonNumberTypeId,
  identifier: "JsonNumber",
  title: "JSON-compatible number",
  description: "a JSON-compatible number, excluding NaN, +Infinity, and -Infinity",
  jsonSchema: {
    type: "number"
  }
})) {
  static annotations = super.annotations;
}
/**
 * @category boolean transformations
 * @since 0.67.0
 */
class Not extends transform(Boolean$, Boolean$, {
  decode: not,
  encode: not
}) {
  static annotations = super.annotations;
}
/** @ignore */
class Symbol$ extends transform(String$, SymbolFromSelf, {
  strict: false,
  decode: s => Symbol.for(s),
  encode: sym => sym.description
}).annotations({
  identifier: "symbol"
}) {
  static annotations = super.annotations;
}
/** @ignore */
class BigInt$ extends transformOrFail(String$, BigIntFromSelf, {
  decode: (s, _, ast) => fromOption(fromString$3(s), () => new Type(ast, s)),
  encode: n => succeed(String(n))
}).annotations({
  identifier: "bigint"
}) {
  static annotations = super.annotations;
}
/**
 * This schema transforms a `number` into a `bigint` by parsing the number using the `BigInt` function.
 *
 * It returns an error if the value can't be safely encoded as a `number` due to being out of range.
 *
 * @category bigint transformations
 * @since 0.67.0
 */
class BigIntFromNumber extends transformOrFail(Number$, BigIntFromSelf, {
  decode: (n, _, ast) => fromOption(fromNumber$1(n), () => new Type(ast, n)),
  encode: (b, _, ast) => fromOption(toNumber(b), () => new Type(ast, b))
}).annotations({
  identifier: "BigintFromNumber"
}) {
  static annotations = super.annotations;
}
/**
 * @category Secret constructors
 * @since 0.67.0
 * @deprecated
 */
class SecretFromSelf extends declare(isSecret, {
  identifier: "SecretFromSelf",
  pretty: () => secret => String(secret),
  arbitrary: () => fc => fc.string().map(_ => fromString$1(_))
}) {
  static annotations = super.annotations;
}
/**
 * A schema that transforms a `string` into a `Secret`.
 *
 * @category Secret transformations
 * @since 0.67.0
 * @deprecated
 */
class Secret extends transform(String$, SecretFromSelf, {
  strict: false,
  decode: str => fromString$1(str),
  encode: secret => value(secret)
}).annotations({
  identifier: "Secret"
}) {
  static annotations = super.annotations;
}
/**
 * @category Duration constructors
 * @since 0.67.0
 */
class DurationFromSelf extends declare(isDuration, {
  identifier: "DurationFromSelf",
  pretty: () => String,
  arbitrary: () => fc => fc.oneof(fc.constant(infinity), fc.bigUint().map(_ => nanos(_)), fc.bigUint().map(_ => micros(_)), fc.maxSafeNat().map(_ => millis(_)), fc.maxSafeNat().map(_ => seconds(_)), fc.maxSafeNat().map(_ => minutes(_)), fc.maxSafeNat().map(_ => hours(_)), fc.maxSafeNat().map(_ => days(_)), fc.maxSafeNat().map(_ => weeks(_))),
  equivalence: () => Equivalence$1
}) {
  static annotations = super.annotations;
}
/**
 * A schema that transforms a `bigint` tuple into a `Duration`.
 * Treats the value as the number of nanoseconds.
 *
 * @category Duration transformations
 * @since 0.67.0
 */
class DurationFromNanos extends transformOrFail(BigIntFromSelf, DurationFromSelf, {
  decode: nanos$1 => succeed(nanos(nanos$1)),
  encode: (duration, _, ast) => match$3(toNanos(duration), {
    onNone: () => fail(new Type(ast, duration)),
    onSome: val => succeed(val)
  })
}).annotations({
  identifier: "DurationFromNanos"
}) {
  static annotations = super.annotations;
}
/**
 * A schema that transforms a `number` tuple into a `Duration`.
 * Treats the value as the number of milliseconds.
 *
 * @category Duration transformations
 * @since 0.67.0
 */
class DurationFromMillis extends transform(Number$, DurationFromSelf, {
  decode: ms => millis(ms),
  encode: n => toMillis(n)
}).annotations({
  identifier: "DurationFromMillis"
}) {
  static annotations = super.annotations;
}
const hrTime = /*#__PURE__*/Tuple( /*#__PURE__*/NonNegative.pipe( /*#__PURE__*/finite({
  [TitleAnnotationId]: "seconds",
  [DescriptionAnnotationId]: "seconds"
})), /*#__PURE__*/NonNegative.pipe( /*#__PURE__*/finite({
  [TitleAnnotationId]: "nanos",
  [DescriptionAnnotationId]: "nanos"
})));
/**
 * A schema that transforms a `[number, number]` tuple into a `Duration`.
 *
 * @category Duration transformations
 * @since 0.67.0
 */
let Duration$2 = class Duration extends transform(hrTime, DurationFromSelf, {
  decode: ([seconds, nanos$1]) => nanos(BigInt(seconds) * BigInt(1e9) + BigInt(nanos$1)),
  encode: duration => toHrTime(duration)
}).annotations({
  identifier: "Duration"
}) {
  static annotations = super.annotations;
};
/**
 * @category Uint8Array constructors
 * @since 0.67.0
 */
const Uint8ArrayFromSelf = /*#__PURE__*/declare(isUint8Array, {
  identifier: "Uint8ArrayFromSelf",
  pretty: () => u8arr => `new Uint8Array(${JSON.stringify(Array.from(u8arr))})`,
  arbitrary: () => fc => fc.uint8Array(),
  equivalence: () => getEquivalence$2(equals$2)
});
/**
 * @category type id
 * @since 0.67.0
 */
const ValidDateTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/ValidDate");
/**
 * A filter that **excludes invalid** dates (e.g., `new Date("Invalid Date")` is rejected).
 *
 * @category Date filters
 * @since 0.67.0
 */
const validDate = annotations => self => self.pipe(filter$1(a => !Number.isNaN(a.getTime()), {
  typeId: ValidDateTypeId,
  description: "a valid Date",
  ...annotations
}));
/**
 * Represents a schema for handling potentially **invalid** `Date` instances (e.g., `new Date("Invalid Date")` is not rejected).
 *
 * @category Date constructors
 * @since 0.67.0
 */
class DateFromSelf extends declare(isDate, {
  identifier: "DateFromSelf",
  description: "a potentially invalid Date instance",
  pretty: () => date => `new Date(${JSON.stringify(date)})`,
  arbitrary: () => fc => fc.date({
    noInvalidDate: false
  }),
  equivalence: () => Date$1
}) {
  static annotations = super.annotations;
}
/**
 * Represents a schema for handling only **valid** dates. For example, `new Date("Invalid Date")` is rejected, even though it is an instance of `Date`.
 *
 * @category Date constructors
 * @since 0.67.0
 */
class ValidDateFromSelf extends DateFromSelf.pipe(validDate({
  identifier: "ValidDateFromSelf",
  description: "a valid Date instance"
})) {
  static annotations = super.annotations;
}
/**
 * Represents a schema that converts a `string` into a (potentially invalid) `Date` (e.g., `new Date("Invalid Date")` is not rejected).
 *
 * @category Date transformations
 * @since 0.67.0
 */
class DateFromString extends transform(String$, DateFromSelf, {
  decode: s => new Date(s),
  encode: d => d.toISOString()
}).annotations({
  identifier: "DateFromString"
}) {
  static annotations = super.annotations;
}
/** @ignore */
class Date$ extends DateFromString.pipe(validDate({
  identifier: "Date"
})) {
  static annotations = super.annotations;
}
/**
 * Represents a schema that converts a `number` into a (potentially invalid) `Date` (e.g., `NaN`, `Infinity` and `-Infinity` are not rejected).
 * Encoding will return `NaN` for invalid dates.
 *
 * @category Date transformations
 * @since 0.67.0
 */
class DateFromNumber extends transform(Number$, DateFromSelf, {
  decode: n => new Date(n),
  encode: d => d.getTime()
}).annotations({
  identifier: "DateFromNumber"
}) {
  static annotations = super.annotations;
}
const optionDecode = input => input._tag === "None" ? none$4() : some(input.value);
const optionArbitrary = value => fc => fc.oneof(fc.record({
  _tag: fc.constant("None")
}), fc.record({
  _tag: fc.constant("Some"),
  value: value(fc)
})).map(optionDecode);
const optionPretty = value => match$3({
  onNone: () => "none()",
  onSome: a => `some(${value(a)})`
});
const optionParse = decodeUnknown => (u, options, ast) => isOption(u) ? isNone(u) ? succeed(none$4()) : map(decodeUnknown(u.value, options), some) : fail(new Type(ast, u));
/**
 * @category Option transformations
 * @since 0.67.0
 */
const OptionFromSelf = value => {
  return declare([value], {
    decode: value => optionParse(decodeUnknown(value)),
    encode: value => optionParse(encodeUnknown(value))
  }, {
    description: `Option<${format(value)}>`,
    pretty: optionPretty,
    arbitrary: optionArbitrary,
    equivalence: getEquivalence$3
  });
};
const bigDecimalPretty = () => val => `BigDecimal(${format$1(normalize(val))})`;
const bigDecimalArbitrary = () => fc => fc.tuple(fc.bigInt(), fc.integer()).map(([value, scale]) => make$2(value, scale));
/**
 * @category BigDecimal constructors
 * @since 0.67.0
 */
class BigDecimalFromSelf extends declare(isBigDecimal, {
  identifier: "BigDecimalFromSelf",
  pretty: bigDecimalPretty,
  arbitrary: bigDecimalArbitrary,
  equivalence: () => Equivalence
}) {
  static annotations = super.annotations;
}
/**
 * @category BigDecimal transformations
 * @since 0.67.0
 */
class BigDecimal extends transformOrFail(String$, BigDecimalFromSelf, {
  decode: (num, _, ast) => fromString$4(num).pipe(match$3({
    onNone: () => fail(new Type(ast, num)),
    onSome: val => succeed(normalize(val))
  })),
  encode: val => succeed(format$1(normalize(val)))
}).annotations({
  identifier: "BigDecimal"
}) {
  static annotations = super.annotations;
}
/**
 * A schema that transforms a `number` into a `BigDecimal`.
 * When encoding, this Schema will produce incorrect results if the BigDecimal exceeds the 64-bit range of a number.
 *
 * @category BigDecimal transformations
 * @since 0.67.0
 */
class BigDecimalFromNumber extends transformOrFail(Number$, BigDecimalFromSelf, {
  decode: num => succeed(fromNumber$2(num)),
  encode: val => succeed(unsafeToNumber(val))
}).annotations({
  identifier: "BigDecimalFromNumber"
}) {
  static annotations = super.annotations;
}
const getDisableValidationMakeOption = options => isBoolean(options) ? options : options?.disableValidation ?? false;
const FiberIdNoneEncoded = /*#__PURE__*/Struct({
  _tag: Literal("None")
}).annotations({
  identifier: "FiberIdNoneEncoded"
});
const FiberIdRuntimeEncoded = /*#__PURE__*/Struct({
  _tag: Literal("Runtime"),
  id: Int.annotations({
    title: "id",
    description: "id"
  }),
  startTimeMillis: Int.annotations({
    title: "startTimeMillis",
    description: "startTimeMillis"
  })
}).annotations({
  identifier: "FiberIdRuntimeEncoded"
});
const FiberIdCompositeEncoded = /*#__PURE__*/Struct({
  _tag: Literal("Composite"),
  left: suspend(() => FiberIdEncoded),
  right: suspend(() => FiberIdEncoded)
}).annotations({
  identifier: "FiberIdCompositeEncoded"
});
const FiberIdEncoded = /*#__PURE__*/Union(FiberIdNoneEncoded, FiberIdRuntimeEncoded, FiberIdCompositeEncoded).annotations({
  identifier: "FiberIdEncoded"
});
const fiberIdArbitrary = fc => fc.letrec(tie => ({
  None: fc.record({
    _tag: fc.constant("None")
  }),
  Runtime: fc.record({
    _tag: fc.constant("Runtime"),
    id: fc.integer(),
    startTimeMillis: fc.integer()
  }),
  Composite: fc.record({
    _tag: fc.constant("Composite"),
    left: tie("FiberId"),
    right: tie("FiberId")
  }),
  FiberId: fc.oneof(tie("None"), tie("Runtime"), tie("Composite"))
})).FiberId.map(fiberIdDecode);
const fiberIdPretty = fiberId => {
  switch (fiberId._tag) {
    case "None":
      return "FiberId.none";
    case "Runtime":
      return `FiberId.runtime(${fiberId.id}, ${fiberId.startTimeMillis})`;
    case "Composite":
      return `FiberId.composite(${fiberIdPretty(fiberId.right)}, ${fiberIdPretty(fiberId.left)})`;
  }
};
/**
 * @category FiberId constructors
 * @since 0.67.0
 */
class FiberIdFromSelf extends declare(isFiberId, {
  identifier: "FiberIdFromSelf",
  pretty: () => fiberIdPretty,
  arbitrary: () => fiberIdArbitrary
}) {
  static annotations = super.annotations;
}
const fiberIdDecode = input => {
  switch (input._tag) {
    case "None":
      return none$2;
    case "Runtime":
      return runtime(input.id, input.startTimeMillis);
    case "Composite":
      return composite(fiberIdDecode(input.left), fiberIdDecode(input.right));
  }
};
const fiberIdEncode = input => {
  switch (input._tag) {
    case "None":
      return {
        _tag: "None"
      };
    case "Runtime":
      return {
        _tag: "Runtime",
        id: input.id,
        startTimeMillis: input.startTimeMillis
      };
    case "Composite":
      return {
        _tag: "Composite",
        left: fiberIdEncode(input.left),
        right: fiberIdEncode(input.right)
      };
  }
};
/**
 * @category FiberId transformations
 * @since 0.67.0
 */
class FiberId extends transform(FiberIdEncoded, FiberIdFromSelf, {
  decode: fiberIdDecode,
  encode: fiberIdEncode
}).annotations({
  identifier: "FiberId"
}) {
  static annotations = super.annotations;
}
/**
 * Converts an arbitrary value to a `boolean` by testing whether it is truthy.
 * Uses `!!val` to coerce the value to a `boolean`.
 *
 * @see https://developer.mozilla.org/docs/Glossary/Truthy
 * @category boolean constructors
 * @since 0.67.0
 */
class BooleanFromUnknown extends transform(Unknown, Boolean$, {
  decode: isTruthy,
  encode: identity
}).annotations({
  identifier: "BooleanFromUnknown"
}) {
  static annotations = super.annotations;
}

({
  ...CommitPrototype,
  [TypeId$2]: TypeId$2,
  pipe() {
    return pipeArguments(this, arguments);
  },
  commit() {
    return this.runtimeEffect;
  }
});

/** @internal */
const ScopedRefSymbolKey = "effect/ScopedRef";
/** @internal */
const ScopedRefTypeId = /*#__PURE__*/Symbol.for(ScopedRefSymbolKey);
/** @internal */
const scopedRefVariance = {
  /* c8 ignore next */
  _A: _ => _
};
/** @internal  */
({
  ...CommitPrototype$1,
  commit() {
    return get$1(this);
  },
  [ScopedRefTypeId]: scopedRefVariance
});
/** @internal */
const get$1 = self => map$2(get$3(self.ref), tuple => tuple[1]);

/** @internal */
const ResourceSymbolKey = "effect/Resource";
/** @internal */
const ResourceTypeId = /*#__PURE__*/Symbol.for(ResourceSymbolKey);
const resourceVariance = {
  /* c8 ignore next */
  _E: _ => _,
  /* c8 ignore next */
  _A: _ => _
};
/** @internal  */
({
  ...CommitPrototype$1,
  commit() {
    return get(this);
  },
  [ResourceTypeId]: resourceVariance
});
/** @internal */
const get = self => flatMap$3(get$1(self.scopedRef), identity);

function isHex(value, { strict = true } = {}) {
    if (!value)
        return false;
    if (typeof value !== 'string')
        return false;
    return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith('0x');
}

/**
 * @description Retrieves the size of the value (in bytes).
 *
 * @param value The value (hex or byte array) to retrieve the size of.
 * @returns The size of the value (in bytes).
 */
function size(value) {
    if (isHex(value, { strict: false }))
        return Math.ceil((value.length - 2) / 2);
    return value.length;
}

const version$1 = '2.22.7';

let errorConfig = {
    getDocsUrl: ({ docsBaseUrl, docsPath = '', docsSlug, }) => docsPath
        ? `${docsBaseUrl ?? 'https://viem.sh'}${docsPath}${docsSlug ? `#${docsSlug}` : ''}`
        : undefined,
    version: `viem@${version$1}`,
};
class BaseError extends Error {
    constructor(shortMessage, args = {}) {
        const details = (() => {
            if (args.cause instanceof BaseError)
                return args.cause.details;
            if (args.cause?.message)
                return args.cause.message;
            return args.details;
        })();
        const docsPath = (() => {
            if (args.cause instanceof BaseError)
                return args.cause.docsPath || args.docsPath;
            return args.docsPath;
        })();
        const docsUrl = errorConfig.getDocsUrl?.({ ...args, docsPath });
        const message = [
            shortMessage || 'An error occurred.',
            '',
            ...(args.metaMessages ? [...args.metaMessages, ''] : []),
            ...(docsUrl ? [`Docs: ${docsUrl}`] : []),
            ...(details ? [`Details: ${details}`] : []),
            ...(errorConfig.version ? [`Version: ${errorConfig.version}`] : []),
        ].join('\n');
        super(message, args.cause ? { cause: args.cause } : undefined);
        Object.defineProperty(this, "details", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: undefined
        });
        Object.defineProperty(this, "docsPath", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: undefined
        });
        Object.defineProperty(this, "metaMessages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: undefined
        });
        Object.defineProperty(this, "shortMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: undefined
        });
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: undefined
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'BaseError'
        });
        this.details = details;
        this.docsPath = docsPath;
        this.metaMessages = args.metaMessages;
        this.name = args.name ?? this.name;
        this.shortMessage = shortMessage;
        this.version = version$1;
    }
    walk(fn) {
        return walk(this, fn);
    }
}
function walk(err, fn) {
    if (fn?.(err))
        return err;
    if (err &&
        typeof err === 'object' &&
        'cause' in err &&
        err.cause !== undefined)
        return walk(err.cause, fn);
    return fn ? null : err;
}

class SizeExceedsPaddingSizeError extends BaseError {
    constructor({ size, targetSize, type, }) {
        super(`${type.charAt(0).toUpperCase()}${type
            .slice(1)
            .toLowerCase()} size (${size}) exceeds padding size (${targetSize}).`, { name: 'SizeExceedsPaddingSizeError' });
    }
}

function pad(hexOrBytes, { dir, size = 32 } = {}) {
    if (typeof hexOrBytes === 'string')
        return padHex(hexOrBytes, { dir, size });
    return padBytes(hexOrBytes, { dir, size });
}
function padHex(hex_, { dir, size = 32 } = {}) {
    if (size === null)
        return hex_;
    const hex = hex_.replace('0x', '');
    if (hex.length > size * 2)
        throw new SizeExceedsPaddingSizeError({
            size: Math.ceil(hex.length / 2),
            targetSize: size,
            type: 'hex',
        });
    return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}`;
}
function padBytes(bytes, { dir, size = 32 } = {}) {
    if (size === null)
        return bytes;
    if (bytes.length > size)
        throw new SizeExceedsPaddingSizeError({
            size: bytes.length,
            targetSize: size,
            type: 'bytes',
        });
    const paddedBytes = new Uint8Array(size);
    for (let i = 0; i < size; i++) {
        const padEnd = dir === 'right';
        paddedBytes[padEnd ? i : size - i - 1] =
            bytes[padEnd ? i : bytes.length - i - 1];
    }
    return paddedBytes;
}

class IntegerOutOfRangeError extends BaseError {
    constructor({ max, min, signed, size, value, }) {
        super(`Number "${value}" is not in safe ${size ? `${size * 8}-bit ${signed ? 'signed' : 'unsigned'} ` : ''}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`, { name: 'IntegerOutOfRangeError' });
    }
}
class SizeOverflowError extends BaseError {
    constructor({ givenSize, maxSize }) {
        super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`, { name: 'SizeOverflowError' });
    }
}

function assertSize(hexOrBytes, { size: size$1 }) {
    if (size(hexOrBytes) > size$1)
        throw new SizeOverflowError({
            givenSize: size(hexOrBytes),
            maxSize: size$1,
        });
}

const hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));
/**
 * Encodes a string, number, bigint, or ByteArray into a hex string
 *
 * - Docs: https://viem.sh/docs/utilities/toHex
 * - Example: https://viem.sh/docs/utilities/toHex#usage
 *
 * @param value Value to encode.
 * @param opts Options.
 * @returns Hex value.
 *
 * @example
 * import { toHex } from 'viem'
 * const data = toHex('Hello world')
 * // '0x48656c6c6f20776f726c6421'
 *
 * @example
 * import { toHex } from 'viem'
 * const data = toHex(420)
 * // '0x1a4'
 *
 * @example
 * import { toHex } from 'viem'
 * const data = toHex('Hello world', { size: 32 })
 * // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'
 */
function toHex(value, opts = {}) {
    if (typeof value === 'number' || typeof value === 'bigint')
        return numberToHex(value, opts);
    if (typeof value === 'string') {
        return stringToHex(value, opts);
    }
    if (typeof value === 'boolean')
        return boolToHex(value, opts);
    return bytesToHex(value, opts);
}
/**
 * Encodes a boolean into a hex string
 *
 * - Docs: https://viem.sh/docs/utilities/toHex#booltohex
 *
 * @param value Value to encode.
 * @param opts Options.
 * @returns Hex value.
 *
 * @example
 * import { boolToHex } from 'viem'
 * const data = boolToHex(true)
 * // '0x1'
 *
 * @example
 * import { boolToHex } from 'viem'
 * const data = boolToHex(false)
 * // '0x0'
 *
 * @example
 * import { boolToHex } from 'viem'
 * const data = boolToHex(true, { size: 32 })
 * // '0x0000000000000000000000000000000000000000000000000000000000000001'
 */
function boolToHex(value, opts = {}) {
    const hex = `0x${Number(value)}`;
    if (typeof opts.size === 'number') {
        assertSize(hex, { size: opts.size });
        return pad(hex, { size: opts.size });
    }
    return hex;
}
/**
 * Encodes a bytes array into a hex string
 *
 * - Docs: https://viem.sh/docs/utilities/toHex#bytestohex
 *
 * @param value Value to encode.
 * @param opts Options.
 * @returns Hex value.
 *
 * @example
 * import { bytesToHex } from 'viem'
 * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
 * // '0x48656c6c6f20576f726c6421'
 *
 * @example
 * import { bytesToHex } from 'viem'
 * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })
 * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'
 */
function bytesToHex(value, opts = {}) {
    let string = '';
    for (let i = 0; i < value.length; i++) {
        string += hexes[value[i]];
    }
    const hex = `0x${string}`;
    if (typeof opts.size === 'number') {
        assertSize(hex, { size: opts.size });
        return pad(hex, { dir: 'right', size: opts.size });
    }
    return hex;
}
/**
 * Encodes a number or bigint into a hex string
 *
 * - Docs: https://viem.sh/docs/utilities/toHex#numbertohex
 *
 * @param value Value to encode.
 * @param opts Options.
 * @returns Hex value.
 *
 * @example
 * import { numberToHex } from 'viem'
 * const data = numberToHex(420)
 * // '0x1a4'
 *
 * @example
 * import { numberToHex } from 'viem'
 * const data = numberToHex(420, { size: 32 })
 * // '0x00000000000000000000000000000000000000000000000000000000000001a4'
 */
function numberToHex(value_, opts = {}) {
    const { signed, size } = opts;
    const value = BigInt(value_);
    let maxValue;
    if (size) {
        if (signed)
            maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n;
        else
            maxValue = 2n ** (BigInt(size) * 8n) - 1n;
    }
    else if (typeof value_ === 'number') {
        maxValue = BigInt(Number.MAX_SAFE_INTEGER);
    }
    const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;
    if ((maxValue && value > maxValue) || value < minValue) {
        const suffix = typeof value_ === 'bigint' ? 'n' : '';
        throw new IntegerOutOfRangeError({
            max: maxValue ? `${maxValue}${suffix}` : undefined,
            min: `${minValue}${suffix}`,
            signed,
            size,
            value: `${value_}${suffix}`,
        });
    }
    const hex = `0x${(signed && value < 0 ? (1n << BigInt(size * 8)) + BigInt(value) : value).toString(16)}`;
    if (size)
        return pad(hex, { size });
    return hex;
}
const encoder = /*#__PURE__*/ new TextEncoder();
/**
 * Encodes a UTF-8 string into a hex string
 *
 * - Docs: https://viem.sh/docs/utilities/toHex#stringtohex
 *
 * @param value Value to encode.
 * @param opts Options.
 * @returns Hex value.
 *
 * @example
 * import { stringToHex } from 'viem'
 * const data = stringToHex('Hello World!')
 * // '0x48656c6c6f20576f726c6421'
 *
 * @example
 * import { stringToHex } from 'viem'
 * const data = stringToHex('Hello World!', { size: 32 })
 * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'
 */
function stringToHex(value_, opts = {}) {
    const value = encoder.encode(value_);
    return bytesToHex(value, opts);
}

// We use very optimized technique to convert hex string to byte array
const charCodeMap = {
    zero: 48,
    nine: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102,
};
function charCodeToBase16(char) {
    if (char >= charCodeMap.zero && char <= charCodeMap.nine)
        return char - charCodeMap.zero;
    if (char >= charCodeMap.A && char <= charCodeMap.F)
        return char - (charCodeMap.A - 10);
    if (char >= charCodeMap.a && char <= charCodeMap.f)
        return char - (charCodeMap.a - 10);
    return undefined;
}
/**
 * Encodes a hex string into a byte array.
 *
 * - Docs: https://viem.sh/docs/utilities/toBytes#hextobytes
 *
 * @param hex Hex string to encode.
 * @param opts Options.
 * @returns Byte array value.
 *
 * @example
 * import { hexToBytes } from 'viem'
 * const data = hexToBytes('0x48656c6c6f20776f726c6421')
 * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
 *
 * @example
 * import { hexToBytes } from 'viem'
 * const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })
 * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
 */
function hexToBytes(hex_, opts = {}) {
    let hex = hex_;
    if (opts.size) {
        assertSize(hex, { size: opts.size });
        hex = pad(hex, { dir: 'right', size: opts.size });
    }
    let hexString = hex.slice(2);
    if (hexString.length % 2)
        hexString = `0${hexString}`;
    const length = hexString.length / 2;
    const bytes = new Uint8Array(length);
    for (let index = 0, j = 0; index < length; index++) {
        const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));
        const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));
        if (nibbleLeft === undefined || nibbleRight === undefined) {
            throw new BaseError(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
        }
        bytes[index] = nibbleLeft * 16 + nibbleRight;
    }
    return bytes;
}

/**
 * @license
 * Copyright 2009 The Closure Library Authors
 * Copyright 2020 Daniel Wirtz / The long.js Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

// WebAssembly optimizations to do native i64 multiplication and divide
var wasm = null;
try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

  /**
   * The low 32 bits as a signed value.
   * @type {number}
   */
  this.low = low | 0;

  /**
   * The high 32 bits as a signed value.
   * @type {number}
   */
  this.high = high | 0;

  /**
   * Whether unsigned or not.
   * @type {boolean}
   */
  this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
  return (obj && obj["__isLong__"]) === true;
}

/**
 * @function
 * @param {*} value number
 * @returns {number}
 * @inner
 */
function ctz32(value) {
  var c = Math.clz32(value & -value);
  return value ? 31 - c : c;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
  var obj, cachedObj, cache;
  if (unsigned) {
    value >>>= 0;
    if (cache = (0 <= value && value < 256)) {
      cachedObj = UINT_CACHE[value];
      if (cachedObj)
        return cachedObj;
    }
    obj = fromBits(value, 0, true);
    if (cache)
      UINT_CACHE[value] = obj;
    return obj;
  } else {
    value |= 0;
    if (cache = (-128 <= value && value < 128)) {
      cachedObj = INT_CACHE[value];
      if (cachedObj)
        return cachedObj;
    }
    obj = fromBits(value, value < 0 ? -1 : 0, false);
    if (cache)
      INT_CACHE[value] = obj;
    return obj;
  }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
  if (isNaN(value))
    return unsigned ? UZERO : ZERO;
  if (unsigned) {
    if (value < 0)
      return UZERO;
    if (value >= TWO_PWR_64_DBL)
      return MAX_UNSIGNED_VALUE;
  } else {
    if (value <= -9223372036854776e3)
      return MIN_VALUE;
    if (value + 1 >= TWO_PWR_63_DBL)
      return MAX_VALUE;
  }
  if (value < 0)
    return fromNumber(-value, unsigned).neg();
  return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
  return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
  if (str.length === 0)
    throw Error('empty string');
  if (typeof unsigned === 'number') {
    // For goog.math.long compatibility
    radix = unsigned;
    unsigned = false;
  } else {
    unsigned = !!unsigned;
  }
  if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
    return unsigned ? UZERO : ZERO;
  radix = radix || 10;
  if (radix < 2 || 36 < radix)
    throw RangeError('radix');

  var p;
  if ((p = str.indexOf('-')) > 0)
    throw Error('interior hyphen');
  else if (p === 0) {
    return fromString(str.substring(1), unsigned, radix).neg();
  }

  // Do several (8) digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.
  var radixToPower = fromNumber(pow_dbl(radix, 8));

  var result = ZERO;
  for (var i = 0; i < str.length; i += 8) {
    var size = Math.min(8, str.length - i),
      value = parseInt(str.substring(i, i + size), radix);
    if (size < 8) {
      var power = fromNumber(pow_dbl(radix, size));
      result = result.mul(power).add(fromNumber(value));
    } else {
      result = result.mul(radixToPower);
      result = result.add(fromNumber(value));
    }
  }
  result.unsigned = unsigned;
  return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
  if (typeof val === 'number')
    return fromNumber(val, unsigned);
  if (typeof val === 'string')
    return fromString(val, unsigned);
  // Throws for non-objects, converts non-instanceof Long:
  return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @this {!Long}
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
  return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @this {!Long}
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
  if (this.unsigned)
    return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
  return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @this {!Long}
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
  radix = radix || 10;
  if (radix < 2 || 36 < radix)
    throw RangeError('radix');
  if (this.isZero())
    return '0';
  if (this.isNegative()) { // Unsigned Longs are never negative
    if (this.eq(MIN_VALUE)) {
      // We need to change the Long value before it can be negated, so we remove
      // the bottom-most digit in this base and then recurse to do the rest.
      var radixLong = fromNumber(radix),
        div = this.div(radixLong),
        rem1 = div.mul(radixLong).sub(this);
      return div.toString(radix) + rem1.toInt().toString(radix);
    } else
      return '-' + this.neg().toString(radix);
  }

  // Do several (6) digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.
  var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
    rem = this;
  var result = '';
  while (true) {
    var remDiv = rem.div(radixToPower),
      intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
      digits = intval.toString(radix);
    rem = remDiv;
    if (rem.isZero())
      return digits + result;
    else {
      while (digits.length < 6)
        digits = '0' + digits;
      result = '' + digits + result;
    }
  }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @this {!Long}
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
  return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @this {!Long}
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
  return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @this {!Long}
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
  return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @this {!Long}
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
  return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @this {!Long}
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
  if (this.isNegative()) // Unsigned Longs are never negative
    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
  var val = this.high != 0 ? this.high : this.low;
  for (var bit = 31; bit > 0; bit--)
    if ((val & (1 << bit)) != 0)
      break;
  return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @this {!Long}
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
  return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @this {!Long}
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
  return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive or zero.
 * @this {!Long}
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
  return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @this {!Long}
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
  return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @this {!Long}
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
  return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
  if (!isLong(other))
    other = fromValue(other);
  if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
    return false;
  return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
  return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
  return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
  return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
  return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
  return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
  if (!isLong(other))
    other = fromValue(other);
  if (this.eq(other))
    return 0;
  var thisNeg = this.isNegative(),
    otherNeg = other.isNegative();
  if (thisNeg && !otherNeg)
    return -1;
  if (!thisNeg && otherNeg)
    return 1;
  // At this point the sign bits are the same
  if (!this.unsigned)
    return this.sub(other).isNegative() ? -1 : 1;
  // Both are positive if at least one is unsigned
  return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @this {!Long}
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
  if (!this.unsigned && this.eq(MIN_VALUE))
    return MIN_VALUE;
  return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @this {!Long}
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
  if (!isLong(addend))
    addend = fromValue(addend);

  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

  var a48 = this.high >>> 16;
  var a32 = this.high & 0xFFFF;
  var a16 = this.low >>> 16;
  var a00 = this.low & 0xFFFF;

  var b48 = addend.high >>> 16;
  var b32 = addend.high & 0xFFFF;
  var b16 = addend.low >>> 16;
  var b00 = addend.low & 0xFFFF;

  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 + b00;
  c16 += c00 >>> 16;
  c00 &= 0xFFFF;
  c16 += a16 + b16;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c32 += a32 + b32;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c48 += a48 + b48;
  c48 &= 0xFFFF;
  return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @this {!Long}
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
  if (!isLong(subtrahend))
    subtrahend = fromValue(subtrahend);
  return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @this {!Long}
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
  if (this.isZero())
    return this;
  if (!isLong(multiplier))
    multiplier = fromValue(multiplier);

  // use wasm support if present
  if (wasm) {
    var low = wasm["mul"](this.low,
      this.high,
      multiplier.low,
      multiplier.high);
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }

  if (multiplier.isZero())
    return this.unsigned ? UZERO : ZERO;
  if (this.eq(MIN_VALUE))
    return multiplier.isOdd() ? MIN_VALUE : ZERO;
  if (multiplier.eq(MIN_VALUE))
    return this.isOdd() ? MIN_VALUE : ZERO;

  if (this.isNegative()) {
    if (multiplier.isNegative())
      return this.neg().mul(multiplier.neg());
    else
      return this.neg().mul(multiplier).neg();
  } else if (multiplier.isNegative())
    return this.mul(multiplier.neg()).neg();

  // If both longs are small, use float multiplication
  if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
    return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

  // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
  // We can skip products that would overflow.

  var a48 = this.high >>> 16;
  var a32 = this.high & 0xFFFF;
  var a16 = this.low >>> 16;
  var a00 = this.low & 0xFFFF;

  var b48 = multiplier.high >>> 16;
  var b32 = multiplier.high & 0xFFFF;
  var b16 = multiplier.low >>> 16;
  var b00 = multiplier.low & 0xFFFF;

  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 * b00;
  c16 += c00 >>> 16;
  c00 &= 0xFFFF;
  c16 += a16 * b00;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c16 += a00 * b16;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c32 += a32 * b00;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c32 += a16 * b16;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c32 += a00 * b32;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
  c48 &= 0xFFFF;
  return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @this {!Long}
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
  if (!isLong(divisor))
    divisor = fromValue(divisor);
  if (divisor.isZero())
    throw Error('division by zero');

  // use wasm support if present
  if (wasm) {
    // guard against signed division overflow: the largest
    // negative number / -1 would be 1 larger than the largest
    // positive number, due to two's complement.
    if (!this.unsigned &&
      this.high === -2147483648 &&
      divisor.low === -1 && divisor.high === -1) {
      // be consistent with non-wasm code path
      return this;
    }
    var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(
      this.low,
      this.high,
      divisor.low,
      divisor.high
    );
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }

  if (this.isZero())
    return this.unsigned ? UZERO : ZERO;
  var approx, rem, res;
  if (!this.unsigned) {
    // This section is only relevant for signed longs and is derived from the
    // closure library as a whole.
    if (this.eq(MIN_VALUE)) {
      if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
        return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
      else if (divisor.eq(MIN_VALUE))
        return ONE;
      else {
        // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
        var halfThis = this.shr(1);
        approx = halfThis.div(divisor).shl(1);
        if (approx.eq(ZERO)) {
          return divisor.isNegative() ? ONE : NEG_ONE;
        } else {
          rem = this.sub(divisor.mul(approx));
          res = approx.add(rem.div(divisor));
          return res;
        }
      }
    } else if (divisor.eq(MIN_VALUE))
      return this.unsigned ? UZERO : ZERO;
    if (this.isNegative()) {
      if (divisor.isNegative())
        return this.neg().div(divisor.neg());
      return this.neg().div(divisor).neg();
    } else if (divisor.isNegative())
      return this.div(divisor.neg()).neg();
    res = ZERO;
  } else {
    // The algorithm below has not been made for unsigned longs. It's therefore
    // required to take special care of the MSB prior to running it.
    if (!divisor.unsigned)
      divisor = divisor.toUnsigned();
    if (divisor.gt(this))
      return UZERO;
    if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
      return UONE;
    res = UZERO;
  }

  // Repeat the following until the remainder is less than other:  find a
  // floating-point that approximates remainder / other *from below*, add this
  // into the result, and subtract it from the remainder.  It is critical that
  // the approximate value is less than or equal to the real value so that the
  // remainder never becomes negative.
  rem = this;
  while (rem.gte(divisor)) {
    // Approximate the result of division. This may be a little greater or
    // smaller than the actual value.
    approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

    // We will tweak the approximate result by changing it in the 48-th digit or
    // the smallest non-fractional digit, whichever is larger.
    var log2 = Math.ceil(Math.log(approx) / Math.LN2),
      delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

      // Decrease the approximation until it is smaller than the remainder.  Note
      // that if it is too large, the product overflows and is negative.
      approxRes = fromNumber(approx),
      approxRem = approxRes.mul(divisor);
    while (approxRem.isNegative() || approxRem.gt(rem)) {
      approx -= delta;
      approxRes = fromNumber(approx, this.unsigned);
      approxRem = approxRes.mul(divisor);
    }

    // We know the answer can't be zero... and actually, zero would cause
    // infinite recursion since we would make no progress.
    if (approxRes.isZero())
      approxRes = ONE;

    res = res.add(approxRes);
    rem = rem.sub(approxRem);
  }
  return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @this {!Long}
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
  if (!isLong(divisor))
    divisor = fromValue(divisor);

  // use wasm support if present
  if (wasm) {
    var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(
      this.low,
      this.high,
      divisor.low,
      divisor.high
    );
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }

  return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @this {!Long}
 * @returns {!Long}
 */
LongPrototype.not = function not() {
  return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns count leading zeros of this Long.
 * @this {!Long}
 * @returns {!number}
 */
LongPrototype.countLeadingZeros = function countLeadingZeros() {
  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
};

/**
 * Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.
 * @function
 * @param {!Long}
 * @returns {!number}
 */
LongPrototype.clz = LongPrototype.countLeadingZeros;

/**
 * Returns count trailing zeros of this Long.
 * @this {!Long}
 * @returns {!number}
 */
LongPrototype.countTrailingZeros = function countTrailingZeros() {
  return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
};

/**
 * Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.
 * @function
 * @param {!Long}
 * @returns {!number}
 */
LongPrototype.ctz = LongPrototype.countTrailingZeros;

/**
 * Returns the bitwise AND of this Long and the specified.
 * @this {!Long}
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
  if (!isLong(other))
    other = fromValue(other);
  return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @this {!Long}
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
  if (!isLong(other))
    other = fromValue(other);
  return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @this {!Long}
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
  if (!isLong(other))
    other = fromValue(other);
  return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @this {!Long}
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
  if (isLong(numBits))
    numBits = numBits.toInt();
  if ((numBits &= 63) === 0)
    return this;
  else if (numBits < 32)
    return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
  else
    return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @this {!Long}
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
  if (isLong(numBits))
    numBits = numBits.toInt();
  if ((numBits &= 63) === 0)
    return this;
  else if (numBits < 32)
    return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
  else
    return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @this {!Long}
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  if (numBits < 32) return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >>> numBits, this.unsigned);
  if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
  return fromBits(this.high >>> (numBits - 32), 0, this.unsigned);
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits rotated to the left by the given amount.
 * @this {!Long}
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Rotated Long
 */
LongPrototype.rotateLeft = function rotateLeft(numBits) {
  var b;
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
  if (numBits < 32) {
    b = (32 - numBits);
    return fromBits(((this.low << numBits) | (this.high >>> b)), ((this.high << numBits) | (this.low >>> b)), this.unsigned);
  }
  numBits -= 32;
  b = (32 - numBits);
  return fromBits(((this.high << numBits) | (this.low >>> b)), ((this.low << numBits) | (this.high >>> b)), this.unsigned);
};
/**
 * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Rotated Long
 */
LongPrototype.rotl = LongPrototype.rotateLeft;

/**
 * Returns this Long with bits rotated to the right by the given amount.
 * @this {!Long}
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Rotated Long
 */
LongPrototype.rotateRight = function rotateRight(numBits) {
  var b;
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
  if (numBits < 32) {
    b = (32 - numBits);
    return fromBits(((this.high << b) | (this.low >>> numBits)), ((this.low << b) | (this.high >>> numBits)), this.unsigned);
  }
  numBits -= 32;
  b = (32 - numBits);
  return fromBits(((this.low << b) | (this.high >>> numBits)), ((this.high << b) | (this.low >>> numBits)), this.unsigned);
};
/**
 * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Rotated Long
 */
LongPrototype.rotr = LongPrototype.rotateRight;

/**
 * Converts this Long to signed.
 * @this {!Long}
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
  if (!this.unsigned)
    return this;
  return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @this {!Long}
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
  if (this.unsigned)
    return this;
  return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @this {!Long}
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
  return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @this {!Long}
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
  var hi = this.high,
    lo = this.low;
  return [
    lo & 0xff,
    lo >>> 8 & 0xff,
    lo >>> 16 & 0xff,
    lo >>> 24,
    hi & 0xff,
    hi >>> 8 & 0xff,
    hi >>> 16 & 0xff,
    hi >>> 24
  ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @this {!Long}
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
  var hi = this.high,
    lo = this.low;
  return [
    hi >>> 24,
    hi >>> 16 & 0xff,
    hi >>> 8 & 0xff,
    hi & 0xff,
    lo >>> 24,
    lo >>> 16 & 0xff,
    lo >>> 8 & 0xff,
    lo & 0xff
  ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
  return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
  return new Long(
    bytes[0] |
    bytes[1] << 8 |
    bytes[2] << 16 |
    bytes[3] << 24,
    bytes[4] |
    bytes[5] << 8 |
    bytes[6] << 16 |
    bytes[7] << 24,
    unsigned
  );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
  return new Long(
    bytes[4] << 24 |
    bytes[5] << 16 |
    bytes[6] << 8 |
    bytes[7],
    bytes[0] << 24 |
    bytes[1] << 16 |
    bytes[2] << 8 |
    bytes[3],
    unsigned
  );
};

function createBaseDuration() {
  return { seconds: BigInt("0"), nanos: 0 };
}
const Duration$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.seconds !== BigInt("0")) {
      if (BigInt.asIntN(64, message.seconds) !== message.seconds) {
        throw new globalThis.Error("value provided for field message.seconds of type int64 too large");
      }
      writer.uint32(8).int64(message.seconds.toString());
    }
    if (message.nanos !== 0) {
      writer.uint32(16).int32(message.nanos);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDuration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.seconds = longToBigint$1$1(reader.int64());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.nanos = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      seconds: isSet$2$1(object.seconds) ? BigInt(object.seconds) : BigInt("0"),
      nanos: isSet$2$1(object.nanos) ? globalThis.Number(object.nanos) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.seconds !== BigInt("0")) {
      obj.seconds = message.seconds.toString();
    }
    if (message.nanos !== 0) {
      obj.nanos = Math.round(message.nanos);
    }
    return obj;
  },
  create(base) {
    return Duration$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDuration();
    message.seconds = object.seconds ?? BigInt("0");
    message.nanos = object.nanos ?? 0;
    return message;
  }
};
function longToBigint$1$1(long) {
  return BigInt(long.toString());
}
if (_m0.util.Long !== Long) {
  _m0.util.Long = Long;
  _m0.configure();
}
function isSet$2$1(value) {
  return value !== null && value !== undefined;
}
var DataFinality$1 = /* @__PURE__ */ ((DataFinality2) => {
  DataFinality2[DataFinality2["UNKNOWN"] = 0] = "UNKNOWN";
  DataFinality2[DataFinality2["PENDING"] = 1] = "PENDING";
  DataFinality2[DataFinality2["ACCEPTED"] = 2] = "ACCEPTED";
  DataFinality2[DataFinality2["FINALIZED"] = 3] = "FINALIZED";
  DataFinality2[DataFinality2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  return DataFinality2;
})(DataFinality$1 || {});
function dataFinalityFromJSON(object) {
  switch (object) {
    case 0:
    case "DATA_FINALITY_UNKNOWN":
      return 0 /* UNKNOWN */;
    case 1:
    case "DATA_FINALITY_PENDING":
      return 1 /* PENDING */;
    case 2:
    case "DATA_FINALITY_ACCEPTED":
      return 2 /* ACCEPTED */;
    case 3:
    case "DATA_FINALITY_FINALIZED":
      return 3 /* FINALIZED */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function dataFinalityToJSON(object) {
  switch (object) {
    case 0 /* UNKNOWN */:
      return "DATA_FINALITY_UNKNOWN";
    case 1 /* PENDING */:
      return "DATA_FINALITY_PENDING";
    case 2 /* ACCEPTED */:
      return "DATA_FINALITY_ACCEPTED";
    case 3 /* FINALIZED */:
      return "DATA_FINALITY_FINALIZED";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function createBaseCursor() {
  return { orderKey: BigInt("0"), uniqueKey: new Uint8Array(0) };
}
const Cursor$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.orderKey !== BigInt("0")) {
      if (BigInt.asUintN(64, message.orderKey) !== message.orderKey) {
        throw new globalThis.Error("value provided for field message.orderKey of type uint64 too large");
      }
      writer.uint32(8).uint64(message.orderKey.toString());
    }
    if (message.uniqueKey.length !== 0) {
      writer.uint32(18).bytes(message.uniqueKey);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCursor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.orderKey = longToBigint$3(reader.uint64());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.uniqueKey = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      orderKey: isSet$1$1(object.orderKey) ? BigInt(object.orderKey) : BigInt("0"),
      uniqueKey: isSet$1$1(object.uniqueKey) ? bytesFromBase64$1(object.uniqueKey) : new Uint8Array(0)
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.orderKey !== BigInt("0")) {
      obj.orderKey = message.orderKey.toString();
    }
    if (message.uniqueKey.length !== 0) {
      obj.uniqueKey = base64FromBytes$1(message.uniqueKey);
    }
    return obj;
  },
  create(base) {
    return Cursor$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCursor();
    message.orderKey = object.orderKey ?? BigInt("0");
    message.uniqueKey = object.uniqueKey ?? new Uint8Array(0);
    return message;
  }
};
function createBaseStatusRequest() {
  return {};
}
const StatusRequest$1 = {
  encode(_, writer = _m0.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return StatusRequest$1.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseStatusRequest();
    return message;
  }
};
function createBaseStatusResponse() {
  return { currentHead: undefined, lastIngested: undefined, finalized: undefined, starting: undefined };
}
const StatusResponse$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.currentHead !== undefined) {
      Cursor$1.encode(message.currentHead, writer.uint32(10).fork()).ldelim();
    }
    if (message.lastIngested !== undefined) {
      Cursor$1.encode(message.lastIngested, writer.uint32(18).fork()).ldelim();
    }
    if (message.finalized !== undefined) {
      Cursor$1.encode(message.finalized, writer.uint32(26).fork()).ldelim();
    }
    if (message.starting !== undefined) {
      Cursor$1.encode(message.starting, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.currentHead = Cursor$1.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.lastIngested = Cursor$1.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.finalized = Cursor$1.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.starting = Cursor$1.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      currentHead: isSet$1$1(object.currentHead) ? Cursor$1.fromJSON(object.currentHead) : undefined,
      lastIngested: isSet$1$1(object.lastIngested) ? Cursor$1.fromJSON(object.lastIngested) : undefined,
      finalized: isSet$1$1(object.finalized) ? Cursor$1.fromJSON(object.finalized) : undefined,
      starting: isSet$1$1(object.starting) ? Cursor$1.fromJSON(object.starting) : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.currentHead !== undefined) {
      obj.currentHead = Cursor$1.toJSON(message.currentHead);
    }
    if (message.lastIngested !== undefined) {
      obj.lastIngested = Cursor$1.toJSON(message.lastIngested);
    }
    if (message.finalized !== undefined) {
      obj.finalized = Cursor$1.toJSON(message.finalized);
    }
    if (message.starting !== undefined) {
      obj.starting = Cursor$1.toJSON(message.starting);
    }
    return obj;
  },
  create(base) {
    return StatusResponse$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStatusResponse();
    message.currentHead = object.currentHead !== undefined && object.currentHead !== null ? Cursor$1.fromPartial(object.currentHead) : undefined;
    message.lastIngested = object.lastIngested !== undefined && object.lastIngested !== null ? Cursor$1.fromPartial(object.lastIngested) : undefined;
    message.finalized = object.finalized !== undefined && object.finalized !== null ? Cursor$1.fromPartial(object.finalized) : undefined;
    message.starting = object.starting !== undefined && object.starting !== null ? Cursor$1.fromPartial(object.starting) : undefined;
    return message;
  }
};
function createBaseStreamDataRequest() {
  return { startingCursor: undefined, finality: undefined, filter: [], heartbeatInterval: undefined };
}
const StreamDataRequest$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.startingCursor !== undefined) {
      Cursor$1.encode(message.startingCursor, writer.uint32(10).fork()).ldelim();
    }
    if (message.finality !== undefined) {
      writer.uint32(16).int32(message.finality);
    }
    for (const v of message.filter) {
      writer.uint32(26).bytes(v);
    }
    if (message.heartbeatInterval !== undefined) {
      Duration$1.encode(message.heartbeatInterval, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.startingCursor = Cursor$1.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.finality = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.filter.push(reader.bytes());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.heartbeatInterval = Duration$1.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      startingCursor: isSet$1$1(object.startingCursor) ? Cursor$1.fromJSON(object.startingCursor) : undefined,
      finality: isSet$1$1(object.finality) ? dataFinalityFromJSON(object.finality) : undefined,
      filter: globalThis.Array.isArray(object?.filter) ? object.filter.map((e) => bytesFromBase64$1(e)) : [],
      heartbeatInterval: isSet$1$1(object.heartbeatInterval) ? Duration$1.fromJSON(object.heartbeatInterval) : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.startingCursor !== undefined) {
      obj.startingCursor = Cursor$1.toJSON(message.startingCursor);
    }
    if (message.finality !== undefined) {
      obj.finality = dataFinalityToJSON(message.finality);
    }
    if (message.filter?.length) {
      obj.filter = message.filter.map((e) => base64FromBytes$1(e));
    }
    if (message.heartbeatInterval !== undefined) {
      obj.heartbeatInterval = Duration$1.toJSON(message.heartbeatInterval);
    }
    return obj;
  },
  create(base) {
    return StreamDataRequest$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStreamDataRequest();
    message.startingCursor = object.startingCursor !== undefined && object.startingCursor !== null ? Cursor$1.fromPartial(object.startingCursor) : undefined;
    message.finality = object.finality ?? undefined;
    message.filter = object.filter?.map((e) => e) || [];
    message.heartbeatInterval = object.heartbeatInterval !== undefined && object.heartbeatInterval !== null ? Duration$1.fromPartial(object.heartbeatInterval) : undefined;
    return message;
  }
};
function createBaseStreamDataResponse() {
  return { message: undefined };
}
const StreamDataResponse$1 = {
  encode(message, writer = _m0.Writer.create()) {
    switch (message.message?.$case) {
      case "data":
        Data$1.encode(message.message.data, writer.uint32(10).fork()).ldelim();
        break;
      case "invalidate":
        Invalidate$1.encode(message.message.invalidate, writer.uint32(18).fork()).ldelim();
        break;
      case "finalize":
        Finalize$1.encode(message.message.finalize, writer.uint32(26).fork()).ldelim();
        break;
      case "heartbeat":
        Heartbeat$1.encode(message.message.heartbeat, writer.uint32(34).fork()).ldelim();
        break;
      case "systemMessage":
        SystemMessage$1.encode(message.message.systemMessage, writer.uint32(42).fork()).ldelim();
        break;
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamDataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.message = { $case: "data", data: Data$1.decode(reader, reader.uint32()) };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.message = { $case: "invalidate", invalidate: Invalidate$1.decode(reader, reader.uint32()) };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.message = { $case: "finalize", finalize: Finalize$1.decode(reader, reader.uint32()) };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.message = { $case: "heartbeat", heartbeat: Heartbeat$1.decode(reader, reader.uint32()) };
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.message = { $case: "systemMessage", systemMessage: SystemMessage$1.decode(reader, reader.uint32()) };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      message: isSet$1$1(object.data) ? { $case: "data", data: Data$1.fromJSON(object.data) } : isSet$1$1(object.invalidate) ? { $case: "invalidate", invalidate: Invalidate$1.fromJSON(object.invalidate) } : isSet$1$1(object.finalize) ? { $case: "finalize", finalize: Finalize$1.fromJSON(object.finalize) } : isSet$1$1(object.heartbeat) ? { $case: "heartbeat", heartbeat: Heartbeat$1.fromJSON(object.heartbeat) } : isSet$1$1(object.systemMessage) ? { $case: "systemMessage", systemMessage: SystemMessage$1.fromJSON(object.systemMessage) } : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.message?.$case === "data") {
      obj.data = Data$1.toJSON(message.message.data);
    }
    if (message.message?.$case === "invalidate") {
      obj.invalidate = Invalidate$1.toJSON(message.message.invalidate);
    }
    if (message.message?.$case === "finalize") {
      obj.finalize = Finalize$1.toJSON(message.message.finalize);
    }
    if (message.message?.$case === "heartbeat") {
      obj.heartbeat = Heartbeat$1.toJSON(message.message.heartbeat);
    }
    if (message.message?.$case === "systemMessage") {
      obj.systemMessage = SystemMessage$1.toJSON(message.message.systemMessage);
    }
    return obj;
  },
  create(base) {
    return StreamDataResponse$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStreamDataResponse();
    if (object.message?.$case === "data" && object.message?.data !== undefined && object.message?.data !== null) {
      message.message = { $case: "data", data: Data$1.fromPartial(object.message.data) };
    }
    if (object.message?.$case === "invalidate" && object.message?.invalidate !== undefined && object.message?.invalidate !== null) {
      message.message = { $case: "invalidate", invalidate: Invalidate$1.fromPartial(object.message.invalidate) };
    }
    if (object.message?.$case === "finalize" && object.message?.finalize !== undefined && object.message?.finalize !== null) {
      message.message = { $case: "finalize", finalize: Finalize$1.fromPartial(object.message.finalize) };
    }
    if (object.message?.$case === "heartbeat" && object.message?.heartbeat !== undefined && object.message?.heartbeat !== null) {
      message.message = { $case: "heartbeat", heartbeat: Heartbeat$1.fromPartial(object.message.heartbeat) };
    }
    if (object.message?.$case === "systemMessage" && object.message?.systemMessage !== undefined && object.message?.systemMessage !== null) {
      message.message = {
        $case: "systemMessage",
        systemMessage: SystemMessage$1.fromPartial(object.message.systemMessage)
      };
    }
    return message;
  }
};
function createBaseInvalidate() {
  return { cursor: undefined, removed: [] };
}
const Invalidate$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.cursor !== undefined) {
      Cursor$1.encode(message.cursor, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.removed) {
      Cursor$1.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvalidate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.cursor = Cursor$1.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.removed.push(Cursor$1.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      cursor: isSet$1$1(object.cursor) ? Cursor$1.fromJSON(object.cursor) : undefined,
      removed: globalThis.Array.isArray(object?.removed) ? object.removed.map((e) => Cursor$1.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.cursor !== undefined) {
      obj.cursor = Cursor$1.toJSON(message.cursor);
    }
    if (message.removed?.length) {
      obj.removed = message.removed.map((e) => Cursor$1.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return Invalidate$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseInvalidate();
    message.cursor = object.cursor !== undefined && object.cursor !== null ? Cursor$1.fromPartial(object.cursor) : undefined;
    message.removed = object.removed?.map((e) => Cursor$1.fromPartial(e)) || [];
    return message;
  }
};
function createBaseFinalize() {
  return { cursor: undefined };
}
const Finalize$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.cursor !== undefined) {
      Cursor$1.encode(message.cursor, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalize();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.cursor = Cursor$1.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { cursor: isSet$1$1(object.cursor) ? Cursor$1.fromJSON(object.cursor) : undefined };
  },
  toJSON(message) {
    const obj = {};
    if (message.cursor !== undefined) {
      obj.cursor = Cursor$1.toJSON(message.cursor);
    }
    return obj;
  },
  create(base) {
    return Finalize$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFinalize();
    message.cursor = object.cursor !== undefined && object.cursor !== null ? Cursor$1.fromPartial(object.cursor) : undefined;
    return message;
  }
};
function createBaseData() {
  return { cursor: undefined, endCursor: undefined, finality: 0, data: [] };
}
const Data$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.cursor !== undefined) {
      Cursor$1.encode(message.cursor, writer.uint32(10).fork()).ldelim();
    }
    if (message.endCursor !== undefined) {
      Cursor$1.encode(message.endCursor, writer.uint32(18).fork()).ldelim();
    }
    if (message.finality !== 0) {
      writer.uint32(24).int32(message.finality);
    }
    for (const v of message.data) {
      writer.uint32(34).bytes(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.cursor = Cursor$1.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.endCursor = Cursor$1.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.finality = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.data.push(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      cursor: isSet$1$1(object.cursor) ? Cursor$1.fromJSON(object.cursor) : undefined,
      endCursor: isSet$1$1(object.endCursor) ? Cursor$1.fromJSON(object.endCursor) : undefined,
      finality: isSet$1$1(object.finality) ? dataFinalityFromJSON(object.finality) : 0,
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e) => bytesFromBase64$1(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.cursor !== undefined) {
      obj.cursor = Cursor$1.toJSON(message.cursor);
    }
    if (message.endCursor !== undefined) {
      obj.endCursor = Cursor$1.toJSON(message.endCursor);
    }
    if (message.finality !== 0) {
      obj.finality = dataFinalityToJSON(message.finality);
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => base64FromBytes$1(e));
    }
    return obj;
  },
  create(base) {
    return Data$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseData();
    message.cursor = object.cursor !== undefined && object.cursor !== null ? Cursor$1.fromPartial(object.cursor) : undefined;
    message.endCursor = object.endCursor !== undefined && object.endCursor !== null ? Cursor$1.fromPartial(object.endCursor) : undefined;
    message.finality = object.finality ?? 0;
    message.data = object.data?.map((e) => e) || [];
    return message;
  }
};
function createBaseHeartbeat() {
  return {};
}
const Heartbeat$1 = {
  encode(_, writer = _m0.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return Heartbeat$1.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseHeartbeat();
    return message;
  }
};
function createBaseSystemMessage() {
  return { output: undefined };
}
const SystemMessage$1 = {
  encode(message, writer = _m0.Writer.create()) {
    switch (message.output?.$case) {
      case "stdout":
        writer.uint32(10).string(message.output.stdout);
        break;
      case "stderr":
        writer.uint32(18).string(message.output.stderr);
        break;
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystemMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.output = { $case: "stdout", stdout: reader.string() };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.output = { $case: "stderr", stderr: reader.string() };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      output: isSet$1$1(object.stdout) ? { $case: "stdout", stdout: globalThis.String(object.stdout) } : isSet$1$1(object.stderr) ? { $case: "stderr", stderr: globalThis.String(object.stderr) } : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.output?.$case === "stdout") {
      obj.stdout = message.output.stdout;
    }
    if (message.output?.$case === "stderr") {
      obj.stderr = message.output.stderr;
    }
    return obj;
  },
  create(base) {
    return SystemMessage$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSystemMessage();
    if (object.output?.$case === "stdout" && object.output?.stdout !== undefined && object.output?.stdout !== null) {
      message.output = { $case: "stdout", stdout: object.output.stdout };
    }
    if (object.output?.$case === "stderr" && object.output?.stderr !== undefined && object.output?.stderr !== null) {
      message.output = { $case: "stderr", stderr: object.output.stderr };
    }
    return message;
  }
};
const DnaStreamDefinition = {
  name: "DnaStream",
  fullName: "dna.v2.stream.DnaStream",
  methods: {
    /** Stream data from the server. */
    streamData: {
      name: "StreamData",
      requestType: StreamDataRequest$1,
      requestStream: false,
      responseType: StreamDataResponse$1,
      responseStream: true,
      options: {}
    },
    /** Get DNA server status. */
    status: {
      name: "Status",
      requestType: StatusRequest$1,
      requestStream: false,
      responseType: StatusResponse$1,
      responseStream: false,
      options: {}
    }
  }
};
function bytesFromBase64$1(b64) {
  if (globalThis.Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes$1(arr) {
  if (globalThis.Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}
function longToBigint$3(long) {
  return BigInt(long.toString());
}
if (_m0.util.Long !== Long) {
  _m0.util.Long = Long;
  _m0.configure();
}
function isSet$1$1(value) {
  return value !== null && value !== undefined;
}

const Bytes = TemplateLiteral(
  Literal("0x"),
  String$
);
const BytesFromUint8Array = requiredToOptional(
  Uint8ArrayFromSelf,
  Bytes,
  {
    decode(value) {
      if (value.length === 0) {
        return none$4();
      }
      return some(toHex(value));
    },
    encode(value) {
      return value.pipe(
        map$6(hexToBytes),
        getOrElse(() => new Uint8Array(0))
      );
    }
  }
);
const _Cursor = Struct({
  /** The block number. */
  orderKey: BigIntFromSelf,
  /** The block hash, if any. */
  uniqueKey: BytesFromUint8Array
});
const Cursor = _Cursor;
encodeSync(Cursor);
decodeSync(Cursor);
const CursorFromBytes = transform(
  Uint8ArrayFromSelf,
  Cursor,
  {
    decode(value) {
      return Cursor$1.decode(value);
    },
    encode(value) {
      return Cursor$1.encode(value).finish();
    }
  }
);
encodeSync(CursorFromBytes);
decodeSync(CursorFromBytes);
function isCursor(value) {
  return is(Cursor)(value);
}

const DataFinality = transform(
  Enums(DataFinality$1),
  Literal("finalized", "accepted", "pending", "unknown"),
  {
    decode(value) {
      const enumMap = {
        [DataFinality$1.FINALIZED]: "finalized",
        [DataFinality$1.ACCEPTED]: "accepted",
        [DataFinality$1.PENDING]: "pending",
        [DataFinality$1.UNKNOWN]: "unknown",
        [DataFinality$1.UNRECOGNIZED]: "unknown"
      };
      return enumMap[value] ?? "unknown";
    },
    encode(value) {
      const enumMap = {
        finalized: DataFinality$1.FINALIZED,
        accepted: DataFinality$1.ACCEPTED,
        pending: DataFinality$1.PENDING,
        unknown: DataFinality$1.UNKNOWN
      };
      return enumMap[value] ?? DataFinality$1.UNKNOWN;
    }
  }
);
const Duration = Struct({
  seconds: BigIntFromSelf,
  nanos: Number$
});
const StreamDataRequest = (filter) => Struct({
  finality: optional(DataFinality),
  startingCursor: optional(Cursor),
  filter: mutable(Array$(filter)),
  heartbeatInterval: optional(Duration)
});
const Invalidate = Struct({
  _tag: tag$1("invalidate"),
  invalidate: Struct({
    cursor: optional(Cursor)
  })
});
const Finalize = Struct({
  _tag: tag$1("finalize"),
  finalize: Struct({
    cursor: optional(Cursor)
  })
});
const Heartbeat = Struct({
  _tag: tag$1("heartbeat")
});
const StdOut = Struct({
  _tag: tag$1("stdout"),
  stdout: String$
});
const StdErr = Struct({
  _tag: tag$1("stderr"),
  stderr: String$
});
const SystemMessage = Struct({
  _tag: tag$1("systemMessage"),
  systemMessage: Struct({
    output: optional(Union(StdOut, StdErr))
  })
});
const Data = (schema) => Struct({
  _tag: tag$1("data"),
  data: Struct({
    cursor: optional(Cursor),
    endCursor: optional(Cursor),
    finality: DataFinality,
    data: Array$(schema)
  })
});
const StreamDataResponse = (data) => Union(Data(data), Invalidate, Finalize, Heartbeat, SystemMessage);
Union(
  Invalidate,
  Finalize,
  Heartbeat,
  SystemMessage
);
function tag$1(tag2) {
  return Literal(tag2).pipe(
    propertySignature,
    fromKey("$case")
  );
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class StreamConfig {
  constructor(filter, block, mergeFilter) {
    this.filter = filter;
    this.block = block;
    this.mergeFilter = mergeFilter;
    __publicField(this, "request");
    __publicField(this, "response");
    this.request = StreamDataRequest(this.filter);
    this.response = StreamDataResponse(this.block);
  }
  /** Filter schema. */
  get Filter() {
    return this.filter;
  }
  /** Block schema. */
  get Block() {
    return this.block;
  }
  /** Stream data request schema. */
  get Request() {
    return this.request;
  }
  /** Stream data response schema. */
  get Response() {
    return this.response;
  }
}

var lib$2 = {};

var lib$1 = {};

var Metadata = {};

var hasRequiredMetadata$1;

function requireMetadata$1 () {
	if (hasRequiredMetadata$1) return Metadata;
	hasRequiredMetadata$1 = 1;
	Object.defineProperty(Metadata, "__esModule", { value: true });
	Metadata.Metadata = undefined;
	Metadata.Metadata = function Metadata(init) {
	    const data = new Map();
	    const metadata = {
	        set(key, value) {
	            key = normalizeKey(key);
	            if (Array.isArray(value)) {
	                if (value.length === 0) {
	                    data.delete(key);
	                }
	                else {
	                    for (const item of value) {
	                        validate(key, item);
	                    }
	                    data.set(key, key.endsWith('-bin') ? value : [value.join(', ')]);
	                }
	            }
	            else {
	                validate(key, value);
	                data.set(key, [value]);
	            }
	            return metadata;
	        },
	        append(key, value) {
	            key = normalizeKey(key);
	            validate(key, value);
	            let values = data.get(key);
	            if (values == null) {
	                values = [];
	                data.set(key, values);
	            }
	            values.push(value);
	            if (!key.endsWith('-bin')) {
	                data.set(key, [values.join(', ')]);
	            }
	            return metadata;
	        },
	        delete(key) {
	            key = normalizeKey(key);
	            data.delete(key);
	        },
	        get(key) {
	            var _a;
	            key = normalizeKey(key);
	            return (_a = data.get(key)) === null || _a === undefined ? undefined : _a[0];
	        },
	        getAll(key) {
	            var _a;
	            key = normalizeKey(key);
	            return ((_a = data.get(key)) !== null && _a !== undefined ? _a : []);
	        },
	        has(key) {
	            key = normalizeKey(key);
	            return data.has(key);
	        },
	        [Symbol.iterator]() {
	            return data[Symbol.iterator]();
	        },
	    };
	    if (init != null) {
	        const entries = isIterable(init) ? init : Object.entries(init);
	        for (const [key, value] of entries) {
	            metadata.set(key, value);
	        }
	    }
	    return metadata;
	};
	function normalizeKey(key) {
	    return key.toLowerCase();
	}
	function validate(key, value) {
	    if (!/^[0-9a-z_.-]+$/.test(key)) {
	        throw new Error(`Metadata key '${key}' contains illegal characters`);
	    }
	    if (key.endsWith('-bin')) {
	        if (!(value instanceof Uint8Array)) {
	            throw new Error(`Metadata key '${key}' ends with '-bin', thus it must have binary value`);
	        }
	    }
	    else {
	        if (typeof value !== 'string') {
	            throw new Error(`Metadata key '${key}' doesn't end with '-bin', thus it must have string value`);
	        }
	        if (!/^[ -~]*$/.test(value)) {
	            throw new Error(`Metadata value '${value}' of key '${key}' contains illegal characters`);
	        }
	    }
	}
	function isIterable(value) {
	    return Symbol.iterator in value;
	}
	
	return Metadata;
}

var Status = {};

var hasRequiredStatus;

function requireStatus () {
	if (hasRequiredStatus) return Status;
	hasRequiredStatus = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Status = undefined;
		(function (Status) {
		    /**
		     * Not an error; returned on success.
		     */
		    Status[Status["OK"] = 0] = "OK";
		    /**
		     * The operation was cancelled, typically by the caller.
		     */
		    Status[Status["CANCELLED"] = 1] = "CANCELLED";
		    /**
		     * Unknown error.
		     *
		     * For example, this error may be returned when a `Status` value received from
		     * another address space belongs to an error space that is not known in this
		     * address space.
		     *
		     * Also errors raised by APIs that do not return enough error information may
		     * be converted to this error.
		     */
		    Status[Status["UNKNOWN"] = 2] = "UNKNOWN";
		    /**
		     * The client specified an invalid argument.
		     *
		     * Note that this differs from `FAILED_PRECONDITION`. `INVALID_ARGUMENT`
		     * indicates arguments that are problematic regardless of the state of the
		     * system (e.g., a malformed file name).
		     */
		    Status[Status["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
		    /**
		     * The deadline expired before the operation could complete.
		     *
		     * For operations that change the state of the system, this error may be
		     * returned even if the operation has completed successfully.
		     *
		     * For example, a successful response from a server could have been delayed
		     * long enough for the deadline to expire.
		     */
		    Status[Status["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
		    /**
		     * Some requested entity (e.g., file or directory) was not found.
		     *
		     * Note to server developers: if a request is denied for an entire class of
		     * users, such as gradual feature rollout or undocumented allowlist,
		     * `NOT_FOUND` may be used. If a request is denied for some users within a
		     * class of users, such as user-based access control, `PERMISSION_DENIED` must
		     * be used.
		     */
		    Status[Status["NOT_FOUND"] = 5] = "NOT_FOUND";
		    /**
		     * The entity that a client attempted to create (e.g., file or directory)
		     * already exists.
		     */
		    Status[Status["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
		    /**
		     * The caller does not have permission to execute the specified operation.
		     *
		     * `PERMISSION_DENIED` must not be used for rejections caused by exhausting
		     * some resource (use `RESOURCE_EXHAUSTED` instead for those errors).
		     * `PERMISSION_DENIED` must not be used if the caller can not be identified
		     * (use `UNAUTHENTICATED` instead for those errors).
		     *
		     * This error code does not imply the request is valid or the requested entity
		     * exists or satisfies other pre-conditions.
		     */
		    Status[Status["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
		    /**
		     * Some resource has been exhausted, perhaps a per-user quota, or perhaps the
		     * entire file system is out of space.
		     */
		    Status[Status["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
		    /**
		     * The operation was rejected because the system is not in a state required
		     * for the operation's execution.
		     *
		     * For example, the directory to be deleted is non-empty, an rmdir operation
		     * is applied to a non-directory, etc.
		     *
		     * Service implementors can use the following guidelines to decide between
		     * `FAILED_PRECONDITION`, `ABORTED`, and `UNAVAILABLE`:
		     *
		     *   (a) Use `UNAVAILABLE` if the client can retry just the failing call.
		     *   (b) Use `ABORTED` if the client should retry at a higher level (e.g.,
		     *       when a client-specified test-and-set fails, indicating the client
		     *       should restart a read-modify-write sequence).
		     *   (c) Use `FAILED_PRECONDITION` if the client should not retry until the
		     *       system state has been explicitly fixed. E.g., if an "rmdir" fails
		     *       because the directory is non-empty, `FAILED_PRECONDITION` should be
		     *       returned since the client should not retry unless the files are
		     *       deleted from the directory.
		     */
		    Status[Status["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
		    /**
		     * The operation was aborted, typically due to a concurrency issue such as a
		     * sequencer check failure or transaction abort.
		     *
		     * See the guidelines above for deciding between `FAILED_PRECONDITION`,
		     * `ABORTED`, and `UNAVAILABLE`.
		     */
		    Status[Status["ABORTED"] = 10] = "ABORTED";
		    /**
		     * The operation was attempted past the valid range.
		     *
		     * E.g., seeking or reading past end-of-file.
		     *
		     * Unlike `INVALID_ARGUMENT`, this error indicates a problem that may be fixed
		     * if the system state changes. For example, a 32-bit file system will
		     * generate `INVALID_ARGUMENT` if asked to read at an offset that is not in
		     * the range [0,2^32-1], but it will generate `OUT_OF_RANGE` if asked to read
		     * from an offset past the current file size.
		     *
		     * There is a fair bit of overlap between `FAILED_PRECONDITION` and
		     * `OUT_OF_RANGE`. We recommend using `OUT_OF_RANGE` (the more specific error)
		     * when it applies so that callers who are iterating through a space can
		     * easily look for an `OUT_OF_RANGE` error to detect when they are done.
		     */
		    Status[Status["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
		    /**
		     * The operation is not implemented or is not supported/enabled in this
		     * service.
		     */
		    Status[Status["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
		    /**
		     * Internal errors.
		     *
		     * This means that some invariants expected by the underlying system have been
		     * broken. This error code is reserved for serious errors.
		     */
		    Status[Status["INTERNAL"] = 13] = "INTERNAL";
		    /**
		     * The service is currently unavailable.
		     *
		     * This is most likely a transient condition, which can be corrected by
		     * retrying with a backoff.
		     *
		     * Note that it is not always safe to retry non-idempotent operations.
		     */
		    Status[Status["UNAVAILABLE"] = 14] = "UNAVAILABLE";
		    /**
		     * Unrecoverable data loss or corruption.
		     */
		    Status[Status["DATA_LOSS"] = 15] = "DATA_LOSS";
		    /**
		     * The request does not have valid authentication credentials for the
		     * operation.
		     */
		    Status[Status["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
		})(exports.Status || (exports.Status = {}));
		
	} (Status));
	return Status;
}

var MethodDescriptor = {};

var hasRequiredMethodDescriptor;

function requireMethodDescriptor () {
	if (hasRequiredMethodDescriptor) return MethodDescriptor;
	hasRequiredMethodDescriptor = 1;
	Object.defineProperty(MethodDescriptor, "__esModule", { value: true });
	
	return MethodDescriptor;
}

var CallOptions = {};

var hasRequiredCallOptions;

function requireCallOptions () {
	if (hasRequiredCallOptions) return CallOptions;
	hasRequiredCallOptions = 1;
	Object.defineProperty(CallOptions, "__esModule", { value: true });
	
	return CallOptions;
}

var ClientMiddleware = {};

var hasRequiredClientMiddleware;

function requireClientMiddleware () {
	if (hasRequiredClientMiddleware) return ClientMiddleware;
	hasRequiredClientMiddleware = 1;
	Object.defineProperty(ClientMiddleware, "__esModule", { value: true });
	
	return ClientMiddleware;
}

var composeClientMiddleware = {};

var hasRequiredComposeClientMiddleware;

function requireComposeClientMiddleware () {
	if (hasRequiredComposeClientMiddleware) return composeClientMiddleware;
	hasRequiredComposeClientMiddleware = 1;
	Object.defineProperty(composeClientMiddleware, "__esModule", { value: true });
	composeClientMiddleware.composeClientMiddleware = undefined;
	function composeClientMiddleware$1(middleware1, middleware2) {
	    return (call, options) => {
	        return middleware2(Object.assign(Object.assign({}, call), { next: (request, options2) => {
	                return middleware1(Object.assign(Object.assign({}, call), { request }), options2);
	            } }), options);
	    };
	}
	composeClientMiddleware.composeClientMiddleware = composeClientMiddleware$1;
	
	return composeClientMiddleware;
}

var ClientError = {};

var cjs$1 = {};

var helpers = {};

var hasRequiredHelpers;

function requireHelpers () {
	if (hasRequiredHelpers) return helpers;
	hasRequiredHelpers = 1;
	helpers.__esModule = undefined;
	helpers.__esModule = true;

	// Misc helpers

	var objectSetPrototypeOfIsDefined = typeof Object.setPrototypeOf === "function";
	var objectGetPrototypeOfIsDefined = typeof Object.getPrototypeOf === "function";
	var objectDefinePropertyIsDefined = typeof Object.defineProperty === "function";
	var objectCreateIsDefined = typeof Object.create === "function";
	var objectHasOwnPropertyIsDefined =
	  typeof Object.prototype.hasOwnProperty === "function";

	var setPrototypeOf = function setPrototypeOf(target, prototype) {
	  if (objectSetPrototypeOfIsDefined) {
	    Object.setPrototypeOf(target, prototype);
	  } else {
	    target.__proto__ = prototype;
	  }
	};
	helpers.setPrototypeOf = setPrototypeOf;

	var getPrototypeOf = function getPrototypeOf(target) {
	  if (objectGetPrototypeOfIsDefined) {
	    return Object.getPrototypeOf(target);
	  } else {
	    return target.__proto__ || target.prototype;
	  }
	};
	helpers.getPrototypeOf = getPrototypeOf;

	// Object.defineProperty exists in IE8, but the implementation is buggy, so we
	// need to test if the call fails, and, if so, set a flag to use the shim, as if
	// the function were not defined. When this error is caught the first time, the
	// function is called again recursively, after the flag is set, so the desired
	// effect is achieved anyway.
	var ie8ObjectDefinePropertyBug = false;
	var defineProperty = function defineProperty(target, name, propertyDescriptor) {
	  if (objectDefinePropertyIsDefined && !ie8ObjectDefinePropertyBug) {
	    try {
	      Object.defineProperty(target, name, propertyDescriptor);
	    } catch (e) {
	      ie8ObjectDefinePropertyBug = true;
	      defineProperty(target, name, propertyDescriptor);
	    }
	  } else {
	    target[name] = propertyDescriptor.value;
	  }
	};
	helpers.defineProperty = defineProperty;

	var hasOwnProperty = function hasOwnProperty(target, name) {
	  if (objectHasOwnPropertyIsDefined) {
	    return target.hasOwnProperty(target, name);
	  } else {
	    return target[name] === undefined;
	  }
	};
	helpers.hasOwnProperty = hasOwnProperty;

	var objectCreate = function objectCreate(prototype, propertyDescriptors) {
	  if (objectCreateIsDefined) {
	    return Object.create(prototype, propertyDescriptors);
	  } else {
	    var F = function F() {};
	    F.prototype = prototype;
	    var result = new F();
	    if (typeof propertyDescriptors === "undefined") {
	      return result;
	    }
	    if (typeof propertyDescriptors === "null") {
	      throw new Error("PropertyDescriptors must not be null.");
	    }
	    if (typeof propertyDescriptors === "object") {
	      for (var key in propertyDescriptors) {
	        if (hasOwnProperty(propertyDescriptors, key)) {
	          result[key] = propertyDescriptors[key].value;
	        }
	      }
	    }

	    return result;
	  }
	};
	helpers.objectCreate = objectCreate;
	return helpers;
}

var hasRequiredCjs$1;

function requireCjs$1 () {
	if (hasRequiredCjs$1) return cjs$1;
	hasRequiredCjs$1 = 1;
	(function (exports) {
		exports.__esModule = undefined;
		exports.__esModule = true;

		var helpers = requireHelpers();
		var setPrototypeOf = helpers.setPrototypeOf;
		var getPrototypeOf = helpers.getPrototypeOf;
		var defineProperty = helpers.defineProperty;
		var objectCreate = helpers.objectCreate;

		// Small test for IE6-8, which checks if the environment prints errors "nicely"
		// If not, a toString() method to be added to the error objects with formatting
		// like in more modern browsers
		var uglyErrorPrinting = new Error().toString() === "[object Error]";

		// For compatibility
		var extendableErrorName = "";

		function ExtendableError(message) {
		  // Get the constructor
		  var originalConstructor = this.constructor;
		  // Get the constructor name from the non-standard name property. If undefined
		  // (on old IEs), it uses the string representation of the function to extract
		  // the name. This should work in all cases, except for directly instantiated
		  // ExtendableError objects, for which the name of the ExtendableError class /
		  // function is used
		  var constructorName =
		    originalConstructor.name ||
		    (function () {
		      var constructorNameMatch = originalConstructor
		        .toString()
		        .match(/^function\s*([^\s(]+)/);
		      return constructorNameMatch === null
		        ? extendableErrorName
		          ? extendableErrorName
		          : "Error"
		        : constructorNameMatch[1];
		    })();
		  // If the constructor name is "Error", ...
		  var constructorNameIsError = constructorName === "Error";
		  // change it to the name of the ExtendableError class / function
		  var name = constructorNameIsError ? extendableErrorName : constructorName;

		  // Obtain a new Error instance. This also sets the message property already.
		  var instance = Error.apply(this, arguments);

		  // Set the prototype of this to the prototype of instance
		  setPrototypeOf(instance, getPrototypeOf(this));

		  // On old IEs, the instance will not extend our subclasses this way. The fix is to use this from the function call instead.
		  if (
		    !(instance instanceof originalConstructor) ||
		    !(instance instanceof ExtendableError)
		  ) {
		    var instance = this;
		    Error.apply(this, arguments);
		    defineProperty(instance, "message", {
		      configurable: true,
		      enumerable: false,
		      value: message,
		      writable: true,
		    });
		  }

		  // define the name property
		  defineProperty(instance, "name", {
		    configurable: true,
		    enumerable: false,
		    value: name,
		    writable: true,
		  });

		  // Use Error.captureStackTrace on V8 to capture the proper stack trace excluding any of our error classes
		  if (Error.captureStackTrace) {
		    // prettier-ignore
		    Error.captureStackTrace(
		      instance,
		      constructorNameIsError ? ExtendableError : originalConstructor
		    );
		  }
		  // instance.stack can still be undefined, in which case the best solution is to create a new Error object and get it from there
		  if (instance.stack === undefined) {
		    var err = new Error(message);
		    err.name = instance.name;
		    instance.stack = err.stack;
		  }

		  // If the environment does not have a proper string representation (IE), provide an alternative toString()
		  if (uglyErrorPrinting) {
		    defineProperty(instance, "toString", {
		      configurable: true,
		      enumerable: false,
		      value: function toString() {
		        return (
		          (this.name || "Error") +
		          (typeof this.message === "undefined" ? "" : ": " + this.message)
		        );
		      },
		      writable: true,
		    });
		  }

		  // We're done!
		  return instance;
		}

		// Get the name of the ExtendableError function or use the string literal
		extendableErrorName = ExtendableError.name || "ExtendableError";

		// Set the prototype of ExtendableError to an Error object
		ExtendableError.prototype = objectCreate(Error.prototype, {
		  constructor: {
		    value: Error,
		    enumerable: false,
		    writable: true,
		    configurable: true,
		  },
		});

		// Export
		exports.ExtendableError = ExtendableError;
		exports["default"] = exports.ExtendableError; 
	} (cjs$1));
	return cjs$1;
}

var hasRequiredClientError;

function requireClientError () {
	if (hasRequiredClientError) return ClientError;
	hasRequiredClientError = 1;
	Object.defineProperty(ClientError, "__esModule", { value: true });
	ClientError.ClientError = undefined;
	const ts_error_1 = requireCjs$1();
	const Status_1 = requireStatus();
	/**
	 * Represents gRPC errors returned from client calls.
	 */
	let ClientError$1 = class ClientError extends ts_error_1.ExtendableError {
	    constructor(path, code, details) {
	        super(`${path} ${Status_1.Status[code]}: ${details}`);
	        this.path = path;
	        this.code = code;
	        this.details = details;
	        this.name = 'ClientError';
	        Object.defineProperty(this, '@@nice-grpc', {
	            value: true,
	        });
	        Object.defineProperty(this, '@@nice-grpc:ClientError', {
	            value: true,
	        });
	    }
	    static [Symbol.hasInstance](instance) {
	        // allow instances of ClientError from different versions of nice-grpc
	        // to work with `instanceof ClientError`
	        if (this !== ClientError) {
	            return this.prototype.isPrototypeOf(instance);
	        }
	        return (typeof instance === 'object' &&
	            instance !== null &&
	            (instance.constructor === ClientError ||
	                instance['@@nice-grpc:ClientError'] === true ||
	                (instance.name === 'ClientError' && instance['@@nice-grpc'] === true)));
	    }
	};
	ClientError.ClientError = ClientError$1;
	
	return ClientError;
}

var CallContext = {};

var hasRequiredCallContext;

function requireCallContext () {
	if (hasRequiredCallContext) return CallContext;
	hasRequiredCallContext = 1;
	Object.defineProperty(CallContext, "__esModule", { value: true });
	
	return CallContext;
}

var ServerMiddleware = {};

var hasRequiredServerMiddleware;

function requireServerMiddleware () {
	if (hasRequiredServerMiddleware) return ServerMiddleware;
	hasRequiredServerMiddleware = 1;
	Object.defineProperty(ServerMiddleware, "__esModule", { value: true });
	
	return ServerMiddleware;
}

var composeServerMiddleware = {};

var hasRequiredComposeServerMiddleware;

function requireComposeServerMiddleware () {
	if (hasRequiredComposeServerMiddleware) return composeServerMiddleware;
	hasRequiredComposeServerMiddleware = 1;
	Object.defineProperty(composeServerMiddleware, "__esModule", { value: true });
	composeServerMiddleware.composeServerMiddleware = undefined;
	function composeServerMiddleware$1(middleware1, middleware2) {
	    return (call, context) => {
	        return middleware1(Object.assign(Object.assign({}, call), { next: (request, context1) => {
	                return middleware2(Object.assign(Object.assign({}, call), { request }), context1);
	            } }), context);
	    };
	}
	composeServerMiddleware.composeServerMiddleware = composeServerMiddleware$1;
	
	return composeServerMiddleware;
}

var ServerError = {};

var hasRequiredServerError;

function requireServerError () {
	if (hasRequiredServerError) return ServerError;
	hasRequiredServerError = 1;
	Object.defineProperty(ServerError, "__esModule", { value: true });
	ServerError.ServerError = undefined;
	const ts_error_1 = requireCjs$1();
	const Status_1 = requireStatus();
	/**
	 * Service implementations may throw this error to report gRPC errors to
	 * clients.
	 */
	let ServerError$1 = class ServerError extends ts_error_1.ExtendableError {
	    constructor(code, details) {
	        super(`${Status_1.Status[code]}: ${details}`);
	        this.code = code;
	        this.details = details;
	        this.name = 'ServerError';
	        Object.defineProperty(this, '@@nice-grpc', {
	            value: true,
	        });
	        Object.defineProperty(this, '@@nice-grpc:ServerError', {
	            value: true,
	        });
	    }
	    static [Symbol.hasInstance](instance) {
	        // allow instances of ServerError from different versions of nice-grpc
	        // to work with `instanceof ServerError`
	        if (this !== ServerError) {
	            return this.prototype.isPrototypeOf(instance);
	        }
	        return (typeof instance === 'object' &&
	            instance !== null &&
	            (instance.constructor === ServerError ||
	                instance['@@nice-grpc:ServerError'] === true ||
	                (instance.name === 'ServerError' && instance['@@nice-grpc'] === true)));
	    }
	};
	ServerError.ServerError = ServerError$1;
	
	return ServerError;
}

var hasRequiredLib$2;

function requireLib$2 () {
	if (hasRequiredLib$2) return lib$1;
	hasRequiredLib$2 = 1;
	(function (exports) {
		var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		__exportStar(requireMetadata$1(), exports);
		__exportStar(requireStatus(), exports);
		__exportStar(requireMethodDescriptor(), exports);
		__exportStar(requireCallOptions(), exports);
		__exportStar(requireClientMiddleware(), exports);
		__exportStar(requireComposeClientMiddleware(), exports);
		__exportStar(requireClientError(), exports);
		__exportStar(requireCallContext(), exports);
		__exportStar(requireServerMiddleware(), exports);
		__exportStar(requireComposeServerMiddleware(), exports);
		__exportStar(requireServerError(), exports);
		
	} (lib$1));
	return lib$1;
}

var Server = {};

var src$2 = {};

var callCredentials = {};

var metadata = {};

var logging = {};

var constants = {};

var hasRequiredConstants;

function requireConstants () {
	if (hasRequiredConstants) return constants;
	hasRequiredConstants = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(constants, "__esModule", { value: true });
	constants.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = constants.DEFAULT_MAX_SEND_MESSAGE_LENGTH = constants.Propagate = constants.LogVerbosity = constants.Status = undefined;
	var Status;
	(function (Status) {
	    Status[Status["OK"] = 0] = "OK";
	    Status[Status["CANCELLED"] = 1] = "CANCELLED";
	    Status[Status["UNKNOWN"] = 2] = "UNKNOWN";
	    Status[Status["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
	    Status[Status["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
	    Status[Status["NOT_FOUND"] = 5] = "NOT_FOUND";
	    Status[Status["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
	    Status[Status["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
	    Status[Status["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
	    Status[Status["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
	    Status[Status["ABORTED"] = 10] = "ABORTED";
	    Status[Status["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
	    Status[Status["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
	    Status[Status["INTERNAL"] = 13] = "INTERNAL";
	    Status[Status["UNAVAILABLE"] = 14] = "UNAVAILABLE";
	    Status[Status["DATA_LOSS"] = 15] = "DATA_LOSS";
	    Status[Status["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
	})(Status || (constants.Status = Status = {}));
	var LogVerbosity;
	(function (LogVerbosity) {
	    LogVerbosity[LogVerbosity["DEBUG"] = 0] = "DEBUG";
	    LogVerbosity[LogVerbosity["INFO"] = 1] = "INFO";
	    LogVerbosity[LogVerbosity["ERROR"] = 2] = "ERROR";
	    LogVerbosity[LogVerbosity["NONE"] = 3] = "NONE";
	})(LogVerbosity || (constants.LogVerbosity = LogVerbosity = {}));
	/**
	 * NOTE: This enum is not currently used in any implemented API in this
	 * library. It is included only for type parity with the other implementation.
	 */
	var Propagate;
	(function (Propagate) {
	    Propagate[Propagate["DEADLINE"] = 1] = "DEADLINE";
	    Propagate[Propagate["CENSUS_STATS_CONTEXT"] = 2] = "CENSUS_STATS_CONTEXT";
	    Propagate[Propagate["CENSUS_TRACING_CONTEXT"] = 4] = "CENSUS_TRACING_CONTEXT";
	    Propagate[Propagate["CANCELLATION"] = 8] = "CANCELLATION";
	    // https://github.com/grpc/grpc/blob/master/include/grpc/impl/codegen/propagation_bits.h#L43
	    Propagate[Propagate["DEFAULTS"] = 65535] = "DEFAULTS";
	})(Propagate || (constants.Propagate = Propagate = {}));
	// -1 means unlimited
	constants.DEFAULT_MAX_SEND_MESSAGE_LENGTH = -1;
	// 4 MB default
	constants.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = 4 * 1024 * 1024;
	
	return constants;
}

var name = "@grpc/grpc-js";
var version = "1.12.5";
var description = "gRPC Library for Node - pure JS implementation";
var homepage = "https://grpc.io/";
var repository = "https://github.com/grpc/grpc-node/tree/master/packages/grpc-js";
var main = "build/src/index.js";
var engines = {
	node: ">=12.10.0"
};
var keywords = [
];
var author = {
	name: "Google Inc."
};
var types$1 = "build/src/index.d.ts";
var license = "Apache-2.0";
var devDependencies = {
	"@grpc/proto-loader": "file:../proto-loader",
	"@types/gulp": "^4.0.17",
	"@types/gulp-mocha": "0.0.37",
	"@types/lodash": "^4.14.202",
	"@types/mocha": "^10.0.6",
	"@types/ncp": "^2.0.8",
	"@types/node": ">=20.11.20",
	"@types/pify": "^5.0.4",
	"@types/semver": "^7.5.8",
	"@typescript-eslint/eslint-plugin": "^7.1.0",
	"@typescript-eslint/parser": "^7.1.0",
	"@typescript-eslint/typescript-estree": "^7.1.0",
	"clang-format": "^1.8.0",
	eslint: "^8.42.0",
	"eslint-config-prettier": "^8.8.0",
	"eslint-plugin-node": "^11.1.0",
	"eslint-plugin-prettier": "^4.2.1",
	execa: "^2.0.3",
	gulp: "^4.0.2",
	"gulp-mocha": "^6.0.0",
	lodash: "^4.17.21",
	madge: "^5.0.1",
	"mocha-jenkins-reporter": "^0.4.1",
	ncp: "^2.0.0",
	pify: "^4.0.1",
	prettier: "^2.8.8",
	rimraf: "^3.0.2",
	semver: "^7.6.0",
	"ts-node": "^10.9.2",
	typescript: "^5.3.3"
};
var contributors = [
	{
		name: "Google Inc."
	}
];
var scripts = {
	build: "npm run compile",
	clean: "rimraf ./build",
	compile: "tsc -p .",
	format: "clang-format -i -style=\"{Language: JavaScript, BasedOnStyle: Google, ColumnLimit: 80}\" src/*.ts test/*.ts",
	lint: "eslint src/*.ts test/*.ts",
	prepare: "npm run generate-types && npm run compile",
	test: "gulp test",
	check: "npm run lint",
	fix: "eslint --fix src/*.ts test/*.ts",
	pretest: "npm run generate-types && npm run generate-test-types && npm run compile",
	posttest: "npm run check && madge -c ./build/src",
	"generate-types": "proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --includeDirs proto/ --include-dirs test/fixtures/ -O src/generated/ --grpcLib ../index channelz.proto",
	"generate-test-types": "proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --include-dirs test/fixtures/ -O test/generated/ --grpcLib ../../src/index test_service.proto"
};
var dependencies = {
	"@grpc/proto-loader": "^0.7.13",
	"@js-sdsl/ordered-map": "^4.4.2"
};
var files = [
	"src/**/*.ts",
	"build/src/**/*.{js,d.ts,js.map}",
	"proto/*.proto",
	"LICENSE",
	"deps/envoy-api/envoy/api/v2/**/*.proto",
	"deps/envoy-api/envoy/config/**/*.proto",
	"deps/envoy-api/envoy/service/**/*.proto",
	"deps/envoy-api/envoy/type/**/*.proto",
	"deps/udpa/udpa/**/*.proto",
	"deps/googleapis/google/api/*.proto",
	"deps/googleapis/google/rpc/*.proto",
	"deps/protoc-gen-validate/validate/**/*.proto"
];
const require$$12 = {
	name: name,
	version: version,
	description: description,
	homepage: homepage,
	repository: repository,
	main: main,
	engines: engines,
	keywords: keywords,
	author: author,
	types: types$1,
	license: license,
	devDependencies: devDependencies,
	contributors: contributors,
	scripts: scripts,
	dependencies: dependencies,
	files: files
};

var hasRequiredLogging;

function requireLogging () {
	if (hasRequiredLogging) return logging;
	hasRequiredLogging = 1;
	(function (exports) {
		/*
		 * Copyright 2019 gRPC authors.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *     http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 *
		 */
		var _a, _b, _c, _d;
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.isTracerEnabled = exports.trace = exports.log = exports.setLoggerVerbosity = exports.setLogger = exports.getLogger = undefined;
		const constants_1 = requireConstants();
		const process_1 = require$$1;
		const clientVersion = require$$12.version;
		const DEFAULT_LOGGER = {
		    error: (message, ...optionalParams) => {
		        console.error('E ' + message, ...optionalParams);
		    },
		    info: (message, ...optionalParams) => {
		        console.error('I ' + message, ...optionalParams);
		    },
		    debug: (message, ...optionalParams) => {
		        console.error('D ' + message, ...optionalParams);
		    },
		};
		let _logger = DEFAULT_LOGGER;
		let _logVerbosity = constants_1.LogVerbosity.ERROR;
		const verbosityString = (_b = (_a = process.env.GRPC_NODE_VERBOSITY) !== null && _a !== undefined ? _a : process.env.GRPC_VERBOSITY) !== null && _b !== undefined ? _b : '';
		switch (verbosityString.toUpperCase()) {
		    case 'DEBUG':
		        _logVerbosity = constants_1.LogVerbosity.DEBUG;
		        break;
		    case 'INFO':
		        _logVerbosity = constants_1.LogVerbosity.INFO;
		        break;
		    case 'ERROR':
		        _logVerbosity = constants_1.LogVerbosity.ERROR;
		        break;
		    case 'NONE':
		        _logVerbosity = constants_1.LogVerbosity.NONE;
		        break;
		    // Ignore any other values
		}
		const getLogger = () => {
		    return _logger;
		};
		exports.getLogger = getLogger;
		const setLogger = (logger) => {
		    _logger = logger;
		};
		exports.setLogger = setLogger;
		const setLoggerVerbosity = (verbosity) => {
		    _logVerbosity = verbosity;
		};
		exports.setLoggerVerbosity = setLoggerVerbosity;
		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		const log = (severity, ...args) => {
		    let logFunction;
		    if (severity >= _logVerbosity) {
		        switch (severity) {
		            case constants_1.LogVerbosity.DEBUG:
		                logFunction = _logger.debug;
		                break;
		            case constants_1.LogVerbosity.INFO:
		                logFunction = _logger.info;
		                break;
		            case constants_1.LogVerbosity.ERROR:
		                logFunction = _logger.error;
		                break;
		        }
		        /* Fall back to _logger.error when other methods are not available for
		         * compatiblity with older behavior that always logged to _logger.error */
		        if (!logFunction) {
		            logFunction = _logger.error;
		        }
		        if (logFunction) {
		            logFunction.bind(_logger)(...args);
		        }
		    }
		};
		exports.log = log;
		const tracersString = (_d = (_c = process.env.GRPC_NODE_TRACE) !== null && _c !== undefined ? _c : process.env.GRPC_TRACE) !== null && _d !== undefined ? _d : '';
		const enabledTracers = new Set();
		const disabledTracers = new Set();
		for (const tracerName of tracersString.split(',')) {
		    if (tracerName.startsWith('-')) {
		        disabledTracers.add(tracerName.substring(1));
		    }
		    else {
		        enabledTracers.add(tracerName);
		    }
		}
		const allEnabled = enabledTracers.has('all');
		function trace(severity, tracer, text) {
		    if (isTracerEnabled(tracer)) {
		        (0, exports.log)(severity, new Date().toISOString() +
		            ' | v' +
		            clientVersion +
		            ' ' +
		            process_1.pid +
		            ' | ' +
		            tracer +
		            ' | ' +
		            text);
		    }
		}
		exports.trace = trace;
		function isTracerEnabled(tracer) {
		    return (!disabledTracers.has(tracer) && (allEnabled || enabledTracers.has(tracer)));
		}
		exports.isTracerEnabled = isTracerEnabled;
		
	} (logging));
	return logging;
}

var error = {};

var hasRequiredError;

function requireError () {
	if (hasRequiredError) return error;
	hasRequiredError = 1;
	/*
	 * Copyright 2022 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(error, "__esModule", { value: true });
	error.getErrorCode = error.getErrorMessage = undefined;
	function getErrorMessage(error) {
	    if (error instanceof Error) {
	        return error.message;
	    }
	    else {
	        return String(error);
	    }
	}
	error.getErrorMessage = getErrorMessage;
	function getErrorCode(error) {
	    if (typeof error === 'object' &&
	        error !== null &&
	        'code' in error &&
	        typeof error.code === 'number') {
	        return error.code;
	    }
	    else {
	        return null;
	    }
	}
	error.getErrorCode = getErrorCode;
	
	return error;
}

var hasRequiredMetadata;

function requireMetadata () {
	if (hasRequiredMetadata) return metadata;
	hasRequiredMetadata = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(metadata, "__esModule", { value: true });
	metadata.Metadata = undefined;
	const logging_1 = requireLogging();
	const constants_1 = requireConstants();
	const error_1 = requireError();
	const LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;
	const LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;
	function isLegalKey(key) {
	    return LEGAL_KEY_REGEX.test(key);
	}
	function isLegalNonBinaryValue(value) {
	    return LEGAL_NON_BINARY_VALUE_REGEX.test(value);
	}
	function isBinaryKey(key) {
	    return key.endsWith('-bin');
	}
	function isCustomMetadata(key) {
	    return !key.startsWith('grpc-');
	}
	function normalizeKey(key) {
	    return key.toLowerCase();
	}
	function validate(key, value) {
	    if (!isLegalKey(key)) {
	        throw new Error('Metadata key "' + key + '" contains illegal characters');
	    }
	    if (value !== null && value !== undefined) {
	        if (isBinaryKey(key)) {
	            if (!Buffer.isBuffer(value)) {
	                throw new Error("keys that end with '-bin' must have Buffer values");
	            }
	        }
	        else {
	            if (Buffer.isBuffer(value)) {
	                throw new Error("keys that don't end with '-bin' must have String values");
	            }
	            if (!isLegalNonBinaryValue(value)) {
	                throw new Error('Metadata string value "' + value + '" contains illegal characters');
	            }
	        }
	    }
	}
	/**
	 * A class for storing metadata. Keys are normalized to lowercase ASCII.
	 */
	class Metadata {
	    constructor(options = {}) {
	        this.internalRepr = new Map();
	        this.options = options;
	    }
	    /**
	     * Sets the given value for the given key by replacing any other values
	     * associated with that key. Normalizes the key.
	     * @param key The key to whose value should be set.
	     * @param value The value to set. Must be a buffer if and only
	     *   if the normalized key ends with '-bin'.
	     */
	    set(key, value) {
	        key = normalizeKey(key);
	        validate(key, value);
	        this.internalRepr.set(key, [value]);
	    }
	    /**
	     * Adds the given value for the given key by appending to a list of previous
	     * values associated with that key. Normalizes the key.
	     * @param key The key for which a new value should be appended.
	     * @param value The value to add. Must be a buffer if and only
	     *   if the normalized key ends with '-bin'.
	     */
	    add(key, value) {
	        key = normalizeKey(key);
	        validate(key, value);
	        const existingValue = this.internalRepr.get(key);
	        if (existingValue === undefined) {
	            this.internalRepr.set(key, [value]);
	        }
	        else {
	            existingValue.push(value);
	        }
	    }
	    /**
	     * Removes the given key and any associated values. Normalizes the key.
	     * @param key The key whose values should be removed.
	     */
	    remove(key) {
	        key = normalizeKey(key);
	        // validate(key);
	        this.internalRepr.delete(key);
	    }
	    /**
	     * Gets a list of all values associated with the key. Normalizes the key.
	     * @param key The key whose value should be retrieved.
	     * @return A list of values associated with the given key.
	     */
	    get(key) {
	        key = normalizeKey(key);
	        // validate(key);
	        return this.internalRepr.get(key) || [];
	    }
	    /**
	     * Gets a plain object mapping each key to the first value associated with it.
	     * This reflects the most common way that people will want to see metadata.
	     * @return A key/value mapping of the metadata.
	     */
	    getMap() {
	        const result = {};
	        for (const [key, values] of this.internalRepr) {
	            if (values.length > 0) {
	                const v = values[0];
	                result[key] = Buffer.isBuffer(v) ? Buffer.from(v) : v;
	            }
	        }
	        return result;
	    }
	    /**
	     * Clones the metadata object.
	     * @return The newly cloned object.
	     */
	    clone() {
	        const newMetadata = new Metadata(this.options);
	        const newInternalRepr = newMetadata.internalRepr;
	        for (const [key, value] of this.internalRepr) {
	            const clonedValue = value.map(v => {
	                if (Buffer.isBuffer(v)) {
	                    return Buffer.from(v);
	                }
	                else {
	                    return v;
	                }
	            });
	            newInternalRepr.set(key, clonedValue);
	        }
	        return newMetadata;
	    }
	    /**
	     * Merges all key-value pairs from a given Metadata object into this one.
	     * If both this object and the given object have values in the same key,
	     * values from the other Metadata object will be appended to this object's
	     * values.
	     * @param other A Metadata object.
	     */
	    merge(other) {
	        for (const [key, values] of other.internalRepr) {
	            const mergedValue = (this.internalRepr.get(key) || []).concat(values);
	            this.internalRepr.set(key, mergedValue);
	        }
	    }
	    setOptions(options) {
	        this.options = options;
	    }
	    getOptions() {
	        return this.options;
	    }
	    /**
	     * Creates an OutgoingHttpHeaders object that can be used with the http2 API.
	     */
	    toHttp2Headers() {
	        // NOTE: Node <8.9 formats http2 headers incorrectly.
	        const result = {};
	        for (const [key, values] of this.internalRepr) {
	            // We assume that the user's interaction with this object is limited to
	            // through its public API (i.e. keys and values are already validated).
	            result[key] = values.map(bufToString);
	        }
	        return result;
	    }
	    /**
	     * This modifies the behavior of JSON.stringify to show an object
	     * representation of the metadata map.
	     */
	    toJSON() {
	        const result = {};
	        for (const [key, values] of this.internalRepr) {
	            result[key] = values;
	        }
	        return result;
	    }
	    /**
	     * Returns a new Metadata object based fields in a given IncomingHttpHeaders
	     * object.
	     * @param headers An IncomingHttpHeaders object.
	     */
	    static fromHttp2Headers(headers) {
	        const result = new Metadata();
	        for (const key of Object.keys(headers)) {
	            // Reserved headers (beginning with `:`) are not valid keys.
	            if (key.charAt(0) === ':') {
	                continue;
	            }
	            const values = headers[key];
	            try {
	                if (isBinaryKey(key)) {
	                    if (Array.isArray(values)) {
	                        values.forEach(value => {
	                            result.add(key, Buffer.from(value, 'base64'));
	                        });
	                    }
	                    else if (values !== undefined) {
	                        if (isCustomMetadata(key)) {
	                            values.split(',').forEach(v => {
	                                result.add(key, Buffer.from(v.trim(), 'base64'));
	                            });
	                        }
	                        else {
	                            result.add(key, Buffer.from(values, 'base64'));
	                        }
	                    }
	                }
	                else {
	                    if (Array.isArray(values)) {
	                        values.forEach(value => {
	                            result.add(key, value);
	                        });
	                    }
	                    else if (values !== undefined) {
	                        result.add(key, values);
	                    }
	                }
	            }
	            catch (error) {
	                const message = `Failed to add metadata entry ${key}: ${values}. ${(0, error_1.getErrorMessage)(error)}. For more information see https://github.com/grpc/grpc-node/issues/1173`;
	                (0, logging_1.log)(constants_1.LogVerbosity.ERROR, message);
	            }
	        }
	        return result;
	    }
	}
	metadata.Metadata = Metadata;
	const bufToString = (val) => {
	    return Buffer.isBuffer(val) ? val.toString('base64') : val;
	};
	
	return metadata;
}

var hasRequiredCallCredentials;

function requireCallCredentials () {
	if (hasRequiredCallCredentials) return callCredentials;
	hasRequiredCallCredentials = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(callCredentials, "__esModule", { value: true });
	callCredentials.CallCredentials = undefined;
	const metadata_1 = requireMetadata();
	function isCurrentOauth2Client(client) {
	    return ('getRequestHeaders' in client &&
	        typeof client.getRequestHeaders === 'function');
	}
	/**
	 * A class that represents a generic method of adding authentication-related
	 * metadata on a per-request basis.
	 */
	class CallCredentials {
	    /**
	     * Creates a new CallCredentials object from a given function that generates
	     * Metadata objects.
	     * @param metadataGenerator A function that accepts a set of options, and
	     * generates a Metadata object based on these options, which is passed back
	     * to the caller via a supplied (err, metadata) callback.
	     */
	    static createFromMetadataGenerator(metadataGenerator) {
	        return new SingleCallCredentials(metadataGenerator);
	    }
	    /**
	     * Create a gRPC credential from a Google credential object.
	     * @param googleCredentials The authentication client to use.
	     * @return The resulting CallCredentials object.
	     */
	    static createFromGoogleCredential(googleCredentials) {
	        return CallCredentials.createFromMetadataGenerator((options, callback) => {
	            let getHeaders;
	            if (isCurrentOauth2Client(googleCredentials)) {
	                getHeaders = googleCredentials.getRequestHeaders(options.service_url);
	            }
	            else {
	                getHeaders = new Promise((resolve, reject) => {
	                    googleCredentials.getRequestMetadata(options.service_url, (err, headers) => {
	                        if (err) {
	                            reject(err);
	                            return;
	                        }
	                        if (!headers) {
	                            reject(new Error('Headers not set by metadata plugin'));
	                            return;
	                        }
	                        resolve(headers);
	                    });
	                });
	            }
	            getHeaders.then(headers => {
	                const metadata = new metadata_1.Metadata();
	                for (const key of Object.keys(headers)) {
	                    metadata.add(key, headers[key]);
	                }
	                callback(null, metadata);
	            }, err => {
	                callback(err);
	            });
	        });
	    }
	    static createEmpty() {
	        return new EmptyCallCredentials();
	    }
	}
	callCredentials.CallCredentials = CallCredentials;
	class ComposedCallCredentials extends CallCredentials {
	    constructor(creds) {
	        super();
	        this.creds = creds;
	    }
	    async generateMetadata(options) {
	        const base = new metadata_1.Metadata();
	        const generated = await Promise.all(this.creds.map(cred => cred.generateMetadata(options)));
	        for (const gen of generated) {
	            base.merge(gen);
	        }
	        return base;
	    }
	    compose(other) {
	        return new ComposedCallCredentials(this.creds.concat([other]));
	    }
	    _equals(other) {
	        if (this === other) {
	            return true;
	        }
	        if (other instanceof ComposedCallCredentials) {
	            return this.creds.every((value, index) => value._equals(other.creds[index]));
	        }
	        else {
	            return false;
	        }
	    }
	}
	class SingleCallCredentials extends CallCredentials {
	    constructor(metadataGenerator) {
	        super();
	        this.metadataGenerator = metadataGenerator;
	    }
	    generateMetadata(options) {
	        return new Promise((resolve, reject) => {
	            this.metadataGenerator(options, (err, metadata) => {
	                if (metadata !== undefined) {
	                    resolve(metadata);
	                }
	                else {
	                    reject(err);
	                }
	            });
	        });
	    }
	    compose(other) {
	        return new ComposedCallCredentials([this, other]);
	    }
	    _equals(other) {
	        if (this === other) {
	            return true;
	        }
	        if (other instanceof SingleCallCredentials) {
	            return this.metadataGenerator === other.metadataGenerator;
	        }
	        else {
	            return false;
	        }
	    }
	}
	class EmptyCallCredentials extends CallCredentials {
	    generateMetadata(options) {
	        return Promise.resolve(new metadata_1.Metadata());
	    }
	    compose(other) {
	        return other;
	    }
	    _equals(other) {
	        return other instanceof EmptyCallCredentials;
	    }
	}
	
	return callCredentials;
}

var channel$1 = {};

var channelCredentials = {};

var tlsHelpers = {};

var hasRequiredTlsHelpers;

function requireTlsHelpers () {
	if (hasRequiredTlsHelpers) return tlsHelpers;
	hasRequiredTlsHelpers = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(tlsHelpers, "__esModule", { value: true });
	tlsHelpers.getDefaultRootsData = tlsHelpers.CIPHER_SUITES = undefined;
	const fs = require$$0;
	tlsHelpers.CIPHER_SUITES = process.env.GRPC_SSL_CIPHER_SUITES;
	const DEFAULT_ROOTS_FILE_PATH = process.env.GRPC_DEFAULT_SSL_ROOTS_FILE_PATH;
	let defaultRootsData = null;
	function getDefaultRootsData() {
	    if (DEFAULT_ROOTS_FILE_PATH) {
	        if (defaultRootsData === null) {
	            defaultRootsData = fs.readFileSync(DEFAULT_ROOTS_FILE_PATH);
	        }
	        return defaultRootsData;
	    }
	    return null;
	}
	tlsHelpers.getDefaultRootsData = getDefaultRootsData;
	
	return tlsHelpers;
}

var hasRequiredChannelCredentials;

function requireChannelCredentials () {
	if (hasRequiredChannelCredentials) return channelCredentials;
	hasRequiredChannelCredentials = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(channelCredentials, "__esModule", { value: true });
	channelCredentials.createCertificateProviderChannelCredentials = channelCredentials.ChannelCredentials = undefined;
	const tls_1 = require$$4$1;
	const call_credentials_1 = requireCallCredentials();
	const tls_helpers_1 = requireTlsHelpers();
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	function verifyIsBufferOrNull(obj, friendlyName) {
	    if (obj && !(obj instanceof Buffer)) {
	        throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);
	    }
	}
	/**
	 * A class that contains credentials for communicating over a channel, as well
	 * as a set of per-call credentials, which are applied to every method call made
	 * over a channel initialized with an instance of this class.
	 */
	class ChannelCredentials {
	    constructor(callCredentials) {
	        this.callCredentials = callCredentials || call_credentials_1.CallCredentials.createEmpty();
	    }
	    /**
	     * Gets the set of per-call credentials associated with this instance.
	     */
	    _getCallCredentials() {
	        return this.callCredentials;
	    }
	    _ref() {
	        // Do nothing by default
	    }
	    _unref() {
	        // Do nothing by default
	    }
	    /**
	     * Return a new ChannelCredentials instance with a given set of credentials.
	     * The resulting instance can be used to construct a Channel that communicates
	     * over TLS.
	     * @param rootCerts The root certificate data.
	     * @param privateKey The client certificate private key, if available.
	     * @param certChain The client certificate key chain, if available.
	     * @param verifyOptions Additional options to modify certificate verification
	     */
	    static createSsl(rootCerts, privateKey, certChain, verifyOptions) {
	        var _a;
	        verifyIsBufferOrNull(rootCerts, 'Root certificate');
	        verifyIsBufferOrNull(privateKey, 'Private key');
	        verifyIsBufferOrNull(certChain, 'Certificate chain');
	        if (privateKey && !certChain) {
	            throw new Error('Private key must be given with accompanying certificate chain');
	        }
	        if (!privateKey && certChain) {
	            throw new Error('Certificate chain must be given with accompanying private key');
	        }
	        const secureContext = (0, tls_1.createSecureContext)({
	            ca: (_a = rootCerts !== null && rootCerts !== undefined ? rootCerts : (0, tls_helpers_1.getDefaultRootsData)()) !== null && _a !== undefined ? _a : undefined,
	            key: privateKey !== null && privateKey !== undefined ? privateKey : undefined,
	            cert: certChain !== null && certChain !== undefined ? certChain : undefined,
	            ciphers: tls_helpers_1.CIPHER_SUITES,
	        });
	        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== undefined ? verifyOptions : {});
	    }
	    /**
	     * Return a new ChannelCredentials instance with credentials created using
	     * the provided secureContext. The resulting instances can be used to
	     * construct a Channel that communicates over TLS. gRPC will not override
	     * anything in the provided secureContext, so the environment variables
	     * GRPC_SSL_CIPHER_SUITES and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH will
	     * not be applied.
	     * @param secureContext The return value of tls.createSecureContext()
	     * @param verifyOptions Additional options to modify certificate verification
	     */
	    static createFromSecureContext(secureContext, verifyOptions) {
	        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== undefined ? verifyOptions : {});
	    }
	    /**
	     * Return a new ChannelCredentials instance with no credentials.
	     */
	    static createInsecure() {
	        return new InsecureChannelCredentialsImpl();
	    }
	}
	channelCredentials.ChannelCredentials = ChannelCredentials;
	class InsecureChannelCredentialsImpl extends ChannelCredentials {
	    constructor() {
	        super();
	    }
	    compose(callCredentials) {
	        throw new Error('Cannot compose insecure credentials');
	    }
	    _getConnectionOptions() {
	        return {};
	    }
	    _isSecure() {
	        return false;
	    }
	    _equals(other) {
	        return other instanceof InsecureChannelCredentialsImpl;
	    }
	}
	class SecureChannelCredentialsImpl extends ChannelCredentials {
	    constructor(secureContext, verifyOptions) {
	        super();
	        this.secureContext = secureContext;
	        this.verifyOptions = verifyOptions;
	        this.connectionOptions = {
	            secureContext,
	        };
	        // Node asserts that this option is a function, so we cannot pass undefined
	        if (verifyOptions === null || verifyOptions === undefined ? undefined : verifyOptions.checkServerIdentity) {
	            this.connectionOptions.checkServerIdentity =
	                verifyOptions.checkServerIdentity;
	        }
	        if ((verifyOptions === null || verifyOptions === undefined ? undefined : verifyOptions.rejectUnauthorized) !== undefined) {
	            this.connectionOptions.rejectUnauthorized =
	                verifyOptions.rejectUnauthorized;
	        }
	    }
	    compose(callCredentials) {
	        const combinedCallCredentials = this.callCredentials.compose(callCredentials);
	        return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);
	    }
	    _getConnectionOptions() {
	        // Copy to prevent callers from mutating this.connectionOptions
	        return Object.assign({}, this.connectionOptions);
	    }
	    _isSecure() {
	        return true;
	    }
	    _equals(other) {
	        if (this === other) {
	            return true;
	        }
	        if (other instanceof SecureChannelCredentialsImpl) {
	            return (this.secureContext === other.secureContext &&
	                this.verifyOptions.checkServerIdentity ===
	                    other.verifyOptions.checkServerIdentity);
	        }
	        else {
	            return false;
	        }
	    }
	}
	class CertificateProviderChannelCredentialsImpl extends ChannelCredentials {
	    constructor(caCertificateProvider, identityCertificateProvider, verifyOptions) {
	        super();
	        this.caCertificateProvider = caCertificateProvider;
	        this.identityCertificateProvider = identityCertificateProvider;
	        this.verifyOptions = verifyOptions;
	        this.refcount = 0;
	        this.latestCaUpdate = null;
	        this.latestIdentityUpdate = null;
	        this.caCertificateUpdateListener = this.handleCaCertificateUpdate.bind(this);
	        this.identityCertificateUpdateListener = this.handleIdentityCertitificateUpdate.bind(this);
	    }
	    compose(callCredentials) {
	        const combinedCallCredentials = this.callCredentials.compose(callCredentials);
	        return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);
	    }
	    _getConnectionOptions() {
	        var _a, _b, _c;
	        if (this.latestCaUpdate === null) {
	            return null;
	        }
	        if (this.identityCertificateProvider !== null && this.latestIdentityUpdate === null) {
	            return null;
	        }
	        const secureContext = (0, tls_1.createSecureContext)({
	            ca: this.latestCaUpdate.caCertificate,
	            key: (_a = this.latestIdentityUpdate) === null || _a === undefined ? undefined : _a.privateKey,
	            cert: (_b = this.latestIdentityUpdate) === null || _b === undefined ? undefined : _b.certificate,
	            ciphers: tls_helpers_1.CIPHER_SUITES
	        });
	        const options = {
	            secureContext: secureContext
	        };
	        if ((_c = this.verifyOptions) === null || _c === undefined ? undefined : _c.checkServerIdentity) {
	            options.checkServerIdentity = this.verifyOptions.checkServerIdentity;
	        }
	        return options;
	    }
	    _isSecure() {
	        return true;
	    }
	    _equals(other) {
	        var _a, _b;
	        if (this === other) {
	            return true;
	        }
	        if (other instanceof CertificateProviderChannelCredentialsImpl) {
	            return this.caCertificateProvider === other.caCertificateProvider &&
	                this.identityCertificateProvider === other.identityCertificateProvider &&
	                ((_a = this.verifyOptions) === null || _a === undefined ? undefined : _a.checkServerIdentity) === ((_b = other.verifyOptions) === null || _b === undefined ? undefined : _b.checkServerIdentity);
	        }
	        else {
	            return false;
	        }
	    }
	    _ref() {
	        var _a;
	        if (this.refcount === 0) {
	            this.caCertificateProvider.addCaCertificateListener(this.caCertificateUpdateListener);
	            (_a = this.identityCertificateProvider) === null || _a === undefined ? undefined : _a.addIdentityCertificateListener(this.identityCertificateUpdateListener);
	        }
	        this.refcount += 1;
	    }
	    _unref() {
	        var _a;
	        this.refcount -= 1;
	        if (this.refcount === 0) {
	            this.caCertificateProvider.removeCaCertificateListener(this.caCertificateUpdateListener);
	            (_a = this.identityCertificateProvider) === null || _a === undefined ? undefined : _a.removeIdentityCertificateListener(this.identityCertificateUpdateListener);
	        }
	    }
	    handleCaCertificateUpdate(update) {
	        this.latestCaUpdate = update;
	    }
	    handleIdentityCertitificateUpdate(update) {
	        this.latestIdentityUpdate = update;
	    }
	}
	function createCertificateProviderChannelCredentials(caCertificateProvider, identityCertificateProvider, verifyOptions) {
	    return new CertificateProviderChannelCredentialsImpl(caCertificateProvider, identityCertificateProvider, verifyOptions !== null && verifyOptions !== undefined ? verifyOptions : null);
	}
	channelCredentials.createCertificateProviderChannelCredentials = createCertificateProviderChannelCredentials;
	class ComposedChannelCredentialsImpl extends ChannelCredentials {
	    constructor(channelCredentials, callCreds) {
	        super(callCreds);
	        this.channelCredentials = channelCredentials;
	        if (!channelCredentials._isSecure()) {
	            throw new Error('Cannot compose insecure credentials');
	        }
	    }
	    compose(callCredentials) {
	        const combinedCallCredentials = this.callCredentials.compose(callCredentials);
	        return new ComposedChannelCredentialsImpl(this.channelCredentials, combinedCallCredentials);
	    }
	    _getConnectionOptions() {
	        return this.channelCredentials._getConnectionOptions();
	    }
	    _isSecure() {
	        return true;
	    }
	    _equals(other) {
	        if (this === other) {
	            return true;
	        }
	        if (other instanceof ComposedChannelCredentialsImpl) {
	            return (this.channelCredentials._equals(other.channelCredentials) &&
	                this.callCredentials._equals(other.callCredentials));
	        }
	        else {
	            return false;
	        }
	    }
	}
	
	return channelCredentials;
}

var internalChannel = {};

var resolvingLoadBalancer = {};

var loadBalancer = {};

var hasRequiredLoadBalancer;

function requireLoadBalancer () {
	if (hasRequiredLoadBalancer) return loadBalancer;
	hasRequiredLoadBalancer = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(loadBalancer, "__esModule", { value: true });
	loadBalancer.selectLbConfigFromList = loadBalancer.getDefaultConfig = loadBalancer.parseLoadBalancingConfig = loadBalancer.isLoadBalancerNameRegistered = loadBalancer.createLoadBalancer = loadBalancer.registerDefaultLoadBalancerType = loadBalancer.registerLoadBalancerType = loadBalancer.createChildChannelControlHelper = undefined;
	const logging_1 = requireLogging();
	const constants_1 = requireConstants();
	/**
	 * Create a child ChannelControlHelper that overrides some methods of the
	 * parent while letting others pass through to the parent unmodified. This
	 * allows other code to create these children without needing to know about
	 * all of the methods to be passed through.
	 * @param parent
	 * @param overrides
	 */
	function createChildChannelControlHelper(parent, overrides) {
	    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
	    return {
	        createSubchannel: (_b = (_a = overrides.createSubchannel) === null || _a === undefined ? undefined : _a.bind(overrides)) !== null && _b !== undefined ? _b : parent.createSubchannel.bind(parent),
	        updateState: (_d = (_c = overrides.updateState) === null || _c === undefined ? undefined : _c.bind(overrides)) !== null && _d !== undefined ? _d : parent.updateState.bind(parent),
	        requestReresolution: (_f = (_e = overrides.requestReresolution) === null || _e === undefined ? undefined : _e.bind(overrides)) !== null && _f !== undefined ? _f : parent.requestReresolution.bind(parent),
	        addChannelzChild: (_h = (_g = overrides.addChannelzChild) === null || _g === undefined ? undefined : _g.bind(overrides)) !== null && _h !== undefined ? _h : parent.addChannelzChild.bind(parent),
	        removeChannelzChild: (_k = (_j = overrides.removeChannelzChild) === null || _j === undefined ? undefined : _j.bind(overrides)) !== null && _k !== undefined ? _k : parent.removeChannelzChild.bind(parent),
	    };
	}
	loadBalancer.createChildChannelControlHelper = createChildChannelControlHelper;
	const registeredLoadBalancerTypes = {};
	let defaultLoadBalancerType = null;
	function registerLoadBalancerType(typeName, loadBalancerType, loadBalancingConfigType) {
	    registeredLoadBalancerTypes[typeName] = {
	        LoadBalancer: loadBalancerType,
	        LoadBalancingConfig: loadBalancingConfigType,
	    };
	}
	loadBalancer.registerLoadBalancerType = registerLoadBalancerType;
	function registerDefaultLoadBalancerType(typeName) {
	    defaultLoadBalancerType = typeName;
	}
	loadBalancer.registerDefaultLoadBalancerType = registerDefaultLoadBalancerType;
	function createLoadBalancer(config, channelControlHelper, credentials, options) {
	    const typeName = config.getLoadBalancerName();
	    if (typeName in registeredLoadBalancerTypes) {
	        return new registeredLoadBalancerTypes[typeName].LoadBalancer(channelControlHelper, credentials, options);
	    }
	    else {
	        return null;
	    }
	}
	loadBalancer.createLoadBalancer = createLoadBalancer;
	function isLoadBalancerNameRegistered(typeName) {
	    return typeName in registeredLoadBalancerTypes;
	}
	loadBalancer.isLoadBalancerNameRegistered = isLoadBalancerNameRegistered;
	function parseLoadBalancingConfig(rawConfig) {
	    const keys = Object.keys(rawConfig);
	    if (keys.length !== 1) {
	        throw new Error('Provided load balancing config has multiple conflicting entries');
	    }
	    const typeName = keys[0];
	    if (typeName in registeredLoadBalancerTypes) {
	        try {
	            return registeredLoadBalancerTypes[typeName].LoadBalancingConfig.createFromJson(rawConfig[typeName]);
	        }
	        catch (e) {
	            throw new Error(`${typeName}: ${e.message}`);
	        }
	    }
	    else {
	        throw new Error(`Unrecognized load balancing config name ${typeName}`);
	    }
	}
	loadBalancer.parseLoadBalancingConfig = parseLoadBalancingConfig;
	function getDefaultConfig() {
	    if (!defaultLoadBalancerType) {
	        throw new Error('No default load balancer type registered');
	    }
	    return new registeredLoadBalancerTypes[defaultLoadBalancerType].LoadBalancingConfig();
	}
	loadBalancer.getDefaultConfig = getDefaultConfig;
	function selectLbConfigFromList(configs, fallbackTodefault = false) {
	    for (const config of configs) {
	        try {
	            return parseLoadBalancingConfig(config);
	        }
	        catch (e) {
	            (0, logging_1.log)(constants_1.LogVerbosity.DEBUG, 'Config parsing failed with error', e.message);
	            continue;
	        }
	    }
	    if (fallbackTodefault) {
	        if (defaultLoadBalancerType) {
	            return new registeredLoadBalancerTypes[defaultLoadBalancerType].LoadBalancingConfig();
	        }
	        else {
	            return null;
	        }
	    }
	    else {
	        return null;
	    }
	}
	loadBalancer.selectLbConfigFromList = selectLbConfigFromList;
	
	return loadBalancer;
}

var serviceConfig = {};

var hasRequiredServiceConfig;

function requireServiceConfig () {
	if (hasRequiredServiceConfig) return serviceConfig;
	hasRequiredServiceConfig = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(serviceConfig, "__esModule", { value: true });
	serviceConfig.extractAndSelectServiceConfig = serviceConfig.validateServiceConfig = serviceConfig.validateRetryThrottling = undefined;
	/* This file implements gRFC A2 and the service config spec:
	 * https://github.com/grpc/proposal/blob/master/A2-service-configs-in-dns.md
	 * https://github.com/grpc/grpc/blob/master/doc/service_config.md. Each
	 * function here takes an object with unknown structure and returns its
	 * specific object type if the input has the right structure, and throws an
	 * error otherwise. */
	/* The any type is purposely used here. All functions validate their input at
	 * runtime */
	/* eslint-disable @typescript-eslint/no-explicit-any */
	const os = require$$0$1;
	const constants_1 = requireConstants();
	/**
	 * Recognizes a number with up to 9 digits after the decimal point, followed by
	 * an "s", representing a number of seconds.
	 */
	const DURATION_REGEX = /^\d+(\.\d{1,9})?s$/;
	/**
	 * Client language name used for determining whether this client matches a
	 * `ServiceConfigCanaryConfig`'s `clientLanguage` list.
	 */
	const CLIENT_LANGUAGE_STRING = 'node';
	function validateName(obj) {
	    // In this context, and unset field and '' are considered the same
	    if ('service' in obj && obj.service !== '') {
	        if (typeof obj.service !== 'string') {
	            throw new Error(`Invalid method config name: invalid service: expected type string, got ${typeof obj.service}`);
	        }
	        if ('method' in obj && obj.method !== '') {
	            if (typeof obj.method !== 'string') {
	                throw new Error(`Invalid method config name: invalid method: expected type string, got ${typeof obj.service}`);
	            }
	            return {
	                service: obj.service,
	                method: obj.method,
	            };
	        }
	        else {
	            return {
	                service: obj.service,
	            };
	        }
	    }
	    else {
	        if ('method' in obj && obj.method !== undefined) {
	            throw new Error(`Invalid method config name: method set with empty or unset service`);
	        }
	        return {};
	    }
	}
	function validateRetryPolicy(obj) {
	    if (!('maxAttempts' in obj) ||
	        !Number.isInteger(obj.maxAttempts) ||
	        obj.maxAttempts < 2) {
	        throw new Error('Invalid method config retry policy: maxAttempts must be an integer at least 2');
	    }
	    if (!('initialBackoff' in obj) ||
	        typeof obj.initialBackoff !== 'string' ||
	        !DURATION_REGEX.test(obj.initialBackoff)) {
	        throw new Error('Invalid method config retry policy: initialBackoff must be a string consisting of a positive integer or decimal followed by s');
	    }
	    if (!('maxBackoff' in obj) ||
	        typeof obj.maxBackoff !== 'string' ||
	        !DURATION_REGEX.test(obj.maxBackoff)) {
	        throw new Error('Invalid method config retry policy: maxBackoff must be a string consisting of a positive integer or decimal followed by s');
	    }
	    if (!('backoffMultiplier' in obj) ||
	        typeof obj.backoffMultiplier !== 'number' ||
	        obj.backoffMultiplier <= 0) {
	        throw new Error('Invalid method config retry policy: backoffMultiplier must be a number greater than 0');
	    }
	    if (!('retryableStatusCodes' in obj && Array.isArray(obj.retryableStatusCodes))) {
	        throw new Error('Invalid method config retry policy: retryableStatusCodes is required');
	    }
	    if (obj.retryableStatusCodes.length === 0) {
	        throw new Error('Invalid method config retry policy: retryableStatusCodes must be non-empty');
	    }
	    for (const value of obj.retryableStatusCodes) {
	        if (typeof value === 'number') {
	            if (!Object.values(constants_1.Status).includes(value)) {
	                throw new Error('Invalid method config retry policy: retryableStatusCodes value not in status code range');
	            }
	        }
	        else if (typeof value === 'string') {
	            if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {
	                throw new Error('Invalid method config retry policy: retryableStatusCodes value not a status code name');
	            }
	        }
	        else {
	            throw new Error('Invalid method config retry policy: retryableStatusCodes value must be a string or number');
	        }
	    }
	    return {
	        maxAttempts: obj.maxAttempts,
	        initialBackoff: obj.initialBackoff,
	        maxBackoff: obj.maxBackoff,
	        backoffMultiplier: obj.backoffMultiplier,
	        retryableStatusCodes: obj.retryableStatusCodes,
	    };
	}
	function validateHedgingPolicy(obj) {
	    if (!('maxAttempts' in obj) ||
	        !Number.isInteger(obj.maxAttempts) ||
	        obj.maxAttempts < 2) {
	        throw new Error('Invalid method config hedging policy: maxAttempts must be an integer at least 2');
	    }
	    if ('hedgingDelay' in obj &&
	        (typeof obj.hedgingDelay !== 'string' ||
	            !DURATION_REGEX.test(obj.hedgingDelay))) {
	        throw new Error('Invalid method config hedging policy: hedgingDelay must be a string consisting of a positive integer followed by s');
	    }
	    if ('nonFatalStatusCodes' in obj && Array.isArray(obj.nonFatalStatusCodes)) {
	        for (const value of obj.nonFatalStatusCodes) {
	            if (typeof value === 'number') {
	                if (!Object.values(constants_1.Status).includes(value)) {
	                    throw new Error('Invalid method config hedging policy: nonFatalStatusCodes value not in status code range');
	                }
	            }
	            else if (typeof value === 'string') {
	                if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {
	                    throw new Error('Invalid method config hedging policy: nonFatalStatusCodes value not a status code name');
	                }
	            }
	            else {
	                throw new Error('Invalid method config hedging policy: nonFatalStatusCodes value must be a string or number');
	            }
	        }
	    }
	    const result = {
	        maxAttempts: obj.maxAttempts,
	    };
	    if (obj.hedgingDelay) {
	        result.hedgingDelay = obj.hedgingDelay;
	    }
	    if (obj.nonFatalStatusCodes) {
	        result.nonFatalStatusCodes = obj.nonFatalStatusCodes;
	    }
	    return result;
	}
	function validateMethodConfig(obj) {
	    var _a;
	    const result = {
	        name: [],
	    };
	    if (!('name' in obj) || !Array.isArray(obj.name)) {
	        throw new Error('Invalid method config: invalid name array');
	    }
	    for (const name of obj.name) {
	        result.name.push(validateName(name));
	    }
	    if ('waitForReady' in obj) {
	        if (typeof obj.waitForReady !== 'boolean') {
	            throw new Error('Invalid method config: invalid waitForReady');
	        }
	        result.waitForReady = obj.waitForReady;
	    }
	    if ('timeout' in obj) {
	        if (typeof obj.timeout === 'object') {
	            if (!('seconds' in obj.timeout) ||
	                !(typeof obj.timeout.seconds === 'number')) {
	                throw new Error('Invalid method config: invalid timeout.seconds');
	            }
	            if (!('nanos' in obj.timeout) ||
	                !(typeof obj.timeout.nanos === 'number')) {
	                throw new Error('Invalid method config: invalid timeout.nanos');
	            }
	            result.timeout = obj.timeout;
	        }
	        else if (typeof obj.timeout === 'string' &&
	            DURATION_REGEX.test(obj.timeout)) {
	            const timeoutParts = obj.timeout
	                .substring(0, obj.timeout.length - 1)
	                .split('.');
	            result.timeout = {
	                seconds: timeoutParts[0] | 0,
	                nanos: ((_a = timeoutParts[1]) !== null && _a !== undefined ? _a : 0) | 0,
	            };
	        }
	        else {
	            throw new Error('Invalid method config: invalid timeout');
	        }
	    }
	    if ('maxRequestBytes' in obj) {
	        if (typeof obj.maxRequestBytes !== 'number') {
	            throw new Error('Invalid method config: invalid maxRequestBytes');
	        }
	        result.maxRequestBytes = obj.maxRequestBytes;
	    }
	    if ('maxResponseBytes' in obj) {
	        if (typeof obj.maxResponseBytes !== 'number') {
	            throw new Error('Invalid method config: invalid maxRequestBytes');
	        }
	        result.maxResponseBytes = obj.maxResponseBytes;
	    }
	    if ('retryPolicy' in obj) {
	        if ('hedgingPolicy' in obj) {
	            throw new Error('Invalid method config: retryPolicy and hedgingPolicy cannot both be specified');
	        }
	        else {
	            result.retryPolicy = validateRetryPolicy(obj.retryPolicy);
	        }
	    }
	    else if ('hedgingPolicy' in obj) {
	        result.hedgingPolicy = validateHedgingPolicy(obj.hedgingPolicy);
	    }
	    return result;
	}
	function validateRetryThrottling(obj) {
	    if (!('maxTokens' in obj) ||
	        typeof obj.maxTokens !== 'number' ||
	        obj.maxTokens <= 0 ||
	        obj.maxTokens > 1000) {
	        throw new Error('Invalid retryThrottling: maxTokens must be a number in (0, 1000]');
	    }
	    if (!('tokenRatio' in obj) ||
	        typeof obj.tokenRatio !== 'number' ||
	        obj.tokenRatio <= 0) {
	        throw new Error('Invalid retryThrottling: tokenRatio must be a number greater than 0');
	    }
	    return {
	        maxTokens: +obj.maxTokens.toFixed(3),
	        tokenRatio: +obj.tokenRatio.toFixed(3),
	    };
	}
	serviceConfig.validateRetryThrottling = validateRetryThrottling;
	function validateLoadBalancingConfig(obj) {
	    if (!(typeof obj === 'object' && obj !== null)) {
	        throw new Error(`Invalid loadBalancingConfig: unexpected type ${typeof obj}`);
	    }
	    const keys = Object.keys(obj);
	    if (keys.length > 1) {
	        throw new Error(`Invalid loadBalancingConfig: unexpected multiple keys ${keys}`);
	    }
	    if (keys.length === 0) {
	        throw new Error('Invalid loadBalancingConfig: load balancing policy name required');
	    }
	    return {
	        [keys[0]]: obj[keys[0]],
	    };
	}
	function validateServiceConfig(obj) {
	    const result = {
	        loadBalancingConfig: [],
	        methodConfig: [],
	    };
	    if ('loadBalancingPolicy' in obj) {
	        if (typeof obj.loadBalancingPolicy === 'string') {
	            result.loadBalancingPolicy = obj.loadBalancingPolicy;
	        }
	        else {
	            throw new Error('Invalid service config: invalid loadBalancingPolicy');
	        }
	    }
	    if ('loadBalancingConfig' in obj) {
	        if (Array.isArray(obj.loadBalancingConfig)) {
	            for (const config of obj.loadBalancingConfig) {
	                result.loadBalancingConfig.push(validateLoadBalancingConfig(config));
	            }
	        }
	        else {
	            throw new Error('Invalid service config: invalid loadBalancingConfig');
	        }
	    }
	    if ('methodConfig' in obj) {
	        if (Array.isArray(obj.methodConfig)) {
	            for (const methodConfig of obj.methodConfig) {
	                result.methodConfig.push(validateMethodConfig(methodConfig));
	            }
	        }
	    }
	    if ('retryThrottling' in obj) {
	        result.retryThrottling = validateRetryThrottling(obj.retryThrottling);
	    }
	    // Validate method name uniqueness
	    const seenMethodNames = [];
	    for (const methodConfig of result.methodConfig) {
	        for (const name of methodConfig.name) {
	            for (const seenName of seenMethodNames) {
	                if (name.service === seenName.service &&
	                    name.method === seenName.method) {
	                    throw new Error(`Invalid service config: duplicate name ${name.service}/${name.method}`);
	                }
	            }
	            seenMethodNames.push(name);
	        }
	    }
	    return result;
	}
	serviceConfig.validateServiceConfig = validateServiceConfig;
	function validateCanaryConfig(obj) {
	    if (!('serviceConfig' in obj)) {
	        throw new Error('Invalid service config choice: missing service config');
	    }
	    const result = {
	        serviceConfig: validateServiceConfig(obj.serviceConfig),
	    };
	    if ('clientLanguage' in obj) {
	        if (Array.isArray(obj.clientLanguage)) {
	            result.clientLanguage = [];
	            for (const lang of obj.clientLanguage) {
	                if (typeof lang === 'string') {
	                    result.clientLanguage.push(lang);
	                }
	                else {
	                    throw new Error('Invalid service config choice: invalid clientLanguage');
	                }
	            }
	        }
	        else {
	            throw new Error('Invalid service config choice: invalid clientLanguage');
	        }
	    }
	    if ('clientHostname' in obj) {
	        if (Array.isArray(obj.clientHostname)) {
	            result.clientHostname = [];
	            for (const lang of obj.clientHostname) {
	                if (typeof lang === 'string') {
	                    result.clientHostname.push(lang);
	                }
	                else {
	                    throw new Error('Invalid service config choice: invalid clientHostname');
	                }
	            }
	        }
	        else {
	            throw new Error('Invalid service config choice: invalid clientHostname');
	        }
	    }
	    if ('percentage' in obj) {
	        if (typeof obj.percentage === 'number' &&
	            0 <= obj.percentage &&
	            obj.percentage <= 100) {
	            result.percentage = obj.percentage;
	        }
	        else {
	            throw new Error('Invalid service config choice: invalid percentage');
	        }
	    }
	    // Validate that no unexpected fields are present
	    const allowedFields = [
	        'clientLanguage',
	        'percentage',
	        'clientHostname',
	        'serviceConfig',
	    ];
	    for (const field in obj) {
	        if (!allowedFields.includes(field)) {
	            throw new Error(`Invalid service config choice: unexpected field ${field}`);
	        }
	    }
	    return result;
	}
	function validateAndSelectCanaryConfig(obj, percentage) {
	    if (!Array.isArray(obj)) {
	        throw new Error('Invalid service config list');
	    }
	    for (const config of obj) {
	        const validatedConfig = validateCanaryConfig(config);
	        /* For each field, we check if it is present, then only discard the
	         * config if the field value does not match the current client */
	        if (typeof validatedConfig.percentage === 'number' &&
	            percentage > validatedConfig.percentage) {
	            continue;
	        }
	        if (Array.isArray(validatedConfig.clientHostname)) {
	            let hostnameMatched = false;
	            for (const hostname of validatedConfig.clientHostname) {
	                if (hostname === os.hostname()) {
	                    hostnameMatched = true;
	                }
	            }
	            if (!hostnameMatched) {
	                continue;
	            }
	        }
	        if (Array.isArray(validatedConfig.clientLanguage)) {
	            let languageMatched = false;
	            for (const language of validatedConfig.clientLanguage) {
	                if (language === CLIENT_LANGUAGE_STRING) {
	                    languageMatched = true;
	                }
	            }
	            if (!languageMatched) {
	                continue;
	            }
	        }
	        return validatedConfig.serviceConfig;
	    }
	    throw new Error('No matching service config found');
	}
	/**
	 * Find the "grpc_config" record among the TXT records, parse its value as JSON, validate its contents,
	 * and select a service config with selection fields that all match this client. Most of these steps
	 * can fail with an error; the caller must handle any errors thrown this way.
	 * @param txtRecord The TXT record array that is output from a successful call to dns.resolveTxt
	 * @param percentage A number chosen from the range [0, 100) that is used to select which config to use
	 * @return The service configuration to use, given the percentage value, or null if the service config
	 *     data has a valid format but none of the options match the current client.
	 */
	function extractAndSelectServiceConfig(txtRecord, percentage) {
	    for (const record of txtRecord) {
	        if (record.length > 0 && record[0].startsWith('grpc_config=')) {
	            /* Treat the list of strings in this record as a single string and remove
	             * "grpc_config=" from the beginning. The rest should be a JSON string */
	            const recordString = record.join('').substring('grpc_config='.length);
	            const recordJson = JSON.parse(recordString);
	            return validateAndSelectCanaryConfig(recordJson, percentage);
	        }
	    }
	    return null;
	}
	serviceConfig.extractAndSelectServiceConfig = extractAndSelectServiceConfig;
	
	return serviceConfig;
}

var connectivityState = {};

var hasRequiredConnectivityState;

function requireConnectivityState () {
	if (hasRequiredConnectivityState) return connectivityState;
	hasRequiredConnectivityState = 1;
	/*
	 * Copyright 2021 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(connectivityState, "__esModule", { value: true });
	connectivityState.ConnectivityState = undefined;
	var ConnectivityState;
	(function (ConnectivityState) {
	    ConnectivityState[ConnectivityState["IDLE"] = 0] = "IDLE";
	    ConnectivityState[ConnectivityState["CONNECTING"] = 1] = "CONNECTING";
	    ConnectivityState[ConnectivityState["READY"] = 2] = "READY";
	    ConnectivityState[ConnectivityState["TRANSIENT_FAILURE"] = 3] = "TRANSIENT_FAILURE";
	    ConnectivityState[ConnectivityState["SHUTDOWN"] = 4] = "SHUTDOWN";
	})(ConnectivityState || (connectivityState.ConnectivityState = ConnectivityState = {}));
	
	return connectivityState;
}

var resolver = {};

var uriParser = {};

var hasRequiredUriParser;

function requireUriParser () {
	if (hasRequiredUriParser) return uriParser;
	hasRequiredUriParser = 1;
	/*
	 * Copyright 2020 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(uriParser, "__esModule", { value: true });
	uriParser.uriToString = uriParser.combineHostPort = uriParser.splitHostPort = uriParser.parseUri = undefined;
	/*
	 * The groups correspond to URI parts as follows:
	 * 1. scheme
	 * 2. authority
	 * 3. path
	 */
	const URI_REGEX = /^(?:([A-Za-z0-9+.-]+):)?(?:\/\/([^/]*)\/)?(.+)$/;
	function parseUri(uriString) {
	    const parsedUri = URI_REGEX.exec(uriString);
	    if (parsedUri === null) {
	        return null;
	    }
	    return {
	        scheme: parsedUri[1],
	        authority: parsedUri[2],
	        path: parsedUri[3],
	    };
	}
	uriParser.parseUri = parseUri;
	const NUMBER_REGEX = /^\d+$/;
	function splitHostPort(path) {
	    if (path.startsWith('[')) {
	        const hostEnd = path.indexOf(']');
	        if (hostEnd === -1) {
	            return null;
	        }
	        const host = path.substring(1, hostEnd);
	        /* Only an IPv6 address should be in bracketed notation, and an IPv6
	         * address should have at least one colon */
	        if (host.indexOf(':') === -1) {
	            return null;
	        }
	        if (path.length > hostEnd + 1) {
	            if (path[hostEnd + 1] === ':') {
	                const portString = path.substring(hostEnd + 2);
	                if (NUMBER_REGEX.test(portString)) {
	                    return {
	                        host: host,
	                        port: +portString,
	                    };
	                }
	                else {
	                    return null;
	                }
	            }
	            else {
	                return null;
	            }
	        }
	        else {
	            return {
	                host,
	            };
	        }
	    }
	    else {
	        const splitPath = path.split(':');
	        /* Exactly one colon means that this is host:port. Zero colons means that
	         * there is no port. And multiple colons means that this is a bare IPv6
	         * address with no port */
	        if (splitPath.length === 2) {
	            if (NUMBER_REGEX.test(splitPath[1])) {
	                return {
	                    host: splitPath[0],
	                    port: +splitPath[1],
	                };
	            }
	            else {
	                return null;
	            }
	        }
	        else {
	            return {
	                host: path,
	            };
	        }
	    }
	}
	uriParser.splitHostPort = splitHostPort;
	function combineHostPort(hostPort) {
	    if (hostPort.port === undefined) {
	        return hostPort.host;
	    }
	    else {
	        // Only an IPv6 host should include a colon
	        if (hostPort.host.includes(':')) {
	            return `[${hostPort.host}]:${hostPort.port}`;
	        }
	        else {
	            return `${hostPort.host}:${hostPort.port}`;
	        }
	    }
	}
	uriParser.combineHostPort = combineHostPort;
	function uriToString(uri) {
	    let result = '';
	    if (uri.scheme !== undefined) {
	        result += uri.scheme + ':';
	    }
	    if (uri.authority !== undefined) {
	        result += '//' + uri.authority + '/';
	    }
	    result += uri.path;
	    return result;
	}
	uriParser.uriToString = uriToString;
	
	return uriParser;
}

var hasRequiredResolver;

function requireResolver () {
	if (hasRequiredResolver) return resolver;
	hasRequiredResolver = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(resolver, "__esModule", { value: true });
	resolver.mapUriDefaultScheme = resolver.getDefaultAuthority = resolver.createResolver = resolver.registerDefaultScheme = resolver.registerResolver = undefined;
	const uri_parser_1 = requireUriParser();
	const registeredResolvers = {};
	let defaultScheme = null;
	/**
	 * Register a resolver class to handle target names prefixed with the `prefix`
	 * string. This prefix should correspond to a URI scheme name listed in the
	 * [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)
	 * @param prefix
	 * @param resolverClass
	 */
	function registerResolver(scheme, resolverClass) {
	    registeredResolvers[scheme] = resolverClass;
	}
	resolver.registerResolver = registerResolver;
	/**
	 * Register a default resolver to handle target names that do not start with
	 * any registered prefix.
	 * @param resolverClass
	 */
	function registerDefaultScheme(scheme) {
	    defaultScheme = scheme;
	}
	resolver.registerDefaultScheme = registerDefaultScheme;
	/**
	 * Create a name resolver for the specified target, if possible. Throws an
	 * error if no such name resolver can be created.
	 * @param target
	 * @param listener
	 */
	function createResolver(target, listener, options) {
	    if (target.scheme !== undefined && target.scheme in registeredResolvers) {
	        return new registeredResolvers[target.scheme](target, listener, options);
	    }
	    else {
	        throw new Error(`No resolver could be created for target ${(0, uri_parser_1.uriToString)(target)}`);
	    }
	}
	resolver.createResolver = createResolver;
	/**
	 * Get the default authority for the specified target, if possible. Throws an
	 * error if no registered name resolver can parse that target string.
	 * @param target
	 */
	function getDefaultAuthority(target) {
	    if (target.scheme !== undefined && target.scheme in registeredResolvers) {
	        return registeredResolvers[target.scheme].getDefaultAuthority(target);
	    }
	    else {
	        throw new Error(`Invalid target ${(0, uri_parser_1.uriToString)(target)}`);
	    }
	}
	resolver.getDefaultAuthority = getDefaultAuthority;
	function mapUriDefaultScheme(target) {
	    if (target.scheme === undefined || !(target.scheme in registeredResolvers)) {
	        if (defaultScheme !== null) {
	            return {
	                scheme: defaultScheme,
	                authority: undefined,
	                path: (0, uri_parser_1.uriToString)(target),
	            };
	        }
	        else {
	            return null;
	        }
	    }
	    return target;
	}
	resolver.mapUriDefaultScheme = mapUriDefaultScheme;
	
	return resolver;
}

var picker = {};

var hasRequiredPicker;

function requirePicker () {
	if (hasRequiredPicker) return picker;
	hasRequiredPicker = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(picker, "__esModule", { value: true });
	picker.QueuePicker = picker.UnavailablePicker = picker.PickResultType = undefined;
	const metadata_1 = requireMetadata();
	const constants_1 = requireConstants();
	var PickResultType;
	(function (PickResultType) {
	    PickResultType[PickResultType["COMPLETE"] = 0] = "COMPLETE";
	    PickResultType[PickResultType["QUEUE"] = 1] = "QUEUE";
	    PickResultType[PickResultType["TRANSIENT_FAILURE"] = 2] = "TRANSIENT_FAILURE";
	    PickResultType[PickResultType["DROP"] = 3] = "DROP";
	})(PickResultType || (picker.PickResultType = PickResultType = {}));
	/**
	 * A standard picker representing a load balancer in the TRANSIENT_FAILURE
	 * state. Always responds to every pick request with an UNAVAILABLE status.
	 */
	class UnavailablePicker {
	    constructor(status) {
	        this.status = Object.assign({ code: constants_1.Status.UNAVAILABLE, details: 'No connection established', metadata: new metadata_1.Metadata() }, status);
	    }
	    pick(pickArgs) {
	        return {
	            pickResultType: PickResultType.TRANSIENT_FAILURE,
	            subchannel: null,
	            status: this.status,
	            onCallStarted: null,
	            onCallEnded: null,
	        };
	    }
	}
	picker.UnavailablePicker = UnavailablePicker;
	/**
	 * A standard picker representing a load balancer in the IDLE or CONNECTING
	 * state. Always responds to every pick request with a QUEUE pick result
	 * indicating that the pick should be tried again with the next `Picker`. Also
	 * reports back to the load balancer that a connection should be established
	 * once any pick is attempted.
	 * If the childPicker is provided, delegate to it instead of returning the
	 * hardcoded QUEUE pick result, but still calls exitIdle.
	 */
	class QueuePicker {
	    // Constructed with a load balancer. Calls exitIdle on it the first time pick is called
	    constructor(loadBalancer, childPicker) {
	        this.loadBalancer = loadBalancer;
	        this.childPicker = childPicker;
	        this.calledExitIdle = false;
	    }
	    pick(pickArgs) {
	        if (!this.calledExitIdle) {
	            process.nextTick(() => {
	                this.loadBalancer.exitIdle();
	            });
	            this.calledExitIdle = true;
	        }
	        if (this.childPicker) {
	            return this.childPicker.pick(pickArgs);
	        }
	        else {
	            return {
	                pickResultType: PickResultType.QUEUE,
	                subchannel: null,
	                status: null,
	                onCallStarted: null,
	                onCallEnded: null,
	            };
	        }
	    }
	}
	picker.QueuePicker = QueuePicker;
	
	return picker;
}

var backoffTimeout = {};

var hasRequiredBackoffTimeout;

function requireBackoffTimeout () {
	if (hasRequiredBackoffTimeout) return backoffTimeout;
	hasRequiredBackoffTimeout = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(backoffTimeout, "__esModule", { value: true });
	backoffTimeout.BackoffTimeout = undefined;
	const INITIAL_BACKOFF_MS = 1000;
	const BACKOFF_MULTIPLIER = 1.6;
	const MAX_BACKOFF_MS = 120000;
	const BACKOFF_JITTER = 0.2;
	/**
	 * Get a number uniformly at random in the range [min, max)
	 * @param min
	 * @param max
	 */
	function uniformRandom(min, max) {
	    return Math.random() * (max - min) + min;
	}
	class BackoffTimeout {
	    constructor(callback, options) {
	        this.callback = callback;
	        /**
	         * The delay time at the start, and after each reset.
	         */
	        this.initialDelay = INITIAL_BACKOFF_MS;
	        /**
	         * The exponential backoff multiplier.
	         */
	        this.multiplier = BACKOFF_MULTIPLIER;
	        /**
	         * The maximum delay time
	         */
	        this.maxDelay = MAX_BACKOFF_MS;
	        /**
	         * The maximum fraction by which the delay time can randomly vary after
	         * applying the multiplier.
	         */
	        this.jitter = BACKOFF_JITTER;
	        /**
	         * Indicates whether the timer is currently running.
	         */
	        this.running = false;
	        /**
	         * Indicates whether the timer should keep the Node process running if no
	         * other async operation is doing so.
	         */
	        this.hasRef = true;
	        /**
	         * The time that the currently running timer was started. Only valid if
	         * running is true.
	         */
	        this.startTime = new Date();
	        /**
	         * The approximate time that the currently running timer will end. Only valid
	         * if running is true.
	         */
	        this.endTime = new Date();
	        if (options) {
	            if (options.initialDelay) {
	                this.initialDelay = options.initialDelay;
	            }
	            if (options.multiplier) {
	                this.multiplier = options.multiplier;
	            }
	            if (options.jitter) {
	                this.jitter = options.jitter;
	            }
	            if (options.maxDelay) {
	                this.maxDelay = options.maxDelay;
	            }
	        }
	        this.nextDelay = this.initialDelay;
	        this.timerId = setTimeout(() => { }, 0);
	        clearTimeout(this.timerId);
	    }
	    runTimer(delay) {
	        var _a, _b;
	        this.endTime = this.startTime;
	        this.endTime.setMilliseconds(this.endTime.getMilliseconds() + this.nextDelay);
	        clearTimeout(this.timerId);
	        this.timerId = setTimeout(() => {
	            this.callback();
	            this.running = false;
	        }, delay);
	        if (!this.hasRef) {
	            (_b = (_a = this.timerId).unref) === null || _b === undefined ? undefined : _b.call(_a);
	        }
	    }
	    /**
	     * Call the callback after the current amount of delay time
	     */
	    runOnce() {
	        this.running = true;
	        this.startTime = new Date();
	        this.runTimer(this.nextDelay);
	        const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);
	        const jitterMagnitude = nextBackoff * this.jitter;
	        this.nextDelay =
	            nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);
	    }
	    /**
	     * Stop the timer. The callback will not be called until `runOnce` is called
	     * again.
	     */
	    stop() {
	        clearTimeout(this.timerId);
	        this.running = false;
	    }
	    /**
	     * Reset the delay time to its initial value. If the timer is still running,
	     * retroactively apply that reset to the current timer.
	     */
	    reset() {
	        this.nextDelay = this.initialDelay;
	        if (this.running) {
	            const now = new Date();
	            const newEndTime = this.startTime;
	            newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);
	            clearTimeout(this.timerId);
	            if (now < newEndTime) {
	                this.runTimer(newEndTime.getTime() - now.getTime());
	            }
	            else {
	                this.running = false;
	            }
	        }
	    }
	    /**
	     * Check whether the timer is currently running.
	     */
	    isRunning() {
	        return this.running;
	    }
	    /**
	     * Set that while the timer is running, it should keep the Node process
	     * running.
	     */
	    ref() {
	        var _a, _b;
	        this.hasRef = true;
	        (_b = (_a = this.timerId).ref) === null || _b === undefined ? undefined : _b.call(_a);
	    }
	    /**
	     * Set that while the timer is running, it should not keep the Node process
	     * running.
	     */
	    unref() {
	        var _a, _b;
	        this.hasRef = false;
	        (_b = (_a = this.timerId).unref) === null || _b === undefined ? undefined : _b.call(_a);
	    }
	    /**
	     * Get the approximate timestamp of when the timer will fire. Only valid if
	     * this.isRunning() is true.
	     */
	    getEndTime() {
	        return this.endTime;
	    }
	}
	backoffTimeout.BackoffTimeout = BackoffTimeout;
	
	return backoffTimeout;
}

var loadBalancerChildHandler = {};

var hasRequiredLoadBalancerChildHandler;

function requireLoadBalancerChildHandler () {
	if (hasRequiredLoadBalancerChildHandler) return loadBalancerChildHandler;
	hasRequiredLoadBalancerChildHandler = 1;
	/*
	 * Copyright 2020 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(loadBalancerChildHandler, "__esModule", { value: true });
	loadBalancerChildHandler.ChildLoadBalancerHandler = undefined;
	const load_balancer_1 = requireLoadBalancer();
	const connectivity_state_1 = requireConnectivityState();
	const TYPE_NAME = 'child_load_balancer_helper';
	class ChildLoadBalancerHandler {
	    constructor(channelControlHelper, credentials, options) {
	        this.channelControlHelper = channelControlHelper;
	        this.credentials = credentials;
	        this.options = options;
	        this.currentChild = null;
	        this.pendingChild = null;
	        this.latestConfig = null;
	        this.ChildPolicyHelper = class {
	            constructor(parent) {
	                this.parent = parent;
	                this.child = null;
	            }
	            createSubchannel(subchannelAddress, subchannelArgs, credentialsOverride) {
	                return this.parent.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs, credentialsOverride);
	            }
	            updateState(connectivityState, picker) {
	                var _a;
	                if (this.calledByPendingChild()) {
	                    if (connectivityState === connectivity_state_1.ConnectivityState.CONNECTING) {
	                        return;
	                    }
	                    (_a = this.parent.currentChild) === null || _a === undefined ? undefined : _a.destroy();
	                    this.parent.currentChild = this.parent.pendingChild;
	                    this.parent.pendingChild = null;
	                }
	                else if (!this.calledByCurrentChild()) {
	                    return;
	                }
	                this.parent.channelControlHelper.updateState(connectivityState, picker);
	            }
	            requestReresolution() {
	                var _a;
	                const latestChild = (_a = this.parent.pendingChild) !== null && _a !== undefined ? _a : this.parent.currentChild;
	                if (this.child === latestChild) {
	                    this.parent.channelControlHelper.requestReresolution();
	                }
	            }
	            setChild(newChild) {
	                this.child = newChild;
	            }
	            addChannelzChild(child) {
	                this.parent.channelControlHelper.addChannelzChild(child);
	            }
	            removeChannelzChild(child) {
	                this.parent.channelControlHelper.removeChannelzChild(child);
	            }
	            calledByPendingChild() {
	                return this.child === this.parent.pendingChild;
	            }
	            calledByCurrentChild() {
	                return this.child === this.parent.currentChild;
	            }
	        };
	    }
	    configUpdateRequiresNewPolicyInstance(oldConfig, newConfig) {
	        return oldConfig.getLoadBalancerName() !== newConfig.getLoadBalancerName();
	    }
	    /**
	     * Prerequisites: lbConfig !== null and lbConfig.name is registered
	     * @param endpointList
	     * @param lbConfig
	     * @param attributes
	     */
	    updateAddressList(endpointList, lbConfig, attributes) {
	        let childToUpdate;
	        if (this.currentChild === null ||
	            this.latestConfig === null ||
	            this.configUpdateRequiresNewPolicyInstance(this.latestConfig, lbConfig)) {
	            const newHelper = new this.ChildPolicyHelper(this);
	            const newChild = (0, load_balancer_1.createLoadBalancer)(lbConfig, newHelper, this.credentials, this.options);
	            newHelper.setChild(newChild);
	            if (this.currentChild === null) {
	                this.currentChild = newChild;
	                childToUpdate = this.currentChild;
	            }
	            else {
	                if (this.pendingChild) {
	                    this.pendingChild.destroy();
	                }
	                this.pendingChild = newChild;
	                childToUpdate = this.pendingChild;
	            }
	        }
	        else {
	            if (this.pendingChild === null) {
	                childToUpdate = this.currentChild;
	            }
	            else {
	                childToUpdate = this.pendingChild;
	            }
	        }
	        this.latestConfig = lbConfig;
	        childToUpdate.updateAddressList(endpointList, lbConfig, attributes);
	    }
	    exitIdle() {
	        if (this.currentChild) {
	            this.currentChild.exitIdle();
	            if (this.pendingChild) {
	                this.pendingChild.exitIdle();
	            }
	        }
	    }
	    resetBackoff() {
	        if (this.currentChild) {
	            this.currentChild.resetBackoff();
	            if (this.pendingChild) {
	                this.pendingChild.resetBackoff();
	            }
	        }
	    }
	    destroy() {
	        /* Note: state updates are only propagated from the child balancer if that
	         * object is equal to this.currentChild or this.pendingChild. Since this
	         * function sets both of those to null, no further state updates will
	         * occur after this function returns. */
	        if (this.currentChild) {
	            this.currentChild.destroy();
	            this.currentChild = null;
	        }
	        if (this.pendingChild) {
	            this.pendingChild.destroy();
	            this.pendingChild = null;
	        }
	    }
	    getTypeName() {
	        return TYPE_NAME;
	    }
	}
	loadBalancerChildHandler.ChildLoadBalancerHandler = ChildLoadBalancerHandler;
	
	return loadBalancerChildHandler;
}

var hasRequiredResolvingLoadBalancer;

function requireResolvingLoadBalancer () {
	if (hasRequiredResolvingLoadBalancer) return resolvingLoadBalancer;
	hasRequiredResolvingLoadBalancer = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(resolvingLoadBalancer, "__esModule", { value: true });
	resolvingLoadBalancer.ResolvingLoadBalancer = undefined;
	const load_balancer_1 = requireLoadBalancer();
	const service_config_1 = requireServiceConfig();
	const connectivity_state_1 = requireConnectivityState();
	const resolver_1 = requireResolver();
	const picker_1 = requirePicker();
	const backoff_timeout_1 = requireBackoffTimeout();
	const constants_1 = requireConstants();
	const metadata_1 = requireMetadata();
	const logging = requireLogging();
	const constants_2 = requireConstants();
	const uri_parser_1 = requireUriParser();
	const load_balancer_child_handler_1 = requireLoadBalancerChildHandler();
	const TRACER_NAME = 'resolving_load_balancer';
	function trace(text) {
	    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);
	}
	/**
	 * Name match levels in order from most to least specific. This is the order in
	 * which searches will be performed.
	 */
	const NAME_MATCH_LEVEL_ORDER = [
	    'SERVICE_AND_METHOD',
	    'SERVICE',
	    'EMPTY',
	];
	function hasMatchingName(service, method, methodConfig, matchLevel) {
	    for (const name of methodConfig.name) {
	        switch (matchLevel) {
	            case 'EMPTY':
	                if (!name.service && !name.method) {
	                    return true;
	                }
	                break;
	            case 'SERVICE':
	                if (name.service === service && !name.method) {
	                    return true;
	                }
	                break;
	            case 'SERVICE_AND_METHOD':
	                if (name.service === service && name.method === method) {
	                    return true;
	                }
	        }
	    }
	    return false;
	}
	function findMatchingConfig(service, method, methodConfigs, matchLevel) {
	    for (const config of methodConfigs) {
	        if (hasMatchingName(service, method, config, matchLevel)) {
	            return config;
	        }
	    }
	    return null;
	}
	function getDefaultConfigSelector(serviceConfig) {
	    return function defaultConfigSelector(methodName, metadata) {
	        var _a, _b;
	        const splitName = methodName.split('/').filter(x => x.length > 0);
	        const service = (_a = splitName[0]) !== null && _a !== undefined ? _a : '';
	        const method = (_b = splitName[1]) !== null && _b !== undefined ? _b : '';
	        if (serviceConfig && serviceConfig.methodConfig) {
	            /* Check for the following in order, and return the first method
	             * config that matches:
	             * 1. A name that exactly matches the service and method
	             * 2. A name with no method set that matches the service
	             * 3. An empty name
	             */
	            for (const matchLevel of NAME_MATCH_LEVEL_ORDER) {
	                const matchingConfig = findMatchingConfig(service, method, serviceConfig.methodConfig, matchLevel);
	                if (matchingConfig) {
	                    return {
	                        methodConfig: matchingConfig,
	                        pickInformation: {},
	                        status: constants_1.Status.OK,
	                        dynamicFilterFactories: [],
	                    };
	                }
	            }
	        }
	        return {
	            methodConfig: { name: [] },
	            pickInformation: {},
	            status: constants_1.Status.OK,
	            dynamicFilterFactories: [],
	        };
	    };
	}
	class ResolvingLoadBalancer {
	    /**
	     * Wrapper class that behaves like a `LoadBalancer` and also handles name
	     * resolution internally.
	     * @param target The address of the backend to connect to.
	     * @param channelControlHelper `ChannelControlHelper` instance provided by
	     *     this load balancer's owner.
	     * @param defaultServiceConfig The default service configuration to be used
	     *     if none is provided by the name resolver. A `null` value indicates
	     *     that the default behavior should be the default unconfigured behavior.
	     *     In practice, that means using the "pick first" load balancer
	     *     implmentation
	     */
	    constructor(target, channelControlHelper, credentials, channelOptions, onSuccessfulResolution, onFailedResolution) {
	        this.target = target;
	        this.channelControlHelper = channelControlHelper;
	        this.onSuccessfulResolution = onSuccessfulResolution;
	        this.onFailedResolution = onFailedResolution;
	        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;
	        this.latestChildPicker = new picker_1.QueuePicker(this);
	        /**
	         * This resolving load balancer's current connectivity state.
	         */
	        this.currentState = connectivity_state_1.ConnectivityState.IDLE;
	        /**
	         * The service config object from the last successful resolution, if
	         * available. A value of null indicates that we have not yet received a valid
	         * service config from the resolver.
	         */
	        this.previousServiceConfig = null;
	        /**
	         * Indicates whether we should attempt to resolve again after the backoff
	         * timer runs out.
	         */
	        this.continueResolving = false;
	        if (channelOptions['grpc.service_config']) {
	            this.defaultServiceConfig = (0, service_config_1.validateServiceConfig)(JSON.parse(channelOptions['grpc.service_config']));
	        }
	        else {
	            this.defaultServiceConfig = {
	                loadBalancingConfig: [],
	                methodConfig: [],
	            };
	        }
	        this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
	        this.childLoadBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler({
	            createSubchannel: channelControlHelper.createSubchannel.bind(channelControlHelper),
	            requestReresolution: () => {
	                /* If the backoffTimeout is running, we're still backing off from
	                 * making resolve requests, so we shouldn't make another one here.
	                 * In that case, the backoff timer callback will call
	                 * updateResolution */
	                if (this.backoffTimeout.isRunning()) {
	                    trace('requestReresolution delayed by backoff timer until ' +
	                        this.backoffTimeout.getEndTime().toISOString());
	                    this.continueResolving = true;
	                }
	                else {
	                    this.updateResolution();
	                }
	            },
	            updateState: (newState, picker) => {
	                this.latestChildState = newState;
	                this.latestChildPicker = picker;
	                this.updateState(newState, picker);
	            },
	            addChannelzChild: channelControlHelper.addChannelzChild.bind(channelControlHelper),
	            removeChannelzChild: channelControlHelper.removeChannelzChild.bind(channelControlHelper),
	        }, credentials, channelOptions);
	        this.innerResolver = (0, resolver_1.createResolver)(target, {
	            onSuccessfulResolution: (endpointList, serviceConfig, serviceConfigError, configSelector, attributes) => {
	                var _a;
	                this.backoffTimeout.stop();
	                this.backoffTimeout.reset();
	                let workingServiceConfig = null;
	                /* This first group of conditionals implements the algorithm described
	                 * in https://github.com/grpc/proposal/blob/master/A21-service-config-error-handling.md
	                 * in the section called "Behavior on receiving a new gRPC Config".
	                 */
	                if (serviceConfig === null) {
	                    // Step 4 and 5
	                    if (serviceConfigError === null) {
	                        // Step 5
	                        this.previousServiceConfig = null;
	                        workingServiceConfig = this.defaultServiceConfig;
	                    }
	                    else {
	                        // Step 4
	                        if (this.previousServiceConfig === null) {
	                            // Step 4.ii
	                            this.handleResolutionFailure(serviceConfigError);
	                        }
	                        else {
	                            // Step 4.i
	                            workingServiceConfig = this.previousServiceConfig;
	                        }
	                    }
	                }
	                else {
	                    // Step 3
	                    workingServiceConfig = serviceConfig;
	                    this.previousServiceConfig = serviceConfig;
	                }
	                const workingConfigList = (_a = workingServiceConfig === null || workingServiceConfig === undefined ? undefined : workingServiceConfig.loadBalancingConfig) !== null && _a !== undefined ? _a : [];
	                const loadBalancingConfig = (0, load_balancer_1.selectLbConfigFromList)(workingConfigList, true);
	                if (loadBalancingConfig === null) {
	                    // There were load balancing configs but none are supported. This counts as a resolution failure
	                    this.handleResolutionFailure({
	                        code: constants_1.Status.UNAVAILABLE,
	                        details: 'All load balancer options in service config are not compatible',
	                        metadata: new metadata_1.Metadata(),
	                    });
	                    return;
	                }
	                this.childLoadBalancer.updateAddressList(endpointList, loadBalancingConfig, attributes);
	                const finalServiceConfig = workingServiceConfig !== null && workingServiceConfig !== undefined ? workingServiceConfig : this.defaultServiceConfig;
	                this.onSuccessfulResolution(finalServiceConfig, configSelector !== null && configSelector !== undefined ? configSelector : getDefaultConfigSelector(finalServiceConfig));
	            },
	            onError: (error) => {
	                this.handleResolutionFailure(error);
	            },
	        }, channelOptions);
	        const backoffOptions = {
	            initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],
	            maxDelay: channelOptions['grpc.max_reconnect_backoff_ms'],
	        };
	        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {
	            if (this.continueResolving) {
	                this.updateResolution();
	                this.continueResolving = false;
	            }
	            else {
	                this.updateState(this.latestChildState, this.latestChildPicker);
	            }
	        }, backoffOptions);
	        this.backoffTimeout.unref();
	    }
	    updateResolution() {
	        this.innerResolver.updateResolution();
	        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {
	            /* this.latestChildPicker is initialized as new QueuePicker(this), which
	             * is an appropriate value here if the child LB policy is unset.
	             * Otherwise, we want to delegate to the child here, in case that
	             * triggers something. */
	            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, this.latestChildPicker);
	        }
	        this.backoffTimeout.runOnce();
	    }
	    updateState(connectivityState, picker) {
	        trace((0, uri_parser_1.uriToString)(this.target) +
	            ' ' +
	            connectivity_state_1.ConnectivityState[this.currentState] +
	            ' -> ' +
	            connectivity_state_1.ConnectivityState[connectivityState]);
	        // Ensure that this.exitIdle() is called by the picker
	        if (connectivityState === connectivity_state_1.ConnectivityState.IDLE) {
	            picker = new picker_1.QueuePicker(this, picker);
	        }
	        this.currentState = connectivityState;
	        this.channelControlHelper.updateState(connectivityState, picker);
	    }
	    handleResolutionFailure(error) {
	        if (this.latestChildState === connectivity_state_1.ConnectivityState.IDLE) {
	            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error));
	            this.onFailedResolution(error);
	        }
	    }
	    exitIdle() {
	        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE ||
	            this.currentState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
	            if (this.backoffTimeout.isRunning()) {
	                this.continueResolving = true;
	            }
	            else {
	                this.updateResolution();
	            }
	        }
	        this.childLoadBalancer.exitIdle();
	    }
	    updateAddressList(endpointList, lbConfig) {
	        throw new Error('updateAddressList not supported on ResolvingLoadBalancer');
	    }
	    resetBackoff() {
	        this.backoffTimeout.reset();
	        this.childLoadBalancer.resetBackoff();
	    }
	    destroy() {
	        this.childLoadBalancer.destroy();
	        this.innerResolver.destroy();
	        this.backoffTimeout.reset();
	        this.backoffTimeout.stop();
	        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;
	        this.latestChildPicker = new picker_1.QueuePicker(this);
	        this.currentState = connectivity_state_1.ConnectivityState.IDLE;
	        this.previousServiceConfig = null;
	        this.continueResolving = false;
	    }
	    getTypeName() {
	        return 'resolving_load_balancer';
	    }
	}
	resolvingLoadBalancer.ResolvingLoadBalancer = ResolvingLoadBalancer;
	
	return resolvingLoadBalancer;
}

var subchannelPool = {};

var channelOptions = {};

var hasRequiredChannelOptions;

function requireChannelOptions () {
	if (hasRequiredChannelOptions) return channelOptions;
	hasRequiredChannelOptions = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(channelOptions, "__esModule", { value: true });
	channelOptions.channelOptionsEqual = channelOptions.recognizedOptions = undefined;
	/**
	 * This is for checking provided options at runtime. This is an object for
	 * easier membership checking.
	 */
	channelOptions.recognizedOptions = {
	    'grpc.ssl_target_name_override': true,
	    'grpc.primary_user_agent': true,
	    'grpc.secondary_user_agent': true,
	    'grpc.default_authority': true,
	    'grpc.keepalive_time_ms': true,
	    'grpc.keepalive_timeout_ms': true,
	    'grpc.keepalive_permit_without_calls': true,
	    'grpc.service_config': true,
	    'grpc.max_concurrent_streams': true,
	    'grpc.initial_reconnect_backoff_ms': true,
	    'grpc.max_reconnect_backoff_ms': true,
	    'grpc.use_local_subchannel_pool': true,
	    'grpc.max_send_message_length': true,
	    'grpc.max_receive_message_length': true,
	    'grpc.enable_http_proxy': true,
	    'grpc.enable_channelz': true,
	    'grpc.dns_min_time_between_resolutions_ms': true,
	    'grpc.enable_retries': true,
	    'grpc.per_rpc_retry_buffer_size': true,
	    'grpc.retry_buffer_size': true,
	    'grpc.max_connection_age_ms': true,
	    'grpc.max_connection_age_grace_ms': true,
	    'grpc-node.max_session_memory': true,
	    'grpc.service_config_disable_resolution': true,
	    'grpc.client_idle_timeout_ms': true,
	    'grpc-node.tls_enable_trace': true,
	    'grpc.lb.ring_hash.ring_size_cap': true,
	    'grpc-node.retry_max_attempts_limit': true,
	};
	function channelOptionsEqual(options1, options2) {
	    const keys1 = Object.keys(options1).sort();
	    const keys2 = Object.keys(options2).sort();
	    if (keys1.length !== keys2.length) {
	        return false;
	    }
	    for (let i = 0; i < keys1.length; i += 1) {
	        if (keys1[i] !== keys2[i]) {
	            return false;
	        }
	        if (options1[keys1[i]] !== options2[keys2[i]]) {
	            return false;
	        }
	    }
	    return true;
	}
	channelOptions.channelOptionsEqual = channelOptionsEqual;
	
	return channelOptions;
}

var subchannel = {};

var subchannelAddress = {};

var hasRequiredSubchannelAddress;

function requireSubchannelAddress () {
	if (hasRequiredSubchannelAddress) return subchannelAddress;
	hasRequiredSubchannelAddress = 1;
	/*
	 * Copyright 2021 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(subchannelAddress, "__esModule", { value: true });
	subchannelAddress.EndpointMap = subchannelAddress.endpointHasAddress = subchannelAddress.endpointToString = subchannelAddress.endpointEqual = subchannelAddress.stringToSubchannelAddress = subchannelAddress.subchannelAddressToString = subchannelAddress.subchannelAddressEqual = subchannelAddress.isTcpSubchannelAddress = undefined;
	const net_1 = require$$0$2;
	function isTcpSubchannelAddress(address) {
	    return 'port' in address;
	}
	subchannelAddress.isTcpSubchannelAddress = isTcpSubchannelAddress;
	function subchannelAddressEqual(address1, address2) {
	    if (!address1 && !address2) {
	        return true;
	    }
	    if (!address1 || !address2) {
	        return false;
	    }
	    if (isTcpSubchannelAddress(address1)) {
	        return (isTcpSubchannelAddress(address2) &&
	            address1.host === address2.host &&
	            address1.port === address2.port);
	    }
	    else {
	        return !isTcpSubchannelAddress(address2) && address1.path === address2.path;
	    }
	}
	subchannelAddress.subchannelAddressEqual = subchannelAddressEqual;
	function subchannelAddressToString(address) {
	    if (isTcpSubchannelAddress(address)) {
	        if ((0, net_1.isIPv6)(address.host)) {
	            return '[' + address.host + ']:' + address.port;
	        }
	        else {
	            return address.host + ':' + address.port;
	        }
	    }
	    else {
	        return address.path;
	    }
	}
	subchannelAddress.subchannelAddressToString = subchannelAddressToString;
	const DEFAULT_PORT = 443;
	function stringToSubchannelAddress(addressString, port) {
	    if ((0, net_1.isIP)(addressString)) {
	        return {
	            host: addressString,
	            port: port !== null && port !== undefined ? port : DEFAULT_PORT,
	        };
	    }
	    else {
	        return {
	            path: addressString,
	        };
	    }
	}
	subchannelAddress.stringToSubchannelAddress = stringToSubchannelAddress;
	function endpointEqual(endpoint1, endpoint2) {
	    if (endpoint1.addresses.length !== endpoint2.addresses.length) {
	        return false;
	    }
	    for (let i = 0; i < endpoint1.addresses.length; i++) {
	        if (!subchannelAddressEqual(endpoint1.addresses[i], endpoint2.addresses[i])) {
	            return false;
	        }
	    }
	    return true;
	}
	subchannelAddress.endpointEqual = endpointEqual;
	function endpointToString(endpoint) {
	    return ('[' + endpoint.addresses.map(subchannelAddressToString).join(', ') + ']');
	}
	subchannelAddress.endpointToString = endpointToString;
	function endpointHasAddress(endpoint, expectedAddress) {
	    for (const address of endpoint.addresses) {
	        if (subchannelAddressEqual(address, expectedAddress)) {
	            return true;
	        }
	    }
	    return false;
	}
	subchannelAddress.endpointHasAddress = endpointHasAddress;
	function endpointEqualUnordered(endpoint1, endpoint2) {
	    if (endpoint1.addresses.length !== endpoint2.addresses.length) {
	        return false;
	    }
	    for (const address1 of endpoint1.addresses) {
	        let matchFound = false;
	        for (const address2 of endpoint2.addresses) {
	            if (subchannelAddressEqual(address1, address2)) {
	                matchFound = true;
	                break;
	            }
	        }
	        if (!matchFound) {
	            return false;
	        }
	    }
	    return true;
	}
	class EndpointMap {
	    constructor() {
	        this.map = new Set();
	    }
	    get size() {
	        return this.map.size;
	    }
	    getForSubchannelAddress(address) {
	        for (const entry of this.map) {
	            if (endpointHasAddress(entry.key, address)) {
	                return entry.value;
	            }
	        }
	        return undefined;
	    }
	    /**
	     * Delete any entries in this map with keys that are not in endpoints
	     * @param endpoints
	     */
	    deleteMissing(endpoints) {
	        const removedValues = [];
	        for (const entry of this.map) {
	            let foundEntry = false;
	            for (const endpoint of endpoints) {
	                if (endpointEqualUnordered(endpoint, entry.key)) {
	                    foundEntry = true;
	                }
	            }
	            if (!foundEntry) {
	                removedValues.push(entry.value);
	                this.map.delete(entry);
	            }
	        }
	        return removedValues;
	    }
	    get(endpoint) {
	        for (const entry of this.map) {
	            if (endpointEqualUnordered(endpoint, entry.key)) {
	                return entry.value;
	            }
	        }
	        return undefined;
	    }
	    set(endpoint, mapEntry) {
	        for (const entry of this.map) {
	            if (endpointEqualUnordered(endpoint, entry.key)) {
	                entry.value = mapEntry;
	                return;
	            }
	        }
	        this.map.add({ key: endpoint, value: mapEntry });
	    }
	    delete(endpoint) {
	        for (const entry of this.map) {
	            if (endpointEqualUnordered(endpoint, entry.key)) {
	                this.map.delete(entry);
	                return;
	            }
	        }
	    }
	    has(endpoint) {
	        for (const entry of this.map) {
	            if (endpointEqualUnordered(endpoint, entry.key)) {
	                return true;
	            }
	        }
	        return false;
	    }
	    clear() {
	        this.map.clear();
	    }
	    *keys() {
	        for (const entry of this.map) {
	            yield entry.key;
	        }
	    }
	    *values() {
	        for (const entry of this.map) {
	            yield entry.value;
	        }
	    }
	    *entries() {
	        for (const entry of this.map) {
	            yield [entry.key, entry.value];
	        }
	    }
	}
	subchannelAddress.EndpointMap = EndpointMap;
	
	return subchannelAddress;
}

var channelz = {};

var cjs = {};

var hasRequiredCjs;

function requireCjs () {
	if (hasRequiredCjs) return cjs;
	hasRequiredCjs = 1;
	(function (exports) {

		Object.defineProperty(exports, "t", {
		    value: true
		});

		class TreeNode {
		    constructor(t, e, s = 1) {
		        this.i = undefined;
		        this.h = undefined;
		        this.o = undefined;
		        this.u = t;
		        this.l = e;
		        this.p = s;
		    }
		    I() {
		        let t = this;
		        const e = t.o.o === t;
		        if (e && t.p === 1) {
		            t = t.h;
		        } else if (t.i) {
		            t = t.i;
		            while (t.h) {
		                t = t.h;
		            }
		        } else {
		            if (e) {
		                return t.o;
		            }
		            let s = t.o;
		            while (s.i === t) {
		                t = s;
		                s = t.o;
		            }
		            t = s;
		        }
		        return t;
		    }
		    B() {
		        let t = this;
		        if (t.h) {
		            t = t.h;
		            while (t.i) {
		                t = t.i;
		            }
		            return t;
		        } else {
		            let e = t.o;
		            while (e.h === t) {
		                t = e;
		                e = t.o;
		            }
		            if (t.h !== e) {
		                return e;
		            } else return t;
		        }
		    }
		    _() {
		        const t = this.o;
		        const e = this.h;
		        const s = e.i;
		        if (t.o === this) t.o = e; else if (t.i === this) t.i = e; else t.h = e;
		        e.o = t;
		        e.i = this;
		        this.o = e;
		        this.h = s;
		        if (s) s.o = this;
		        return e;
		    }
		    g() {
		        const t = this.o;
		        const e = this.i;
		        const s = e.h;
		        if (t.o === this) t.o = e; else if (t.i === this) t.i = e; else t.h = e;
		        e.o = t;
		        e.h = this;
		        this.o = e;
		        this.i = s;
		        if (s) s.o = this;
		        return e;
		    }
		}

		class TreeNodeEnableIndex extends TreeNode {
		    constructor() {
		        super(...arguments);
		        this.M = 1;
		    }
		    _() {
		        const t = super._();
		        this.O();
		        t.O();
		        return t;
		    }
		    g() {
		        const t = super.g();
		        this.O();
		        t.O();
		        return t;
		    }
		    O() {
		        this.M = 1;
		        if (this.i) {
		            this.M += this.i.M;
		        }
		        if (this.h) {
		            this.M += this.h.M;
		        }
		    }
		}

		class ContainerIterator {
		    constructor(t = 0) {
		        this.iteratorType = t;
		    }
		    equals(t) {
		        return this.T === t.T;
		    }
		}

		class Base {
		    constructor() {
		        this.m = 0;
		    }
		    get length() {
		        return this.m;
		    }
		    size() {
		        return this.m;
		    }
		    empty() {
		        return this.m === 0;
		    }
		}

		class Container extends Base {}

		function throwIteratorAccessError() {
		    throw new RangeError("Iterator access denied!");
		}

		class TreeContainer extends Container {
		    constructor(t = function(t, e) {
		        if (t < e) return -1;
		        if (t > e) return 1;
		        return 0;
		    }, e = false) {
		        super();
		        this.v = undefined;
		        this.A = t;
		        this.enableIndex = e;
		        this.N = e ? TreeNodeEnableIndex : TreeNode;
		        this.C = new this.N;
		    }
		    R(t, e) {
		        let s = this.C;
		        while (t) {
		            const i = this.A(t.u, e);
		            if (i < 0) {
		                t = t.h;
		            } else if (i > 0) {
		                s = t;
		                t = t.i;
		            } else return t;
		        }
		        return s;
		    }
		    K(t, e) {
		        let s = this.C;
		        while (t) {
		            const i = this.A(t.u, e);
		            if (i <= 0) {
		                t = t.h;
		            } else {
		                s = t;
		                t = t.i;
		            }
		        }
		        return s;
		    }
		    L(t, e) {
		        let s = this.C;
		        while (t) {
		            const i = this.A(t.u, e);
		            if (i < 0) {
		                s = t;
		                t = t.h;
		            } else if (i > 0) {
		                t = t.i;
		            } else return t;
		        }
		        return s;
		    }
		    k(t, e) {
		        let s = this.C;
		        while (t) {
		            const i = this.A(t.u, e);
		            if (i < 0) {
		                s = t;
		                t = t.h;
		            } else {
		                t = t.i;
		            }
		        }
		        return s;
		    }
		    P(t) {
		        while (true) {
		            const e = t.o;
		            if (e === this.C) return;
		            if (t.p === 1) {
		                t.p = 0;
		                return;
		            }
		            if (t === e.i) {
		                const s = e.h;
		                if (s.p === 1) {
		                    s.p = 0;
		                    e.p = 1;
		                    if (e === this.v) {
		                        this.v = e._();
		                    } else e._();
		                } else {
		                    if (s.h && s.h.p === 1) {
		                        s.p = e.p;
		                        e.p = 0;
		                        s.h.p = 0;
		                        if (e === this.v) {
		                            this.v = e._();
		                        } else e._();
		                        return;
		                    } else if (s.i && s.i.p === 1) {
		                        s.p = 1;
		                        s.i.p = 0;
		                        s.g();
		                    } else {
		                        s.p = 1;
		                        t = e;
		                    }
		                }
		            } else {
		                const s = e.i;
		                if (s.p === 1) {
		                    s.p = 0;
		                    e.p = 1;
		                    if (e === this.v) {
		                        this.v = e.g();
		                    } else e.g();
		                } else {
		                    if (s.i && s.i.p === 1) {
		                        s.p = e.p;
		                        e.p = 0;
		                        s.i.p = 0;
		                        if (e === this.v) {
		                            this.v = e.g();
		                        } else e.g();
		                        return;
		                    } else if (s.h && s.h.p === 1) {
		                        s.p = 1;
		                        s.h.p = 0;
		                        s._();
		                    } else {
		                        s.p = 1;
		                        t = e;
		                    }
		                }
		            }
		        }
		    }
		    S(t) {
		        if (this.m === 1) {
		            this.clear();
		            return;
		        }
		        let e = t;
		        while (e.i || e.h) {
		            if (e.h) {
		                e = e.h;
		                while (e.i) e = e.i;
		            } else {
		                e = e.i;
		            }
		            const s = t.u;
		            t.u = e.u;
		            e.u = s;
		            const i = t.l;
		            t.l = e.l;
		            e.l = i;
		            t = e;
		        }
		        if (this.C.i === e) {
		            this.C.i = e.o;
		        } else if (this.C.h === e) {
		            this.C.h = e.o;
		        }
		        this.P(e);
		        let s = e.o;
		        if (e === s.i) {
		            s.i = undefined;
		        } else s.h = undefined;
		        this.m -= 1;
		        this.v.p = 0;
		        if (this.enableIndex) {
		            while (s !== this.C) {
		                s.M -= 1;
		                s = s.o;
		            }
		        }
		    }
		    U(t) {
		        const e = typeof t === "number" ? t : undefined;
		        const s = typeof t === "function" ? t : undefined;
		        const i = typeof t === "undefined" ? [] : undefined;
		        let r = 0;
		        let n = this.v;
		        const h = [];
		        while (h.length || n) {
		            if (n) {
		                h.push(n);
		                n = n.i;
		            } else {
		                n = h.pop();
		                if (r === e) return n;
		                i && i.push(n);
		                s && s(n, r, this);
		                r += 1;
		                n = n.h;
		            }
		        }
		        return i;
		    }
		    j(t) {
		        while (true) {
		            const e = t.o;
		            if (e.p === 0) return;
		            const s = e.o;
		            if (e === s.i) {
		                const i = s.h;
		                if (i && i.p === 1) {
		                    i.p = e.p = 0;
		                    if (s === this.v) return;
		                    s.p = 1;
		                    t = s;
		                    continue;
		                } else if (t === e.h) {
		                    t.p = 0;
		                    if (t.i) {
		                        t.i.o = e;
		                    }
		                    if (t.h) {
		                        t.h.o = s;
		                    }
		                    e.h = t.i;
		                    s.i = t.h;
		                    t.i = e;
		                    t.h = s;
		                    if (s === this.v) {
		                        this.v = t;
		                        this.C.o = t;
		                    } else {
		                        const e = s.o;
		                        if (e.i === s) {
		                            e.i = t;
		                        } else e.h = t;
		                    }
		                    t.o = s.o;
		                    e.o = t;
		                    s.o = t;
		                    s.p = 1;
		                } else {
		                    e.p = 0;
		                    if (s === this.v) {
		                        this.v = s.g();
		                    } else s.g();
		                    s.p = 1;
		                    return;
		                }
		            } else {
		                const i = s.i;
		                if (i && i.p === 1) {
		                    i.p = e.p = 0;
		                    if (s === this.v) return;
		                    s.p = 1;
		                    t = s;
		                    continue;
		                } else if (t === e.i) {
		                    t.p = 0;
		                    if (t.i) {
		                        t.i.o = s;
		                    }
		                    if (t.h) {
		                        t.h.o = e;
		                    }
		                    s.h = t.i;
		                    e.i = t.h;
		                    t.i = s;
		                    t.h = e;
		                    if (s === this.v) {
		                        this.v = t;
		                        this.C.o = t;
		                    } else {
		                        const e = s.o;
		                        if (e.i === s) {
		                            e.i = t;
		                        } else e.h = t;
		                    }
		                    t.o = s.o;
		                    e.o = t;
		                    s.o = t;
		                    s.p = 1;
		                } else {
		                    e.p = 0;
		                    if (s === this.v) {
		                        this.v = s._();
		                    } else s._();
		                    s.p = 1;
		                    return;
		                }
		            }
		            if (this.enableIndex) {
		                e.O();
		                s.O();
		                t.O();
		            }
		            return;
		        }
		    }
		    q(t, e, s) {
		        if (this.v === undefined) {
		            this.m += 1;
		            this.v = new this.N(t, e, 0);
		            this.v.o = this.C;
		            this.C.o = this.C.i = this.C.h = this.v;
		            return this.m;
		        }
		        let i;
		        const r = this.C.i;
		        const n = this.A(r.u, t);
		        if (n === 0) {
		            r.l = e;
		            return this.m;
		        } else if (n > 0) {
		            r.i = new this.N(t, e);
		            r.i.o = r;
		            i = r.i;
		            this.C.i = i;
		        } else {
		            const r = this.C.h;
		            const n = this.A(r.u, t);
		            if (n === 0) {
		                r.l = e;
		                return this.m;
		            } else if (n < 0) {
		                r.h = new this.N(t, e);
		                r.h.o = r;
		                i = r.h;
		                this.C.h = i;
		            } else {
		                if (s !== undefined) {
		                    const r = s.T;
		                    if (r !== this.C) {
		                        const s = this.A(r.u, t);
		                        if (s === 0) {
		                            r.l = e;
		                            return this.m;
		                        } else if (s > 0) {
		                            const s = r.I();
		                            const n = this.A(s.u, t);
		                            if (n === 0) {
		                                s.l = e;
		                                return this.m;
		                            } else if (n < 0) {
		                                i = new this.N(t, e);
		                                if (s.h === undefined) {
		                                    s.h = i;
		                                    i.o = s;
		                                } else {
		                                    r.i = i;
		                                    i.o = r;
		                                }
		                            }
		                        }
		                    }
		                }
		                if (i === undefined) {
		                    i = this.v;
		                    while (true) {
		                        const s = this.A(i.u, t);
		                        if (s > 0) {
		                            if (i.i === undefined) {
		                                i.i = new this.N(t, e);
		                                i.i.o = i;
		                                i = i.i;
		                                break;
		                            }
		                            i = i.i;
		                        } else if (s < 0) {
		                            if (i.h === undefined) {
		                                i.h = new this.N(t, e);
		                                i.h.o = i;
		                                i = i.h;
		                                break;
		                            }
		                            i = i.h;
		                        } else {
		                            i.l = e;
		                            return this.m;
		                        }
		                    }
		                }
		            }
		        }
		        if (this.enableIndex) {
		            let t = i.o;
		            while (t !== this.C) {
		                t.M += 1;
		                t = t.o;
		            }
		        }
		        this.j(i);
		        this.m += 1;
		        return this.m;
		    }
		    H(t, e) {
		        while (t) {
		            const s = this.A(t.u, e);
		            if (s < 0) {
		                t = t.h;
		            } else if (s > 0) {
		                t = t.i;
		            } else return t;
		        }
		        return t || this.C;
		    }
		    clear() {
		        this.m = 0;
		        this.v = undefined;
		        this.C.o = undefined;
		        this.C.i = this.C.h = undefined;
		    }
		    updateKeyByIterator(t, e) {
		        const s = t.T;
		        if (s === this.C) {
		            throwIteratorAccessError();
		        }
		        if (this.m === 1) {
		            s.u = e;
		            return true;
		        }
		        const i = s.B().u;
		        if (s === this.C.i) {
		            if (this.A(i, e) > 0) {
		                s.u = e;
		                return true;
		            }
		            return false;
		        }
		        const r = s.I().u;
		        if (s === this.C.h) {
		            if (this.A(r, e) < 0) {
		                s.u = e;
		                return true;
		            }
		            return false;
		        }
		        if (this.A(r, e) >= 0 || this.A(i, e) <= 0) return false;
		        s.u = e;
		        return true;
		    }
		    eraseElementByPos(t) {
		        if (t < 0 || t > this.m - 1) {
		            throw new RangeError;
		        }
		        const e = this.U(t);
		        this.S(e);
		        return this.m;
		    }
		    eraseElementByKey(t) {
		        if (this.m === 0) return false;
		        const e = this.H(this.v, t);
		        if (e === this.C) return false;
		        this.S(e);
		        return true;
		    }
		    eraseElementByIterator(t) {
		        const e = t.T;
		        if (e === this.C) {
		            throwIteratorAccessError();
		        }
		        const s = e.h === undefined;
		        const i = t.iteratorType === 0;
		        if (i) {
		            if (s) t.next();
		        } else {
		            if (!s || e.i === undefined) t.next();
		        }
		        this.S(e);
		        return t;
		    }
		    getHeight() {
		        if (this.m === 0) return 0;
		        function traversal(t) {
		            if (!t) return 0;
		            return Math.max(traversal(t.i), traversal(t.h)) + 1;
		        }
		        return traversal(this.v);
		    }
		}

		class TreeIterator extends ContainerIterator {
		    constructor(t, e, s) {
		        super(s);
		        this.T = t;
		        this.C = e;
		        if (this.iteratorType === 0) {
		            this.pre = function() {
		                if (this.T === this.C.i) {
		                    throwIteratorAccessError();
		                }
		                this.T = this.T.I();
		                return this;
		            };
		            this.next = function() {
		                if (this.T === this.C) {
		                    throwIteratorAccessError();
		                }
		                this.T = this.T.B();
		                return this;
		            };
		        } else {
		            this.pre = function() {
		                if (this.T === this.C.h) {
		                    throwIteratorAccessError();
		                }
		                this.T = this.T.B();
		                return this;
		            };
		            this.next = function() {
		                if (this.T === this.C) {
		                    throwIteratorAccessError();
		                }
		                this.T = this.T.I();
		                return this;
		            };
		        }
		    }
		    get index() {
		        let t = this.T;
		        const e = this.C.o;
		        if (t === this.C) {
		            if (e) {
		                return e.M - 1;
		            }
		            return 0;
		        }
		        let s = 0;
		        if (t.i) {
		            s += t.i.M;
		        }
		        while (t !== e) {
		            const e = t.o;
		            if (t === e.h) {
		                s += 1;
		                if (e.i) {
		                    s += e.i.M;
		                }
		            }
		            t = e;
		        }
		        return s;
		    }
		    isAccessible() {
		        return this.T !== this.C;
		    }
		}

		class OrderedMapIterator extends TreeIterator {
		    constructor(t, e, s, i) {
		        super(t, e, i);
		        this.container = s;
		    }
		    get pointer() {
		        if (this.T === this.C) {
		            throwIteratorAccessError();
		        }
		        const t = this;
		        return new Proxy([], {
		            get(e, s) {
		                if (s === "0") return t.T.u; else if (s === "1") return t.T.l;
		                e[0] = t.T.u;
		                e[1] = t.T.l;
		                return e[s];
		            },
		            set(e, s, i) {
		                if (s !== "1") {
		                    throw new TypeError("prop must be 1");
		                }
		                t.T.l = i;
		                return true;
		            }
		        });
		    }
		    copy() {
		        return new OrderedMapIterator(this.T, this.C, this.container, this.iteratorType);
		    }
		}

		class OrderedMap extends TreeContainer {
		    constructor(t = [], e, s) {
		        super(e, s);
		        const i = this;
		        t.forEach((function(t) {
		            i.setElement(t[0], t[1]);
		        }));
		    }
		    begin() {
		        return new OrderedMapIterator(this.C.i || this.C, this.C, this);
		    }
		    end() {
		        return new OrderedMapIterator(this.C, this.C, this);
		    }
		    rBegin() {
		        return new OrderedMapIterator(this.C.h || this.C, this.C, this, 1);
		    }
		    rEnd() {
		        return new OrderedMapIterator(this.C, this.C, this, 1);
		    }
		    front() {
		        if (this.m === 0) return;
		        const t = this.C.i;
		        return [ t.u, t.l ];
		    }
		    back() {
		        if (this.m === 0) return;
		        const t = this.C.h;
		        return [ t.u, t.l ];
		    }
		    lowerBound(t) {
		        const e = this.R(this.v, t);
		        return new OrderedMapIterator(e, this.C, this);
		    }
		    upperBound(t) {
		        const e = this.K(this.v, t);
		        return new OrderedMapIterator(e, this.C, this);
		    }
		    reverseLowerBound(t) {
		        const e = this.L(this.v, t);
		        return new OrderedMapIterator(e, this.C, this);
		    }
		    reverseUpperBound(t) {
		        const e = this.k(this.v, t);
		        return new OrderedMapIterator(e, this.C, this);
		    }
		    forEach(t) {
		        this.U((function(e, s, i) {
		            t([ e.u, e.l ], s, i);
		        }));
		    }
		    setElement(t, e, s) {
		        return this.q(t, e, s);
		    }
		    getElementByPos(t) {
		        if (t < 0 || t > this.m - 1) {
		            throw new RangeError;
		        }
		        const e = this.U(t);
		        return [ e.u, e.l ];
		    }
		    find(t) {
		        const e = this.H(this.v, t);
		        return new OrderedMapIterator(e, this.C, this);
		    }
		    getElementByKey(t) {
		        const e = this.H(this.v, t);
		        return e.l;
		    }
		    union(t) {
		        const e = this;
		        t.forEach((function(t) {
		            e.setElement(t[0], t[1]);
		        }));
		        return this.m;
		    }
		    * [Symbol.iterator]() {
		        const t = this.m;
		        const e = this.U();
		        for (let s = 0; s < t; ++s) {
		            const t = e[s];
		            yield [ t.u, t.l ];
		        }
		    }
		}

		exports.OrderedMap = OrderedMap;
		
	} (cjs));
	return cjs;
}

var admin = {};

var hasRequiredAdmin;

function requireAdmin () {
	if (hasRequiredAdmin) return admin;
	hasRequiredAdmin = 1;
	/*
	 * Copyright 2021 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(admin, "__esModule", { value: true });
	admin.addAdminServicesToServer = admin.registerAdminService = undefined;
	const registeredAdminServices = [];
	function registerAdminService(getServiceDefinition, getHandlers) {
	    registeredAdminServices.push({ getServiceDefinition, getHandlers });
	}
	admin.registerAdminService = registerAdminService;
	function addAdminServicesToServer(server) {
	    for (const { getServiceDefinition, getHandlers } of registeredAdminServices) {
	        server.addService(getServiceDefinition(), getHandlers());
	    }
	}
	admin.addAdminServicesToServer = addAdminServicesToServer;
	
	return admin;
}

var makeClient = {};

var client = {};

var call = {};

var hasRequiredCall;

function requireCall () {
	if (hasRequiredCall) return call;
	hasRequiredCall = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(call, "__esModule", { value: true });
	call.ClientDuplexStreamImpl = call.ClientWritableStreamImpl = call.ClientReadableStreamImpl = call.ClientUnaryCallImpl = call.callErrorFromStatus = undefined;
	const events_1 = require$$0$3;
	const stream_1 = require$$0$4;
	const constants_1 = requireConstants();
	/**
	 * Construct a ServiceError from a StatusObject. This function exists primarily
	 * as an attempt to make the error stack trace clearly communicate that the
	 * error is not necessarily a problem in gRPC itself.
	 * @param status
	 */
	function callErrorFromStatus(status, callerStack) {
	    const message = `${status.code} ${constants_1.Status[status.code]}: ${status.details}`;
	    const error = new Error(message);
	    const stack = `${error.stack}\nfor call at\n${callerStack}`;
	    return Object.assign(new Error(message), status, { stack });
	}
	call.callErrorFromStatus = callErrorFromStatus;
	class ClientUnaryCallImpl extends events_1.EventEmitter {
	    constructor() {
	        super();
	    }
	    cancel() {
	        var _a;
	        (_a = this.call) === null || _a === undefined ? undefined : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');
	    }
	    getPeer() {
	        var _a, _b;
	        return (_b = (_a = this.call) === null || _a === undefined ? undefined : _a.getPeer()) !== null && _b !== undefined ? _b : 'unknown';
	    }
	}
	call.ClientUnaryCallImpl = ClientUnaryCallImpl;
	class ClientReadableStreamImpl extends stream_1.Readable {
	    constructor(deserialize) {
	        super({ objectMode: true });
	        this.deserialize = deserialize;
	    }
	    cancel() {
	        var _a;
	        (_a = this.call) === null || _a === undefined ? undefined : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');
	    }
	    getPeer() {
	        var _a, _b;
	        return (_b = (_a = this.call) === null || _a === undefined ? undefined : _a.getPeer()) !== null && _b !== undefined ? _b : 'unknown';
	    }
	    _read(_size) {
	        var _a;
	        (_a = this.call) === null || _a === undefined ? undefined : _a.startRead();
	    }
	}
	call.ClientReadableStreamImpl = ClientReadableStreamImpl;
	class ClientWritableStreamImpl extends stream_1.Writable {
	    constructor(serialize) {
	        super({ objectMode: true });
	        this.serialize = serialize;
	    }
	    cancel() {
	        var _a;
	        (_a = this.call) === null || _a === undefined ? undefined : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');
	    }
	    getPeer() {
	        var _a, _b;
	        return (_b = (_a = this.call) === null || _a === undefined ? undefined : _a.getPeer()) !== null && _b !== undefined ? _b : 'unknown';
	    }
	    _write(chunk, encoding, cb) {
	        var _a;
	        const context = {
	            callback: cb,
	        };
	        const flags = Number(encoding);
	        if (!Number.isNaN(flags)) {
	            context.flags = flags;
	        }
	        (_a = this.call) === null || _a === undefined ? undefined : _a.sendMessageWithContext(context, chunk);
	    }
	    _final(cb) {
	        var _a;
	        (_a = this.call) === null || _a === undefined ? undefined : _a.halfClose();
	        cb();
	    }
	}
	call.ClientWritableStreamImpl = ClientWritableStreamImpl;
	class ClientDuplexStreamImpl extends stream_1.Duplex {
	    constructor(serialize, deserialize) {
	        super({ objectMode: true });
	        this.serialize = serialize;
	        this.deserialize = deserialize;
	    }
	    cancel() {
	        var _a;
	        (_a = this.call) === null || _a === undefined ? undefined : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');
	    }
	    getPeer() {
	        var _a, _b;
	        return (_b = (_a = this.call) === null || _a === undefined ? undefined : _a.getPeer()) !== null && _b !== undefined ? _b : 'unknown';
	    }
	    _read(_size) {
	        var _a;
	        (_a = this.call) === null || _a === undefined ? undefined : _a.startRead();
	    }
	    _write(chunk, encoding, cb) {
	        var _a;
	        const context = {
	            callback: cb,
	        };
	        const flags = Number(encoding);
	        if (!Number.isNaN(flags)) {
	            context.flags = flags;
	        }
	        (_a = this.call) === null || _a === undefined ? undefined : _a.sendMessageWithContext(context, chunk);
	    }
	    _final(cb) {
	        var _a;
	        (_a = this.call) === null || _a === undefined ? undefined : _a.halfClose();
	        cb();
	    }
	}
	call.ClientDuplexStreamImpl = ClientDuplexStreamImpl;
	
	return call;
}

var clientInterceptors = {};

var callInterface = {};

var hasRequiredCallInterface;

function requireCallInterface () {
	if (hasRequiredCallInterface) return callInterface;
	hasRequiredCallInterface = 1;
	/*
	 * Copyright 2022 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(callInterface, "__esModule", { value: true });
	callInterface.InterceptingListenerImpl = callInterface.isInterceptingListener = undefined;
	function isInterceptingListener(listener) {
	    return (listener.onReceiveMetadata !== undefined &&
	        listener.onReceiveMetadata.length === 1);
	}
	callInterface.isInterceptingListener = isInterceptingListener;
	class InterceptingListenerImpl {
	    constructor(listener, nextListener) {
	        this.listener = listener;
	        this.nextListener = nextListener;
	        this.processingMetadata = false;
	        this.hasPendingMessage = false;
	        this.processingMessage = false;
	        this.pendingStatus = null;
	    }
	    processPendingMessage() {
	        if (this.hasPendingMessage) {
	            this.nextListener.onReceiveMessage(this.pendingMessage);
	            this.pendingMessage = null;
	            this.hasPendingMessage = false;
	        }
	    }
	    processPendingStatus() {
	        if (this.pendingStatus) {
	            this.nextListener.onReceiveStatus(this.pendingStatus);
	        }
	    }
	    onReceiveMetadata(metadata) {
	        this.processingMetadata = true;
	        this.listener.onReceiveMetadata(metadata, metadata => {
	            this.processingMetadata = false;
	            this.nextListener.onReceiveMetadata(metadata);
	            this.processPendingMessage();
	            this.processPendingStatus();
	        });
	    }
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    onReceiveMessage(message) {
	        /* If this listener processes messages asynchronously, the last message may
	         * be reordered with respect to the status */
	        this.processingMessage = true;
	        this.listener.onReceiveMessage(message, msg => {
	            this.processingMessage = false;
	            if (this.processingMetadata) {
	                this.pendingMessage = msg;
	                this.hasPendingMessage = true;
	            }
	            else {
	                this.nextListener.onReceiveMessage(msg);
	                this.processPendingStatus();
	            }
	        });
	    }
	    onReceiveStatus(status) {
	        this.listener.onReceiveStatus(status, processedStatus => {
	            if (this.processingMetadata || this.processingMessage) {
	                this.pendingStatus = processedStatus;
	            }
	            else {
	                this.nextListener.onReceiveStatus(processedStatus);
	            }
	        });
	    }
	}
	callInterface.InterceptingListenerImpl = InterceptingListenerImpl;
	
	return callInterface;
}

var hasRequiredClientInterceptors;

function requireClientInterceptors () {
	if (hasRequiredClientInterceptors) return clientInterceptors;
	hasRequiredClientInterceptors = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(clientInterceptors, "__esModule", { value: true });
	clientInterceptors.getInterceptingCall = clientInterceptors.InterceptingCall = clientInterceptors.RequesterBuilder = clientInterceptors.ListenerBuilder = clientInterceptors.InterceptorConfigurationError = undefined;
	const metadata_1 = requireMetadata();
	const call_interface_1 = requireCallInterface();
	const constants_1 = requireConstants();
	const error_1 = requireError();
	/**
	 * Error class associated with passing both interceptors and interceptor
	 * providers to a client constructor or as call options.
	 */
	class InterceptorConfigurationError extends Error {
	    constructor(message) {
	        super(message);
	        this.name = 'InterceptorConfigurationError';
	        Error.captureStackTrace(this, InterceptorConfigurationError);
	    }
	}
	clientInterceptors.InterceptorConfigurationError = InterceptorConfigurationError;
	class ListenerBuilder {
	    constructor() {
	        this.metadata = undefined;
	        this.message = undefined;
	        this.status = undefined;
	    }
	    withOnReceiveMetadata(onReceiveMetadata) {
	        this.metadata = onReceiveMetadata;
	        return this;
	    }
	    withOnReceiveMessage(onReceiveMessage) {
	        this.message = onReceiveMessage;
	        return this;
	    }
	    withOnReceiveStatus(onReceiveStatus) {
	        this.status = onReceiveStatus;
	        return this;
	    }
	    build() {
	        return {
	            onReceiveMetadata: this.metadata,
	            onReceiveMessage: this.message,
	            onReceiveStatus: this.status,
	        };
	    }
	}
	clientInterceptors.ListenerBuilder = ListenerBuilder;
	class RequesterBuilder {
	    constructor() {
	        this.start = undefined;
	        this.message = undefined;
	        this.halfClose = undefined;
	        this.cancel = undefined;
	    }
	    withStart(start) {
	        this.start = start;
	        return this;
	    }
	    withSendMessage(sendMessage) {
	        this.message = sendMessage;
	        return this;
	    }
	    withHalfClose(halfClose) {
	        this.halfClose = halfClose;
	        return this;
	    }
	    withCancel(cancel) {
	        this.cancel = cancel;
	        return this;
	    }
	    build() {
	        return {
	            start: this.start,
	            sendMessage: this.message,
	            halfClose: this.halfClose,
	            cancel: this.cancel,
	        };
	    }
	}
	clientInterceptors.RequesterBuilder = RequesterBuilder;
	/**
	 * A Listener with a default pass-through implementation of each method. Used
	 * for filling out Listeners with some methods omitted.
	 */
	const defaultListener = {
	    onReceiveMetadata: (metadata, next) => {
	        next(metadata);
	    },
	    onReceiveMessage: (message, next) => {
	        next(message);
	    },
	    onReceiveStatus: (status, next) => {
	        next(status);
	    },
	};
	/**
	 * A Requester with a default pass-through implementation of each method. Used
	 * for filling out Requesters with some methods omitted.
	 */
	const defaultRequester = {
	    start: (metadata, listener, next) => {
	        next(metadata, listener);
	    },
	    sendMessage: (message, next) => {
	        next(message);
	    },
	    halfClose: next => {
	        next();
	    },
	    cancel: next => {
	        next();
	    },
	};
	class InterceptingCall {
	    constructor(nextCall, requester) {
	        var _a, _b, _c, _d;
	        this.nextCall = nextCall;
	        /**
	         * Indicates that metadata has been passed to the requester's start
	         * method but it has not been passed to the corresponding next callback
	         */
	        this.processingMetadata = false;
	        /**
	         * Message context for a pending message that is waiting for
	         */
	        this.pendingMessageContext = null;
	        /**
	         * Indicates that a message has been passed to the requester's sendMessage
	         * method but it has not been passed to the corresponding next callback
	         */
	        this.processingMessage = false;
	        /**
	         * Indicates that a status was received but could not be propagated because
	         * a message was still being processed.
	         */
	        this.pendingHalfClose = false;
	        if (requester) {
	            this.requester = {
	                start: (_a = requester.start) !== null && _a !== undefined ? _a : defaultRequester.start,
	                sendMessage: (_b = requester.sendMessage) !== null && _b !== undefined ? _b : defaultRequester.sendMessage,
	                halfClose: (_c = requester.halfClose) !== null && _c !== undefined ? _c : defaultRequester.halfClose,
	                cancel: (_d = requester.cancel) !== null && _d !== undefined ? _d : defaultRequester.cancel,
	            };
	        }
	        else {
	            this.requester = defaultRequester;
	        }
	    }
	    cancelWithStatus(status, details) {
	        this.requester.cancel(() => {
	            this.nextCall.cancelWithStatus(status, details);
	        });
	    }
	    getPeer() {
	        return this.nextCall.getPeer();
	    }
	    processPendingMessage() {
	        if (this.pendingMessageContext) {
	            this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);
	            this.pendingMessageContext = null;
	            this.pendingMessage = null;
	        }
	    }
	    processPendingHalfClose() {
	        if (this.pendingHalfClose) {
	            this.nextCall.halfClose();
	        }
	    }
	    start(metadata, interceptingListener) {
	        var _a, _b, _c, _d, _e, _f;
	        const fullInterceptingListener = {
	            onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === undefined ? undefined : interceptingListener.onReceiveMetadata) === null || _a === undefined ? undefined : _a.bind(interceptingListener)) !== null && _b !== undefined ? _b : (metadata => { }),
	            onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === undefined ? undefined : interceptingListener.onReceiveMessage) === null || _c === undefined ? undefined : _c.bind(interceptingListener)) !== null && _d !== undefined ? _d : (message => { }),
	            onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === undefined ? undefined : interceptingListener.onReceiveStatus) === null || _e === undefined ? undefined : _e.bind(interceptingListener)) !== null && _f !== undefined ? _f : (status => { }),
	        };
	        this.processingMetadata = true;
	        this.requester.start(metadata, fullInterceptingListener, (md, listener) => {
	            var _a, _b, _c;
	            this.processingMetadata = false;
	            let finalInterceptingListener;
	            if ((0, call_interface_1.isInterceptingListener)(listener)) {
	                finalInterceptingListener = listener;
	            }
	            else {
	                const fullListener = {
	                    onReceiveMetadata: (_a = listener.onReceiveMetadata) !== null && _a !== undefined ? _a : defaultListener.onReceiveMetadata,
	                    onReceiveMessage: (_b = listener.onReceiveMessage) !== null && _b !== undefined ? _b : defaultListener.onReceiveMessage,
	                    onReceiveStatus: (_c = listener.onReceiveStatus) !== null && _c !== undefined ? _c : defaultListener.onReceiveStatus,
	                };
	                finalInterceptingListener = new call_interface_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);
	            }
	            this.nextCall.start(md, finalInterceptingListener);
	            this.processPendingMessage();
	            this.processPendingHalfClose();
	        });
	    }
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    sendMessageWithContext(context, message) {
	        this.processingMessage = true;
	        this.requester.sendMessage(message, finalMessage => {
	            this.processingMessage = false;
	            if (this.processingMetadata) {
	                this.pendingMessageContext = context;
	                this.pendingMessage = message;
	            }
	            else {
	                this.nextCall.sendMessageWithContext(context, finalMessage);
	                this.processPendingHalfClose();
	            }
	        });
	    }
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    sendMessage(message) {
	        this.sendMessageWithContext({}, message);
	    }
	    startRead() {
	        this.nextCall.startRead();
	    }
	    halfClose() {
	        this.requester.halfClose(() => {
	            if (this.processingMetadata || this.processingMessage) {
	                this.pendingHalfClose = true;
	            }
	            else {
	                this.nextCall.halfClose();
	            }
	        });
	    }
	}
	clientInterceptors.InterceptingCall = InterceptingCall;
	function getCall(channel, path, options) {
	    var _a, _b;
	    const deadline = (_a = options.deadline) !== null && _a !== undefined ? _a : Infinity;
	    const host = options.host;
	    const parent = (_b = options.parent) !== null && _b !== undefined ? _b : null;
	    const propagateFlags = options.propagate_flags;
	    const credentials = options.credentials;
	    const call = channel.createCall(path, deadline, host, parent, propagateFlags);
	    if (credentials) {
	        call.setCredentials(credentials);
	    }
	    return call;
	}
	/**
	 * InterceptingCall implementation that directly owns the underlying Call
	 * object and handles serialization and deseraizliation.
	 */
	class BaseInterceptingCall {
	    constructor(call, 
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    methodDefinition) {
	        this.call = call;
	        this.methodDefinition = methodDefinition;
	    }
	    cancelWithStatus(status, details) {
	        this.call.cancelWithStatus(status, details);
	    }
	    getPeer() {
	        return this.call.getPeer();
	    }
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    sendMessageWithContext(context, message) {
	        let serialized;
	        try {
	            serialized = this.methodDefinition.requestSerialize(message);
	        }
	        catch (e) {
	            this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${(0, error_1.getErrorMessage)(e)}`);
	            return;
	        }
	        this.call.sendMessageWithContext(context, serialized);
	    }
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    sendMessage(message) {
	        this.sendMessageWithContext({}, message);
	    }
	    start(metadata, interceptingListener) {
	        let readError = null;
	        this.call.start(metadata, {
	            onReceiveMetadata: metadata => {
	                var _a;
	                (_a = interceptingListener === null || interceptingListener === undefined ? undefined : interceptingListener.onReceiveMetadata) === null || _a === undefined ? undefined : _a.call(interceptingListener, metadata);
	            },
	            onReceiveMessage: message => {
	                var _a;
	                // eslint-disable-next-line @typescript-eslint/no-explicit-any
	                let deserialized;
	                try {
	                    deserialized = this.methodDefinition.responseDeserialize(message);
	                }
	                catch (e) {
	                    readError = {
	                        code: constants_1.Status.INTERNAL,
	                        details: `Response message parsing error: ${(0, error_1.getErrorMessage)(e)}`,
	                        metadata: new metadata_1.Metadata(),
	                    };
	                    this.call.cancelWithStatus(readError.code, readError.details);
	                    return;
	                }
	                (_a = interceptingListener === null || interceptingListener === undefined ? undefined : interceptingListener.onReceiveMessage) === null || _a === undefined ? undefined : _a.call(interceptingListener, deserialized);
	            },
	            onReceiveStatus: status => {
	                var _a, _b;
	                if (readError) {
	                    (_a = interceptingListener === null || interceptingListener === undefined ? undefined : interceptingListener.onReceiveStatus) === null || _a === undefined ? undefined : _a.call(interceptingListener, readError);
	                }
	                else {
	                    (_b = interceptingListener === null || interceptingListener === undefined ? undefined : interceptingListener.onReceiveStatus) === null || _b === undefined ? undefined : _b.call(interceptingListener, status);
	                }
	            },
	        });
	    }
	    startRead() {
	        this.call.startRead();
	    }
	    halfClose() {
	        this.call.halfClose();
	    }
	}
	/**
	 * BaseInterceptingCall with special-cased behavior for methods with unary
	 * responses.
	 */
	class BaseUnaryInterceptingCall extends BaseInterceptingCall {
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    constructor(call, methodDefinition) {
	        super(call, methodDefinition);
	    }
	    start(metadata, listener) {
	        var _a, _b;
	        let receivedMessage = false;
	        const wrapperListener = {
	            onReceiveMetadata: (_b = (_a = listener === null || listener === undefined ? undefined : listener.onReceiveMetadata) === null || _a === undefined ? undefined : _a.bind(listener)) !== null && _b !== undefined ? _b : (metadata => { }),
	            // eslint-disable-next-line @typescript-eslint/no-explicit-any
	            onReceiveMessage: (message) => {
	                var _a;
	                receivedMessage = true;
	                (_a = listener === null || listener === undefined ? undefined : listener.onReceiveMessage) === null || _a === undefined ? undefined : _a.call(listener, message);
	            },
	            onReceiveStatus: (status) => {
	                var _a, _b;
	                if (!receivedMessage) {
	                    (_a = listener === null || listener === undefined ? undefined : listener.onReceiveMessage) === null || _a === undefined ? undefined : _a.call(listener, null);
	                }
	                (_b = listener === null || listener === undefined ? undefined : listener.onReceiveStatus) === null || _b === undefined ? undefined : _b.call(listener, status);
	            },
	        };
	        super.start(metadata, wrapperListener);
	        this.call.startRead();
	    }
	}
	/**
	 * BaseInterceptingCall with special-cased behavior for methods with streaming
	 * responses.
	 */
	class BaseStreamingInterceptingCall extends BaseInterceptingCall {
	}
	function getBottomInterceptingCall(channel, options, 
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	methodDefinition) {
	    const call = getCall(channel, methodDefinition.path, options);
	    if (methodDefinition.responseStream) {
	        return new BaseStreamingInterceptingCall(call, methodDefinition);
	    }
	    else {
	        return new BaseUnaryInterceptingCall(call, methodDefinition);
	    }
	}
	function getInterceptingCall(interceptorArgs, 
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	methodDefinition, options, channel) {
	    if (interceptorArgs.clientInterceptors.length > 0 &&
	        interceptorArgs.clientInterceptorProviders.length > 0) {
	        throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as options ' +
	            'to the client constructor. Only one of these is allowed.');
	    }
	    if (interceptorArgs.callInterceptors.length > 0 &&
	        interceptorArgs.callInterceptorProviders.length > 0) {
	        throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as call ' +
	            'options. Only one of these is allowed.');
	    }
	    let interceptors = [];
	    // Interceptors passed to the call override interceptors passed to the client constructor
	    if (interceptorArgs.callInterceptors.length > 0 ||
	        interceptorArgs.callInterceptorProviders.length > 0) {
	        interceptors = []
	            .concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map(provider => provider(methodDefinition)))
	            .filter(interceptor => interceptor);
	        // Filter out falsy values when providers return nothing
	    }
	    else {
	        interceptors = []
	            .concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map(provider => provider(methodDefinition)))
	            .filter(interceptor => interceptor);
	        // Filter out falsy values when providers return nothing
	    }
	    const interceptorOptions = Object.assign({}, options, {
	        method_definition: methodDefinition,
	    });
	    /* For each interceptor in the list, the nextCall function passed to it is
	     * based on the next interceptor in the list, using a nextCall function
	     * constructed with the following interceptor in the list, and so on. The
	     * initialValue, which is effectively at the end of the list, is a nextCall
	     * function that invokes getBottomInterceptingCall, the result of which
	     * handles (de)serialization and also gets the underlying call from the
	     * channel. */
	    const getCall = interceptors.reduceRight((nextCall, nextInterceptor) => {
	        return currentOptions => nextInterceptor(currentOptions, nextCall);
	    }, (finalOptions) => getBottomInterceptingCall(channel, finalOptions, methodDefinition));
	    return getCall(interceptorOptions);
	}
	clientInterceptors.getInterceptingCall = getInterceptingCall;
	
	return clientInterceptors;
}

var hasRequiredClient$1;

function requireClient$1 () {
	if (hasRequiredClient$1) return client;
	hasRequiredClient$1 = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(client, "__esModule", { value: true });
	client.Client = undefined;
	const call_1 = requireCall();
	const channel_1 = requireChannel$1();
	const connectivity_state_1 = requireConnectivityState();
	const constants_1 = requireConstants();
	const metadata_1 = requireMetadata();
	const client_interceptors_1 = requireClientInterceptors();
	const CHANNEL_SYMBOL = Symbol();
	const INTERCEPTOR_SYMBOL = Symbol();
	const INTERCEPTOR_PROVIDER_SYMBOL = Symbol();
	const CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();
	function isFunction(arg) {
	    return typeof arg === 'function';
	}
	function getErrorStackString(error) {
	    var _a;
	    return ((_a = error.stack) === null || _a === undefined ? undefined : _a.split('\n').slice(1).join('\n')) || 'no stack trace available';
	}
	/**
	 * A generic gRPC client. Primarily useful as a base class for all generated
	 * clients.
	 */
	class Client {
	    constructor(address, credentials, options = {}) {
	        var _a, _b;
	        options = Object.assign({}, options);
	        this[INTERCEPTOR_SYMBOL] = (_a = options.interceptors) !== null && _a !== undefined ? _a : [];
	        delete options.interceptors;
	        this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options.interceptor_providers) !== null && _b !== undefined ? _b : [];
	        delete options.interceptor_providers;
	        if (this[INTERCEPTOR_SYMBOL].length > 0 &&
	            this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {
	            throw new Error('Both interceptors and interceptor_providers were passed as options ' +
	                'to the client constructor. Only one of these is allowed.');
	        }
	        this[CALL_INVOCATION_TRANSFORMER_SYMBOL] =
	            options.callInvocationTransformer;
	        delete options.callInvocationTransformer;
	        if (options.channelOverride) {
	            this[CHANNEL_SYMBOL] = options.channelOverride;
	        }
	        else if (options.channelFactoryOverride) {
	            const channelFactoryOverride = options.channelFactoryOverride;
	            delete options.channelFactoryOverride;
	            this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials, options);
	        }
	        else {
	            this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);
	        }
	    }
	    close() {
	        this[CHANNEL_SYMBOL].close();
	    }
	    getChannel() {
	        return this[CHANNEL_SYMBOL];
	    }
	    waitForReady(deadline, callback) {
	        const checkState = (err) => {
	            if (err) {
	                callback(new Error('Failed to connect before the deadline'));
	                return;
	            }
	            let newState;
	            try {
	                newState = this[CHANNEL_SYMBOL].getConnectivityState(true);
	            }
	            catch (e) {
	                callback(new Error('The channel has been closed'));
	                return;
	            }
	            if (newState === connectivity_state_1.ConnectivityState.READY) {
	                callback();
	            }
	            else {
	                try {
	                    this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);
	                }
	                catch (e) {
	                    callback(new Error('The channel has been closed'));
	                }
	            }
	        };
	        setImmediate(checkState);
	    }
	    checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {
	        if (isFunction(arg1)) {
	            return { metadata: new metadata_1.Metadata(), options: {}, callback: arg1 };
	        }
	        else if (isFunction(arg2)) {
	            if (arg1 instanceof metadata_1.Metadata) {
	                return { metadata: arg1, options: {}, callback: arg2 };
	            }
	            else {
	                return { metadata: new metadata_1.Metadata(), options: arg1, callback: arg2 };
	            }
	        }
	        else {
	            if (!(arg1 instanceof metadata_1.Metadata &&
	                arg2 instanceof Object &&
	                isFunction(arg3))) {
	                throw new Error('Incorrect arguments passed');
	            }
	            return { metadata: arg1, options: arg2, callback: arg3 };
	        }
	    }
	    makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {
	        var _a, _b;
	        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);
	        const methodDefinition = {
	            path: method,
	            requestStream: false,
	            responseStream: false,
	            requestSerialize: serialize,
	            responseDeserialize: deserialize,
	        };
	        let callProperties = {
	            argument: argument,
	            metadata: checkedArguments.metadata,
	            call: new call_1.ClientUnaryCallImpl(),
	            channel: this[CHANNEL_SYMBOL],
	            methodDefinition: methodDefinition,
	            callOptions: checkedArguments.options,
	            callback: checkedArguments.callback,
	        };
	        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
	            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
	        }
	        const emitter = callProperties.call;
	        const interceptorArgs = {
	            clientInterceptors: this[INTERCEPTOR_SYMBOL],
	            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
	            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== undefined ? _a : [],
	            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== undefined ? _b : [],
	        };
	        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
	        /* This needs to happen before the emitter is used. Unfortunately we can't
	         * enforce this with the type system. We need to construct this emitter
	         * before calling the CallInvocationTransformer, and we need to create the
	         * call after that. */
	        emitter.call = call;
	        let responseMessage = null;
	        let receivedStatus = false;
	        let callerStackError = new Error();
	        call.start(callProperties.metadata, {
	            onReceiveMetadata: metadata => {
	                emitter.emit('metadata', metadata);
	            },
	            // eslint-disable-next-line @typescript-eslint/no-explicit-any
	            onReceiveMessage(message) {
	                if (responseMessage !== null) {
	                    call.cancelWithStatus(constants_1.Status.UNIMPLEMENTED, 'Too many responses received');
	                }
	                responseMessage = message;
	            },
	            onReceiveStatus(status) {
	                if (receivedStatus) {
	                    return;
	                }
	                receivedStatus = true;
	                if (status.code === constants_1.Status.OK) {
	                    if (responseMessage === null) {
	                        const callerStack = getErrorStackString(callerStackError);
	                        callProperties.callback((0, call_1.callErrorFromStatus)({
	                            code: constants_1.Status.UNIMPLEMENTED,
	                            details: 'No message received',
	                            metadata: status.metadata,
	                        }, callerStack));
	                    }
	                    else {
	                        callProperties.callback(null, responseMessage);
	                    }
	                }
	                else {
	                    const callerStack = getErrorStackString(callerStackError);
	                    callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));
	                }
	                /* Avoid retaining the callerStackError object in the call context of
	                 * the status event handler. */
	                callerStackError = null;
	                emitter.emit('status', status);
	            },
	        });
	        call.sendMessage(argument);
	        call.halfClose();
	        return emitter;
	    }
	    makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {
	        var _a, _b;
	        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);
	        const methodDefinition = {
	            path: method,
	            requestStream: true,
	            responseStream: false,
	            requestSerialize: serialize,
	            responseDeserialize: deserialize,
	        };
	        let callProperties = {
	            metadata: checkedArguments.metadata,
	            call: new call_1.ClientWritableStreamImpl(serialize),
	            channel: this[CHANNEL_SYMBOL],
	            methodDefinition: methodDefinition,
	            callOptions: checkedArguments.options,
	            callback: checkedArguments.callback,
	        };
	        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
	            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
	        }
	        const emitter = callProperties.call;
	        const interceptorArgs = {
	            clientInterceptors: this[INTERCEPTOR_SYMBOL],
	            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
	            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== undefined ? _a : [],
	            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== undefined ? _b : [],
	        };
	        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
	        /* This needs to happen before the emitter is used. Unfortunately we can't
	         * enforce this with the type system. We need to construct this emitter
	         * before calling the CallInvocationTransformer, and we need to create the
	         * call after that. */
	        emitter.call = call;
	        let responseMessage = null;
	        let receivedStatus = false;
	        let callerStackError = new Error();
	        call.start(callProperties.metadata, {
	            onReceiveMetadata: metadata => {
	                emitter.emit('metadata', metadata);
	            },
	            // eslint-disable-next-line @typescript-eslint/no-explicit-any
	            onReceiveMessage(message) {
	                if (responseMessage !== null) {
	                    call.cancelWithStatus(constants_1.Status.UNIMPLEMENTED, 'Too many responses received');
	                }
	                responseMessage = message;
	                call.startRead();
	            },
	            onReceiveStatus(status) {
	                if (receivedStatus) {
	                    return;
	                }
	                receivedStatus = true;
	                if (status.code === constants_1.Status.OK) {
	                    if (responseMessage === null) {
	                        const callerStack = getErrorStackString(callerStackError);
	                        callProperties.callback((0, call_1.callErrorFromStatus)({
	                            code: constants_1.Status.UNIMPLEMENTED,
	                            details: 'No message received',
	                            metadata: status.metadata,
	                        }, callerStack));
	                    }
	                    else {
	                        callProperties.callback(null, responseMessage);
	                    }
	                }
	                else {
	                    const callerStack = getErrorStackString(callerStackError);
	                    callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));
	                }
	                /* Avoid retaining the callerStackError object in the call context of
	                 * the status event handler. */
	                callerStackError = null;
	                emitter.emit('status', status);
	            },
	        });
	        return emitter;
	    }
	    checkMetadataAndOptions(arg1, arg2) {
	        let metadata;
	        let options;
	        if (arg1 instanceof metadata_1.Metadata) {
	            metadata = arg1;
	            if (arg2) {
	                options = arg2;
	            }
	            else {
	                options = {};
	            }
	        }
	        else {
	            if (arg1) {
	                options = arg1;
	            }
	            else {
	                options = {};
	            }
	            metadata = new metadata_1.Metadata();
	        }
	        return { metadata, options };
	    }
	    makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {
	        var _a, _b;
	        const checkedArguments = this.checkMetadataAndOptions(metadata, options);
	        const methodDefinition = {
	            path: method,
	            requestStream: false,
	            responseStream: true,
	            requestSerialize: serialize,
	            responseDeserialize: deserialize,
	        };
	        let callProperties = {
	            argument: argument,
	            metadata: checkedArguments.metadata,
	            call: new call_1.ClientReadableStreamImpl(deserialize),
	            channel: this[CHANNEL_SYMBOL],
	            methodDefinition: methodDefinition,
	            callOptions: checkedArguments.options,
	        };
	        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
	            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
	        }
	        const stream = callProperties.call;
	        const interceptorArgs = {
	            clientInterceptors: this[INTERCEPTOR_SYMBOL],
	            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
	            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== undefined ? _a : [],
	            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== undefined ? _b : [],
	        };
	        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
	        /* This needs to happen before the emitter is used. Unfortunately we can't
	         * enforce this with the type system. We need to construct this emitter
	         * before calling the CallInvocationTransformer, and we need to create the
	         * call after that. */
	        stream.call = call;
	        let receivedStatus = false;
	        let callerStackError = new Error();
	        call.start(callProperties.metadata, {
	            onReceiveMetadata(metadata) {
	                stream.emit('metadata', metadata);
	            },
	            // eslint-disable-next-line @typescript-eslint/no-explicit-any
	            onReceiveMessage(message) {
	                stream.push(message);
	            },
	            onReceiveStatus(status) {
	                if (receivedStatus) {
	                    return;
	                }
	                receivedStatus = true;
	                stream.push(null);
	                if (status.code !== constants_1.Status.OK) {
	                    const callerStack = getErrorStackString(callerStackError);
	                    stream.emit('error', (0, call_1.callErrorFromStatus)(status, callerStack));
	                }
	                /* Avoid retaining the callerStackError object in the call context of
	                 * the status event handler. */
	                callerStackError = null;
	                stream.emit('status', status);
	            },
	        });
	        call.sendMessage(argument);
	        call.halfClose();
	        return stream;
	    }
	    makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {
	        var _a, _b;
	        const checkedArguments = this.checkMetadataAndOptions(metadata, options);
	        const methodDefinition = {
	            path: method,
	            requestStream: true,
	            responseStream: true,
	            requestSerialize: serialize,
	            responseDeserialize: deserialize,
	        };
	        let callProperties = {
	            metadata: checkedArguments.metadata,
	            call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),
	            channel: this[CHANNEL_SYMBOL],
	            methodDefinition: methodDefinition,
	            callOptions: checkedArguments.options,
	        };
	        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
	            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
	        }
	        const stream = callProperties.call;
	        const interceptorArgs = {
	            clientInterceptors: this[INTERCEPTOR_SYMBOL],
	            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
	            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== undefined ? _a : [],
	            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== undefined ? _b : [],
	        };
	        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
	        /* This needs to happen before the emitter is used. Unfortunately we can't
	         * enforce this with the type system. We need to construct this emitter
	         * before calling the CallInvocationTransformer, and we need to create the
	         * call after that. */
	        stream.call = call;
	        let receivedStatus = false;
	        let callerStackError = new Error();
	        call.start(callProperties.metadata, {
	            onReceiveMetadata(metadata) {
	                stream.emit('metadata', metadata);
	            },
	            onReceiveMessage(message) {
	                stream.push(message);
	            },
	            onReceiveStatus(status) {
	                if (receivedStatus) {
	                    return;
	                }
	                receivedStatus = true;
	                stream.push(null);
	                if (status.code !== constants_1.Status.OK) {
	                    const callerStack = getErrorStackString(callerStackError);
	                    stream.emit('error', (0, call_1.callErrorFromStatus)(status, callerStack));
	                }
	                /* Avoid retaining the callerStackError object in the call context of
	                 * the status event handler. */
	                callerStackError = null;
	                stream.emit('status', status);
	            },
	        });
	        return stream;
	    }
	}
	client.Client = Client;
	
	return client;
}

var hasRequiredMakeClient;

function requireMakeClient () {
	if (hasRequiredMakeClient) return makeClient;
	hasRequiredMakeClient = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(makeClient, "__esModule", { value: true });
	makeClient.loadPackageDefinition = makeClient.makeClientConstructor = undefined;
	const client_1 = requireClient$1();
	/**
	 * Map with short names for each of the requester maker functions. Used in
	 * makeClientConstructor
	 * @private
	 */
	const requesterFuncs = {
	    unary: client_1.Client.prototype.makeUnaryRequest,
	    server_stream: client_1.Client.prototype.makeServerStreamRequest,
	    client_stream: client_1.Client.prototype.makeClientStreamRequest,
	    bidi: client_1.Client.prototype.makeBidiStreamRequest,
	};
	/**
	 * Returns true, if given key is included in the blacklisted
	 * keys.
	 * @param key key for check, string.
	 */
	function isPrototypePolluted(key) {
	    return ['__proto__', 'prototype', 'constructor'].includes(key);
	}
	/**
	 * Creates a constructor for a client with the given methods, as specified in
	 * the methods argument. The resulting class will have an instance method for
	 * each method in the service, which is a partial application of one of the
	 * [Client]{@link grpc.Client} request methods, depending on `requestSerialize`
	 * and `responseSerialize`, with the `method`, `serialize`, and `deserialize`
	 * arguments predefined.
	 * @param methods An object mapping method names to
	 *     method attributes
	 * @param serviceName The fully qualified name of the service
	 * @param classOptions An options object.
	 * @return New client constructor, which is a subclass of
	 *     {@link grpc.Client}, and has the same arguments as that constructor.
	 */
	function makeClientConstructor(methods, serviceName, classOptions) {
	    class ServiceClientImpl extends client_1.Client {
	    }
	    Object.keys(methods).forEach(name => {
	        if (isPrototypePolluted(name)) {
	            return;
	        }
	        const attrs = methods[name];
	        let methodType;
	        // TODO(murgatroid99): Verify that we don't need this anymore
	        if (typeof name === 'string' && name.charAt(0) === '$') {
	            throw new Error('Method names cannot start with $');
	        }
	        if (attrs.requestStream) {
	            if (attrs.responseStream) {
	                methodType = 'bidi';
	            }
	            else {
	                methodType = 'client_stream';
	            }
	        }
	        else {
	            if (attrs.responseStream) {
	                methodType = 'server_stream';
	            }
	            else {
	                methodType = 'unary';
	            }
	        }
	        const serialize = attrs.requestSerialize;
	        const deserialize = attrs.responseDeserialize;
	        const methodFunc = partial(requesterFuncs[methodType], attrs.path, serialize, deserialize);
	        ServiceClientImpl.prototype[name] = methodFunc;
	        // Associate all provided attributes with the method
	        Object.assign(ServiceClientImpl.prototype[name], attrs);
	        if (attrs.originalName && !isPrototypePolluted(attrs.originalName)) {
	            ServiceClientImpl.prototype[attrs.originalName] =
	                ServiceClientImpl.prototype[name];
	        }
	    });
	    ServiceClientImpl.service = methods;
	    ServiceClientImpl.serviceName = serviceName;
	    return ServiceClientImpl;
	}
	makeClient.makeClientConstructor = makeClientConstructor;
	function partial(fn, path, serialize, deserialize) {
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    return function (...args) {
	        return fn.call(this, path, serialize, deserialize, ...args);
	    };
	}
	function isProtobufTypeDefinition(obj) {
	    return 'format' in obj;
	}
	/**
	 * Load a gRPC package definition as a gRPC object hierarchy.
	 * @param packageDef The package definition object.
	 * @return The resulting gRPC object.
	 */
	function loadPackageDefinition(packageDef) {
	    const result = {};
	    for (const serviceFqn in packageDef) {
	        if (Object.prototype.hasOwnProperty.call(packageDef, serviceFqn)) {
	            const service = packageDef[serviceFqn];
	            const nameComponents = serviceFqn.split('.');
	            if (nameComponents.some((comp) => isPrototypePolluted(comp))) {
	                continue;
	            }
	            const serviceName = nameComponents[nameComponents.length - 1];
	            let current = result;
	            for (const packageName of nameComponents.slice(0, -1)) {
	                if (!current[packageName]) {
	                    current[packageName] = {};
	                }
	                current = current[packageName];
	            }
	            if (isProtobufTypeDefinition(service)) {
	                current[serviceName] = service;
	            }
	            else {
	                current[serviceName] = makeClientConstructor(service, serviceName);
	            }
	        }
	    }
	    return result;
	}
	makeClient.loadPackageDefinition = loadPackageDefinition;
	
	return makeClient;
}

var src$1 = {};

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

var lodash_camelcase;
var hasRequiredLodash_camelcase;

function requireLodash_camelcase () {
	if (hasRequiredLodash_camelcase) return lodash_camelcase;
	hasRequiredLodash_camelcase = 1;

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/** Used to match words composed of alphanumeric characters. */
	var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

	/** Used to match Latin Unicode letters (excluding mathematical operators). */
	var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

	/** Used to compose unicode character classes. */
	var rsAstralRange = '\\ud800-\\udfff',
	    rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
	    rsComboSymbolsRange = '\\u20d0-\\u20f0',
	    rsDingbatRange = '\\u2700-\\u27bf',
	    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
	    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
	    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
	    rsPunctuationRange = '\\u2000-\\u206f',
	    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
	    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
	    rsVarRange = '\\ufe0e\\ufe0f',
	    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

	/** Used to compose unicode capture groups. */
	var rsApos = "['\u2019]",
	    rsAstral = '[' + rsAstralRange + ']',
	    rsBreak = '[' + rsBreakRange + ']',
	    rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
	    rsDigits = '\\d+',
	    rsDingbat = '[' + rsDingbatRange + ']',
	    rsLower = '[' + rsLowerRange + ']',
	    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
	    rsFitz = '\\ud83c[\\udffb-\\udfff]',
	    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
	    rsNonAstral = '[^' + rsAstralRange + ']',
	    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
	    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
	    rsUpper = '[' + rsUpperRange + ']',
	    rsZWJ = '\\u200d';

	/** Used to compose unicode regexes. */
	var rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')',
	    rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')',
	    rsOptLowerContr = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
	    rsOptUpperContr = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
	    reOptMod = rsModifier + '?',
	    rsOptVar = '[' + rsVarRange + ']?',
	    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
	    rsSeq = rsOptVar + reOptMod + rsOptJoin,
	    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
	    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

	/** Used to match apostrophes. */
	var reApos = RegExp(rsApos, 'g');

	/**
	 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
	 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
	 */
	var reComboMark = RegExp(rsCombo, 'g');

	/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
	var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

	/** Used to match complex or compound words. */
	var reUnicodeWord = RegExp([
	  rsUpper + '?' + rsLower + '+' + rsOptLowerContr + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
	  rsUpperMisc + '+' + rsOptUpperContr + '(?=' + [rsBreak, rsUpper + rsLowerMisc, '$'].join('|') + ')',
	  rsUpper + '?' + rsLowerMisc + '+' + rsOptLowerContr,
	  rsUpper + '+' + rsOptUpperContr,
	  rsDigits,
	  rsEmoji
	].join('|'), 'g');

	/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
	var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');

	/** Used to detect strings that need a more robust regexp to match words. */
	var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

	/** Used to map Latin Unicode letters to basic Latin letters. */
	var deburredLetters = {
	  // Latin-1 Supplement block.
	  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
	  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
	  '\xc7': 'C',  '\xe7': 'c',
	  '\xd0': 'D',  '\xf0': 'd',
	  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
	  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
	  '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
	  '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
	  '\xd1': 'N',  '\xf1': 'n',
	  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
	  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
	  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
	  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
	  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
	  '\xc6': 'Ae', '\xe6': 'ae',
	  '\xde': 'Th', '\xfe': 'th',
	  '\xdf': 'ss',
	  // Latin Extended-A block.
	  '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
	  '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
	  '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
	  '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
	  '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
	  '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
	  '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
	  '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
	  '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
	  '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
	  '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
	  '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
	  '\u0134': 'J',  '\u0135': 'j',
	  '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
	  '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
	  '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
	  '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
	  '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
	  '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
	  '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
	  '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
	  '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
	  '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
	  '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
	  '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
	  '\u0163': 't',  '\u0165': 't', '\u0167': 't',
	  '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
	  '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
	  '\u0174': 'W',  '\u0175': 'w',
	  '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
	  '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
	  '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
	  '\u0132': 'IJ', '\u0133': 'ij',
	  '\u0152': 'Oe', '\u0153': 'oe',
	  '\u0149': "'n", '\u017f': 'ss'
	};

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/**
	 * A specialized version of `_.reduce` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {*} [accumulator] The initial value.
	 * @param {boolean} [initAccum] Specify using the first element of `array` as
	 *  the initial value.
	 * @returns {*} Returns the accumulated value.
	 */
	function arrayReduce(array, iteratee, accumulator, initAccum) {
	  var index = -1,
	      length = array ? array.length : 0;
	  while (++index < length) {
	    accumulator = iteratee(accumulator, array[index], index, array);
	  }
	  return accumulator;
	}

	/**
	 * Converts an ASCII `string` to an array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the converted array.
	 */
	function asciiToArray(string) {
	  return string.split('');
	}

	/**
	 * Splits an ASCII `string` into an array of its words.
	 *
	 * @private
	 * @param {string} The string to inspect.
	 * @returns {Array} Returns the words of `string`.
	 */
	function asciiWords(string) {
	  return string.match(reAsciiWord) || [];
	}

	/**
	 * The base implementation of `_.propertyOf` without support for deep paths.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Function} Returns the new accessor function.
	 */
	function basePropertyOf(object) {
	  return function(key) {
	    return object == null ? undefined : object[key];
	  };
	}

	/**
	 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
	 * letters to basic Latin letters.
	 *
	 * @private
	 * @param {string} letter The matched letter to deburr.
	 * @returns {string} Returns the deburred letter.
	 */
	var deburrLetter = basePropertyOf(deburredLetters);

	/**
	 * Checks if `string` contains Unicode symbols.
	 *
	 * @private
	 * @param {string} string The string to inspect.
	 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
	 */
	function hasUnicode(string) {
	  return reHasUnicode.test(string);
	}

	/**
	 * Checks if `string` contains a word composed of Unicode symbols.
	 *
	 * @private
	 * @param {string} string The string to inspect.
	 * @returns {boolean} Returns `true` if a word is found, else `false`.
	 */
	function hasUnicodeWord(string) {
	  return reHasUnicodeWord.test(string);
	}

	/**
	 * Converts `string` to an array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the converted array.
	 */
	function stringToArray(string) {
	  return hasUnicode(string)
	    ? unicodeToArray(string)
	    : asciiToArray(string);
	}

	/**
	 * Converts a Unicode `string` to an array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the converted array.
	 */
	function unicodeToArray(string) {
	  return string.match(reUnicode) || [];
	}

	/**
	 * Splits a Unicode `string` into an array of its words.
	 *
	 * @private
	 * @param {string} The string to inspect.
	 * @returns {Array} Returns the words of `string`.
	 */
	function unicodeWords(string) {
	  return string.match(reUnicodeWord) || [];
	}

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/** Built-in value references. */
	var Symbol = root.Symbol;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * The base implementation of `_.slice` without an iteratee call guard.
	 *
	 * @private
	 * @param {Array} array The array to slice.
	 * @param {number} [start=0] The start position.
	 * @param {number} [end=array.length] The end position.
	 * @returns {Array} Returns the slice of `array`.
	 */
	function baseSlice(array, start, end) {
	  var index = -1,
	      length = array.length;

	  if (start < 0) {
	    start = -start > length ? 0 : (length + start);
	  }
	  end = end > length ? length : end;
	  if (end < 0) {
	    end += length;
	  }
	  length = start > end ? 0 : ((end - start) >>> 0);
	  start >>>= 0;

	  var result = Array(length);
	  while (++index < length) {
	    result[index] = array[index + start];
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -Infinity) ? '-0' : result;
	}

	/**
	 * Casts `array` to a slice if it's needed.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {number} start The start position.
	 * @param {number} [end=array.length] The end position.
	 * @returns {Array} Returns the cast slice.
	 */
	function castSlice(array, start, end) {
	  var length = array.length;
	  end = end === undefined ? length : end;
	  return (!start && end >= length) ? array : baseSlice(array, start, end);
	}

	/**
	 * Creates a function like `_.lowerFirst`.
	 *
	 * @private
	 * @param {string} methodName The name of the `String` case method to use.
	 * @returns {Function} Returns the new case function.
	 */
	function createCaseFirst(methodName) {
	  return function(string) {
	    string = toString(string);

	    var strSymbols = hasUnicode(string)
	      ? stringToArray(string)
	      : undefined;

	    var chr = strSymbols
	      ? strSymbols[0]
	      : string.charAt(0);

	    var trailing = strSymbols
	      ? castSlice(strSymbols, 1).join('')
	      : string.slice(1);

	    return chr[methodName]() + trailing;
	  };
	}

	/**
	 * Creates a function like `_.camelCase`.
	 *
	 * @private
	 * @param {Function} callback The function to combine each word.
	 * @returns {Function} Returns the new compounder function.
	 */
	function createCompounder(callback) {
	  return function(string) {
	    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
	  };
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && objectToString.call(value) == symbolTag);
	}

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}

	/**
	 * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to convert.
	 * @returns {string} Returns the camel cased string.
	 * @example
	 *
	 * _.camelCase('Foo Bar');
	 * // => 'fooBar'
	 *
	 * _.camelCase('--foo-bar--');
	 * // => 'fooBar'
	 *
	 * _.camelCase('__FOO_BAR__');
	 * // => 'fooBar'
	 */
	var camelCase = createCompounder(function(result, word, index) {
	  word = word.toLowerCase();
	  return result + (index ? capitalize(word) : word);
	});

	/**
	 * Converts the first character of `string` to upper case and the remaining
	 * to lower case.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to capitalize.
	 * @returns {string} Returns the capitalized string.
	 * @example
	 *
	 * _.capitalize('FRED');
	 * // => 'Fred'
	 */
	function capitalize(string) {
	  return upperFirst(toString(string).toLowerCase());
	}

	/**
	 * Deburrs `string` by converting
	 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
	 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
	 * letters to basic Latin letters and removing
	 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to deburr.
	 * @returns {string} Returns the deburred string.
	 * @example
	 *
	 * _.deburr('déjà vu');
	 * // => 'deja vu'
	 */
	function deburr(string) {
	  string = toString(string);
	  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
	}

	/**
	 * Converts the first character of `string` to upper case.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category String
	 * @param {string} [string=''] The string to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.upperFirst('fred');
	 * // => 'Fred'
	 *
	 * _.upperFirst('FRED');
	 * // => 'FRED'
	 */
	var upperFirst = createCaseFirst('toUpperCase');

	/**
	 * Splits `string` into an array of its words.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to inspect.
	 * @param {RegExp|string} [pattern] The pattern to match words.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {Array} Returns the words of `string`.
	 * @example
	 *
	 * _.words('fred, barney, & pebbles');
	 * // => ['fred', 'barney', 'pebbles']
	 *
	 * _.words('fred, barney, & pebbles', /[^, ]+/g);
	 * // => ['fred', 'barney', '&', 'pebbles']
	 */
	function words(string, pattern, guard) {
	  string = toString(string);
	  pattern = pattern;

	  if (pattern === undefined) {
	    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
	  }
	  return string.match(pattern) || [];
	}

	lodash_camelcase = camelCase;
	return lodash_camelcase;
}

var src = {exports: {}};

var indexLight = {exports: {}};

var util$1 = {exports: {}};

var codegen_1;
var hasRequiredCodegen;

function requireCodegen () {
	if (hasRequiredCodegen) return codegen_1;
	hasRequiredCodegen = 1;
	codegen_1 = codegen;

	/**
	 * Begins generating a function.
	 * @memberof util
	 * @param {string[]} functionParams Function parameter names
	 * @param {string} [functionName] Function name if not anonymous
	 * @returns {Codegen} Appender that appends code to the function's body
	 */
	function codegen(functionParams, functionName) {

	    /* istanbul ignore if */
	    if (typeof functionParams === "string") {
	        functionName = functionParams;
	        functionParams = undefined;
	    }

	    var body = [];

	    /**
	     * Appends code to the function's body or finishes generation.
	     * @typedef Codegen
	     * @type {function}
	     * @param {string|Object.<string,*>} [formatStringOrScope] Format string or, to finish the function, an object of additional scope variables, if any
	     * @param {...*} [formatParams] Format parameters
	     * @returns {Codegen|Function} Itself or the generated function if finished
	     * @throws {Error} If format parameter counts do not match
	     */

	    function Codegen(formatStringOrScope) {
	        // note that explicit array handling below makes this ~50% faster

	        // finish the function
	        if (typeof formatStringOrScope !== "string") {
	            var source = toString();
	            if (codegen.verbose)
	                console.log("codegen: " + source); // eslint-disable-line no-console
	            source = "return " + source;
	            if (formatStringOrScope) {
	                var scopeKeys   = Object.keys(formatStringOrScope),
	                    scopeParams = new Array(scopeKeys.length + 1),
	                    scopeValues = new Array(scopeKeys.length),
	                    scopeOffset = 0;
	                while (scopeOffset < scopeKeys.length) {
	                    scopeParams[scopeOffset] = scopeKeys[scopeOffset];
	                    scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
	                }
	                scopeParams[scopeOffset] = source;
	                return Function.apply(null, scopeParams).apply(null, scopeValues); // eslint-disable-line no-new-func
	            }
	            return Function(source)(); // eslint-disable-line no-new-func
	        }

	        // otherwise append to body
	        var formatParams = new Array(arguments.length - 1),
	            formatOffset = 0;
	        while (formatOffset < formatParams.length)
	            formatParams[formatOffset] = arguments[++formatOffset];
	        formatOffset = 0;
	        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
	            var value = formatParams[formatOffset++];
	            switch ($1) {
	                case "d": case "f": return String(Number(value));
	                case "i": return String(Math.floor(value));
	                case "j": return JSON.stringify(value);
	                case "s": return String(value);
	            }
	            return "%";
	        });
	        if (formatOffset !== formatParams.length)
	            throw Error("parameter count mismatch");
	        body.push(formatStringOrScope);
	        return Codegen;
	    }

	    function toString(functionNameOverride) {
	        return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
	    }

	    Codegen.toString = toString;
	    return Codegen;
	}

	/**
	 * Begins generating a function.
	 * @memberof util
	 * @function codegen
	 * @param {string} [functionName] Function name if not anonymous
	 * @returns {Codegen} Appender that appends code to the function's body
	 * @variation 2
	 */

	/**
	 * When set to `true`, codegen will log generated code to console. Useful for debugging.
	 * @name util.codegen.verbose
	 * @type {boolean}
	 */
	codegen.verbose = false;
	return codegen_1;
}

var fetch_1;
var hasRequiredFetch;

function requireFetch () {
	if (hasRequiredFetch) return fetch_1;
	hasRequiredFetch = 1;
	fetch_1 = fetch;

	var asPromise = requireAspromise(),
	    inquire   = requireInquire();

	var fs = inquire("fs");

	/**
	 * Node-style callback as used by {@link util.fetch}.
	 * @typedef FetchCallback
	 * @type {function}
	 * @param {?Error} error Error, if any, otherwise `null`
	 * @param {string} [contents] File contents, if there hasn't been an error
	 * @returns {undefined}
	 */

	/**
	 * Options as used by {@link util.fetch}.
	 * @typedef FetchOptions
	 * @type {Object}
	 * @property {boolean} [binary=false] Whether expecting a binary response
	 * @property {boolean} [xhr=false] If `true`, forces the use of XMLHttpRequest
	 */

	/**
	 * Fetches the contents of a file.
	 * @memberof util
	 * @param {string} filename File path or url
	 * @param {FetchOptions} options Fetch options
	 * @param {FetchCallback} callback Callback function
	 * @returns {undefined}
	 */
	function fetch(filename, options, callback) {
	    if (typeof options === "function") {
	        callback = options;
	        options = {};
	    } else if (!options)
	        options = {};

	    if (!callback)
	        return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this

	    // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.
	    if (!options.xhr && fs && fs.readFile)
	        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
	            return err && typeof XMLHttpRequest !== "undefined"
	                ? fetch.xhr(filename, options, callback)
	                : err
	                ? callback(err)
	                : callback(null, options.binary ? contents : contents.toString("utf8"));
	        });

	    // use the XHR version otherwise.
	    return fetch.xhr(filename, options, callback);
	}

	/**
	 * Fetches the contents of a file.
	 * @name util.fetch
	 * @function
	 * @param {string} path File path or url
	 * @param {FetchCallback} callback Callback function
	 * @returns {undefined}
	 * @variation 2
	 */

	/**
	 * Fetches the contents of a file.
	 * @name util.fetch
	 * @function
	 * @param {string} path File path or url
	 * @param {FetchOptions} [options] Fetch options
	 * @returns {Promise<string|Uint8Array>} Promise
	 * @variation 3
	 */

	/**/
	fetch.xhr = function fetch_xhr(filename, options, callback) {
	    var xhr = new XMLHttpRequest();
	    xhr.onreadystatechange /* works everywhere */ = function fetchOnReadyStateChange() {

	        if (xhr.readyState !== 4)
	            return undefined;

	        // local cors security errors return status 0 / empty string, too. afaik this cannot be
	        // reliably distinguished from an actually empty file for security reasons. feel free
	        // to send a pull request if you are aware of a solution.
	        if (xhr.status !== 0 && xhr.status !== 200)
	            return callback(Error("status " + xhr.status));

	        // if binary data is expected, make sure that some sort of array is returned, even if
	        // ArrayBuffers are not supported. the binary string fallback, however, is unsafe.
	        if (options.binary) {
	            var buffer = xhr.response;
	            if (!buffer) {
	                buffer = [];
	                for (var i = 0; i < xhr.responseText.length; ++i)
	                    buffer.push(xhr.responseText.charCodeAt(i) & 255);
	            }
	            return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
	        }
	        return callback(null, xhr.responseText);
	    };

	    if (options.binary) {
	        // ref: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data#Receiving_binary_data_in_older_browsers
	        if ("overrideMimeType" in xhr)
	            xhr.overrideMimeType("text/plain; charset=x-user-defined");
	        xhr.responseType = "arraybuffer";
	    }

	    xhr.open("GET", filename);
	    xhr.send();
	};
	return fetch_1;
}

var path = {};

var hasRequiredPath;

function requirePath () {
	if (hasRequiredPath) return path;
	hasRequiredPath = 1;
	(function (exports) {

		/**
		 * A minimal path module to resolve Unix, Windows and URL paths alike.
		 * @memberof util
		 * @namespace
		 */
		var path = exports;

		var isAbsolute =
		/**
		 * Tests if the specified path is absolute.
		 * @param {string} path Path to test
		 * @returns {boolean} `true` if path is absolute
		 */
		path.isAbsolute = function isAbsolute(path) {
		    return /^(?:\/|\w+:)/.test(path);
		};

		var normalize =
		/**
		 * Normalizes the specified path.
		 * @param {string} path Path to normalize
		 * @returns {string} Normalized path
		 */
		path.normalize = function normalize(path) {
		    path = path.replace(/\\/g, "/")
		               .replace(/\/{2,}/g, "/");
		    var parts    = path.split("/"),
		        absolute = isAbsolute(path),
		        prefix   = "";
		    if (absolute)
		        prefix = parts.shift() + "/";
		    for (var i = 0; i < parts.length;) {
		        if (parts[i] === "..") {
		            if (i > 0 && parts[i - 1] !== "..")
		                parts.splice(--i, 2);
		            else if (absolute)
		                parts.splice(i, 1);
		            else
		                ++i;
		        } else if (parts[i] === ".")
		            parts.splice(i, 1);
		        else
		            ++i;
		    }
		    return prefix + parts.join("/");
		};

		/**
		 * Resolves the specified include path against the specified origin path.
		 * @param {string} originPath Path to the origin file
		 * @param {string} includePath Include path relative to origin path
		 * @param {boolean} [alreadyNormalized=false] `true` if both paths are already known to be normalized
		 * @returns {string} Path to the include file
		 */
		path.resolve = function resolve(originPath, includePath, alreadyNormalized) {
		    if (!alreadyNormalized)
		        includePath = normalize(includePath);
		    if (isAbsolute(includePath))
		        return includePath;
		    if (!alreadyNormalized)
		        originPath = normalize(originPath);
		    return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
		}; 
	} (path));
	return path;
}

var types = {};

var hasRequiredTypes;

function requireTypes () {
	if (hasRequiredTypes) return types;
	hasRequiredTypes = 1;
	(function (exports) {

		/**
		 * Common type constants.
		 * @namespace
		 */
		var types = exports;

		var util = requireUtil$1();

		var s = [
		    "double",   // 0
		    "float",    // 1
		    "int32",    // 2
		    "uint32",   // 3
		    "sint32",   // 4
		    "fixed32",  // 5
		    "sfixed32", // 6
		    "int64",    // 7
		    "uint64",   // 8
		    "sint64",   // 9
		    "fixed64",  // 10
		    "sfixed64", // 11
		    "bool",     // 12
		    "string",   // 13
		    "bytes"     // 14
		];

		function bake(values, offset) {
		    var i = 0, o = {};
		    offset |= 0;
		    while (i < values.length) o[s[i + offset]] = values[i++];
		    return o;
		}

		/**
		 * Basic type wire types.
		 * @type {Object.<string,number>}
		 * @const
		 * @property {number} double=1 Fixed64 wire type
		 * @property {number} float=5 Fixed32 wire type
		 * @property {number} int32=0 Varint wire type
		 * @property {number} uint32=0 Varint wire type
		 * @property {number} sint32=0 Varint wire type
		 * @property {number} fixed32=5 Fixed32 wire type
		 * @property {number} sfixed32=5 Fixed32 wire type
		 * @property {number} int64=0 Varint wire type
		 * @property {number} uint64=0 Varint wire type
		 * @property {number} sint64=0 Varint wire type
		 * @property {number} fixed64=1 Fixed64 wire type
		 * @property {number} sfixed64=1 Fixed64 wire type
		 * @property {number} bool=0 Varint wire type
		 * @property {number} string=2 Ldelim wire type
		 * @property {number} bytes=2 Ldelim wire type
		 */
		types.basic = bake([
		    /* double   */ 1,
		    /* float    */ 5,
		    /* int32    */ 0,
		    /* uint32   */ 0,
		    /* sint32   */ 0,
		    /* fixed32  */ 5,
		    /* sfixed32 */ 5,
		    /* int64    */ 0,
		    /* uint64   */ 0,
		    /* sint64   */ 0,
		    /* fixed64  */ 1,
		    /* sfixed64 */ 1,
		    /* bool     */ 0,
		    /* string   */ 2,
		    /* bytes    */ 2
		]);

		/**
		 * Basic type defaults.
		 * @type {Object.<string,*>}
		 * @const
		 * @property {number} double=0 Double default
		 * @property {number} float=0 Float default
		 * @property {number} int32=0 Int32 default
		 * @property {number} uint32=0 Uint32 default
		 * @property {number} sint32=0 Sint32 default
		 * @property {number} fixed32=0 Fixed32 default
		 * @property {number} sfixed32=0 Sfixed32 default
		 * @property {number} int64=0 Int64 default
		 * @property {number} uint64=0 Uint64 default
		 * @property {number} sint64=0 Sint32 default
		 * @property {number} fixed64=0 Fixed64 default
		 * @property {number} sfixed64=0 Sfixed64 default
		 * @property {boolean} bool=false Bool default
		 * @property {string} string="" String default
		 * @property {Array.<number>} bytes=Array(0) Bytes default
		 * @property {null} message=null Message default
		 */
		types.defaults = bake([
		    /* double   */ 0,
		    /* float    */ 0,
		    /* int32    */ 0,
		    /* uint32   */ 0,
		    /* sint32   */ 0,
		    /* fixed32  */ 0,
		    /* sfixed32 */ 0,
		    /* int64    */ 0,
		    /* uint64   */ 0,
		    /* sint64   */ 0,
		    /* fixed64  */ 0,
		    /* sfixed64 */ 0,
		    /* bool     */ false,
		    /* string   */ "",
		    /* bytes    */ util.emptyArray,
		    /* message  */ null
		]);

		/**
		 * Basic long type wire types.
		 * @type {Object.<string,number>}
		 * @const
		 * @property {number} int64=0 Varint wire type
		 * @property {number} uint64=0 Varint wire type
		 * @property {number} sint64=0 Varint wire type
		 * @property {number} fixed64=1 Fixed64 wire type
		 * @property {number} sfixed64=1 Fixed64 wire type
		 */
		types.long = bake([
		    /* int64    */ 0,
		    /* uint64   */ 0,
		    /* sint64   */ 0,
		    /* fixed64  */ 1,
		    /* sfixed64 */ 1
		], 7);

		/**
		 * Allowed types for map keys with their associated wire type.
		 * @type {Object.<string,number>}
		 * @const
		 * @property {number} int32=0 Varint wire type
		 * @property {number} uint32=0 Varint wire type
		 * @property {number} sint32=0 Varint wire type
		 * @property {number} fixed32=5 Fixed32 wire type
		 * @property {number} sfixed32=5 Fixed32 wire type
		 * @property {number} int64=0 Varint wire type
		 * @property {number} uint64=0 Varint wire type
		 * @property {number} sint64=0 Varint wire type
		 * @property {number} fixed64=1 Fixed64 wire type
		 * @property {number} sfixed64=1 Fixed64 wire type
		 * @property {number} bool=0 Varint wire type
		 * @property {number} string=2 Ldelim wire type
		 */
		types.mapKey = bake([
		    /* int32    */ 0,
		    /* uint32   */ 0,
		    /* sint32   */ 0,
		    /* fixed32  */ 5,
		    /* sfixed32 */ 5,
		    /* int64    */ 0,
		    /* uint64   */ 0,
		    /* sint64   */ 0,
		    /* fixed64  */ 1,
		    /* sfixed64 */ 1,
		    /* bool     */ 0,
		    /* string   */ 2
		], 2);

		/**
		 * Allowed types for packed repeated fields with their associated wire type.
		 * @type {Object.<string,number>}
		 * @const
		 * @property {number} double=1 Fixed64 wire type
		 * @property {number} float=5 Fixed32 wire type
		 * @property {number} int32=0 Varint wire type
		 * @property {number} uint32=0 Varint wire type
		 * @property {number} sint32=0 Varint wire type
		 * @property {number} fixed32=5 Fixed32 wire type
		 * @property {number} sfixed32=5 Fixed32 wire type
		 * @property {number} int64=0 Varint wire type
		 * @property {number} uint64=0 Varint wire type
		 * @property {number} sint64=0 Varint wire type
		 * @property {number} fixed64=1 Fixed64 wire type
		 * @property {number} sfixed64=1 Fixed64 wire type
		 * @property {number} bool=0 Varint wire type
		 */
		types.packed = bake([
		    /* double   */ 1,
		    /* float    */ 5,
		    /* int32    */ 0,
		    /* uint32   */ 0,
		    /* sint32   */ 0,
		    /* fixed32  */ 5,
		    /* sfixed32 */ 5,
		    /* int64    */ 0,
		    /* uint64   */ 0,
		    /* sint64   */ 0,
		    /* fixed64  */ 1,
		    /* sfixed64 */ 1,
		    /* bool     */ 0
		]); 
	} (types));
	return types;
}

var field;
var hasRequiredField;

function requireField () {
	if (hasRequiredField) return field;
	hasRequiredField = 1;
	field = Field;

	// extends ReflectionObject
	var ReflectionObject = requireObject();
	((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";

	var Enum  = require_enum(),
	    types = requireTypes(),
	    util  = requireUtil$1();

	var Type; // cyclic

	var ruleRe = /^required|optional|repeated$/;

	/**
	 * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.
	 * @name Field
	 * @classdesc Reflected message field.
	 * @extends FieldBase
	 * @constructor
	 * @param {string} name Unique name within its namespace
	 * @param {number} id Unique id within its namespace
	 * @param {string} type Value type
	 * @param {string|Object.<string,*>} [rule="optional"] Field rule
	 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
	 * @param {Object.<string,*>} [options] Declared options
	 */

	/**
	 * Constructs a field from a field descriptor.
	 * @param {string} name Field name
	 * @param {IField} json Field descriptor
	 * @returns {Field} Created field
	 * @throws {TypeError} If arguments are invalid
	 */
	Field.fromJSON = function fromJSON(name, json) {
	    return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);
	};

	/**
	 * Not an actual constructor. Use {@link Field} instead.
	 * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.
	 * @exports FieldBase
	 * @extends ReflectionObject
	 * @constructor
	 * @param {string} name Unique name within its namespace
	 * @param {number} id Unique id within its namespace
	 * @param {string} type Value type
	 * @param {string|Object.<string,*>} [rule="optional"] Field rule
	 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
	 * @param {Object.<string,*>} [options] Declared options
	 * @param {string} [comment] Comment associated with this field
	 */
	function Field(name, id, type, rule, extend, options, comment) {

	    if (util.isObject(rule)) {
	        comment = extend;
	        options = rule;
	        rule = extend = undefined;
	    } else if (util.isObject(extend)) {
	        comment = options;
	        options = extend;
	        extend = undefined;
	    }

	    ReflectionObject.call(this, name, options);

	    if (!util.isInteger(id) || id < 0)
	        throw TypeError("id must be a non-negative integer");

	    if (!util.isString(type))
	        throw TypeError("type must be a string");

	    if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase()))
	        throw TypeError("rule must be a string rule");

	    if (extend !== undefined && !util.isString(extend))
	        throw TypeError("extend must be a string");

	    /**
	     * Field rule, if any.
	     * @type {string|undefined}
	     */
	    if (rule === "proto3_optional") {
	        rule = "optional";
	    }
	    this.rule = rule && rule !== "optional" ? rule : undefined; // toJSON

	    /**
	     * Field type.
	     * @type {string}
	     */
	    this.type = type; // toJSON

	    /**
	     * Unique field id.
	     * @type {number}
	     */
	    this.id = id; // toJSON, marker

	    /**
	     * Extended type if different from parent.
	     * @type {string|undefined}
	     */
	    this.extend = extend || undefined; // toJSON

	    /**
	     * Whether this field is required.
	     * @type {boolean}
	     */
	    this.required = rule === "required";

	    /**
	     * Whether this field is optional.
	     * @type {boolean}
	     */
	    this.optional = !this.required;

	    /**
	     * Whether this field is repeated.
	     * @type {boolean}
	     */
	    this.repeated = rule === "repeated";

	    /**
	     * Whether this field is a map or not.
	     * @type {boolean}
	     */
	    this.map = false;

	    /**
	     * Message this field belongs to.
	     * @type {Type|null}
	     */
	    this.message = null;

	    /**
	     * OneOf this field belongs to, if any,
	     * @type {OneOf|null}
	     */
	    this.partOf = null;

	    /**
	     * The field type's default value.
	     * @type {*}
	     */
	    this.typeDefault = null;

	    /**
	     * The field's default value on prototypes.
	     * @type {*}
	     */
	    this.defaultValue = null;

	    /**
	     * Whether this field's value should be treated as a long.
	     * @type {boolean}
	     */
	    this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */ false;

	    /**
	     * Whether this field's value is a buffer.
	     * @type {boolean}
	     */
	    this.bytes = type === "bytes";

	    /**
	     * Resolved type if not a basic type.
	     * @type {Type|Enum|null}
	     */
	    this.resolvedType = null;

	    /**
	     * Sister-field within the extended type if a declaring extension field.
	     * @type {Field|null}
	     */
	    this.extensionField = null;

	    /**
	     * Sister-field within the declaring namespace if an extended field.
	     * @type {Field|null}
	     */
	    this.declaringField = null;

	    /**
	     * Internally remembers whether this field is packed.
	     * @type {boolean|null}
	     * @private
	     */
	    this._packed = null;

	    /**
	     * Comment for this field.
	     * @type {string|null}
	     */
	    this.comment = comment;
	}

	/**
	 * Determines whether this field is packed. Only relevant when repeated and working with proto2.
	 * @name Field#packed
	 * @type {boolean}
	 * @readonly
	 */
	Object.defineProperty(Field.prototype, "packed", {
	    get: function() {
	        // defaults to packed=true if not explicity set to false
	        if (this._packed === null)
	            this._packed = this.getOption("packed") !== false;
	        return this._packed;
	    }
	});

	/**
	 * @override
	 */
	Field.prototype.setOption = function setOption(name, value, ifNotSet) {
	    if (name === "packed") // clear cached before setting
	        this._packed = null;
	    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
	};

	/**
	 * Field descriptor.
	 * @interface IField
	 * @property {string} [rule="optional"] Field rule
	 * @property {string} type Field type
	 * @property {number} id Field id
	 * @property {Object.<string,*>} [options] Field options
	 */

	/**
	 * Extension field descriptor.
	 * @interface IExtensionField
	 * @extends IField
	 * @property {string} extend Extended type
	 */

	/**
	 * Converts this field to a field descriptor.
	 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
	 * @returns {IField} Field descriptor
	 */
	Field.prototype.toJSON = function toJSON(toJSONOptions) {
	    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
	    return util.toObject([
	        "rule"    , this.rule !== "optional" && this.rule || undefined,
	        "type"    , this.type,
	        "id"      , this.id,
	        "extend"  , this.extend,
	        "options" , this.options,
	        "comment" , keepComments ? this.comment : undefined
	    ]);
	};

	/**
	 * Resolves this field's type references.
	 * @returns {Field} `this`
	 * @throws {Error} If any reference cannot be resolved
	 */
	Field.prototype.resolve = function resolve() {

	    if (this.resolved)
	        return this;

	    if ((this.typeDefault = types.defaults[this.type]) === undefined) { // if not a basic type, resolve it
	        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
	        if (this.resolvedType instanceof Type)
	            this.typeDefault = null;
	        else // instanceof Enum
	            this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]; // first defined
	    } else if (this.options && this.options.proto3_optional) {
	        // proto3 scalar value marked optional; should default to null
	        this.typeDefault = null;
	    }

	    // use explicitly set default value if present
	    if (this.options && this.options["default"] != null) {
	        this.typeDefault = this.options["default"];
	        if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
	            this.typeDefault = this.resolvedType.values[this.typeDefault];
	    }

	    // remove unnecessary options
	    if (this.options) {
	        if (this.options.packed === true || this.options.packed !== undefined && this.resolvedType && !(this.resolvedType instanceof Enum))
	            delete this.options.packed;
	        if (!Object.keys(this.options).length)
	            this.options = undefined;
	    }

	    // convert to internal data type if necesssary
	    if (this.long) {
	        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");

	        /* istanbul ignore else */
	        if (Object.freeze)
	            Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even requires it)

	    } else if (this.bytes && typeof this.typeDefault === "string") {
	        var buf;
	        if (util.base64.test(this.typeDefault))
	            util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);
	        else
	            util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
	        this.typeDefault = buf;
	    }

	    // take special care of maps and repeated fields
	    if (this.map)
	        this.defaultValue = util.emptyObject;
	    else if (this.repeated)
	        this.defaultValue = util.emptyArray;
	    else
	        this.defaultValue = this.typeDefault;

	    // ensure proper value on prototype
	    if (this.parent instanceof Type)
	        this.parent.ctor.prototype[this.name] = this.defaultValue;

	    return ReflectionObject.prototype.resolve.call(this);
	};

	/**
	 * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).
	 * @typedef FieldDecorator
	 * @type {function}
	 * @param {Object} prototype Target prototype
	 * @param {string} fieldName Field name
	 * @returns {undefined}
	 */

	/**
	 * Field decorator (TypeScript).
	 * @name Field.d
	 * @function
	 * @param {number} fieldId Field id
	 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"string"|"bool"|"bytes"|Object} fieldType Field type
	 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
	 * @param {T} [defaultValue] Default value
	 * @returns {FieldDecorator} Decorator function
	 * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]
	 */
	Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {

	    // submessage: decorate the submessage and use its name as the type
	    if (typeof fieldType === "function")
	        fieldType = util.decorateType(fieldType).name;

	    // enum reference: create a reflected copy of the enum and keep reuseing it
	    else if (fieldType && typeof fieldType === "object")
	        fieldType = util.decorateEnum(fieldType).name;

	    return function fieldDecorator(prototype, fieldName) {
	        util.decorateType(prototype.constructor)
	            .add(new Field(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
	    };
	};

	/**
	 * Field decorator (TypeScript).
	 * @name Field.d
	 * @function
	 * @param {number} fieldId Field id
	 * @param {Constructor<T>|string} fieldType Field type
	 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
	 * @returns {FieldDecorator} Decorator function
	 * @template T extends Message<T>
	 * @variation 2
	 */
	// like Field.d but without a default value

	// Sets up cyclic dependencies (called in index-light)
	Field._configure = function configure(Type_) {
	    Type = Type_;
	};
	return field;
}

var oneof;
var hasRequiredOneof;

function requireOneof () {
	if (hasRequiredOneof) return oneof;
	hasRequiredOneof = 1;
	oneof = OneOf;

	// extends ReflectionObject
	var ReflectionObject = requireObject();
	((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";

	var Field = requireField(),
	    util  = requireUtil$1();

	/**
	 * Constructs a new oneof instance.
	 * @classdesc Reflected oneof.
	 * @extends ReflectionObject
	 * @constructor
	 * @param {string} name Oneof name
	 * @param {string[]|Object.<string,*>} [fieldNames] Field names
	 * @param {Object.<string,*>} [options] Declared options
	 * @param {string} [comment] Comment associated with this field
	 */
	function OneOf(name, fieldNames, options, comment) {
	    if (!Array.isArray(fieldNames)) {
	        options = fieldNames;
	        fieldNames = undefined;
	    }
	    ReflectionObject.call(this, name, options);

	    /* istanbul ignore if */
	    if (!(fieldNames === undefined || Array.isArray(fieldNames)))
	        throw TypeError("fieldNames must be an Array");

	    /**
	     * Field names that belong to this oneof.
	     * @type {string[]}
	     */
	    this.oneof = fieldNames || []; // toJSON, marker

	    /**
	     * Fields that belong to this oneof as an array for iteration.
	     * @type {Field[]}
	     * @readonly
	     */
	    this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent

	    /**
	     * Comment for this field.
	     * @type {string|null}
	     */
	    this.comment = comment;
	}

	/**
	 * Oneof descriptor.
	 * @interface IOneOf
	 * @property {Array.<string>} oneof Oneof field names
	 * @property {Object.<string,*>} [options] Oneof options
	 */

	/**
	 * Constructs a oneof from a oneof descriptor.
	 * @param {string} name Oneof name
	 * @param {IOneOf} json Oneof descriptor
	 * @returns {OneOf} Created oneof
	 * @throws {TypeError} If arguments are invalid
	 */
	OneOf.fromJSON = function fromJSON(name, json) {
	    return new OneOf(name, json.oneof, json.options, json.comment);
	};

	/**
	 * Converts this oneof to a oneof descriptor.
	 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
	 * @returns {IOneOf} Oneof descriptor
	 */
	OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
	    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
	    return util.toObject([
	        "options" , this.options,
	        "oneof"   , this.oneof,
	        "comment" , keepComments ? this.comment : undefined
	    ]);
	};

	/**
	 * Adds the fields of the specified oneof to the parent if not already done so.
	 * @param {OneOf} oneof The oneof
	 * @returns {undefined}
	 * @inner
	 * @ignore
	 */
	function addFieldsToParent(oneof) {
	    if (oneof.parent)
	        for (var i = 0; i < oneof.fieldsArray.length; ++i)
	            if (!oneof.fieldsArray[i].parent)
	                oneof.parent.add(oneof.fieldsArray[i]);
	}

	/**
	 * Adds a field to this oneof and removes it from its current parent, if any.
	 * @param {Field} field Field to add
	 * @returns {OneOf} `this`
	 */
	OneOf.prototype.add = function add(field) {

	    /* istanbul ignore if */
	    if (!(field instanceof Field))
	        throw TypeError("field must be a Field");

	    if (field.parent && field.parent !== this.parent)
	        field.parent.remove(field);
	    this.oneof.push(field.name);
	    this.fieldsArray.push(field);
	    field.partOf = this; // field.parent remains null
	    addFieldsToParent(this);
	    return this;
	};

	/**
	 * Removes a field from this oneof and puts it back to the oneof's parent.
	 * @param {Field} field Field to remove
	 * @returns {OneOf} `this`
	 */
	OneOf.prototype.remove = function remove(field) {

	    /* istanbul ignore if */
	    if (!(field instanceof Field))
	        throw TypeError("field must be a Field");

	    var index = this.fieldsArray.indexOf(field);

	    /* istanbul ignore if */
	    if (index < 0)
	        throw Error(field + " is not a member of " + this);

	    this.fieldsArray.splice(index, 1);
	    index = this.oneof.indexOf(field.name);

	    /* istanbul ignore else */
	    if (index > -1) // theoretical
	        this.oneof.splice(index, 1);

	    field.partOf = null;
	    return this;
	};

	/**
	 * @override
	 */
	OneOf.prototype.onAdd = function onAdd(parent) {
	    ReflectionObject.prototype.onAdd.call(this, parent);
	    var self = this;
	    // Collect present fields
	    for (var i = 0; i < this.oneof.length; ++i) {
	        var field = parent.get(this.oneof[i]);
	        if (field && !field.partOf) {
	            field.partOf = self;
	            self.fieldsArray.push(field);
	        }
	    }
	    // Add not yet present fields
	    addFieldsToParent(this);
	};

	/**
	 * @override
	 */
	OneOf.prototype.onRemove = function onRemove(parent) {
	    for (var i = 0, field; i < this.fieldsArray.length; ++i)
	        if ((field = this.fieldsArray[i]).parent)
	            field.parent.remove(field);
	    ReflectionObject.prototype.onRemove.call(this, parent);
	};

	/**
	 * Decorator function as returned by {@link OneOf.d} (TypeScript).
	 * @typedef OneOfDecorator
	 * @type {function}
	 * @param {Object} prototype Target prototype
	 * @param {string} oneofName OneOf name
	 * @returns {undefined}
	 */

	/**
	 * OneOf decorator (TypeScript).
	 * @function
	 * @param {...string} fieldNames Field names
	 * @returns {OneOfDecorator} Decorator function
	 * @template T extends string
	 */
	OneOf.d = function decorateOneOf() {
	    var fieldNames = new Array(arguments.length),
	        index = 0;
	    while (index < arguments.length)
	        fieldNames[index] = arguments[index++];
	    return function oneOfDecorator(prototype, oneofName) {
	        util.decorateType(prototype.constructor)
	            .add(new OneOf(oneofName, fieldNames));
	        Object.defineProperty(prototype, oneofName, {
	            get: util.oneOfGetter(fieldNames),
	            set: util.oneOfSetter(fieldNames)
	        });
	    };
	};
	return oneof;
}

var namespace;
var hasRequiredNamespace;

function requireNamespace () {
	if (hasRequiredNamespace) return namespace;
	hasRequiredNamespace = 1;
	namespace = Namespace;

	// extends ReflectionObject
	var ReflectionObject = requireObject();
	((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";

	var Field    = requireField(),
	    util     = requireUtil$1(),
	    OneOf    = requireOneof();

	var Type,    // cyclic
	    Service,
	    Enum;

	/**
	 * Constructs a new namespace instance.
	 * @name Namespace
	 * @classdesc Reflected namespace.
	 * @extends NamespaceBase
	 * @constructor
	 * @param {string} name Namespace name
	 * @param {Object.<string,*>} [options] Declared options
	 */

	/**
	 * Constructs a namespace from JSON.
	 * @memberof Namespace
	 * @function
	 * @param {string} name Namespace name
	 * @param {Object.<string,*>} json JSON object
	 * @returns {Namespace} Created namespace
	 * @throws {TypeError} If arguments are invalid
	 */
	Namespace.fromJSON = function fromJSON(name, json) {
	    return new Namespace(name, json.options).addJSON(json.nested);
	};

	/**
	 * Converts an array of reflection objects to JSON.
	 * @memberof Namespace
	 * @param {ReflectionObject[]} array Object array
	 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
	 * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty
	 */
	function arrayToJSON(array, toJSONOptions) {
	    if (!(array && array.length))
	        return undefined;
	    var obj = {};
	    for (var i = 0; i < array.length; ++i)
	        obj[array[i].name] = array[i].toJSON(toJSONOptions);
	    return obj;
	}

	Namespace.arrayToJSON = arrayToJSON;

	/**
	 * Tests if the specified id is reserved.
	 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
	 * @param {number} id Id to test
	 * @returns {boolean} `true` if reserved, otherwise `false`
	 */
	Namespace.isReservedId = function isReservedId(reserved, id) {
	    if (reserved)
	        for (var i = 0; i < reserved.length; ++i)
	            if (typeof reserved[i] !== "string" && reserved[i][0] <= id && reserved[i][1] > id)
	                return true;
	    return false;
	};

	/**
	 * Tests if the specified name is reserved.
	 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
	 * @param {string} name Name to test
	 * @returns {boolean} `true` if reserved, otherwise `false`
	 */
	Namespace.isReservedName = function isReservedName(reserved, name) {
	    if (reserved)
	        for (var i = 0; i < reserved.length; ++i)
	            if (reserved[i] === name)
	                return true;
	    return false;
	};

	/**
	 * Not an actual constructor. Use {@link Namespace} instead.
	 * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.
	 * @exports NamespaceBase
	 * @extends ReflectionObject
	 * @abstract
	 * @constructor
	 * @param {string} name Namespace name
	 * @param {Object.<string,*>} [options] Declared options
	 * @see {@link Namespace}
	 */
	function Namespace(name, options) {
	    ReflectionObject.call(this, name, options);

	    /**
	     * Nested objects by name.
	     * @type {Object.<string,ReflectionObject>|undefined}
	     */
	    this.nested = undefined; // toJSON

	    /**
	     * Cached nested objects as an array.
	     * @type {ReflectionObject[]|null}
	     * @private
	     */
	    this._nestedArray = null;
	}

	function clearCache(namespace) {
	    namespace._nestedArray = null;
	    return namespace;
	}

	/**
	 * Nested objects of this namespace as an array for iteration.
	 * @name NamespaceBase#nestedArray
	 * @type {ReflectionObject[]}
	 * @readonly
	 */
	Object.defineProperty(Namespace.prototype, "nestedArray", {
	    get: function() {
	        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
	    }
	});

	/**
	 * Namespace descriptor.
	 * @interface INamespace
	 * @property {Object.<string,*>} [options] Namespace options
	 * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors
	 */

	/**
	 * Any extension field descriptor.
	 * @typedef AnyExtensionField
	 * @type {IExtensionField|IExtensionMapField}
	 */

	/**
	 * Any nested object descriptor.
	 * @typedef AnyNestedObject
	 * @type {IEnum|IType|IService|AnyExtensionField|INamespace|IOneOf}
	 */

	/**
	 * Converts this namespace to a namespace descriptor.
	 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
	 * @returns {INamespace} Namespace descriptor
	 */
	Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
	    return util.toObject([
	        "options" , this.options,
	        "nested"  , arrayToJSON(this.nestedArray, toJSONOptions)
	    ]);
	};

	/**
	 * Adds nested objects to this namespace from nested object descriptors.
	 * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors
	 * @returns {Namespace} `this`
	 */
	Namespace.prototype.addJSON = function addJSON(nestedJson) {
	    var ns = this;
	    /* istanbul ignore else */
	    if (nestedJson) {
	        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
	            nested = nestedJson[names[i]];
	            ns.add( // most to least likely
	                ( nested.fields !== undefined
	                ? Type.fromJSON
	                : nested.values !== undefined
	                ? Enum.fromJSON
	                : nested.methods !== undefined
	                ? Service.fromJSON
	                : nested.id !== undefined
	                ? Field.fromJSON
	                : Namespace.fromJSON )(names[i], nested)
	            );
	        }
	    }
	    return this;
	};

	/**
	 * Gets the nested object of the specified name.
	 * @param {string} name Nested object name
	 * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist
	 */
	Namespace.prototype.get = function get(name) {
	    return this.nested && this.nested[name]
	        || null;
	};

	/**
	 * Gets the values of the nested {@link Enum|enum} of the specified name.
	 * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.
	 * @param {string} name Nested enum name
	 * @returns {Object.<string,number>} Enum values
	 * @throws {Error} If there is no such enum
	 */
	Namespace.prototype.getEnum = function getEnum(name) {
	    if (this.nested && this.nested[name] instanceof Enum)
	        return this.nested[name].values;
	    throw Error("no such enum: " + name);
	};

	/**
	 * Adds a nested object to this namespace.
	 * @param {ReflectionObject} object Nested object to add
	 * @returns {Namespace} `this`
	 * @throws {TypeError} If arguments are invalid
	 * @throws {Error} If there is already a nested object with this name
	 */
	Namespace.prototype.add = function add(object) {

	    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type  || object instanceof OneOf || object instanceof Enum || object instanceof Service || object instanceof Namespace))
	        throw TypeError("object must be a valid nested object");

	    if (!this.nested)
	        this.nested = {};
	    else {
	        var prev = this.get(object.name);
	        if (prev) {
	            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
	                // replace plain namespace but keep existing nested elements and options
	                var nested = prev.nestedArray;
	                for (var i = 0; i < nested.length; ++i)
	                    object.add(nested[i]);
	                this.remove(prev);
	                if (!this.nested)
	                    this.nested = {};
	                object.setOptions(prev.options, true);

	            } else
	                throw Error("duplicate name '" + object.name + "' in " + this);
	        }
	    }
	    this.nested[object.name] = object;
	    object.onAdd(this);
	    return clearCache(this);
	};

	/**
	 * Removes a nested object from this namespace.
	 * @param {ReflectionObject} object Nested object to remove
	 * @returns {Namespace} `this`
	 * @throws {TypeError} If arguments are invalid
	 * @throws {Error} If `object` is not a member of this namespace
	 */
	Namespace.prototype.remove = function remove(object) {

	    if (!(object instanceof ReflectionObject))
	        throw TypeError("object must be a ReflectionObject");
	    if (object.parent !== this)
	        throw Error(object + " is not a member of " + this);

	    delete this.nested[object.name];
	    if (!Object.keys(this.nested).length)
	        this.nested = undefined;

	    object.onRemove(this);
	    return clearCache(this);
	};

	/**
	 * Defines additial namespaces within this one if not yet existing.
	 * @param {string|string[]} path Path to create
	 * @param {*} [json] Nested types to create from JSON
	 * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty
	 */
	Namespace.prototype.define = function define(path, json) {

	    if (util.isString(path))
	        path = path.split(".");
	    else if (!Array.isArray(path))
	        throw TypeError("illegal path");
	    if (path && path.length && path[0] === "")
	        throw Error("path must be relative");

	    var ptr = this;
	    while (path.length > 0) {
	        var part = path.shift();
	        if (ptr.nested && ptr.nested[part]) {
	            ptr = ptr.nested[part];
	            if (!(ptr instanceof Namespace))
	                throw Error("path conflicts with non-namespace objects");
	        } else
	            ptr.add(ptr = new Namespace(part));
	    }
	    if (json)
	        ptr.addJSON(json);
	    return ptr;
	};

	/**
	 * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.
	 * @returns {Namespace} `this`
	 */
	Namespace.prototype.resolveAll = function resolveAll() {
	    var nested = this.nestedArray, i = 0;
	    while (i < nested.length)
	        if (nested[i] instanceof Namespace)
	            nested[i++].resolveAll();
	        else
	            nested[i++].resolve();
	    return this.resolve();
	};

	/**
	 * Recursively looks up the reflection object matching the specified path in the scope of this namespace.
	 * @param {string|string[]} path Path to look up
	 * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.
	 * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked
	 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
	 */
	Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {

	    /* istanbul ignore next */
	    if (typeof filterTypes === "boolean") {
	        parentAlreadyChecked = filterTypes;
	        filterTypes = undefined;
	    } else if (filterTypes && !Array.isArray(filterTypes))
	        filterTypes = [ filterTypes ];

	    if (util.isString(path) && path.length) {
	        if (path === ".")
	            return this.root;
	        path = path.split(".");
	    } else if (!path.length)
	        return this;

	    // Start at root if path is absolute
	    if (path[0] === "")
	        return this.root.lookup(path.slice(1), filterTypes);

	    // Test if the first part matches any nested object, and if so, traverse if path contains more
	    var found = this.get(path[0]);
	    if (found) {
	        if (path.length === 1) {
	            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)
	                return found;
	        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))
	            return found;

	    // Otherwise try each nested namespace
	    } else
	        for (var i = 0; i < this.nestedArray.length; ++i)
	            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))
	                return found;

	    // If there hasn't been a match, try again at the parent
	    if (this.parent === null || parentAlreadyChecked)
	        return null;
	    return this.parent.lookup(path, filterTypes);
	};

	/**
	 * Looks up the reflection object at the specified path, relative to this namespace.
	 * @name NamespaceBase#lookup
	 * @function
	 * @param {string|string[]} path Path to look up
	 * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked
	 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
	 * @variation 2
	 */
	// lookup(path: string, [parentAlreadyChecked: boolean])

	/**
	 * Looks up the {@link Type|type} at the specified path, relative to this namespace.
	 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
	 * @param {string|string[]} path Path to look up
	 * @returns {Type} Looked up type
	 * @throws {Error} If `path` does not point to a type
	 */
	Namespace.prototype.lookupType = function lookupType(path) {
	    var found = this.lookup(path, [ Type ]);
	    if (!found)
	        throw Error("no such type: " + path);
	    return found;
	};

	/**
	 * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.
	 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
	 * @param {string|string[]} path Path to look up
	 * @returns {Enum} Looked up enum
	 * @throws {Error} If `path` does not point to an enum
	 */
	Namespace.prototype.lookupEnum = function lookupEnum(path) {
	    var found = this.lookup(path, [ Enum ]);
	    if (!found)
	        throw Error("no such Enum '" + path + "' in " + this);
	    return found;
	};

	/**
	 * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.
	 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
	 * @param {string|string[]} path Path to look up
	 * @returns {Type} Looked up type or enum
	 * @throws {Error} If `path` does not point to a type or enum
	 */
	Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
	    var found = this.lookup(path, [ Type, Enum ]);
	    if (!found)
	        throw Error("no such Type or Enum '" + path + "' in " + this);
	    return found;
	};

	/**
	 * Looks up the {@link Service|service} at the specified path, relative to this namespace.
	 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
	 * @param {string|string[]} path Path to look up
	 * @returns {Service} Looked up service
	 * @throws {Error} If `path` does not point to a service
	 */
	Namespace.prototype.lookupService = function lookupService(path) {
	    var found = this.lookup(path, [ Service ]);
	    if (!found)
	        throw Error("no such Service '" + path + "' in " + this);
	    return found;
	};

	// Sets up cyclic dependencies (called in index-light)
	Namespace._configure = function(Type_, Service_, Enum_) {
	    Type    = Type_;
	    Service = Service_;
	    Enum    = Enum_;
	};
	return namespace;
}

var mapfield;
var hasRequiredMapfield;

function requireMapfield () {
	if (hasRequiredMapfield) return mapfield;
	hasRequiredMapfield = 1;
	mapfield = MapField;

	// extends Field
	var Field = requireField();
	((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";

	var types   = requireTypes(),
	    util    = requireUtil$1();

	/**
	 * Constructs a new map field instance.
	 * @classdesc Reflected map field.
	 * @extends FieldBase
	 * @constructor
	 * @param {string} name Unique name within its namespace
	 * @param {number} id Unique id within its namespace
	 * @param {string} keyType Key type
	 * @param {string} type Value type
	 * @param {Object.<string,*>} [options] Declared options
	 * @param {string} [comment] Comment associated with this field
	 */
	function MapField(name, id, keyType, type, options, comment) {
	    Field.call(this, name, id, type, undefined, undefined, options, comment);

	    /* istanbul ignore if */
	    if (!util.isString(keyType))
	        throw TypeError("keyType must be a string");

	    /**
	     * Key type.
	     * @type {string}
	     */
	    this.keyType = keyType; // toJSON, marker

	    /**
	     * Resolved key type if not a basic type.
	     * @type {ReflectionObject|null}
	     */
	    this.resolvedKeyType = null;

	    // Overrides Field#map
	    this.map = true;
	}

	/**
	 * Map field descriptor.
	 * @interface IMapField
	 * @extends {IField}
	 * @property {string} keyType Key type
	 */

	/**
	 * Extension map field descriptor.
	 * @interface IExtensionMapField
	 * @extends IMapField
	 * @property {string} extend Extended type
	 */

	/**
	 * Constructs a map field from a map field descriptor.
	 * @param {string} name Field name
	 * @param {IMapField} json Map field descriptor
	 * @returns {MapField} Created map field
	 * @throws {TypeError} If arguments are invalid
	 */
	MapField.fromJSON = function fromJSON(name, json) {
	    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);
	};

	/**
	 * Converts this map field to a map field descriptor.
	 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
	 * @returns {IMapField} Map field descriptor
	 */
	MapField.prototype.toJSON = function toJSON(toJSONOptions) {
	    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
	    return util.toObject([
	        "keyType" , this.keyType,
	        "type"    , this.type,
	        "id"      , this.id,
	        "extend"  , this.extend,
	        "options" , this.options,
	        "comment" , keepComments ? this.comment : undefined
	    ]);
	};

	/**
	 * @override
	 */
	MapField.prototype.resolve = function resolve() {
	    if (this.resolved)
	        return this;

	    // Besides a value type, map fields have a key type that may be "any scalar type except for floating point types and bytes"
	    if (types.mapKey[this.keyType] === undefined)
	        throw Error("invalid key type: " + this.keyType);

	    return Field.prototype.resolve.call(this);
	};

	/**
	 * Map field decorator (TypeScript).
	 * @name MapField.d
	 * @function
	 * @param {number} fieldId Field id
	 * @param {"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"} fieldKeyType Field key type
	 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"|"bytes"|Object|Constructor<{}>} fieldValueType Field value type
	 * @returns {FieldDecorator} Decorator function
	 * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }
	 */
	MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {

	    // submessage value: decorate the submessage and use its name as the type
	    if (typeof fieldValueType === "function")
	        fieldValueType = util.decorateType(fieldValueType).name;

	    // enum reference value: create a reflected copy of the enum and keep reuseing it
	    else if (fieldValueType && typeof fieldValueType === "object")
	        fieldValueType = util.decorateEnum(fieldValueType).name;

	    return function mapFieldDecorator(prototype, fieldName) {
	        util.decorateType(prototype.constructor)
	            .add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
	    };
	};
	return mapfield;
}

var method;
var hasRequiredMethod;

function requireMethod () {
	if (hasRequiredMethod) return method;
	hasRequiredMethod = 1;
	method = Method;

	// extends ReflectionObject
	var ReflectionObject = requireObject();
	((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";

	var util = requireUtil$1();

	/**
	 * Constructs a new service method instance.
	 * @classdesc Reflected service method.
	 * @extends ReflectionObject
	 * @constructor
	 * @param {string} name Method name
	 * @param {string|undefined} type Method type, usually `"rpc"`
	 * @param {string} requestType Request message type
	 * @param {string} responseType Response message type
	 * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed
	 * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed
	 * @param {Object.<string,*>} [options] Declared options
	 * @param {string} [comment] The comment for this method
	 * @param {Object.<string,*>} [parsedOptions] Declared options, properly parsed into an object
	 */
	function Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {

	    /* istanbul ignore next */
	    if (util.isObject(requestStream)) {
	        options = requestStream;
	        requestStream = responseStream = undefined;
	    } else if (util.isObject(responseStream)) {
	        options = responseStream;
	        responseStream = undefined;
	    }

	    /* istanbul ignore if */
	    if (!(type === undefined || util.isString(type)))
	        throw TypeError("type must be a string");

	    /* istanbul ignore if */
	    if (!util.isString(requestType))
	        throw TypeError("requestType must be a string");

	    /* istanbul ignore if */
	    if (!util.isString(responseType))
	        throw TypeError("responseType must be a string");

	    ReflectionObject.call(this, name, options);

	    /**
	     * Method type.
	     * @type {string}
	     */
	    this.type = type || "rpc"; // toJSON

	    /**
	     * Request type.
	     * @type {string}
	     */
	    this.requestType = requestType; // toJSON, marker

	    /**
	     * Whether requests are streamed or not.
	     * @type {boolean|undefined}
	     */
	    this.requestStream = requestStream ? true : undefined; // toJSON

	    /**
	     * Response type.
	     * @type {string}
	     */
	    this.responseType = responseType; // toJSON

	    /**
	     * Whether responses are streamed or not.
	     * @type {boolean|undefined}
	     */
	    this.responseStream = responseStream ? true : undefined; // toJSON

	    /**
	     * Resolved request type.
	     * @type {Type|null}
	     */
	    this.resolvedRequestType = null;

	    /**
	     * Resolved response type.
	     * @type {Type|null}
	     */
	    this.resolvedResponseType = null;

	    /**
	     * Comment for this method
	     * @type {string|null}
	     */
	    this.comment = comment;

	    /**
	     * Options properly parsed into an object
	     */
	    this.parsedOptions = parsedOptions;
	}

	/**
	 * Method descriptor.
	 * @interface IMethod
	 * @property {string} [type="rpc"] Method type
	 * @property {string} requestType Request type
	 * @property {string} responseType Response type
	 * @property {boolean} [requestStream=false] Whether requests are streamed
	 * @property {boolean} [responseStream=false] Whether responses are streamed
	 * @property {Object.<string,*>} [options] Method options
	 * @property {string} comment Method comments
	 * @property {Object.<string,*>} [parsedOptions] Method options properly parsed into an object
	 */

	/**
	 * Constructs a method from a method descriptor.
	 * @param {string} name Method name
	 * @param {IMethod} json Method descriptor
	 * @returns {Method} Created method
	 * @throws {TypeError} If arguments are invalid
	 */
	Method.fromJSON = function fromJSON(name, json) {
	    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);
	};

	/**
	 * Converts this method to a method descriptor.
	 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
	 * @returns {IMethod} Method descriptor
	 */
	Method.prototype.toJSON = function toJSON(toJSONOptions) {
	    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
	    return util.toObject([
	        "type"           , this.type !== "rpc" && /* istanbul ignore next */ this.type || undefined,
	        "requestType"    , this.requestType,
	        "requestStream"  , this.requestStream,
	        "responseType"   , this.responseType,
	        "responseStream" , this.responseStream,
	        "options"        , this.options,
	        "comment"        , keepComments ? this.comment : undefined,
	        "parsedOptions"  , this.parsedOptions,
	    ]);
	};

	/**
	 * @override
	 */
	Method.prototype.resolve = function resolve() {

	    /* istanbul ignore if */
	    if (this.resolved)
	        return this;

	    this.resolvedRequestType = this.parent.lookupType(this.requestType);
	    this.resolvedResponseType = this.parent.lookupType(this.responseType);

	    return ReflectionObject.prototype.resolve.call(this);
	};
	return method;
}

var service;
var hasRequiredService;

function requireService () {
	if (hasRequiredService) return service;
	hasRequiredService = 1;
	service = Service;

	// extends Namespace
	var Namespace = requireNamespace();
	((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";

	var Method = requireMethod(),
	    util   = requireUtil$1(),
	    rpc    = requireRpc();

	/**
	 * Constructs a new service instance.
	 * @classdesc Reflected service.
	 * @extends NamespaceBase
	 * @constructor
	 * @param {string} name Service name
	 * @param {Object.<string,*>} [options] Service options
	 * @throws {TypeError} If arguments are invalid
	 */
	function Service(name, options) {
	    Namespace.call(this, name, options);

	    /**
	     * Service methods.
	     * @type {Object.<string,Method>}
	     */
	    this.methods = {}; // toJSON, marker

	    /**
	     * Cached methods as an array.
	     * @type {Method[]|null}
	     * @private
	     */
	    this._methodsArray = null;
	}

	/**
	 * Service descriptor.
	 * @interface IService
	 * @extends INamespace
	 * @property {Object.<string,IMethod>} methods Method descriptors
	 */

	/**
	 * Constructs a service from a service descriptor.
	 * @param {string} name Service name
	 * @param {IService} json Service descriptor
	 * @returns {Service} Created service
	 * @throws {TypeError} If arguments are invalid
	 */
	Service.fromJSON = function fromJSON(name, json) {
	    var service = new Service(name, json.options);
	    /* istanbul ignore else */
	    if (json.methods)
	        for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)
	            service.add(Method.fromJSON(names[i], json.methods[names[i]]));
	    if (json.nested)
	        service.addJSON(json.nested);
	    service.comment = json.comment;
	    return service;
	};

	/**
	 * Converts this service to a service descriptor.
	 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
	 * @returns {IService} Service descriptor
	 */
	Service.prototype.toJSON = function toJSON(toJSONOptions) {
	    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
	    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
	    return util.toObject([
	        "options" , inherited && inherited.options || undefined,
	        "methods" , Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */ {},
	        "nested"  , inherited && inherited.nested || undefined,
	        "comment" , keepComments ? this.comment : undefined
	    ]);
	};

	/**
	 * Methods of this service as an array for iteration.
	 * @name Service#methodsArray
	 * @type {Method[]}
	 * @readonly
	 */
	Object.defineProperty(Service.prototype, "methodsArray", {
	    get: function() {
	        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
	    }
	});

	function clearCache(service) {
	    service._methodsArray = null;
	    return service;
	}

	/**
	 * @override
	 */
	Service.prototype.get = function get(name) {
	    return this.methods[name]
	        || Namespace.prototype.get.call(this, name);
	};

	/**
	 * @override
	 */
	Service.prototype.resolveAll = function resolveAll() {
	    var methods = this.methodsArray;
	    for (var i = 0; i < methods.length; ++i)
	        methods[i].resolve();
	    return Namespace.prototype.resolve.call(this);
	};

	/**
	 * @override
	 */
	Service.prototype.add = function add(object) {

	    /* istanbul ignore if */
	    if (this.get(object.name))
	        throw Error("duplicate name '" + object.name + "' in " + this);

	    if (object instanceof Method) {
	        this.methods[object.name] = object;
	        object.parent = this;
	        return clearCache(this);
	    }
	    return Namespace.prototype.add.call(this, object);
	};

	/**
	 * @override
	 */
	Service.prototype.remove = function remove(object) {
	    if (object instanceof Method) {

	        /* istanbul ignore if */
	        if (this.methods[object.name] !== object)
	            throw Error(object + " is not a member of " + this);

	        delete this.methods[object.name];
	        object.parent = null;
	        return clearCache(this);
	    }
	    return Namespace.prototype.remove.call(this, object);
	};

	/**
	 * Creates a runtime service using the specified rpc implementation.
	 * @param {RPCImpl} rpcImpl RPC implementation
	 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
	 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
	 * @returns {rpc.Service} RPC service. Useful where requests and/or responses are streamed.
	 */
	Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
	    var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
	    for (var i = 0, method; i < /* initializes */ this.methodsArray.length; ++i) {
	        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
	        rpcService[methodName] = util.codegen(["r","c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
	            m: method,
	            q: method.resolvedRequestType.ctor,
	            s: method.resolvedResponseType.ctor
	        });
	    }
	    return rpcService;
	};
	return service;
}

var message;
var hasRequiredMessage;

function requireMessage () {
	if (hasRequiredMessage) return message;
	hasRequiredMessage = 1;
	message = Message;

	var util = requireMinimal$1();

	/**
	 * Constructs a new message instance.
	 * @classdesc Abstract runtime message.
	 * @constructor
	 * @param {Properties<T>} [properties] Properties to set
	 * @template T extends object = object
	 */
	function Message(properties) {
	    // not used internally
	    if (properties)
	        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	            this[keys[i]] = properties[keys[i]];
	}

	/**
	 * Reference to the reflected type.
	 * @name Message.$type
	 * @type {Type}
	 * @readonly
	 */

	/**
	 * Reference to the reflected type.
	 * @name Message#$type
	 * @type {Type}
	 * @readonly
	 */

	/*eslint-disable valid-jsdoc*/

	/**
	 * Creates a new message of this type using the specified properties.
	 * @param {Object.<string,*>} [properties] Properties to set
	 * @returns {Message<T>} Message instance
	 * @template T extends Message<T>
	 * @this Constructor<T>
	 */
	Message.create = function create(properties) {
	    return this.$type.create(properties);
	};

	/**
	 * Encodes a message of this type.
	 * @param {T|Object.<string,*>} message Message to encode
	 * @param {Writer} [writer] Writer to use
	 * @returns {Writer} Writer
	 * @template T extends Message<T>
	 * @this Constructor<T>
	 */
	Message.encode = function encode(message, writer) {
	    return this.$type.encode(message, writer);
	};

	/**
	 * Encodes a message of this type preceeded by its length as a varint.
	 * @param {T|Object.<string,*>} message Message to encode
	 * @param {Writer} [writer] Writer to use
	 * @returns {Writer} Writer
	 * @template T extends Message<T>
	 * @this Constructor<T>
	 */
	Message.encodeDelimited = function encodeDelimited(message, writer) {
	    return this.$type.encodeDelimited(message, writer);
	};

	/**
	 * Decodes a message of this type.
	 * @name Message.decode
	 * @function
	 * @param {Reader|Uint8Array} reader Reader or buffer to decode
	 * @returns {T} Decoded message
	 * @template T extends Message<T>
	 * @this Constructor<T>
	 */
	Message.decode = function decode(reader) {
	    return this.$type.decode(reader);
	};

	/**
	 * Decodes a message of this type preceeded by its length as a varint.
	 * @name Message.decodeDelimited
	 * @function
	 * @param {Reader|Uint8Array} reader Reader or buffer to decode
	 * @returns {T} Decoded message
	 * @template T extends Message<T>
	 * @this Constructor<T>
	 */
	Message.decodeDelimited = function decodeDelimited(reader) {
	    return this.$type.decodeDelimited(reader);
	};

	/**
	 * Verifies a message of this type.
	 * @name Message.verify
	 * @function
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	Message.verify = function verify(message) {
	    return this.$type.verify(message);
	};

	/**
	 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
	 * @param {Object.<string,*>} object Plain object
	 * @returns {T} Message instance
	 * @template T extends Message<T>
	 * @this Constructor<T>
	 */
	Message.fromObject = function fromObject(object) {
	    return this.$type.fromObject(object);
	};

	/**
	 * Creates a plain object from a message of this type. Also converts values to other types if specified.
	 * @param {T} message Message instance
	 * @param {IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 * @template T extends Message<T>
	 * @this Constructor<T>
	 */
	Message.toObject = function toObject(message, options) {
	    return this.$type.toObject(message, options);
	};

	/**
	 * Converts this message to JSON.
	 * @returns {Object.<string,*>} JSON object
	 */
	Message.prototype.toJSON = function toJSON() {
	    return this.$type.toObject(this, util.toJSONOptions);
	};

	/*eslint-enable valid-jsdoc*/
	return message;
}

var decoder_1;
var hasRequiredDecoder;

function requireDecoder () {
	if (hasRequiredDecoder) return decoder_1;
	hasRequiredDecoder = 1;
	decoder_1 = decoder;

	var Enum    = require_enum(),
	    types   = requireTypes(),
	    util    = requireUtil$1();

	function missing(field) {
	    return "missing required '" + field.name + "'";
	}

	/**
	 * Generates a decoder specific to the specified message type.
	 * @param {Type} mtype Message type
	 * @returns {Codegen} Codegen instance
	 */
	function decoder(mtype) {
	    /* eslint-disable no-unexpected-multiline */
	    var gen = util.codegen(["r", "l"], mtype.name + "$decode")
	    ("if(!(r instanceof Reader))")
	        ("r=Reader.create(r)")
	    ("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field) { return field.map; }).length ? ",k,value" : ""))
	    ("while(r.pos<c){")
	        ("var t=r.uint32()");
	    if (mtype.group) gen
	        ("if((t&7)===4)")
	            ("break");
	    gen
	        ("switch(t>>>3){");

	    var i = 0;
	    for (; i < /* initializes */ mtype.fieldsArray.length; ++i) {
	        var field = mtype._fieldsArray[i].resolve(),
	            type  = field.resolvedType instanceof Enum ? "int32" : field.type,
	            ref   = "m" + util.safeProp(field.name); gen
	            ("case %i: {", field.id);

	        // Map fields
	        if (field.map) { gen
	                ("if(%s===util.emptyObject)", ref)
	                    ("%s={}", ref)
	                ("var c2 = r.uint32()+r.pos");

	            if (types.defaults[field.keyType] !== undefined) gen
	                ("k=%j", types.defaults[field.keyType]);
	            else gen
	                ("k=null");

	            if (types.defaults[type] !== undefined) gen
	                ("value=%j", types.defaults[type]);
	            else gen
	                ("value=null");

	            gen
	                ("while(r.pos<c2){")
	                    ("var tag2=r.uint32()")
	                    ("switch(tag2>>>3){")
	                        ("case 1: k=r.%s(); break", field.keyType)
	                        ("case 2:");

	            if (types.basic[type] === undefined) gen
	                            ("value=types[%i].decode(r,r.uint32())", i); // can't be groups
	            else gen
	                            ("value=r.%s()", type);

	            gen
	                            ("break")
	                        ("default:")
	                            ("r.skipType(tag2&7)")
	                            ("break")
	                    ("}")
	                ("}");

	            if (types.long[field.keyType] !== undefined) gen
	                ("%s[typeof k===\"object\"?util.longToHash(k):k]=value", ref);
	            else gen
	                ("%s[k]=value", ref);

	        // Repeated fields
	        } else if (field.repeated) { gen

	                ("if(!(%s&&%s.length))", ref, ref)
	                    ("%s=[]", ref);

	            // Packable (always check for forward and backward compatiblity)
	            if (types.packed[type] !== undefined) gen
	                ("if((t&7)===2){")
	                    ("var c2=r.uint32()+r.pos")
	                    ("while(r.pos<c2)")
	                        ("%s.push(r.%s())", ref, type)
	                ("}else");

	            // Non-packed
	            if (types.basic[type] === undefined) gen(field.resolvedType.group
	                    ? "%s.push(types[%i].decode(r))"
	                    : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);
	            else gen
	                    ("%s.push(r.%s())", ref, type);

	        // Non-repeated
	        } else if (types.basic[type] === undefined) gen(field.resolvedType.group
	                ? "%s=types[%i].decode(r)"
	                : "%s=types[%i].decode(r,r.uint32())", ref, i);
	        else gen
	                ("%s=r.%s()", ref, type);
	        gen
	                ("break")
	            ("}");
	        // Unknown fields
	    } gen
	            ("default:")
	                ("r.skipType(t&7)")
	                ("break")

	        ("}")
	    ("}");

	    // Field presence
	    for (i = 0; i < mtype._fieldsArray.length; ++i) {
	        var rfield = mtype._fieldsArray[i];
	        if (rfield.required) gen
	    ("if(!m.hasOwnProperty(%j))", rfield.name)
	        ("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
	    }

	    return gen
	    ("return m");
	    /* eslint-enable no-unexpected-multiline */
	}
	return decoder_1;
}

var verifier_1;
var hasRequiredVerifier;

function requireVerifier () {
	if (hasRequiredVerifier) return verifier_1;
	hasRequiredVerifier = 1;
	verifier_1 = verifier;

	var Enum      = require_enum(),
	    util      = requireUtil$1();

	function invalid(field, expected) {
	    return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:"+field.keyType+"}" : "") + " expected";
	}

	/**
	 * Generates a partial value verifier.
	 * @param {Codegen} gen Codegen instance
	 * @param {Field} field Reflected field
	 * @param {number} fieldIndex Field index
	 * @param {string} ref Variable reference
	 * @returns {Codegen} Codegen instance
	 * @ignore
	 */
	function genVerifyValue(gen, field, fieldIndex, ref) {
	    /* eslint-disable no-unexpected-multiline */
	    if (field.resolvedType) {
	        if (field.resolvedType instanceof Enum) { gen
	            ("switch(%s){", ref)
	                ("default:")
	                    ("return%j", invalid(field, "enum value"));
	            for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) gen
	                ("case %i:", field.resolvedType.values[keys[j]]);
	            gen
	                    ("break")
	            ("}");
	        } else {
	            gen
	            ("{")
	                ("var e=types[%i].verify(%s);", fieldIndex, ref)
	                ("if(e)")
	                    ("return%j+e", field.name + ".")
	            ("}");
	        }
	    } else {
	        switch (field.type) {
	            case "int32":
	            case "uint32":
	            case "sint32":
	            case "fixed32":
	            case "sfixed32": gen
	                ("if(!util.isInteger(%s))", ref)
	                    ("return%j", invalid(field, "integer"));
	                break;
	            case "int64":
	            case "uint64":
	            case "sint64":
	            case "fixed64":
	            case "sfixed64": gen
	                ("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)
	                    ("return%j", invalid(field, "integer|Long"));
	                break;
	            case "float":
	            case "double": gen
	                ("if(typeof %s!==\"number\")", ref)
	                    ("return%j", invalid(field, "number"));
	                break;
	            case "bool": gen
	                ("if(typeof %s!==\"boolean\")", ref)
	                    ("return%j", invalid(field, "boolean"));
	                break;
	            case "string": gen
	                ("if(!util.isString(%s))", ref)
	                    ("return%j", invalid(field, "string"));
	                break;
	            case "bytes": gen
	                ("if(!(%s&&typeof %s.length===\"number\"||util.isString(%s)))", ref, ref, ref)
	                    ("return%j", invalid(field, "buffer"));
	                break;
	        }
	    }
	    return gen;
	    /* eslint-enable no-unexpected-multiline */
	}

	/**
	 * Generates a partial key verifier.
	 * @param {Codegen} gen Codegen instance
	 * @param {Field} field Reflected field
	 * @param {string} ref Variable reference
	 * @returns {Codegen} Codegen instance
	 * @ignore
	 */
	function genVerifyKey(gen, field, ref) {
	    /* eslint-disable no-unexpected-multiline */
	    switch (field.keyType) {
	        case "int32":
	        case "uint32":
	        case "sint32":
	        case "fixed32":
	        case "sfixed32": gen
	            ("if(!util.key32Re.test(%s))", ref)
	                ("return%j", invalid(field, "integer key"));
	            break;
	        case "int64":
	        case "uint64":
	        case "sint64":
	        case "fixed64":
	        case "sfixed64": gen
	            ("if(!util.key64Re.test(%s))", ref) // see comment above: x is ok, d is not
	                ("return%j", invalid(field, "integer|Long key"));
	            break;
	        case "bool": gen
	            ("if(!util.key2Re.test(%s))", ref)
	                ("return%j", invalid(field, "boolean key"));
	            break;
	    }
	    return gen;
	    /* eslint-enable no-unexpected-multiline */
	}

	/**
	 * Generates a verifier specific to the specified message type.
	 * @param {Type} mtype Message type
	 * @returns {Codegen} Codegen instance
	 */
	function verifier(mtype) {
	    /* eslint-disable no-unexpected-multiline */

	    var gen = util.codegen(["m"], mtype.name + "$verify")
	    ("if(typeof m!==\"object\"||m===null)")
	        ("return%j", "object expected");
	    var oneofs = mtype.oneofsArray,
	        seenFirstField = {};
	    if (oneofs.length) gen
	    ("var p={}");

	    for (var i = 0; i < /* initializes */ mtype.fieldsArray.length; ++i) {
	        var field = mtype._fieldsArray[i].resolve(),
	            ref   = "m" + util.safeProp(field.name);

	        if (field.optional) gen
	        ("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name); // !== undefined && !== null

	        // map fields
	        if (field.map) { gen
	            ("if(!util.isObject(%s))", ref)
	                ("return%j", invalid(field, "object"))
	            ("var k=Object.keys(%s)", ref)
	            ("for(var i=0;i<k.length;++i){");
	                genVerifyKey(gen, field, "k[i]");
	                genVerifyValue(gen, field, i, ref + "[k[i]]")
	            ("}");

	        // repeated fields
	        } else if (field.repeated) { gen
	            ("if(!Array.isArray(%s))", ref)
	                ("return%j", invalid(field, "array"))
	            ("for(var i=0;i<%s.length;++i){", ref);
	                genVerifyValue(gen, field, i, ref + "[i]")
	            ("}");

	        // required or present fields
	        } else {
	            if (field.partOf) {
	                var oneofProp = util.safeProp(field.partOf.name);
	                if (seenFirstField[field.partOf.name] === 1) gen
	            ("if(p%s===1)", oneofProp)
	                ("return%j", field.partOf.name + ": multiple values");
	                seenFirstField[field.partOf.name] = 1;
	                gen
	            ("p%s=1", oneofProp);
	            }
	            genVerifyValue(gen, field, i, ref);
	        }
	        if (field.optional) gen
	        ("}");
	    }
	    return gen
	    ("return null");
	    /* eslint-enable no-unexpected-multiline */
	}
	return verifier_1;
}

var converter = {};

var hasRequiredConverter;

function requireConverter () {
	if (hasRequiredConverter) return converter;
	hasRequiredConverter = 1;
	(function (exports) {
		/**
		 * Runtime message from/to plain object converters.
		 * @namespace
		 */
		var converter = exports;

		var Enum = require_enum(),
		    util = requireUtil$1();

		/**
		 * Generates a partial value fromObject conveter.
		 * @param {Codegen} gen Codegen instance
		 * @param {Field} field Reflected field
		 * @param {number} fieldIndex Field index
		 * @param {string} prop Property reference
		 * @returns {Codegen} Codegen instance
		 * @ignore
		 */
		function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
		    var defaultAlreadyEmitted = false;
		    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
		    if (field.resolvedType) {
		        if (field.resolvedType instanceof Enum) { gen
		            ("switch(d%s){", prop);
		            for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
		                // enum unknown values passthrough
		                if (values[keys[i]] === field.typeDefault && !defaultAlreadyEmitted) { gen
		                    ("default:")
		                        ("if(typeof(d%s)===\"number\"){m%s=d%s;break}", prop, prop, prop);
		                    if (!field.repeated) gen // fallback to default value only for
		                                             // arrays, to avoid leaving holes.
		                        ("break");           // for non-repeated fields, just ignore
		                    defaultAlreadyEmitted = true;
		                }
		                gen
		                ("case%j:", keys[i])
		                ("case %i:", values[keys[i]])
		                    ("m%s=%j", prop, values[keys[i]])
		                    ("break");
		            } gen
		            ("}");
		        } else gen
		            ("if(typeof d%s!==\"object\")", prop)
		                ("throw TypeError(%j)", field.fullName + ": object expected")
		            ("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
		    } else {
		        var isUnsigned = false;
		        switch (field.type) {
		            case "double":
		            case "float": gen
		                ("m%s=Number(d%s)", prop, prop); // also catches "NaN", "Infinity"
		                break;
		            case "uint32":
		            case "fixed32": gen
		                ("m%s=d%s>>>0", prop, prop);
		                break;
		            case "int32":
		            case "sint32":
		            case "sfixed32": gen
		                ("m%s=d%s|0", prop, prop);
		                break;
		            case "uint64":
		                isUnsigned = true;
		                // eslint-disable-next-line no-fallthrough
		            case "int64":
		            case "sint64":
		            case "fixed64":
		            case "sfixed64": gen
		                ("if(util.Long)")
		                    ("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)
		                ("else if(typeof d%s===\"string\")", prop)
		                    ("m%s=parseInt(d%s,10)", prop, prop)
		                ("else if(typeof d%s===\"number\")", prop)
		                    ("m%s=d%s", prop, prop)
		                ("else if(typeof d%s===\"object\")", prop)
		                    ("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
		                break;
		            case "bytes": gen
		                ("if(typeof d%s===\"string\")", prop)
		                    ("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)
		                ("else if(d%s.length >= 0)", prop)
		                    ("m%s=d%s", prop, prop);
		                break;
		            case "string": gen
		                ("m%s=String(d%s)", prop, prop);
		                break;
		            case "bool": gen
		                ("m%s=Boolean(d%s)", prop, prop);
		                break;
		            /* default: gen
		                ("m%s=d%s", prop, prop);
		                break; */
		        }
		    }
		    return gen;
		    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
		}

		/**
		 * Generates a plain object to runtime message converter specific to the specified message type.
		 * @param {Type} mtype Message type
		 * @returns {Codegen} Codegen instance
		 */
		converter.fromObject = function fromObject(mtype) {
		    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
		    var fields = mtype.fieldsArray;
		    var gen = util.codegen(["d"], mtype.name + "$fromObject")
		    ("if(d instanceof this.ctor)")
		        ("return d");
		    if (!fields.length) return gen
		    ("return new this.ctor");
		    gen
		    ("var m=new this.ctor");
		    for (var i = 0; i < fields.length; ++i) {
		        var field  = fields[i].resolve(),
		            prop   = util.safeProp(field.name);

		        // Map fields
		        if (field.map) { gen
		    ("if(d%s){", prop)
		        ("if(typeof d%s!==\"object\")", prop)
		            ("throw TypeError(%j)", field.fullName + ": object expected")
		        ("m%s={}", prop)
		        ("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
		            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[ks[i]]")
		        ("}")
		    ("}");

		        // Repeated fields
		        } else if (field.repeated) { gen
		    ("if(d%s){", prop)
		        ("if(!Array.isArray(d%s))", prop)
		            ("throw TypeError(%j)", field.fullName + ": array expected")
		        ("m%s=[]", prop)
		        ("for(var i=0;i<d%s.length;++i){", prop);
		            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[i]")
		        ("}")
		    ("}");

		        // Non-repeated fields
		        } else {
		            if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)
		    ("if(d%s!=null){", prop); // !== undefined && !== null
		        genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);
		            if (!(field.resolvedType instanceof Enum)) gen
		    ("}");
		        }
		    } return gen
		    ("return m");
		    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
		};

		/**
		 * Generates a partial value toObject converter.
		 * @param {Codegen} gen Codegen instance
		 * @param {Field} field Reflected field
		 * @param {number} fieldIndex Field index
		 * @param {string} prop Property reference
		 * @returns {Codegen} Codegen instance
		 * @ignore
		 */
		function genValuePartial_toObject(gen, field, fieldIndex, prop) {
		    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
		    if (field.resolvedType) {
		        if (field.resolvedType instanceof Enum) gen
		            ("d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s", prop, fieldIndex, prop, prop, fieldIndex, prop, prop);
		        else gen
		            ("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
		    } else {
		        var isUnsigned = false;
		        switch (field.type) {
		            case "double":
		            case "float": gen
		            ("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
		                break;
		            case "uint64":
		                isUnsigned = true;
		                // eslint-disable-next-line no-fallthrough
		            case "int64":
		            case "sint64":
		            case "fixed64":
		            case "sfixed64": gen
		            ("if(typeof m%s===\"number\")", prop)
		                ("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)
		            ("else") // Long-like
		                ("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true": "", prop);
		                break;
		            case "bytes": gen
		            ("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
		                break;
		            default: gen
		            ("d%s=m%s", prop, prop);
		                break;
		        }
		    }
		    return gen;
		    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
		}

		/**
		 * Generates a runtime message to plain object converter specific to the specified message type.
		 * @param {Type} mtype Message type
		 * @returns {Codegen} Codegen instance
		 */
		converter.toObject = function toObject(mtype) {
		    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
		    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
		    if (!fields.length)
		        return util.codegen()("return {}");
		    var gen = util.codegen(["m", "o"], mtype.name + "$toObject")
		    ("if(!o)")
		        ("o={}")
		    ("var d={}");

		    var repeatedFields = [],
		        mapFields = [],
		        normalFields = [],
		        i = 0;
		    for (; i < fields.length; ++i)
		        if (!fields[i].partOf)
		            ( fields[i].resolve().repeated ? repeatedFields
		            : fields[i].map ? mapFields
		            : normalFields).push(fields[i]);

		    if (repeatedFields.length) { gen
		    ("if(o.arrays||o.defaults){");
		        for (i = 0; i < repeatedFields.length; ++i) gen
		        ("d%s=[]", util.safeProp(repeatedFields[i].name));
		        gen
		    ("}");
		    }

		    if (mapFields.length) { gen
		    ("if(o.objects||o.defaults){");
		        for (i = 0; i < mapFields.length; ++i) gen
		        ("d%s={}", util.safeProp(mapFields[i].name));
		        gen
		    ("}");
		    }

		    if (normalFields.length) { gen
		    ("if(o.defaults){");
		        for (i = 0; i < normalFields.length; ++i) {
		            var field = normalFields[i],
		                prop  = util.safeProp(field.name);
		            if (field.resolvedType instanceof Enum) gen
		        ("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
		            else if (field.long) gen
		        ("if(util.Long){")
		            ("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)
		            ("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)
		        ("}else")
		            ("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
		            else if (field.bytes) {
		                var arrayDefault = "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]";
		                gen
		        ("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field.typeDefault))
		        ("else{")
		            ("d%s=%s", prop, arrayDefault)
		            ("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)
		        ("}");
		            } else gen
		        ("d%s=%j", prop, field.typeDefault); // also messages (=null)
		        } gen
		    ("}");
		    }
		    var hasKs2 = false;
		    for (i = 0; i < fields.length; ++i) {
		        var field = fields[i],
		            index = mtype._fieldsArray.indexOf(field),
		            prop  = util.safeProp(field.name);
		        if (field.map) {
		            if (!hasKs2) { hasKs2 = true; gen
		    ("var ks2");
		            } gen
		    ("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)
		        ("d%s={}", prop)
		        ("for(var j=0;j<ks2.length;++j){");
		            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[ks2[j]]")
		        ("}");
		        } else if (field.repeated) { gen
		    ("if(m%s&&m%s.length){", prop, prop)
		        ("d%s=[]", prop)
		        ("for(var j=0;j<m%s.length;++j){", prop);
		            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[j]")
		        ("}");
		        } else { gen
		    ("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name); // !== undefined && !== null
		        genValuePartial_toObject(gen, field, /* sorted */ index, prop);
		        if (field.partOf) gen
		        ("if(o.oneofs)")
		            ("d%s=%j", util.safeProp(field.partOf.name), field.name);
		        }
		        gen
		    ("}");
		    }
		    return gen
		    ("return d");
		    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
		}; 
	} (converter));
	return converter;
}

var wrappers = {};

var hasRequiredWrappers;

function requireWrappers () {
	if (hasRequiredWrappers) return wrappers;
	hasRequiredWrappers = 1;
	(function (exports) {

		/**
		 * Wrappers for common types.
		 * @type {Object.<string,IWrapper>}
		 * @const
		 */
		var wrappers = exports;

		var Message = requireMessage();

		/**
		 * From object converter part of an {@link IWrapper}.
		 * @typedef WrapperFromObjectConverter
		 * @type {function}
		 * @param {Object.<string,*>} object Plain object
		 * @returns {Message<{}>} Message instance
		 * @this Type
		 */

		/**
		 * To object converter part of an {@link IWrapper}.
		 * @typedef WrapperToObjectConverter
		 * @type {function}
		 * @param {Message<{}>} message Message instance
		 * @param {IConversionOptions} [options] Conversion options
		 * @returns {Object.<string,*>} Plain object
		 * @this Type
		 */

		/**
		 * Common type wrapper part of {@link wrappers}.
		 * @interface IWrapper
		 * @property {WrapperFromObjectConverter} [fromObject] From object converter
		 * @property {WrapperToObjectConverter} [toObject] To object converter
		 */

		// Custom wrapper for Any
		wrappers[".google.protobuf.Any"] = {

		    fromObject: function(object) {

		        // unwrap value type if mapped
		        if (object && object["@type"]) {
		             // Only use fully qualified type name after the last '/'
		            var name = object["@type"].substring(object["@type"].lastIndexOf("/") + 1);
		            var type = this.lookup(name);
		            /* istanbul ignore else */
		            if (type) {
		                // type_url does not accept leading "."
		                var type_url = object["@type"].charAt(0) === "." ?
		                    object["@type"].slice(1) : object["@type"];
		                // type_url prefix is optional, but path seperator is required
		                if (type_url.indexOf("/") === -1) {
		                    type_url = "/" + type_url;
		                }
		                return this.create({
		                    type_url: type_url,
		                    value: type.encode(type.fromObject(object)).finish()
		                });
		            }
		        }

		        return this.fromObject(object);
		    },

		    toObject: function(message, options) {

		        // Default prefix
		        var googleApi = "type.googleapis.com/";
		        var prefix = "";
		        var name = "";

		        // decode value if requested and unmapped
		        if (options && options.json && message.type_url && message.value) {
		            // Only use fully qualified type name after the last '/'
		            name = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
		            // Separate the prefix used
		            prefix = message.type_url.substring(0, message.type_url.lastIndexOf("/") + 1);
		            var type = this.lookup(name);
		            /* istanbul ignore else */
		            if (type)
		                message = type.decode(message.value);
		        }

		        // wrap value if unmapped
		        if (!(message instanceof this.ctor) && message instanceof Message) {
		            var object = message.$type.toObject(message, options);
		            var messageName = message.$type.fullName[0] === "." ?
		                message.$type.fullName.slice(1) : message.$type.fullName;
		            // Default to type.googleapis.com prefix if no prefix is used
		            if (prefix === "") {
		                prefix = googleApi;
		            }
		            name = prefix + messageName;
		            object["@type"] = name;
		            return object;
		        }

		        return this.toObject(message, options);
		    }
		}; 
	} (wrappers));
	return wrappers;
}

var type;
var hasRequiredType;

function requireType () {
	if (hasRequiredType) return type;
	hasRequiredType = 1;
	type = Type;

	// extends Namespace
	var Namespace = requireNamespace();
	((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";

	var Enum      = require_enum(),
	    OneOf     = requireOneof(),
	    Field     = requireField(),
	    MapField  = requireMapfield(),
	    Service   = requireService(),
	    Message   = requireMessage(),
	    Reader    = requireReader(),
	    Writer    = requireWriter(),
	    util      = requireUtil$1(),
	    encoder   = requireEncoder(),
	    decoder   = requireDecoder(),
	    verifier  = requireVerifier(),
	    converter = requireConverter(),
	    wrappers  = requireWrappers();

	/**
	 * Constructs a new reflected message type instance.
	 * @classdesc Reflected message type.
	 * @extends NamespaceBase
	 * @constructor
	 * @param {string} name Message name
	 * @param {Object.<string,*>} [options] Declared options
	 */
	function Type(name, options) {
	    Namespace.call(this, name, options);

	    /**
	     * Message fields.
	     * @type {Object.<string,Field>}
	     */
	    this.fields = {};  // toJSON, marker

	    /**
	     * Oneofs declared within this namespace, if any.
	     * @type {Object.<string,OneOf>}
	     */
	    this.oneofs = undefined; // toJSON

	    /**
	     * Extension ranges, if any.
	     * @type {number[][]}
	     */
	    this.extensions = undefined; // toJSON

	    /**
	     * Reserved ranges, if any.
	     * @type {Array.<number[]|string>}
	     */
	    this.reserved = undefined; // toJSON

	    /*?
	     * Whether this type is a legacy group.
	     * @type {boolean|undefined}
	     */
	    this.group = undefined; // toJSON

	    /**
	     * Cached fields by id.
	     * @type {Object.<number,Field>|null}
	     * @private
	     */
	    this._fieldsById = null;

	    /**
	     * Cached fields as an array.
	     * @type {Field[]|null}
	     * @private
	     */
	    this._fieldsArray = null;

	    /**
	     * Cached oneofs as an array.
	     * @type {OneOf[]|null}
	     * @private
	     */
	    this._oneofsArray = null;

	    /**
	     * Cached constructor.
	     * @type {Constructor<{}>}
	     * @private
	     */
	    this._ctor = null;
	}

	Object.defineProperties(Type.prototype, {

	    /**
	     * Message fields by id.
	     * @name Type#fieldsById
	     * @type {Object.<number,Field>}
	     * @readonly
	     */
	    fieldsById: {
	        get: function() {

	            /* istanbul ignore if */
	            if (this._fieldsById)
	                return this._fieldsById;

	            this._fieldsById = {};
	            for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
	                var field = this.fields[names[i]],
	                    id = field.id;

	                /* istanbul ignore if */
	                if (this._fieldsById[id])
	                    throw Error("duplicate id " + id + " in " + this);

	                this._fieldsById[id] = field;
	            }
	            return this._fieldsById;
	        }
	    },

	    /**
	     * Fields of this message as an array for iteration.
	     * @name Type#fieldsArray
	     * @type {Field[]}
	     * @readonly
	     */
	    fieldsArray: {
	        get: function() {
	            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
	        }
	    },

	    /**
	     * Oneofs of this message as an array for iteration.
	     * @name Type#oneofsArray
	     * @type {OneOf[]}
	     * @readonly
	     */
	    oneofsArray: {
	        get: function() {
	            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
	        }
	    },

	    /**
	     * The registered constructor, if any registered, otherwise a generic constructor.
	     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
	     * @name Type#ctor
	     * @type {Constructor<{}>}
	     */
	    ctor: {
	        get: function() {
	            return this._ctor || (this.ctor = Type.generateConstructor(this)());
	        },
	        set: function(ctor) {

	            // Ensure proper prototype
	            var prototype = ctor.prototype;
	            if (!(prototype instanceof Message)) {
	                (ctor.prototype = new Message()).constructor = ctor;
	                util.merge(ctor.prototype, prototype);
	            }

	            // Classes and messages reference their reflected type
	            ctor.$type = ctor.prototype.$type = this;

	            // Mix in static methods
	            util.merge(ctor, Message, true);

	            this._ctor = ctor;

	            // Messages have non-enumerable default values on their prototype
	            var i = 0;
	            for (; i < /* initializes */ this.fieldsArray.length; ++i)
	                this._fieldsArray[i].resolve(); // ensures a proper value

	            // Messages have non-enumerable getters and setters for each virtual oneof field
	            var ctorProperties = {};
	            for (i = 0; i < /* initializes */ this.oneofsArray.length; ++i)
	                ctorProperties[this._oneofsArray[i].resolve().name] = {
	                    get: util.oneOfGetter(this._oneofsArray[i].oneof),
	                    set: util.oneOfSetter(this._oneofsArray[i].oneof)
	                };
	            if (i)
	                Object.defineProperties(ctor.prototype, ctorProperties);
	        }
	    }
	});

	/**
	 * Generates a constructor function for the specified type.
	 * @param {Type} mtype Message type
	 * @returns {Codegen} Codegen instance
	 */
	Type.generateConstructor = function generateConstructor(mtype) {
	    /* eslint-disable no-unexpected-multiline */
	    var gen = util.codegen(["p"], mtype.name);
	    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype
	    for (var i = 0, field; i < mtype.fieldsArray.length; ++i)
	        if ((field = mtype._fieldsArray[i]).map) gen
	            ("this%s={}", util.safeProp(field.name));
	        else if (field.repeated) gen
	            ("this%s=[]", util.safeProp(field.name));
	    return gen
	    ("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)") // omit undefined or null
	        ("this[ks[i]]=p[ks[i]]");
	    /* eslint-enable no-unexpected-multiline */
	};

	function clearCache(type) {
	    type._fieldsById = type._fieldsArray = type._oneofsArray = null;
	    delete type.encode;
	    delete type.decode;
	    delete type.verify;
	    return type;
	}

	/**
	 * Message type descriptor.
	 * @interface IType
	 * @extends INamespace
	 * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors
	 * @property {Object.<string,IField>} fields Field descriptors
	 * @property {number[][]} [extensions] Extension ranges
	 * @property {Array.<number[]|string>} [reserved] Reserved ranges
	 * @property {boolean} [group=false] Whether a legacy group or not
	 */

	/**
	 * Creates a message type from a message type descriptor.
	 * @param {string} name Message name
	 * @param {IType} json Message type descriptor
	 * @returns {Type} Created message type
	 */
	Type.fromJSON = function fromJSON(name, json) {
	    var type = new Type(name, json.options);
	    type.extensions = json.extensions;
	    type.reserved = json.reserved;
	    var names = Object.keys(json.fields),
	        i = 0;
	    for (; i < names.length; ++i)
	        type.add(
	            ( typeof json.fields[names[i]].keyType !== "undefined"
	            ? MapField.fromJSON
	            : Field.fromJSON )(names[i], json.fields[names[i]])
	        );
	    if (json.oneofs)
	        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)
	            type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
	    if (json.nested)
	        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
	            var nested = json.nested[names[i]];
	            type.add( // most to least likely
	                ( nested.id !== undefined
	                ? Field.fromJSON
	                : nested.fields !== undefined
	                ? Type.fromJSON
	                : nested.values !== undefined
	                ? Enum.fromJSON
	                : nested.methods !== undefined
	                ? Service.fromJSON
	                : Namespace.fromJSON )(names[i], nested)
	            );
	        }
	    if (json.extensions && json.extensions.length)
	        type.extensions = json.extensions;
	    if (json.reserved && json.reserved.length)
	        type.reserved = json.reserved;
	    if (json.group)
	        type.group = true;
	    if (json.comment)
	        type.comment = json.comment;
	    return type;
	};

	/**
	 * Converts this message type to a message type descriptor.
	 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
	 * @returns {IType} Message type descriptor
	 */
	Type.prototype.toJSON = function toJSON(toJSONOptions) {
	    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
	    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
	    return util.toObject([
	        "options"    , inherited && inherited.options || undefined,
	        "oneofs"     , Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
	        "fields"     , Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) { return !obj.declaringField; }), toJSONOptions) || {},
	        "extensions" , this.extensions && this.extensions.length ? this.extensions : undefined,
	        "reserved"   , this.reserved && this.reserved.length ? this.reserved : undefined,
	        "group"      , this.group || undefined,
	        "nested"     , inherited && inherited.nested || undefined,
	        "comment"    , keepComments ? this.comment : undefined
	    ]);
	};

	/**
	 * @override
	 */
	Type.prototype.resolveAll = function resolveAll() {
	    var fields = this.fieldsArray, i = 0;
	    while (i < fields.length)
	        fields[i++].resolve();
	    var oneofs = this.oneofsArray; i = 0;
	    while (i < oneofs.length)
	        oneofs[i++].resolve();
	    return Namespace.prototype.resolveAll.call(this);
	};

	/**
	 * @override
	 */
	Type.prototype.get = function get(name) {
	    return this.fields[name]
	        || this.oneofs && this.oneofs[name]
	        || this.nested && this.nested[name]
	        || null;
	};

	/**
	 * Adds a nested object to this type.
	 * @param {ReflectionObject} object Nested object to add
	 * @returns {Type} `this`
	 * @throws {TypeError} If arguments are invalid
	 * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id
	 */
	Type.prototype.add = function add(object) {

	    if (this.get(object.name))
	        throw Error("duplicate name '" + object.name + "' in " + this);

	    if (object instanceof Field && object.extend === undefined) {
	        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.
	        // The root object takes care of adding distinct sister-fields to the respective extended
	        // type instead.

	        // avoids calling the getter if not absolutely necessary because it's called quite frequently
	        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id])
	            throw Error("duplicate id " + object.id + " in " + this);
	        if (this.isReservedId(object.id))
	            throw Error("id " + object.id + " is reserved in " + this);
	        if (this.isReservedName(object.name))
	            throw Error("name '" + object.name + "' is reserved in " + this);

	        if (object.parent)
	            object.parent.remove(object);
	        this.fields[object.name] = object;
	        object.message = this;
	        object.onAdd(this);
	        return clearCache(this);
	    }
	    if (object instanceof OneOf) {
	        if (!this.oneofs)
	            this.oneofs = {};
	        this.oneofs[object.name] = object;
	        object.onAdd(this);
	        return clearCache(this);
	    }
	    return Namespace.prototype.add.call(this, object);
	};

	/**
	 * Removes a nested object from this type.
	 * @param {ReflectionObject} object Nested object to remove
	 * @returns {Type} `this`
	 * @throws {TypeError} If arguments are invalid
	 * @throws {Error} If `object` is not a member of this type
	 */
	Type.prototype.remove = function remove(object) {
	    if (object instanceof Field && object.extend === undefined) {
	        // See Type#add for the reason why extension fields are excluded here.

	        /* istanbul ignore if */
	        if (!this.fields || this.fields[object.name] !== object)
	            throw Error(object + " is not a member of " + this);

	        delete this.fields[object.name];
	        object.parent = null;
	        object.onRemove(this);
	        return clearCache(this);
	    }
	    if (object instanceof OneOf) {

	        /* istanbul ignore if */
	        if (!this.oneofs || this.oneofs[object.name] !== object)
	            throw Error(object + " is not a member of " + this);

	        delete this.oneofs[object.name];
	        object.parent = null;
	        object.onRemove(this);
	        return clearCache(this);
	    }
	    return Namespace.prototype.remove.call(this, object);
	};

	/**
	 * Tests if the specified id is reserved.
	 * @param {number} id Id to test
	 * @returns {boolean} `true` if reserved, otherwise `false`
	 */
	Type.prototype.isReservedId = function isReservedId(id) {
	    return Namespace.isReservedId(this.reserved, id);
	};

	/**
	 * Tests if the specified name is reserved.
	 * @param {string} name Name to test
	 * @returns {boolean} `true` if reserved, otherwise `false`
	 */
	Type.prototype.isReservedName = function isReservedName(name) {
	    return Namespace.isReservedName(this.reserved, name);
	};

	/**
	 * Creates a new message of this type using the specified properties.
	 * @param {Object.<string,*>} [properties] Properties to set
	 * @returns {Message<{}>} Message instance
	 */
	Type.prototype.create = function create(properties) {
	    return new this.ctor(properties);
	};

	/**
	 * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.
	 * @returns {Type} `this`
	 */
	Type.prototype.setup = function setup() {
	    // Sets up everything at once so that the prototype chain does not have to be re-evaluated
	    // multiple times (V8, soft-deopt prototype-check).

	    var fullName = this.fullName,
	        types    = [];
	    for (var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)
	        types.push(this._fieldsArray[i].resolve().resolvedType);

	    // Replace setup methods with type-specific generated functions
	    this.encode = encoder(this)({
	        Writer : Writer,
	        types  : types,
	        util   : util
	    });
	    this.decode = decoder(this)({
	        Reader : Reader,
	        types  : types,
	        util   : util
	    });
	    this.verify = verifier(this)({
	        types : types,
	        util  : util
	    });
	    this.fromObject = converter.fromObject(this)({
	        types : types,
	        util  : util
	    });
	    this.toObject = converter.toObject(this)({
	        types : types,
	        util  : util
	    });

	    // Inject custom wrappers for common types
	    var wrapper = wrappers[fullName];
	    if (wrapper) {
	        var originalThis = Object.create(this);
	        // if (wrapper.fromObject) {
	            originalThis.fromObject = this.fromObject;
	            this.fromObject = wrapper.fromObject.bind(originalThis);
	        // }
	        // if (wrapper.toObject) {
	            originalThis.toObject = this.toObject;
	            this.toObject = wrapper.toObject.bind(originalThis);
	        // }
	    }

	    return this;
	};

	/**
	 * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.
	 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
	 * @param {Writer} [writer] Writer to encode to
	 * @returns {Writer} writer
	 */
	Type.prototype.encode = function encode_setup(message, writer) {
	    return this.setup().encode(message, writer); // overrides this method
	};

	/**
	 * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.
	 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
	 * @param {Writer} [writer] Writer to encode to
	 * @returns {Writer} writer
	 */
	Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
	    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
	};

	/**
	 * Decodes a message of this type.
	 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Length of the message, if known beforehand
	 * @returns {Message<{}>} Decoded message
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {util.ProtocolError<{}>} If required fields are missing
	 */
	Type.prototype.decode = function decode_setup(reader, length) {
	    return this.setup().decode(reader, length); // overrides this method
	};

	/**
	 * Decodes a message of this type preceeded by its byte length as a varint.
	 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {Message<{}>} Decoded message
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {util.ProtocolError} If required fields are missing
	 */
	Type.prototype.decodeDelimited = function decodeDelimited(reader) {
	    if (!(reader instanceof Reader))
	        reader = Reader.create(reader);
	    return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies that field values are valid and that required fields are present.
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {null|string} `null` if valid, otherwise the reason why it is not
	 */
	Type.prototype.verify = function verify_setup(message) {
	    return this.setup().verify(message); // overrides this method
	};

	/**
	 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
	 * @param {Object.<string,*>} object Plain object to convert
	 * @returns {Message<{}>} Message instance
	 */
	Type.prototype.fromObject = function fromObject(object) {
	    return this.setup().fromObject(object);
	};

	/**
	 * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.
	 * @interface IConversionOptions
	 * @property {Function} [longs] Long conversion type.
	 * Valid values are `String` and `Number` (the global types).
	 * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.
	 * @property {Function} [enums] Enum value conversion type.
	 * Only valid value is `String` (the global type).
	 * Defaults to copy the present value, which is the numeric id.
	 * @property {Function} [bytes] Bytes value conversion type.
	 * Valid values are `Array` and (a base64 encoded) `String` (the global types).
	 * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.
	 * @property {boolean} [defaults=false] Also sets default values on the resulting object
	 * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`
	 * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`
	 * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any
	 * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings
	 */

	/**
	 * Creates a plain object from a message of this type. Also converts values to other types if specified.
	 * @param {Message<{}>} message Message instance
	 * @param {IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	Type.prototype.toObject = function toObject(message, options) {
	    return this.setup().toObject(message, options);
	};

	/**
	 * Decorator function as returned by {@link Type.d} (TypeScript).
	 * @typedef TypeDecorator
	 * @type {function}
	 * @param {Constructor<T>} target Target constructor
	 * @returns {undefined}
	 * @template T extends Message<T>
	 */

	/**
	 * Type decorator (TypeScript).
	 * @param {string} [typeName] Type name, defaults to the constructor's name
	 * @returns {TypeDecorator<T>} Decorator function
	 * @template T extends Message<T>
	 */
	Type.d = function decorateType(typeName) {
	    return function typeDecorator(target) {
	        util.decorateType(target, typeName);
	    };
	};
	return type;
}

var root;
var hasRequiredRoot;

function requireRoot () {
	if (hasRequiredRoot) return root;
	hasRequiredRoot = 1;
	root = Root;

	// extends Namespace
	var Namespace = requireNamespace();
	((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";

	var Field   = requireField(),
	    Enum    = require_enum(),
	    OneOf   = requireOneof(),
	    util    = requireUtil$1();

	var Type,   // cyclic
	    parse,  // might be excluded
	    common; // "

	/**
	 * Constructs a new root namespace instance.
	 * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.
	 * @extends NamespaceBase
	 * @constructor
	 * @param {Object.<string,*>} [options] Top level options
	 */
	function Root(options) {
	    Namespace.call(this, "", options);

	    /**
	     * Deferred extension fields.
	     * @type {Field[]}
	     */
	    this.deferred = [];

	    /**
	     * Resolved file names of loaded files.
	     * @type {string[]}
	     */
	    this.files = [];
	}

	/**
	 * Loads a namespace descriptor into a root namespace.
	 * @param {INamespace} json Nameespace descriptor
	 * @param {Root} [root] Root namespace, defaults to create a new one if omitted
	 * @returns {Root} Root namespace
	 */
	Root.fromJSON = function fromJSON(json, root) {
	    if (!root)
	        root = new Root();
	    if (json.options)
	        root.setOptions(json.options);
	    return root.addJSON(json.nested);
	};

	/**
	 * Resolves the path of an imported file, relative to the importing origin.
	 * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.
	 * @function
	 * @param {string} origin The file name of the importing file
	 * @param {string} target The file name being imported
	 * @returns {string|null} Resolved path to `target` or `null` to skip the file
	 */
	Root.prototype.resolvePath = util.path.resolve;

	/**
	 * Fetch content from file path or url
	 * This method exists so you can override it with your own logic.
	 * @function
	 * @param {string} path File path or url
	 * @param {FetchCallback} callback Callback function
	 * @returns {undefined}
	 */
	Root.prototype.fetch = util.fetch;

	// A symbol-like function to safely signal synchronous loading
	/* istanbul ignore next */
	function SYNC() {} // eslint-disable-line no-empty-function

	/**
	 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
	 * @param {string|string[]} filename Names of one or multiple files to load
	 * @param {IParseOptions} options Parse options
	 * @param {LoadCallback} callback Callback function
	 * @returns {undefined}
	 */
	Root.prototype.load = function load(filename, options, callback) {
	    if (typeof options === "function") {
	        callback = options;
	        options = undefined;
	    }
	    var self = this;
	    if (!callback)
	        return util.asPromise(load, self, filename, options);

	    var sync = callback === SYNC; // undocumented

	    // Finishes loading by calling the callback (exactly once)
	    function finish(err, root) {
	        /* istanbul ignore if */
	        if (!callback)
	            return;
	        if (sync)
	            throw err;
	        var cb = callback;
	        callback = null;
	        cb(err, root);
	    }

	    // Bundled definition existence checking
	    function getBundledFileName(filename) {
	        var idx = filename.lastIndexOf("google/protobuf/");
	        if (idx > -1) {
	            var altname = filename.substring(idx);
	            if (altname in common) return altname;
	        }
	        return null;
	    }

	    // Processes a single file
	    function process(filename, source) {
	        try {
	            if (util.isString(source) && source.charAt(0) === "{")
	                source = JSON.parse(source);
	            if (!util.isString(source))
	                self.setOptions(source.options).addJSON(source.nested);
	            else {
	                parse.filename = filename;
	                var parsed = parse(source, self, options),
	                    resolved,
	                    i = 0;
	                if (parsed.imports)
	                    for (; i < parsed.imports.length; ++i)
	                        if (resolved = getBundledFileName(parsed.imports[i]) || self.resolvePath(filename, parsed.imports[i]))
	                            fetch(resolved);
	                if (parsed.weakImports)
	                    for (i = 0; i < parsed.weakImports.length; ++i)
	                        if (resolved = getBundledFileName(parsed.weakImports[i]) || self.resolvePath(filename, parsed.weakImports[i]))
	                            fetch(resolved, true);
	            }
	        } catch (err) {
	            finish(err);
	        }
	        if (!sync && !queued)
	            finish(null, self); // only once anyway
	    }

	    // Fetches a single file
	    function fetch(filename, weak) {
	        filename = getBundledFileName(filename) || filename;

	        // Skip if already loaded / attempted
	        if (self.files.indexOf(filename) > -1)
	            return;
	        self.files.push(filename);

	        // Shortcut bundled definitions
	        if (filename in common) {
	            if (sync)
	                process(filename, common[filename]);
	            else {
	                ++queued;
	                setTimeout(function() {
	                    --queued;
	                    process(filename, common[filename]);
	                });
	            }
	            return;
	        }

	        // Otherwise fetch from disk or network
	        if (sync) {
	            var source;
	            try {
	                source = util.fs.readFileSync(filename).toString("utf8");
	            } catch (err) {
	                if (!weak)
	                    finish(err);
	                return;
	            }
	            process(filename, source);
	        } else {
	            ++queued;
	            self.fetch(filename, function(err, source) {
	                --queued;
	                /* istanbul ignore if */
	                if (!callback)
	                    return; // terminated meanwhile
	                if (err) {
	                    /* istanbul ignore else */
	                    if (!weak)
	                        finish(err);
	                    else if (!queued) // can't be covered reliably
	                        finish(null, self);
	                    return;
	                }
	                process(filename, source);
	            });
	        }
	    }
	    var queued = 0;

	    // Assembling the root namespace doesn't require working type
	    // references anymore, so we can load everything in parallel
	    if (util.isString(filename))
	        filename = [ filename ];
	    for (var i = 0, resolved; i < filename.length; ++i)
	        if (resolved = self.resolvePath("", filename[i]))
	            fetch(resolved);

	    if (sync)
	        return self;
	    if (!queued)
	        finish(null, self);
	    return undefined;
	};
	// function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined

	/**
	 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
	 * @function Root#load
	 * @param {string|string[]} filename Names of one or multiple files to load
	 * @param {LoadCallback} callback Callback function
	 * @returns {undefined}
	 * @variation 2
	 */
	// function load(filename:string, callback:LoadCallback):undefined

	/**
	 * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.
	 * @function Root#load
	 * @param {string|string[]} filename Names of one or multiple files to load
	 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
	 * @returns {Promise<Root>} Promise
	 * @variation 3
	 */
	// function load(filename:string, [options:IParseOptions]):Promise<Root>

	/**
	 * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).
	 * @function Root#loadSync
	 * @param {string|string[]} filename Names of one or multiple files to load
	 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
	 * @returns {Root} Root namespace
	 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
	 */
	Root.prototype.loadSync = function loadSync(filename, options) {
	    if (!util.isNode)
	        throw Error("not supported");
	    return this.load(filename, options, SYNC);
	};

	/**
	 * @override
	 */
	Root.prototype.resolveAll = function resolveAll() {
	    if (this.deferred.length)
	        throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
	            return "'extend " + field.extend + "' in " + field.parent.fullName;
	        }).join(", "));
	    return Namespace.prototype.resolveAll.call(this);
	};

	// only uppercased (and thus conflict-free) children are exposed, see below
	var exposeRe = /^[A-Z]/;

	/**
	 * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.
	 * @param {Root} root Root instance
	 * @param {Field} field Declaring extension field witin the declaring type
	 * @returns {boolean} `true` if successfully added to the extended type, `false` otherwise
	 * @inner
	 * @ignore
	 */
	function tryHandleExtension(root, field) {
	    var extendedType = field.parent.lookup(field.extend);
	    if (extendedType) {
	        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);
	        //do not allow to extend same field twice to prevent the error
	        if (extendedType.get(sisterField.name)) {
	            return true;
	        }
	        sisterField.declaringField = field;
	        field.extensionField = sisterField;
	        extendedType.add(sisterField);
	        return true;
	    }
	    return false;
	}

	/**
	 * Called when any object is added to this root or its sub-namespaces.
	 * @param {ReflectionObject} object Object added
	 * @returns {undefined}
	 * @private
	 */
	Root.prototype._handleAdd = function _handleAdd(object) {
	    if (object instanceof Field) {

	        if (/* an extension field (implies not part of a oneof) */ object.extend !== undefined && /* not already handled */ !object.extensionField)
	            if (!tryHandleExtension(this, object))
	                this.deferred.push(object);

	    } else if (object instanceof Enum) {

	        if (exposeRe.test(object.name))
	            object.parent[object.name] = object.values; // expose enum values as property of its parent

	    } else if (!(object instanceof OneOf)) /* everything else is a namespace */ {

	        if (object instanceof Type) // Try to handle any deferred extensions
	            for (var i = 0; i < this.deferred.length;)
	                if (tryHandleExtension(this, this.deferred[i]))
	                    this.deferred.splice(i, 1);
	                else
	                    ++i;
	        for (var j = 0; j < /* initializes */ object.nestedArray.length; ++j) // recurse into the namespace
	            this._handleAdd(object._nestedArray[j]);
	        if (exposeRe.test(object.name))
	            object.parent[object.name] = object; // expose namespace as property of its parent
	    }

	    // The above also adds uppercased (and thus conflict-free) nested types, services and enums as
	    // properties of namespaces just like static code does. This allows using a .d.ts generated for
	    // a static module with reflection-based solutions where the condition is met.
	};

	/**
	 * Called when any object is removed from this root or its sub-namespaces.
	 * @param {ReflectionObject} object Object removed
	 * @returns {undefined}
	 * @private
	 */
	Root.prototype._handleRemove = function _handleRemove(object) {
	    if (object instanceof Field) {

	        if (/* an extension field */ object.extend !== undefined) {
	            if (/* already handled */ object.extensionField) { // remove its sister field
	                object.extensionField.parent.remove(object.extensionField);
	                object.extensionField = null;
	            } else { // cancel the extension
	                var index = this.deferred.indexOf(object);
	                /* istanbul ignore else */
	                if (index > -1)
	                    this.deferred.splice(index, 1);
	            }
	        }

	    } else if (object instanceof Enum) {

	        if (exposeRe.test(object.name))
	            delete object.parent[object.name]; // unexpose enum values

	    } else if (object instanceof Namespace) {

	        for (var i = 0; i < /* initializes */ object.nestedArray.length; ++i) // recurse into the namespace
	            this._handleRemove(object._nestedArray[i]);

	        if (exposeRe.test(object.name))
	            delete object.parent[object.name]; // unexpose namespaces

	    }
	};

	// Sets up cyclic dependencies (called in index-light)
	Root._configure = function(Type_, parse_, common_) {
	    Type   = Type_;
	    parse  = parse_;
	    common = common_;
	};
	return root;
}

var hasRequiredUtil$1;

function requireUtil$1 () {
	if (hasRequiredUtil$1) return util$1.exports;
	hasRequiredUtil$1 = 1;

	/**
	 * Various utility functions.
	 * @namespace
	 */
	var util = util$1.exports = requireMinimal$1();

	var roots = requireRoots();

	var Type, // cyclic
	    Enum;

	util.codegen = requireCodegen();
	util.fetch   = requireFetch();
	util.path    = requirePath();

	/**
	 * Node's fs module if available.
	 * @type {Object.<string,*>}
	 */
	util.fs = util.inquire("fs");

	/**
	 * Converts an object's values to an array.
	 * @param {Object.<string,*>} object Object to convert
	 * @returns {Array.<*>} Converted array
	 */
	util.toArray = function toArray(object) {
	    if (object) {
	        var keys  = Object.keys(object),
	            array = new Array(keys.length),
	            index = 0;
	        while (index < keys.length)
	            array[index] = object[keys[index++]];
	        return array;
	    }
	    return [];
	};

	/**
	 * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.
	 * @param {Array.<*>} array Array to convert
	 * @returns {Object.<string,*>} Converted object
	 */
	util.toObject = function toObject(array) {
	    var object = {},
	        index  = 0;
	    while (index < array.length) {
	        var key = array[index++],
	            val = array[index++];
	        if (val !== undefined)
	            object[key] = val;
	    }
	    return object;
	};

	var safePropBackslashRe = /\\/g,
	    safePropQuoteRe     = /"/g;

	/**
	 * Tests whether the specified name is a reserved word in JS.
	 * @param {string} name Name to test
	 * @returns {boolean} `true` if reserved, otherwise `false`
	 */
	util.isReserved = function isReserved(name) {
	    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
	};

	/**
	 * Returns a safe property accessor for the specified property name.
	 * @param {string} prop Property name
	 * @returns {string} Safe accessor
	 */
	util.safeProp = function safeProp(prop) {
	    if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop))
	        return "[\"" + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, "\\\"") + "\"]";
	    return "." + prop;
	};

	/**
	 * Converts the first character of a string to upper case.
	 * @param {string} str String to convert
	 * @returns {string} Converted string
	 */
	util.ucFirst = function ucFirst(str) {
	    return str.charAt(0).toUpperCase() + str.substring(1);
	};

	var camelCaseRe = /_([a-z])/g;

	/**
	 * Converts a string to camel case.
	 * @param {string} str String to convert
	 * @returns {string} Converted string
	 */
	util.camelCase = function camelCase(str) {
	    return str.substring(0, 1)
	         + str.substring(1)
	               .replace(camelCaseRe, function($0, $1) { return $1.toUpperCase(); });
	};

	/**
	 * Compares reflected fields by id.
	 * @param {Field} a First field
	 * @param {Field} b Second field
	 * @returns {number} Comparison value
	 */
	util.compareFieldsById = function compareFieldsById(a, b) {
	    return a.id - b.id;
	};

	/**
	 * Decorator helper for types (TypeScript).
	 * @param {Constructor<T>} ctor Constructor function
	 * @param {string} [typeName] Type name, defaults to the constructor's name
	 * @returns {Type} Reflected type
	 * @template T extends Message<T>
	 * @property {Root} root Decorators root
	 */
	util.decorateType = function decorateType(ctor, typeName) {

	    /* istanbul ignore if */
	    if (ctor.$type) {
	        if (typeName && ctor.$type.name !== typeName) {
	            util.decorateRoot.remove(ctor.$type);
	            ctor.$type.name = typeName;
	            util.decorateRoot.add(ctor.$type);
	        }
	        return ctor.$type;
	    }

	    /* istanbul ignore next */
	    if (!Type)
	        Type = requireType();

	    var type = new Type(typeName || ctor.name);
	    util.decorateRoot.add(type);
	    type.ctor = ctor; // sets up .encode, .decode etc.
	    Object.defineProperty(ctor, "$type", { value: type, enumerable: false });
	    Object.defineProperty(ctor.prototype, "$type", { value: type, enumerable: false });
	    return type;
	};

	var decorateEnumIndex = 0;

	/**
	 * Decorator helper for enums (TypeScript).
	 * @param {Object} object Enum object
	 * @returns {Enum} Reflected enum
	 */
	util.decorateEnum = function decorateEnum(object) {

	    /* istanbul ignore if */
	    if (object.$type)
	        return object.$type;

	    /* istanbul ignore next */
	    if (!Enum)
	        Enum = require_enum();

	    var enm = new Enum("Enum" + decorateEnumIndex++, object);
	    util.decorateRoot.add(enm);
	    Object.defineProperty(object, "$type", { value: enm, enumerable: false });
	    return enm;
	};


	/**
	 * Sets the value of a property by property path. If a value already exists, it is turned to an array
	 * @param {Object.<string,*>} dst Destination object
	 * @param {string} path dot '.' delimited path of the property to set
	 * @param {Object} value the value to set
	 * @returns {Object.<string,*>} Destination object
	 */
	util.setProperty = function setProperty(dst, path, value) {
	    function setProp(dst, path, value) {
	        var part = path.shift();
	        if (part === "__proto__" || part === "prototype") {
	          return dst;
	        }
	        if (path.length > 0) {
	            dst[part] = setProp(dst[part] || {}, path, value);
	        } else {
	            var prevValue = dst[part];
	            if (prevValue)
	                value = [].concat(prevValue).concat(value);
	            dst[part] = value;
	        }
	        return dst;
	    }

	    if (typeof dst !== "object")
	        throw TypeError("dst must be an object");
	    if (!path)
	        throw TypeError("path must be specified");

	    path = path.split(".");
	    return setProp(dst, path, value);
	};

	/**
	 * Decorator root (TypeScript).
	 * @name util.decorateRoot
	 * @type {Root}
	 * @readonly
	 */
	Object.defineProperty(util, "decorateRoot", {
	    get: function() {
	        return roots["decorated"] || (roots["decorated"] = new (requireRoot())());
	    }
	});
	return util$1.exports;
}

var object;
var hasRequiredObject;

function requireObject () {
	if (hasRequiredObject) return object;
	hasRequiredObject = 1;
	object = ReflectionObject;

	ReflectionObject.className = "ReflectionObject";

	var util = requireUtil$1();

	var Root; // cyclic

	/**
	 * Constructs a new reflection object instance.
	 * @classdesc Base class of all reflection objects.
	 * @constructor
	 * @param {string} name Object name
	 * @param {Object.<string,*>} [options] Declared options
	 * @abstract
	 */
	function ReflectionObject(name, options) {

	    if (!util.isString(name))
	        throw TypeError("name must be a string");

	    if (options && !util.isObject(options))
	        throw TypeError("options must be an object");

	    /**
	     * Options.
	     * @type {Object.<string,*>|undefined}
	     */
	    this.options = options; // toJSON

	    /**
	     * Parsed Options.
	     * @type {Array.<Object.<string,*>>|undefined}
	     */
	    this.parsedOptions = null;

	    /**
	     * Unique name within its namespace.
	     * @type {string}
	     */
	    this.name = name;

	    /**
	     * Parent namespace.
	     * @type {Namespace|null}
	     */
	    this.parent = null;

	    /**
	     * Whether already resolved or not.
	     * @type {boolean}
	     */
	    this.resolved = false;

	    /**
	     * Comment text, if any.
	     * @type {string|null}
	     */
	    this.comment = null;

	    /**
	     * Defining file name.
	     * @type {string|null}
	     */
	    this.filename = null;
	}

	Object.defineProperties(ReflectionObject.prototype, {

	    /**
	     * Reference to the root namespace.
	     * @name ReflectionObject#root
	     * @type {Root}
	     * @readonly
	     */
	    root: {
	        get: function() {
	            var ptr = this;
	            while (ptr.parent !== null)
	                ptr = ptr.parent;
	            return ptr;
	        }
	    },

	    /**
	     * Full name including leading dot.
	     * @name ReflectionObject#fullName
	     * @type {string}
	     * @readonly
	     */
	    fullName: {
	        get: function() {
	            var path = [ this.name ],
	                ptr = this.parent;
	            while (ptr) {
	                path.unshift(ptr.name);
	                ptr = ptr.parent;
	            }
	            return path.join(".");
	        }
	    }
	});

	/**
	 * Converts this reflection object to its descriptor representation.
	 * @returns {Object.<string,*>} Descriptor
	 * @abstract
	 */
	ReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() {
	    throw Error(); // not implemented, shouldn't happen
	};

	/**
	 * Called when this object is added to a parent.
	 * @param {ReflectionObject} parent Parent added to
	 * @returns {undefined}
	 */
	ReflectionObject.prototype.onAdd = function onAdd(parent) {
	    if (this.parent && this.parent !== parent)
	        this.parent.remove(this);
	    this.parent = parent;
	    this.resolved = false;
	    var root = parent.root;
	    if (root instanceof Root)
	        root._handleAdd(this);
	};

	/**
	 * Called when this object is removed from a parent.
	 * @param {ReflectionObject} parent Parent removed from
	 * @returns {undefined}
	 */
	ReflectionObject.prototype.onRemove = function onRemove(parent) {
	    var root = parent.root;
	    if (root instanceof Root)
	        root._handleRemove(this);
	    this.parent = null;
	    this.resolved = false;
	};

	/**
	 * Resolves this objects type references.
	 * @returns {ReflectionObject} `this`
	 */
	ReflectionObject.prototype.resolve = function resolve() {
	    if (this.resolved)
	        return this;
	    if (this.root instanceof Root)
	        this.resolved = true; // only if part of a root
	    return this;
	};

	/**
	 * Gets an option value.
	 * @param {string} name Option name
	 * @returns {*} Option value or `undefined` if not set
	 */
	ReflectionObject.prototype.getOption = function getOption(name) {
	    if (this.options)
	        return this.options[name];
	    return undefined;
	};

	/**
	 * Sets an option.
	 * @param {string} name Option name
	 * @param {*} value Option value
	 * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set
	 * @returns {ReflectionObject} `this`
	 */
	ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {
	    if (!ifNotSet || !this.options || this.options[name] === undefined)
	        (this.options || (this.options = {}))[name] = value;
	    return this;
	};

	/**
	 * Sets a parsed option.
	 * @param {string} name parsed Option name
	 * @param {*} value Option value
	 * @param {string} propName dot '.' delimited full path of property within the option to set. if undefined\empty, will add a new option with that value
	 * @returns {ReflectionObject} `this`
	 */
	ReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {
	    if (!this.parsedOptions) {
	        this.parsedOptions = [];
	    }
	    var parsedOptions = this.parsedOptions;
	    if (propName) {
	        // If setting a sub property of an option then try to merge it
	        // with an existing option
	        var opt = parsedOptions.find(function (opt) {
	            return Object.prototype.hasOwnProperty.call(opt, name);
	        });
	        if (opt) {
	            // If we found an existing option - just merge the property value
	            var newValue = opt[name];
	            util.setProperty(newValue, propName, value);
	        } else {
	            // otherwise, create a new option, set it's property and add it to the list
	            opt = {};
	            opt[name] = util.setProperty({}, propName, value);
	            parsedOptions.push(opt);
	        }
	    } else {
	        // Always create a new option when setting the value of the option itself
	        var newOpt = {};
	        newOpt[name] = value;
	        parsedOptions.push(newOpt);
	    }
	    return this;
	};

	/**
	 * Sets multiple options.
	 * @param {Object.<string,*>} options Options to set
	 * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set
	 * @returns {ReflectionObject} `this`
	 */
	ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
	    if (options)
	        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)
	            this.setOption(keys[i], options[keys[i]], ifNotSet);
	    return this;
	};

	/**
	 * Converts this instance to its string representation.
	 * @returns {string} Class name[, space, full name]
	 */
	ReflectionObject.prototype.toString = function toString() {
	    var className = this.constructor.className,
	        fullName  = this.fullName;
	    if (fullName.length)
	        return className + " " + fullName;
	    return className;
	};

	// Sets up cyclic dependencies (called in index-light)
	ReflectionObject._configure = function(Root_) {
	    Root = Root_;
	};
	return object;
}

var _enum;
var hasRequired_enum;

function require_enum () {
	if (hasRequired_enum) return _enum;
	hasRequired_enum = 1;
	_enum = Enum;

	// extends ReflectionObject
	var ReflectionObject = requireObject();
	((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";

	var Namespace = requireNamespace(),
	    util = requireUtil$1();

	/**
	 * Constructs a new enum instance.
	 * @classdesc Reflected enum.
	 * @extends ReflectionObject
	 * @constructor
	 * @param {string} name Unique name within its namespace
	 * @param {Object.<string,number>} [values] Enum values as an object, by name
	 * @param {Object.<string,*>} [options] Declared options
	 * @param {string} [comment] The comment for this enum
	 * @param {Object.<string,string>} [comments] The value comments for this enum
	 * @param {Object.<string,Object<string,*>>|undefined} [valuesOptions] The value options for this enum
	 */
	function Enum(name, values, options, comment, comments, valuesOptions) {
	    ReflectionObject.call(this, name, options);

	    if (values && typeof values !== "object")
	        throw TypeError("values must be an object");

	    /**
	     * Enum values by id.
	     * @type {Object.<number,string>}
	     */
	    this.valuesById = {};

	    /**
	     * Enum values by name.
	     * @type {Object.<string,number>}
	     */
	    this.values = Object.create(this.valuesById); // toJSON, marker

	    /**
	     * Enum comment text.
	     * @type {string|null}
	     */
	    this.comment = comment;

	    /**
	     * Value comment texts, if any.
	     * @type {Object.<string,string>}
	     */
	    this.comments = comments || {};

	    /**
	     * Values options, if any
	     * @type {Object<string, Object<string, *>>|undefined}
	     */
	    this.valuesOptions = valuesOptions;

	    /**
	     * Reserved ranges, if any.
	     * @type {Array.<number[]|string>}
	     */
	    this.reserved = undefined; // toJSON

	    // Note that values inherit valuesById on their prototype which makes them a TypeScript-
	    // compatible enum. This is used by pbts to write actual enum definitions that work for
	    // static and reflection code alike instead of emitting generic object definitions.

	    if (values)
	        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)
	            if (typeof values[keys[i]] === "number") // use forward entries only
	                this.valuesById[ this.values[keys[i]] = values[keys[i]] ] = keys[i];
	}

	/**
	 * Enum descriptor.
	 * @interface IEnum
	 * @property {Object.<string,number>} values Enum values
	 * @property {Object.<string,*>} [options] Enum options
	 */

	/**
	 * Constructs an enum from an enum descriptor.
	 * @param {string} name Enum name
	 * @param {IEnum} json Enum descriptor
	 * @returns {Enum} Created enum
	 * @throws {TypeError} If arguments are invalid
	 */
	Enum.fromJSON = function fromJSON(name, json) {
	    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);
	    enm.reserved = json.reserved;
	    return enm;
	};

	/**
	 * Converts this enum to an enum descriptor.
	 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
	 * @returns {IEnum} Enum descriptor
	 */
	Enum.prototype.toJSON = function toJSON(toJSONOptions) {
	    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
	    return util.toObject([
	        "options"       , this.options,
	        "valuesOptions" , this.valuesOptions,
	        "values"        , this.values,
	        "reserved"      , this.reserved && this.reserved.length ? this.reserved : undefined,
	        "comment"       , keepComments ? this.comment : undefined,
	        "comments"      , keepComments ? this.comments : undefined
	    ]);
	};

	/**
	 * Adds a value to this enum.
	 * @param {string} name Value name
	 * @param {number} id Value id
	 * @param {string} [comment] Comment, if any
	 * @param {Object.<string, *>|undefined} [options] Options, if any
	 * @returns {Enum} `this`
	 * @throws {TypeError} If arguments are invalid
	 * @throws {Error} If there is already a value with this name or id
	 */
	Enum.prototype.add = function add(name, id, comment, options) {
	    // utilized by the parser but not by .fromJSON

	    if (!util.isString(name))
	        throw TypeError("name must be a string");

	    if (!util.isInteger(id))
	        throw TypeError("id must be an integer");

	    if (this.values[name] !== undefined)
	        throw Error("duplicate name '" + name + "' in " + this);

	    if (this.isReservedId(id))
	        throw Error("id " + id + " is reserved in " + this);

	    if (this.isReservedName(name))
	        throw Error("name '" + name + "' is reserved in " + this);

	    if (this.valuesById[id] !== undefined) {
	        if (!(this.options && this.options.allow_alias))
	            throw Error("duplicate id " + id + " in " + this);
	        this.values[name] = id;
	    } else
	        this.valuesById[this.values[name] = id] = name;

	    if (options) {
	        if (this.valuesOptions === undefined)
	            this.valuesOptions = {};
	        this.valuesOptions[name] = options || null;
	    }

	    this.comments[name] = comment || null;
	    return this;
	};

	/**
	 * Removes a value from this enum
	 * @param {string} name Value name
	 * @returns {Enum} `this`
	 * @throws {TypeError} If arguments are invalid
	 * @throws {Error} If `name` is not a name of this enum
	 */
	Enum.prototype.remove = function remove(name) {

	    if (!util.isString(name))
	        throw TypeError("name must be a string");

	    var val = this.values[name];
	    if (val == null)
	        throw Error("name '" + name + "' does not exist in " + this);

	    delete this.valuesById[val];
	    delete this.values[name];
	    delete this.comments[name];
	    if (this.valuesOptions)
	        delete this.valuesOptions[name];

	    return this;
	};

	/**
	 * Tests if the specified id is reserved.
	 * @param {number} id Id to test
	 * @returns {boolean} `true` if reserved, otherwise `false`
	 */
	Enum.prototype.isReservedId = function isReservedId(id) {
	    return Namespace.isReservedId(this.reserved, id);
	};

	/**
	 * Tests if the specified name is reserved.
	 * @param {string} name Name to test
	 * @returns {boolean} `true` if reserved, otherwise `false`
	 */
	Enum.prototype.isReservedName = function isReservedName(name) {
	    return Namespace.isReservedName(this.reserved, name);
	};
	return _enum;
}

var encoder_1;
var hasRequiredEncoder;

function requireEncoder () {
	if (hasRequiredEncoder) return encoder_1;
	hasRequiredEncoder = 1;
	encoder_1 = encoder;

	var Enum     = require_enum(),
	    types    = requireTypes(),
	    util     = requireUtil$1();

	/**
	 * Generates a partial message type encoder.
	 * @param {Codegen} gen Codegen instance
	 * @param {Field} field Reflected field
	 * @param {number} fieldIndex Field index
	 * @param {string} ref Variable reference
	 * @returns {Codegen} Codegen instance
	 * @ignore
	 */
	function genTypePartial(gen, field, fieldIndex, ref) {
	    return field.resolvedType.group
	        ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0)
	        : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
	}

	/**
	 * Generates an encoder specific to the specified message type.
	 * @param {Type} mtype Message type
	 * @returns {Codegen} Codegen instance
	 */
	function encoder(mtype) {
	    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
	    var gen = util.codegen(["m", "w"], mtype.name + "$encode")
	    ("if(!w)")
	        ("w=Writer.create()");

	    var i, ref;

	    // "when a message is serialized its known fields should be written sequentially by field number"
	    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);

	    for (var i = 0; i < fields.length; ++i) {
	        var field    = fields[i].resolve(),
	            index    = mtype._fieldsArray.indexOf(field),
	            type     = field.resolvedType instanceof Enum ? "int32" : field.type,
	            wireType = types.basic[type];
	            ref      = "m" + util.safeProp(field.name);

	        // Map fields
	        if (field.map) {
	            gen
	    ("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", ref, field.name) // !== undefined && !== null
	        ("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)
	            ("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
	            if (wireType === undefined) gen
	            ("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref); // can't be groups
	            else gen
	            (".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
	            gen
	        ("}")
	    ("}");

	            // Repeated fields
	        } else if (field.repeated) { gen
	    ("if(%s!=null&&%s.length){", ref, ref); // !== undefined && !== null

	            // Packed repeated
	            if (field.packed && types.packed[type] !== undefined) { gen

	        ("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)
	        ("for(var i=0;i<%s.length;++i)", ref)
	            ("w.%s(%s[i])", type, ref)
	        ("w.ldelim()");

	            // Non-packed
	            } else { gen

	        ("for(var i=0;i<%s.length;++i)", ref);
	                if (wireType === undefined)
	            genTypePartial(gen, field, index, ref + "[i]");
	                else gen
	            ("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);

	            } gen
	    ("}");

	        // Non-repeated
	        } else {
	            if (field.optional) gen
	    ("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", ref, field.name); // !== undefined && !== null

	            if (wireType === undefined)
	        genTypePartial(gen, field, index, ref);
	            else gen
	        ("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);

	        }
	    }

	    return gen
	    ("return w");
	    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
	}
	return encoder_1;
}

var hasRequiredIndexLight;

function requireIndexLight () {
	if (hasRequiredIndexLight) return indexLight.exports;
	hasRequiredIndexLight = 1;
	var protobuf = indexLight.exports = requireIndexMinimal();

	protobuf.build = "light";

	/**
	 * A node-style callback as used by {@link load} and {@link Root#load}.
	 * @typedef LoadCallback
	 * @type {function}
	 * @param {Error|null} error Error, if any, otherwise `null`
	 * @param {Root} [root] Root, if there hasn't been an error
	 * @returns {undefined}
	 */

	/**
	 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
	 * @param {string|string[]} filename One or multiple files to load
	 * @param {Root} root Root namespace, defaults to create a new one if omitted.
	 * @param {LoadCallback} callback Callback function
	 * @returns {undefined}
	 * @see {@link Root#load}
	 */
	function load(filename, root, callback) {
	    if (typeof root === "function") {
	        callback = root;
	        root = new protobuf.Root();
	    } else if (!root)
	        root = new protobuf.Root();
	    return root.load(filename, callback);
	}

	/**
	 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
	 * @name load
	 * @function
	 * @param {string|string[]} filename One or multiple files to load
	 * @param {LoadCallback} callback Callback function
	 * @returns {undefined}
	 * @see {@link Root#load}
	 * @variation 2
	 */
	// function load(filename:string, callback:LoadCallback):undefined

	/**
	 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.
	 * @name load
	 * @function
	 * @param {string|string[]} filename One or multiple files to load
	 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
	 * @returns {Promise<Root>} Promise
	 * @see {@link Root#load}
	 * @variation 3
	 */
	// function load(filename:string, [root:Root]):Promise<Root>

	protobuf.load = load;

	/**
	 * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).
	 * @param {string|string[]} filename One or multiple files to load
	 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
	 * @returns {Root} Root namespace
	 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
	 * @see {@link Root#loadSync}
	 */
	function loadSync(filename, root) {
	    if (!root)
	        root = new protobuf.Root();
	    return root.loadSync(filename);
	}

	protobuf.loadSync = loadSync;

	// Serialization
	protobuf.encoder          = requireEncoder();
	protobuf.decoder          = requireDecoder();
	protobuf.verifier         = requireVerifier();
	protobuf.converter        = requireConverter();

	// Reflection
	protobuf.ReflectionObject = requireObject();
	protobuf.Namespace        = requireNamespace();
	protobuf.Root             = requireRoot();
	protobuf.Enum             = require_enum();
	protobuf.Type             = requireType();
	protobuf.Field            = requireField();
	protobuf.OneOf            = requireOneof();
	protobuf.MapField         = requireMapfield();
	protobuf.Service          = requireService();
	protobuf.Method           = requireMethod();

	// Runtime
	protobuf.Message          = requireMessage();
	protobuf.wrappers         = requireWrappers();

	// Utility
	protobuf.types            = requireTypes();
	protobuf.util             = requireUtil$1();

	// Set up possibly cyclic reflection dependencies
	protobuf.ReflectionObject._configure(protobuf.Root);
	protobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);
	protobuf.Root._configure(protobuf.Type);
	protobuf.Field._configure(protobuf.Type);
	return indexLight.exports;
}

var tokenize_1;
var hasRequiredTokenize;

function requireTokenize () {
	if (hasRequiredTokenize) return tokenize_1;
	hasRequiredTokenize = 1;
	tokenize_1 = tokenize;

	var delimRe        = /[\s{}=;:[\],'"()<>]/g,
	    stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
	    stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;

	var setCommentRe = /^ *[*/]+ */,
	    setCommentAltRe = /^\s*\*?\/*/,
	    setCommentSplitRe = /\n/g,
	    whitespaceRe = /\s/,
	    unescapeRe = /\\(.?)/g;

	var unescapeMap = {
	    "0": "\0",
	    "r": "\r",
	    "n": "\n",
	    "t": "\t"
	};

	/**
	 * Unescapes a string.
	 * @param {string} str String to unescape
	 * @returns {string} Unescaped string
	 * @property {Object.<string,string>} map Special characters map
	 * @memberof tokenize
	 */
	function unescape(str) {
	    return str.replace(unescapeRe, function($0, $1) {
	        switch ($1) {
	            case "\\":
	            case "":
	                return $1;
	            default:
	                return unescapeMap[$1] || "";
	        }
	    });
	}

	tokenize.unescape = unescape;

	/**
	 * Gets the next token and advances.
	 * @typedef TokenizerHandleNext
	 * @type {function}
	 * @returns {string|null} Next token or `null` on eof
	 */

	/**
	 * Peeks for the next token.
	 * @typedef TokenizerHandlePeek
	 * @type {function}
	 * @returns {string|null} Next token or `null` on eof
	 */

	/**
	 * Pushes a token back to the stack.
	 * @typedef TokenizerHandlePush
	 * @type {function}
	 * @param {string} token Token
	 * @returns {undefined}
	 */

	/**
	 * Skips the next token.
	 * @typedef TokenizerHandleSkip
	 * @type {function}
	 * @param {string} expected Expected token
	 * @param {boolean} [optional=false] If optional
	 * @returns {boolean} Whether the token matched
	 * @throws {Error} If the token didn't match and is not optional
	 */

	/**
	 * Gets the comment on the previous line or, alternatively, the line comment on the specified line.
	 * @typedef TokenizerHandleCmnt
	 * @type {function}
	 * @param {number} [line] Line number
	 * @returns {string|null} Comment text or `null` if none
	 */

	/**
	 * Handle object returned from {@link tokenize}.
	 * @interface ITokenizerHandle
	 * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)
	 * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)
	 * @property {TokenizerHandlePush} push Pushes a token back to the stack
	 * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws
	 * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any
	 * @property {number} line Current line number
	 */

	/**
	 * Tokenizes the given .proto source and returns an object with useful utility functions.
	 * @param {string} source Source contents
	 * @param {boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.
	 * @returns {ITokenizerHandle} Tokenizer handle
	 */
	function tokenize(source, alternateCommentMode) {
	    /* eslint-disable callback-return */
	    source = source.toString();

	    var offset = 0,
	        length = source.length,
	        line = 1,
	        lastCommentLine = 0,
	        comments = {};

	    var stack = [];

	    var stringDelim = null;

	    /* istanbul ignore next */
	    /**
	     * Creates an error for illegal syntax.
	     * @param {string} subject Subject
	     * @returns {Error} Error created
	     * @inner
	     */
	    function illegal(subject) {
	        return Error("illegal " + subject + " (line " + line + ")");
	    }

	    /**
	     * Reads a string till its end.
	     * @returns {string} String read
	     * @inner
	     */
	    function readString() {
	        var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
	        re.lastIndex = offset - 1;
	        var match = re.exec(source);
	        if (!match)
	            throw illegal("string");
	        offset = re.lastIndex;
	        push(stringDelim);
	        stringDelim = null;
	        return unescape(match[1]);
	    }

	    /**
	     * Gets the character at `pos` within the source.
	     * @param {number} pos Position
	     * @returns {string} Character
	     * @inner
	     */
	    function charAt(pos) {
	        return source.charAt(pos);
	    }

	    /**
	     * Sets the current comment text.
	     * @param {number} start Start offset
	     * @param {number} end End offset
	     * @param {boolean} isLeading set if a leading comment
	     * @returns {undefined}
	     * @inner
	     */
	    function setComment(start, end, isLeading) {
	        var comment = {
	            type: source.charAt(start++),
	            lineEmpty: false,
	            leading: isLeading,
	        };
	        var lookback;
	        if (alternateCommentMode) {
	            lookback = 2;  // alternate comment parsing: "//" or "/*"
	        } else {
	            lookback = 3;  // "///" or "/**"
	        }
	        var commentOffset = start - lookback,
	            c;
	        do {
	            if (--commentOffset < 0 ||
	                    (c = source.charAt(commentOffset)) === "\n") {
	                comment.lineEmpty = true;
	                break;
	            }
	        } while (c === " " || c === "\t");
	        var lines = source
	            .substring(start, end)
	            .split(setCommentSplitRe);
	        for (var i = 0; i < lines.length; ++i)
	            lines[i] = lines[i]
	                .replace(alternateCommentMode ? setCommentAltRe : setCommentRe, "")
	                .trim();
	        comment.text = lines
	            .join("\n")
	            .trim();

	        comments[line] = comment;
	        lastCommentLine = line;
	    }

	    function isDoubleSlashCommentLine(startOffset) {
	        var endOffset = findEndOfLine(startOffset);

	        // see if remaining line matches comment pattern
	        var lineText = source.substring(startOffset, endOffset);
	        var isComment = /^\s*\/\//.test(lineText);
	        return isComment;
	    }

	    function findEndOfLine(cursor) {
	        // find end of cursor's line
	        var endOffset = cursor;
	        while (endOffset < length && charAt(endOffset) !== "\n") {
	            endOffset++;
	        }
	        return endOffset;
	    }

	    /**
	     * Obtains the next token.
	     * @returns {string|null} Next token or `null` on eof
	     * @inner
	     */
	    function next() {
	        if (stack.length > 0)
	            return stack.shift();
	        if (stringDelim)
	            return readString();
	        var repeat,
	            prev,
	            curr,
	            start,
	            isDoc,
	            isLeadingComment = offset === 0;
	        do {
	            if (offset === length)
	                return null;
	            repeat = false;
	            while (whitespaceRe.test(curr = charAt(offset))) {
	                if (curr === "\n") {
	                    isLeadingComment = true;
	                    ++line;
	                }
	                if (++offset === length)
	                    return null;
	            }

	            if (charAt(offset) === "/") {
	                if (++offset === length) {
	                    throw illegal("comment");
	                }
	                if (charAt(offset) === "/") { // Line
	                    if (!alternateCommentMode) {
	                        // check for triple-slash comment
	                        isDoc = charAt(start = offset + 1) === "/";

	                        while (charAt(++offset) !== "\n") {
	                            if (offset === length) {
	                                return null;
	                            }
	                        }
	                        ++offset;
	                        if (isDoc) {
	                            setComment(start, offset - 1, isLeadingComment);
	                            // Trailing comment cannot not be multi-line,
	                            // so leading comment state should be reset to handle potential next comments
	                            isLeadingComment = true;
	                        }
	                        ++line;
	                        repeat = true;
	                    } else {
	                        // check for double-slash comments, consolidating consecutive lines
	                        start = offset;
	                        isDoc = false;
	                        if (isDoubleSlashCommentLine(offset - 1)) {
	                            isDoc = true;
	                            do {
	                                offset = findEndOfLine(offset);
	                                if (offset === length) {
	                                    break;
	                                }
	                                offset++;
	                                if (!isLeadingComment) {
	                                    // Trailing comment cannot not be multi-line
	                                    break;
	                                }
	                            } while (isDoubleSlashCommentLine(offset));
	                        } else {
	                            offset = Math.min(length, findEndOfLine(offset) + 1);
	                        }
	                        if (isDoc) {
	                            setComment(start, offset, isLeadingComment);
	                            isLeadingComment = true;
	                        }
	                        line++;
	                        repeat = true;
	                    }
	                } else if ((curr = charAt(offset)) === "*") { /* Block */
	                    // check for /** (regular comment mode) or /* (alternate comment mode)
	                    start = offset + 1;
	                    isDoc = alternateCommentMode || charAt(start) === "*";
	                    do {
	                        if (curr === "\n") {
	                            ++line;
	                        }
	                        if (++offset === length) {
	                            throw illegal("comment");
	                        }
	                        prev = curr;
	                        curr = charAt(offset);
	                    } while (prev !== "*" || curr !== "/");
	                    ++offset;
	                    if (isDoc) {
	                        setComment(start, offset - 2, isLeadingComment);
	                        isLeadingComment = true;
	                    }
	                    repeat = true;
	                } else {
	                    return "/";
	                }
	            }
	        } while (repeat);

	        // offset !== length if we got here

	        var end = offset;
	        delimRe.lastIndex = 0;
	        var delim = delimRe.test(charAt(end++));
	        if (!delim)
	            while (end < length && !delimRe.test(charAt(end)))
	                ++end;
	        var token = source.substring(offset, offset = end);
	        if (token === "\"" || token === "'")
	            stringDelim = token;
	        return token;
	    }

	    /**
	     * Pushes a token back to the stack.
	     * @param {string} token Token
	     * @returns {undefined}
	     * @inner
	     */
	    function push(token) {
	        stack.push(token);
	    }

	    /**
	     * Peeks for the next token.
	     * @returns {string|null} Token or `null` on eof
	     * @inner
	     */
	    function peek() {
	        if (!stack.length) {
	            var token = next();
	            if (token === null)
	                return null;
	            push(token);
	        }
	        return stack[0];
	    }

	    /**
	     * Skips a token.
	     * @param {string} expected Expected token
	     * @param {boolean} [optional=false] Whether the token is optional
	     * @returns {boolean} `true` when skipped, `false` if not
	     * @throws {Error} When a required token is not present
	     * @inner
	     */
	    function skip(expected, optional) {
	        var actual = peek(),
	            equals = actual === expected;
	        if (equals) {
	            next();
	            return true;
	        }
	        if (!optional)
	            throw illegal("token '" + actual + "', '" + expected + "' expected");
	        return false;
	    }

	    /**
	     * Gets a comment.
	     * @param {number} [trailingLine] Line number if looking for a trailing comment
	     * @returns {string|null} Comment text
	     * @inner
	     */
	    function cmnt(trailingLine) {
	        var ret = null;
	        var comment;
	        if (trailingLine === undefined) {
	            comment = comments[line - 1];
	            delete comments[line - 1];
	            if (comment && (alternateCommentMode || comment.type === "*" || comment.lineEmpty)) {
	                ret = comment.leading ? comment.text : null;
	            }
	        } else {
	            /* istanbul ignore else */
	            if (lastCommentLine < trailingLine) {
	                peek();
	            }
	            comment = comments[trailingLine];
	            delete comments[trailingLine];
	            if (comment && !comment.lineEmpty && (alternateCommentMode || comment.type === "/")) {
	                ret = comment.leading ? null : comment.text;
	            }
	        }
	        return ret;
	    }

	    return Object.defineProperty({
	        next: next,
	        peek: peek,
	        push: push,
	        skip: skip,
	        cmnt: cmnt
	    }, "line", {
	        get: function() { return line; }
	    });
	    /* eslint-enable callback-return */
	}
	return tokenize_1;
}

var parse_1;
var hasRequiredParse;

function requireParse () {
	if (hasRequiredParse) return parse_1;
	hasRequiredParse = 1;
	parse_1 = parse;

	parse.filename = null;
	parse.defaults = { keepCase: false };

	var tokenize  = requireTokenize(),
	    Root      = requireRoot(),
	    Type      = requireType(),
	    Field     = requireField(),
	    MapField  = requireMapfield(),
	    OneOf     = requireOneof(),
	    Enum      = require_enum(),
	    Service   = requireService(),
	    Method    = requireMethod(),
	    types     = requireTypes(),
	    util      = requireUtil$1();

	var base10Re    = /^[1-9][0-9]*$/,
	    base10NegRe = /^-?[1-9][0-9]*$/,
	    base16Re    = /^0[x][0-9a-fA-F]+$/,
	    base16NegRe = /^-?0[x][0-9a-fA-F]+$/,
	    base8Re     = /^0[0-7]+$/,
	    base8NegRe  = /^-?0[0-7]+$/,
	    numberRe    = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,
	    nameRe      = /^[a-zA-Z_][a-zA-Z_0-9]*$/,
	    typeRefRe   = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/,
	    fqTypeRefRe = /^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;

	/**
	 * Result object returned from {@link parse}.
	 * @interface IParserResult
	 * @property {string|undefined} package Package name, if declared
	 * @property {string[]|undefined} imports Imports, if any
	 * @property {string[]|undefined} weakImports Weak imports, if any
	 * @property {string|undefined} syntax Syntax, if specified (either `"proto2"` or `"proto3"`)
	 * @property {Root} root Populated root instance
	 */

	/**
	 * Options modifying the behavior of {@link parse}.
	 * @interface IParseOptions
	 * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case
	 * @property {boolean} [alternateCommentMode=false] Recognize double-slash comments in addition to doc-block comments.
	 * @property {boolean} [preferTrailingComment=false] Use trailing comment when both leading comment and trailing comment exist.
	 */

	/**
	 * Options modifying the behavior of JSON serialization.
	 * @interface IToJSONOptions
	 * @property {boolean} [keepComments=false] Serializes comments.
	 */

	/**
	 * Parses the given .proto source and returns an object with the parsed contents.
	 * @param {string} source Source contents
	 * @param {Root} root Root to populate
	 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
	 * @returns {IParserResult} Parser result
	 * @property {string} filename=null Currently processing file name for error reporting, if known
	 * @property {IParseOptions} defaults Default {@link IParseOptions}
	 */
	function parse(source, root, options) {
	    /* eslint-disable callback-return */
	    if (!(root instanceof Root)) {
	        options = root;
	        root = new Root();
	    }
	    if (!options)
	        options = parse.defaults;

	    var preferTrailingComment = options.preferTrailingComment || false;
	    var tn = tokenize(source, options.alternateCommentMode || false),
	        next = tn.next,
	        push = tn.push,
	        peek = tn.peek,
	        skip = tn.skip,
	        cmnt = tn.cmnt;

	    var head = true,
	        pkg,
	        imports,
	        weakImports,
	        syntax,
	        isProto3 = false;

	    var ptr = root;

	    var applyCase = options.keepCase ? function(name) { return name; } : util.camelCase;

	    /* istanbul ignore next */
	    function illegal(token, name, insideTryCatch) {
	        var filename = parse.filename;
	        if (!insideTryCatch)
	            parse.filename = null;
	        return Error("illegal " + (name || "token") + " '" + token + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
	    }

	    function readString() {
	        var values = [],
	            token;
	        do {
	            /* istanbul ignore if */
	            if ((token = next()) !== "\"" && token !== "'")
	                throw illegal(token);

	            values.push(next());
	            skip(token);
	            token = peek();
	        } while (token === "\"" || token === "'");
	        return values.join("");
	    }

	    function readValue(acceptTypeRef) {
	        var token = next();
	        switch (token) {
	            case "'":
	            case "\"":
	                push(token);
	                return readString();
	            case "true": case "TRUE":
	                return true;
	            case "false": case "FALSE":
	                return false;
	        }
	        try {
	            return parseNumber(token, /* insideTryCatch */ true);
	        } catch (e) {

	            /* istanbul ignore else */
	            if (typeRefRe.test(token))
	                return token;

	            /* istanbul ignore next */
	            throw illegal(token, "value");
	        }
	    }

	    function readRanges(target, acceptStrings) {
	        var token, start;
	        do {
	            if (acceptStrings && ((token = peek()) === "\"" || token === "'"))
	                target.push(readString());
	            else
	                target.push([ start = parseId(next()), skip("to", true) ? parseId(next()) : start ]);
	        } while (skip(",", true));
	        var dummy = {options: undefined};
	        dummy.setOption = function(name, value) {
	          if (this.options === undefined) this.options = {};
	          this.options[name] = value;
	        };
	        ifBlock(
	            dummy,
	            function parseRange_block(token) {
	              /* istanbul ignore else */
	              if (token === "option") {
	                parseOption(dummy, token);  // skip
	                skip(";");
	              } else
	                throw illegal(token);
	            },
	            function parseRange_line() {
	              parseInlineOptions(dummy);  // skip
	            });
	    }

	    function parseNumber(token, insideTryCatch) {
	        var sign = 1;
	        if (token.charAt(0) === "-") {
	            sign = -1;
	            token = token.substring(1);
	        }
	        switch (token) {
	            case "inf": case "INF": case "Inf":
	                return sign * Infinity;
	            case "nan": case "NAN": case "Nan": case "NaN":
	                return NaN;
	            case "0":
	                return 0;
	        }
	        if (base10Re.test(token))
	            return sign * parseInt(token, 10);
	        if (base16Re.test(token))
	            return sign * parseInt(token, 16);
	        if (base8Re.test(token))
	            return sign * parseInt(token, 8);

	        /* istanbul ignore else */
	        if (numberRe.test(token))
	            return sign * parseFloat(token);

	        /* istanbul ignore next */
	        throw illegal(token, "number", insideTryCatch);
	    }

	    function parseId(token, acceptNegative) {
	        switch (token) {
	            case "max": case "MAX": case "Max":
	                return 536870911;
	            case "0":
	                return 0;
	        }

	        /* istanbul ignore if */
	        if (!acceptNegative && token.charAt(0) === "-")
	            throw illegal(token, "id");

	        if (base10NegRe.test(token))
	            return parseInt(token, 10);
	        if (base16NegRe.test(token))
	            return parseInt(token, 16);

	        /* istanbul ignore else */
	        if (base8NegRe.test(token))
	            return parseInt(token, 8);

	        /* istanbul ignore next */
	        throw illegal(token, "id");
	    }

	    function parsePackage() {

	        /* istanbul ignore if */
	        if (pkg !== undefined)
	            throw illegal("package");

	        pkg = next();

	        /* istanbul ignore if */
	        if (!typeRefRe.test(pkg))
	            throw illegal(pkg, "name");

	        ptr = ptr.define(pkg);
	        skip(";");
	    }

	    function parseImport() {
	        var token = peek();
	        var whichImports;
	        switch (token) {
	            case "weak":
	                whichImports = weakImports || (weakImports = []);
	                next();
	                break;
	            case "public":
	                next();
	                // eslint-disable-next-line no-fallthrough
	            default:
	                whichImports = imports || (imports = []);
	                break;
	        }
	        token = readString();
	        skip(";");
	        whichImports.push(token);
	    }

	    function parseSyntax() {
	        skip("=");
	        syntax = readString();
	        isProto3 = syntax === "proto3";

	        /* istanbul ignore if */
	        if (!isProto3 && syntax !== "proto2")
	            throw illegal(syntax, "syntax");

	        // Syntax is needed to understand the meaning of the optional field rule
	        // Otherwise the meaning is ambiguous between proto2 and proto3
	        root.setOption("syntax", syntax);

	        skip(";");
	    }

	    function parseCommon(parent, token) {
	        switch (token) {

	            case "option":
	                parseOption(parent, token);
	                skip(";");
	                return true;

	            case "message":
	                parseType(parent, token);
	                return true;

	            case "enum":
	                parseEnum(parent, token);
	                return true;

	            case "service":
	                parseService(parent, token);
	                return true;

	            case "extend":
	                parseExtension(parent, token);
	                return true;
	        }
	        return false;
	    }

	    function ifBlock(obj, fnIf, fnElse) {
	        var trailingLine = tn.line;
	        if (obj) {
	            if(typeof obj.comment !== "string") {
	              obj.comment = cmnt(); // try block-type comment
	            }
	            obj.filename = parse.filename;
	        }
	        if (skip("{", true)) {
	            var token;
	            while ((token = next()) !== "}")
	                fnIf(token);
	            skip(";", true);
	        } else {
	            if (fnElse)
	                fnElse();
	            skip(";");
	            if (obj && (typeof obj.comment !== "string" || preferTrailingComment))
	                obj.comment = cmnt(trailingLine) || obj.comment; // try line-type comment
	        }
	    }

	    function parseType(parent, token) {

	        /* istanbul ignore if */
	        if (!nameRe.test(token = next()))
	            throw illegal(token, "type name");

	        var type = new Type(token);
	        ifBlock(type, function parseType_block(token) {
	            if (parseCommon(type, token))
	                return;

	            switch (token) {

	                case "map":
	                    parseMapField(type);
	                    break;

	                case "required":
	                case "repeated":
	                    parseField(type, token);
	                    break;

	                case "optional":
	                    /* istanbul ignore if */
	                    if (isProto3) {
	                        parseField(type, "proto3_optional");
	                    } else {
	                        parseField(type, "optional");
	                    }
	                    break;

	                case "oneof":
	                    parseOneOf(type, token);
	                    break;

	                case "extensions":
	                    readRanges(type.extensions || (type.extensions = []));
	                    break;

	                case "reserved":
	                    readRanges(type.reserved || (type.reserved = []), true);
	                    break;

	                default:
	                    /* istanbul ignore if */
	                    if (!isProto3 || !typeRefRe.test(token))
	                        throw illegal(token);

	                    push(token);
	                    parseField(type, "optional");
	                    break;
	            }
	        });
	        parent.add(type);
	    }

	    function parseField(parent, rule, extend) {
	        var type = next();
	        if (type === "group") {
	            parseGroup(parent, rule);
	            return;
	        }
	        // Type names can consume multiple tokens, in multiple variants:
	        //    package.subpackage   field       tokens: "package.subpackage" [TYPE NAME ENDS HERE] "field"
	        //    package . subpackage field       tokens: "package" "." "subpackage" [TYPE NAME ENDS HERE] "field"
	        //    package.  subpackage field       tokens: "package." "subpackage" [TYPE NAME ENDS HERE] "field"
	        //    package  .subpackage field       tokens: "package" ".subpackage" [TYPE NAME ENDS HERE] "field"
	        // Keep reading tokens until we get a type name with no period at the end,
	        // and the next token does not start with a period.
	        while (type.endsWith(".") || peek().startsWith(".")) {
	            type += next();
	        }

	        /* istanbul ignore if */
	        if (!typeRefRe.test(type))
	            throw illegal(type, "type");

	        var name = next();

	        /* istanbul ignore if */
	        if (!nameRe.test(name))
	            throw illegal(name, "name");

	        name = applyCase(name);
	        skip("=");

	        var field = new Field(name, parseId(next()), type, rule, extend);
	        ifBlock(field, function parseField_block(token) {

	            /* istanbul ignore else */
	            if (token === "option") {
	                parseOption(field, token);
	                skip(";");
	            } else
	                throw illegal(token);

	        }, function parseField_line() {
	            parseInlineOptions(field);
	        });

	        if (rule === "proto3_optional") {
	            // for proto3 optional fields, we create a single-member Oneof to mimic "optional" behavior
	            var oneof = new OneOf("_" + name);
	            field.setOption("proto3_optional", true);
	            oneof.add(field);
	            parent.add(oneof);
	        } else {
	            parent.add(field);
	        }

	        // JSON defaults to packed=true if not set so we have to set packed=false explicity when
	        // parsing proto2 descriptors without the option, where applicable. This must be done for
	        // all known packable types and anything that could be an enum (= is not a basic type).
	        if (!isProto3 && field.repeated && (types.packed[type] !== undefined || types.basic[type] === undefined))
	            field.setOption("packed", false, /* ifNotSet */ true);
	    }

	    function parseGroup(parent, rule) {
	        var name = next();

	        /* istanbul ignore if */
	        if (!nameRe.test(name))
	            throw illegal(name, "name");

	        var fieldName = util.lcFirst(name);
	        if (name === fieldName)
	            name = util.ucFirst(name);
	        skip("=");
	        var id = parseId(next());
	        var type = new Type(name);
	        type.group = true;
	        var field = new Field(fieldName, id, name, rule);
	        field.filename = parse.filename;
	        ifBlock(type, function parseGroup_block(token) {
	            switch (token) {

	                case "option":
	                    parseOption(type, token);
	                    skip(";");
	                    break;

	                case "required":
	                case "repeated":
	                    parseField(type, token);
	                    break;

	                case "optional":
	                    /* istanbul ignore if */
	                    if (isProto3) {
	                        parseField(type, "proto3_optional");
	                    } else {
	                        parseField(type, "optional");
	                    }
	                    break;

	                case "message":
	                    parseType(type, token);
	                    break;

	                case "enum":
	                    parseEnum(type, token);
	                    break;

	                /* istanbul ignore next */
	                default:
	                    throw illegal(token); // there are no groups with proto3 semantics
	            }
	        });
	        parent.add(type)
	              .add(field);
	    }

	    function parseMapField(parent) {
	        skip("<");
	        var keyType = next();

	        /* istanbul ignore if */
	        if (types.mapKey[keyType] === undefined)
	            throw illegal(keyType, "type");

	        skip(",");
	        var valueType = next();

	        /* istanbul ignore if */
	        if (!typeRefRe.test(valueType))
	            throw illegal(valueType, "type");

	        skip(">");
	        var name = next();

	        /* istanbul ignore if */
	        if (!nameRe.test(name))
	            throw illegal(name, "name");

	        skip("=");
	        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);
	        ifBlock(field, function parseMapField_block(token) {

	            /* istanbul ignore else */
	            if (token === "option") {
	                parseOption(field, token);
	                skip(";");
	            } else
	                throw illegal(token);

	        }, function parseMapField_line() {
	            parseInlineOptions(field);
	        });
	        parent.add(field);
	    }

	    function parseOneOf(parent, token) {

	        /* istanbul ignore if */
	        if (!nameRe.test(token = next()))
	            throw illegal(token, "name");

	        var oneof = new OneOf(applyCase(token));
	        ifBlock(oneof, function parseOneOf_block(token) {
	            if (token === "option") {
	                parseOption(oneof, token);
	                skip(";");
	            } else {
	                push(token);
	                parseField(oneof, "optional");
	            }
	        });
	        parent.add(oneof);
	    }

	    function parseEnum(parent, token) {

	        /* istanbul ignore if */
	        if (!nameRe.test(token = next()))
	            throw illegal(token, "name");

	        var enm = new Enum(token);
	        ifBlock(enm, function parseEnum_block(token) {
	          switch(token) {
	            case "option":
	              parseOption(enm, token);
	              skip(";");
	              break;

	            case "reserved":
	              readRanges(enm.reserved || (enm.reserved = []), true);
	              break;

	            default:
	              parseEnumValue(enm, token);
	          }
	        });
	        parent.add(enm);
	    }

	    function parseEnumValue(parent, token) {

	        /* istanbul ignore if */
	        if (!nameRe.test(token))
	            throw illegal(token, "name");

	        skip("=");
	        var value = parseId(next(), true),
	            dummy = {
	                options: undefined
	            };
	        dummy.setOption = function(name, value) {
	            if (this.options === undefined)
	                this.options = {};
	            this.options[name] = value;
	        };
	        ifBlock(dummy, function parseEnumValue_block(token) {

	            /* istanbul ignore else */
	            if (token === "option") {
	                parseOption(dummy, token); // skip
	                skip(";");
	            } else
	                throw illegal(token);

	        }, function parseEnumValue_line() {
	            parseInlineOptions(dummy); // skip
	        });
	        parent.add(token, value, dummy.comment, dummy.options);
	    }

	    function parseOption(parent, token) {
	        var isCustom = skip("(", true);

	        /* istanbul ignore if */
	        if (!typeRefRe.test(token = next()))
	            throw illegal(token, "name");

	        var name = token;
	        var option = name;
	        var propName;

	        if (isCustom) {
	            skip(")");
	            name = "(" + name + ")";
	            option = name;
	            token = peek();
	            if (fqTypeRefRe.test(token)) {
	                propName = token.slice(1); //remove '.' before property name
	                name += token;
	                next();
	            }
	        }
	        skip("=");
	        var optionValue = parseOptionValue(parent, name);
	        setParsedOption(parent, option, optionValue, propName);
	    }

	    function parseOptionValue(parent, name) {
	        // { a: "foo" b { c: "bar" } }
	        if (skip("{", true)) {
	            var objectResult = {};

	            while (!skip("}", true)) {
	                /* istanbul ignore if */
	                if (!nameRe.test(token = next())) {
	                    throw illegal(token, "name");
	                }
	                if (token === null) {
	                  throw illegal(token, "end of input");
	                }

	                var value;
	                var propName = token;

	                skip(":", true);

	                if (peek() === "{")
	                    value = parseOptionValue(parent, name + "." + token);
	                else if (peek() === "[") {
	                    // option (my_option) = {
	                    //     repeated_value: [ "foo", "bar" ]
	                    // };
	                    value = [];
	                    var lastValue;
	                    if (skip("[", true)) {
	                        do {
	                            lastValue = readValue();
	                            value.push(lastValue);
	                        } while (skip(",", true));
	                        skip("]");
	                        if (typeof lastValue !== "undefined") {
	                            setOption(parent, name + "." + token, lastValue);
	                        }
	                    }
	                } else {
	                    value = readValue();
	                    setOption(parent, name + "." + token, value);
	                }

	                var prevValue = objectResult[propName];

	                if (prevValue)
	                    value = [].concat(prevValue).concat(value);

	                objectResult[propName] = value;

	                // Semicolons and commas can be optional
	                skip(",", true);
	                skip(";", true);
	            }

	            return objectResult;
	        }

	        var simpleValue = readValue();
	        setOption(parent, name, simpleValue);
	        return simpleValue;
	        // Does not enforce a delimiter to be universal
	    }

	    function setOption(parent, name, value) {
	        if (parent.setOption)
	            parent.setOption(name, value);
	    }

	    function setParsedOption(parent, name, value, propName) {
	        if (parent.setParsedOption)
	            parent.setParsedOption(name, value, propName);
	    }

	    function parseInlineOptions(parent) {
	        if (skip("[", true)) {
	            do {
	                parseOption(parent, "option");
	            } while (skip(",", true));
	            skip("]");
	        }
	        return parent;
	    }

	    function parseService(parent, token) {

	        /* istanbul ignore if */
	        if (!nameRe.test(token = next()))
	            throw illegal(token, "service name");

	        var service = new Service(token);
	        ifBlock(service, function parseService_block(token) {
	            if (parseCommon(service, token))
	                return;

	            /* istanbul ignore else */
	            if (token === "rpc")
	                parseMethod(service, token);
	            else
	                throw illegal(token);
	        });
	        parent.add(service);
	    }

	    function parseMethod(parent, token) {
	        // Get the comment of the preceding line now (if one exists) in case the
	        // method is defined across multiple lines.
	        var commentText = cmnt();

	        var type = token;

	        /* istanbul ignore if */
	        if (!nameRe.test(token = next()))
	            throw illegal(token, "name");

	        var name = token,
	            requestType, requestStream,
	            responseType, responseStream;

	        skip("(");
	        if (skip("stream", true))
	            requestStream = true;

	        /* istanbul ignore if */
	        if (!typeRefRe.test(token = next()))
	            throw illegal(token);

	        requestType = token;
	        skip(")"); skip("returns"); skip("(");
	        if (skip("stream", true))
	            responseStream = true;

	        /* istanbul ignore if */
	        if (!typeRefRe.test(token = next()))
	            throw illegal(token);

	        responseType = token;
	        skip(")");

	        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);
	        method.comment = commentText;
	        ifBlock(method, function parseMethod_block(token) {

	            /* istanbul ignore else */
	            if (token === "option") {
	                parseOption(method, token);
	                skip(";");
	            } else
	                throw illegal(token);

	        });
	        parent.add(method);
	    }

	    function parseExtension(parent, token) {

	        /* istanbul ignore if */
	        if (!typeRefRe.test(token = next()))
	            throw illegal(token, "reference");

	        var reference = token;
	        ifBlock(null, function parseExtension_block(token) {
	            switch (token) {

	                case "required":
	                case "repeated":
	                    parseField(parent, token, reference);
	                    break;

	                case "optional":
	                    /* istanbul ignore if */
	                    if (isProto3) {
	                        parseField(parent, "proto3_optional", reference);
	                    } else {
	                        parseField(parent, "optional", reference);
	                    }
	                    break;

	                default:
	                    /* istanbul ignore if */
	                    if (!isProto3 || !typeRefRe.test(token))
	                        throw illegal(token);
	                    push(token);
	                    parseField(parent, "optional", reference);
	                    break;
	            }
	        });
	    }

	    var token;
	    while ((token = next()) !== null) {
	        switch (token) {

	            case "package":

	                /* istanbul ignore if */
	                if (!head)
	                    throw illegal(token);

	                parsePackage();
	                break;

	            case "import":

	                /* istanbul ignore if */
	                if (!head)
	                    throw illegal(token);

	                parseImport();
	                break;

	            case "syntax":

	                /* istanbul ignore if */
	                if (!head)
	                    throw illegal(token);

	                parseSyntax();
	                break;

	            case "option":

	                parseOption(ptr, token);
	                skip(";");
	                break;

	            default:

	                /* istanbul ignore else */
	                if (parseCommon(ptr, token)) {
	                    head = false;
	                    continue;
	                }

	                /* istanbul ignore next */
	                throw illegal(token);
	        }
	    }

	    parse.filename = null;
	    return {
	        "package"     : pkg,
	        "imports"     : imports,
	         weakImports  : weakImports,
	         syntax       : syntax,
	         root         : root
	    };
	}

	/**
	 * Parses the given .proto source and returns an object with the parsed contents.
	 * @name parse
	 * @function
	 * @param {string} source Source contents
	 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
	 * @returns {IParserResult} Parser result
	 * @property {string} filename=null Currently processing file name for error reporting, if known
	 * @property {IParseOptions} defaults Default {@link IParseOptions}
	 * @variation 2
	 */
	return parse_1;
}

var common_1;
var hasRequiredCommon;

function requireCommon () {
	if (hasRequiredCommon) return common_1;
	hasRequiredCommon = 1;
	common_1 = common;

	var commonRe = /\/|\./;

	/**
	 * Provides common type definitions.
	 * Can also be used to provide additional google types or your own custom types.
	 * @param {string} name Short name as in `google/protobuf/[name].proto` or full file name
	 * @param {Object.<string,*>} json JSON definition within `google.protobuf` if a short name, otherwise the file's root definition
	 * @returns {undefined}
	 * @property {INamespace} google/protobuf/any.proto Any
	 * @property {INamespace} google/protobuf/duration.proto Duration
	 * @property {INamespace} google/protobuf/empty.proto Empty
	 * @property {INamespace} google/protobuf/field_mask.proto FieldMask
	 * @property {INamespace} google/protobuf/struct.proto Struct, Value, NullValue and ListValue
	 * @property {INamespace} google/protobuf/timestamp.proto Timestamp
	 * @property {INamespace} google/protobuf/wrappers.proto Wrappers
	 * @example
	 * // manually provides descriptor.proto (assumes google/protobuf/ namespace and .proto extension)
	 * protobuf.common("descriptor", descriptorJson);
	 *
	 * // manually provides a custom definition (uses my.foo namespace)
	 * protobuf.common("my/foo/bar.proto", myFooBarJson);
	 */
	function common(name, json) {
	    if (!commonRe.test(name)) {
	        name = "google/protobuf/" + name + ".proto";
	        json = { nested: { google: { nested: { protobuf: { nested: json } } } } };
	    }
	    common[name] = json;
	}

	// Not provided because of limited use (feel free to discuss or to provide yourself):
	//
	// google/protobuf/descriptor.proto
	// google/protobuf/source_context.proto
	// google/protobuf/type.proto
	//
	// Stripped and pre-parsed versions of these non-bundled files are instead available as part of
	// the repository or package within the google/protobuf directory.

	common("any", {

	    /**
	     * Properties of a google.protobuf.Any message.
	     * @interface IAny
	     * @type {Object}
	     * @property {string} [typeUrl]
	     * @property {Uint8Array} [bytes]
	     * @memberof common
	     */
	    Any: {
	        fields: {
	            type_url: {
	                type: "string",
	                id: 1
	            },
	            value: {
	                type: "bytes",
	                id: 2
	            }
	        }
	    }
	});

	var timeType;

	common("duration", {

	    /**
	     * Properties of a google.protobuf.Duration message.
	     * @interface IDuration
	     * @type {Object}
	     * @property {number|Long} [seconds]
	     * @property {number} [nanos]
	     * @memberof common
	     */
	    Duration: timeType = {
	        fields: {
	            seconds: {
	                type: "int64",
	                id: 1
	            },
	            nanos: {
	                type: "int32",
	                id: 2
	            }
	        }
	    }
	});

	common("timestamp", {

	    /**
	     * Properties of a google.protobuf.Timestamp message.
	     * @interface ITimestamp
	     * @type {Object}
	     * @property {number|Long} [seconds]
	     * @property {number} [nanos]
	     * @memberof common
	     */
	    Timestamp: timeType
	});

	common("empty", {

	    /**
	     * Properties of a google.protobuf.Empty message.
	     * @interface IEmpty
	     * @memberof common
	     */
	    Empty: {
	        fields: {}
	    }
	});

	common("struct", {

	    /**
	     * Properties of a google.protobuf.Struct message.
	     * @interface IStruct
	     * @type {Object}
	     * @property {Object.<string,IValue>} [fields]
	     * @memberof common
	     */
	    Struct: {
	        fields: {
	            fields: {
	                keyType: "string",
	                type: "Value",
	                id: 1
	            }
	        }
	    },

	    /**
	     * Properties of a google.protobuf.Value message.
	     * @interface IValue
	     * @type {Object}
	     * @property {string} [kind]
	     * @property {0} [nullValue]
	     * @property {number} [numberValue]
	     * @property {string} [stringValue]
	     * @property {boolean} [boolValue]
	     * @property {IStruct} [structValue]
	     * @property {IListValue} [listValue]
	     * @memberof common
	     */
	    Value: {
	        oneofs: {
	            kind: {
	                oneof: [
	                    "nullValue",
	                    "numberValue",
	                    "stringValue",
	                    "boolValue",
	                    "structValue",
	                    "listValue"
	                ]
	            }
	        },
	        fields: {
	            nullValue: {
	                type: "NullValue",
	                id: 1
	            },
	            numberValue: {
	                type: "double",
	                id: 2
	            },
	            stringValue: {
	                type: "string",
	                id: 3
	            },
	            boolValue: {
	                type: "bool",
	                id: 4
	            },
	            structValue: {
	                type: "Struct",
	                id: 5
	            },
	            listValue: {
	                type: "ListValue",
	                id: 6
	            }
	        }
	    },

	    NullValue: {
	        values: {
	            NULL_VALUE: 0
	        }
	    },

	    /**
	     * Properties of a google.protobuf.ListValue message.
	     * @interface IListValue
	     * @type {Object}
	     * @property {Array.<IValue>} [values]
	     * @memberof common
	     */
	    ListValue: {
	        fields: {
	            values: {
	                rule: "repeated",
	                type: "Value",
	                id: 1
	            }
	        }
	    }
	});

	common("wrappers", {

	    /**
	     * Properties of a google.protobuf.DoubleValue message.
	     * @interface IDoubleValue
	     * @type {Object}
	     * @property {number} [value]
	     * @memberof common
	     */
	    DoubleValue: {
	        fields: {
	            value: {
	                type: "double",
	                id: 1
	            }
	        }
	    },

	    /**
	     * Properties of a google.protobuf.FloatValue message.
	     * @interface IFloatValue
	     * @type {Object}
	     * @property {number} [value]
	     * @memberof common
	     */
	    FloatValue: {
	        fields: {
	            value: {
	                type: "float",
	                id: 1
	            }
	        }
	    },

	    /**
	     * Properties of a google.protobuf.Int64Value message.
	     * @interface IInt64Value
	     * @type {Object}
	     * @property {number|Long} [value]
	     * @memberof common
	     */
	    Int64Value: {
	        fields: {
	            value: {
	                type: "int64",
	                id: 1
	            }
	        }
	    },

	    /**
	     * Properties of a google.protobuf.UInt64Value message.
	     * @interface IUInt64Value
	     * @type {Object}
	     * @property {number|Long} [value]
	     * @memberof common
	     */
	    UInt64Value: {
	        fields: {
	            value: {
	                type: "uint64",
	                id: 1
	            }
	        }
	    },

	    /**
	     * Properties of a google.protobuf.Int32Value message.
	     * @interface IInt32Value
	     * @type {Object}
	     * @property {number} [value]
	     * @memberof common
	     */
	    Int32Value: {
	        fields: {
	            value: {
	                type: "int32",
	                id: 1
	            }
	        }
	    },

	    /**
	     * Properties of a google.protobuf.UInt32Value message.
	     * @interface IUInt32Value
	     * @type {Object}
	     * @property {number} [value]
	     * @memberof common
	     */
	    UInt32Value: {
	        fields: {
	            value: {
	                type: "uint32",
	                id: 1
	            }
	        }
	    },

	    /**
	     * Properties of a google.protobuf.BoolValue message.
	     * @interface IBoolValue
	     * @type {Object}
	     * @property {boolean} [value]
	     * @memberof common
	     */
	    BoolValue: {
	        fields: {
	            value: {
	                type: "bool",
	                id: 1
	            }
	        }
	    },

	    /**
	     * Properties of a google.protobuf.StringValue message.
	     * @interface IStringValue
	     * @type {Object}
	     * @property {string} [value]
	     * @memberof common
	     */
	    StringValue: {
	        fields: {
	            value: {
	                type: "string",
	                id: 1
	            }
	        }
	    },

	    /**
	     * Properties of a google.protobuf.BytesValue message.
	     * @interface IBytesValue
	     * @type {Object}
	     * @property {Uint8Array} [value]
	     * @memberof common
	     */
	    BytesValue: {
	        fields: {
	            value: {
	                type: "bytes",
	                id: 1
	            }
	        }
	    }
	});

	common("field_mask", {

	    /**
	     * Properties of a google.protobuf.FieldMask message.
	     * @interface IDoubleValue
	     * @type {Object}
	     * @property {number} [value]
	     * @memberof common
	     */
	    FieldMask: {
	        fields: {
	            paths: {
	                rule: "repeated",
	                type: "string",
	                id: 1
	            }
	        }
	    }
	});

	/**
	 * Gets the root definition of the specified common proto file.
	 *
	 * Bundled definitions are:
	 * - google/protobuf/any.proto
	 * - google/protobuf/duration.proto
	 * - google/protobuf/empty.proto
	 * - google/protobuf/field_mask.proto
	 * - google/protobuf/struct.proto
	 * - google/protobuf/timestamp.proto
	 * - google/protobuf/wrappers.proto
	 *
	 * @param {string} file Proto file name
	 * @returns {INamespace|null} Root definition or `null` if not defined
	 */
	common.get = function get(file) {
	    return common[file] || null;
	};
	return common_1;
}

var hasRequiredSrc$2;

function requireSrc$2 () {
	if (hasRequiredSrc$2) return src.exports;
	hasRequiredSrc$2 = 1;
	var protobuf = src.exports = requireIndexLight();

	protobuf.build = "full";

	// Parser
	protobuf.tokenize         = requireTokenize();
	protobuf.parse            = requireParse();
	protobuf.common           = requireCommon();

	// Configure parser
	protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);
	return src.exports;
}

var protobufjs;
var hasRequiredProtobufjs;

function requireProtobufjs () {
	if (hasRequiredProtobufjs) return protobufjs;
	hasRequiredProtobufjs = 1;
	protobufjs = requireSrc$2();
	return protobufjs;
}

var descriptor = {exports: {}};

var nested$3 = {
	google: {
		nested: {
			protobuf: {
				nested: {
					FileDescriptorSet: {
						fields: {
							file: {
								rule: "repeated",
								type: "FileDescriptorProto",
								id: 1
							}
						}
					},
					FileDescriptorProto: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							"package": {
								type: "string",
								id: 2
							},
							dependency: {
								rule: "repeated",
								type: "string",
								id: 3
							},
							publicDependency: {
								rule: "repeated",
								type: "int32",
								id: 10,
								options: {
									packed: false
								}
							},
							weakDependency: {
								rule: "repeated",
								type: "int32",
								id: 11,
								options: {
									packed: false
								}
							},
							messageType: {
								rule: "repeated",
								type: "DescriptorProto",
								id: 4
							},
							enumType: {
								rule: "repeated",
								type: "EnumDescriptorProto",
								id: 5
							},
							service: {
								rule: "repeated",
								type: "ServiceDescriptorProto",
								id: 6
							},
							extension: {
								rule: "repeated",
								type: "FieldDescriptorProto",
								id: 7
							},
							options: {
								type: "FileOptions",
								id: 8
							},
							sourceCodeInfo: {
								type: "SourceCodeInfo",
								id: 9
							},
							syntax: {
								type: "string",
								id: 12
							}
						}
					},
					DescriptorProto: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							field: {
								rule: "repeated",
								type: "FieldDescriptorProto",
								id: 2
							},
							extension: {
								rule: "repeated",
								type: "FieldDescriptorProto",
								id: 6
							},
							nestedType: {
								rule: "repeated",
								type: "DescriptorProto",
								id: 3
							},
							enumType: {
								rule: "repeated",
								type: "EnumDescriptorProto",
								id: 4
							},
							extensionRange: {
								rule: "repeated",
								type: "ExtensionRange",
								id: 5
							},
							oneofDecl: {
								rule: "repeated",
								type: "OneofDescriptorProto",
								id: 8
							},
							options: {
								type: "MessageOptions",
								id: 7
							},
							reservedRange: {
								rule: "repeated",
								type: "ReservedRange",
								id: 9
							},
							reservedName: {
								rule: "repeated",
								type: "string",
								id: 10
							}
						},
						nested: {
							ExtensionRange: {
								fields: {
									start: {
										type: "int32",
										id: 1
									},
									end: {
										type: "int32",
										id: 2
									}
								}
							},
							ReservedRange: {
								fields: {
									start: {
										type: "int32",
										id: 1
									},
									end: {
										type: "int32",
										id: 2
									}
								}
							}
						}
					},
					FieldDescriptorProto: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							number: {
								type: "int32",
								id: 3
							},
							label: {
								type: "Label",
								id: 4
							},
							type: {
								type: "Type",
								id: 5
							},
							typeName: {
								type: "string",
								id: 6
							},
							extendee: {
								type: "string",
								id: 2
							},
							defaultValue: {
								type: "string",
								id: 7
							},
							oneofIndex: {
								type: "int32",
								id: 9
							},
							jsonName: {
								type: "string",
								id: 10
							},
							options: {
								type: "FieldOptions",
								id: 8
							}
						},
						nested: {
							Type: {
								values: {
									TYPE_DOUBLE: 1,
									TYPE_FLOAT: 2,
									TYPE_INT64: 3,
									TYPE_UINT64: 4,
									TYPE_INT32: 5,
									TYPE_FIXED64: 6,
									TYPE_FIXED32: 7,
									TYPE_BOOL: 8,
									TYPE_STRING: 9,
									TYPE_GROUP: 10,
									TYPE_MESSAGE: 11,
									TYPE_BYTES: 12,
									TYPE_UINT32: 13,
									TYPE_ENUM: 14,
									TYPE_SFIXED32: 15,
									TYPE_SFIXED64: 16,
									TYPE_SINT32: 17,
									TYPE_SINT64: 18
								}
							},
							Label: {
								values: {
									LABEL_OPTIONAL: 1,
									LABEL_REQUIRED: 2,
									LABEL_REPEATED: 3
								}
							}
						}
					},
					OneofDescriptorProto: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							options: {
								type: "OneofOptions",
								id: 2
							}
						}
					},
					EnumDescriptorProto: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							value: {
								rule: "repeated",
								type: "EnumValueDescriptorProto",
								id: 2
							},
							options: {
								type: "EnumOptions",
								id: 3
							}
						}
					},
					EnumValueDescriptorProto: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							number: {
								type: "int32",
								id: 2
							},
							options: {
								type: "EnumValueOptions",
								id: 3
							}
						}
					},
					ServiceDescriptorProto: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							method: {
								rule: "repeated",
								type: "MethodDescriptorProto",
								id: 2
							},
							options: {
								type: "ServiceOptions",
								id: 3
							}
						}
					},
					MethodDescriptorProto: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							inputType: {
								type: "string",
								id: 2
							},
							outputType: {
								type: "string",
								id: 3
							},
							options: {
								type: "MethodOptions",
								id: 4
							},
							clientStreaming: {
								type: "bool",
								id: 5
							},
							serverStreaming: {
								type: "bool",
								id: 6
							}
						}
					},
					FileOptions: {
						fields: {
							javaPackage: {
								type: "string",
								id: 1
							},
							javaOuterClassname: {
								type: "string",
								id: 8
							},
							javaMultipleFiles: {
								type: "bool",
								id: 10
							},
							javaGenerateEqualsAndHash: {
								type: "bool",
								id: 20,
								options: {
									deprecated: true
								}
							},
							javaStringCheckUtf8: {
								type: "bool",
								id: 27
							},
							optimizeFor: {
								type: "OptimizeMode",
								id: 9,
								options: {
									"default": "SPEED"
								}
							},
							goPackage: {
								type: "string",
								id: 11
							},
							ccGenericServices: {
								type: "bool",
								id: 16
							},
							javaGenericServices: {
								type: "bool",
								id: 17
							},
							pyGenericServices: {
								type: "bool",
								id: 18
							},
							deprecated: {
								type: "bool",
								id: 23
							},
							ccEnableArenas: {
								type: "bool",
								id: 31
							},
							objcClassPrefix: {
								type: "string",
								id: 36
							},
							csharpNamespace: {
								type: "string",
								id: 37
							},
							uninterpretedOption: {
								rule: "repeated",
								type: "UninterpretedOption",
								id: 999
							}
						},
						extensions: [
							[
								1000,
								536870911
							]
						],
						reserved: [
							[
								38,
								38
							]
						],
						nested: {
							OptimizeMode: {
								values: {
									SPEED: 1,
									CODE_SIZE: 2,
									LITE_RUNTIME: 3
								}
							}
						}
					},
					MessageOptions: {
						fields: {
							messageSetWireFormat: {
								type: "bool",
								id: 1
							},
							noStandardDescriptorAccessor: {
								type: "bool",
								id: 2
							},
							deprecated: {
								type: "bool",
								id: 3
							},
							mapEntry: {
								type: "bool",
								id: 7
							},
							uninterpretedOption: {
								rule: "repeated",
								type: "UninterpretedOption",
								id: 999
							}
						},
						extensions: [
							[
								1000,
								536870911
							]
						],
						reserved: [
							[
								8,
								8
							]
						]
					},
					FieldOptions: {
						fields: {
							ctype: {
								type: "CType",
								id: 1,
								options: {
									"default": "STRING"
								}
							},
							packed: {
								type: "bool",
								id: 2
							},
							jstype: {
								type: "JSType",
								id: 6,
								options: {
									"default": "JS_NORMAL"
								}
							},
							lazy: {
								type: "bool",
								id: 5
							},
							deprecated: {
								type: "bool",
								id: 3
							},
							weak: {
								type: "bool",
								id: 10
							},
							uninterpretedOption: {
								rule: "repeated",
								type: "UninterpretedOption",
								id: 999
							}
						},
						extensions: [
							[
								1000,
								536870911
							]
						],
						reserved: [
							[
								4,
								4
							]
						],
						nested: {
							CType: {
								values: {
									STRING: 0,
									CORD: 1,
									STRING_PIECE: 2
								}
							},
							JSType: {
								values: {
									JS_NORMAL: 0,
									JS_STRING: 1,
									JS_NUMBER: 2
								}
							}
						}
					},
					OneofOptions: {
						fields: {
							uninterpretedOption: {
								rule: "repeated",
								type: "UninterpretedOption",
								id: 999
							}
						},
						extensions: [
							[
								1000,
								536870911
							]
						]
					},
					EnumOptions: {
						fields: {
							allowAlias: {
								type: "bool",
								id: 2
							},
							deprecated: {
								type: "bool",
								id: 3
							},
							uninterpretedOption: {
								rule: "repeated",
								type: "UninterpretedOption",
								id: 999
							}
						},
						extensions: [
							[
								1000,
								536870911
							]
						]
					},
					EnumValueOptions: {
						fields: {
							deprecated: {
								type: "bool",
								id: 1
							},
							uninterpretedOption: {
								rule: "repeated",
								type: "UninterpretedOption",
								id: 999
							}
						},
						extensions: [
							[
								1000,
								536870911
							]
						]
					},
					ServiceOptions: {
						fields: {
							deprecated: {
								type: "bool",
								id: 33
							},
							uninterpretedOption: {
								rule: "repeated",
								type: "UninterpretedOption",
								id: 999
							}
						},
						extensions: [
							[
								1000,
								536870911
							]
						]
					},
					MethodOptions: {
						fields: {
							deprecated: {
								type: "bool",
								id: 33
							},
							uninterpretedOption: {
								rule: "repeated",
								type: "UninterpretedOption",
								id: 999
							}
						},
						extensions: [
							[
								1000,
								536870911
							]
						]
					},
					UninterpretedOption: {
						fields: {
							name: {
								rule: "repeated",
								type: "NamePart",
								id: 2
							},
							identifierValue: {
								type: "string",
								id: 3
							},
							positiveIntValue: {
								type: "uint64",
								id: 4
							},
							negativeIntValue: {
								type: "int64",
								id: 5
							},
							doubleValue: {
								type: "double",
								id: 6
							},
							stringValue: {
								type: "bytes",
								id: 7
							},
							aggregateValue: {
								type: "string",
								id: 8
							}
						},
						nested: {
							NamePart: {
								fields: {
									namePart: {
										rule: "required",
										type: "string",
										id: 1
									},
									isExtension: {
										rule: "required",
										type: "bool",
										id: 2
									}
								}
							}
						}
					},
					SourceCodeInfo: {
						fields: {
							location: {
								rule: "repeated",
								type: "Location",
								id: 1
							}
						},
						nested: {
							Location: {
								fields: {
									path: {
										rule: "repeated",
										type: "int32",
										id: 1
									},
									span: {
										rule: "repeated",
										type: "int32",
										id: 2
									},
									leadingComments: {
										type: "string",
										id: 3
									},
									trailingComments: {
										type: "string",
										id: 4
									},
									leadingDetachedComments: {
										rule: "repeated",
										type: "string",
										id: 6
									}
								}
							}
						}
					},
					GeneratedCodeInfo: {
						fields: {
							annotation: {
								rule: "repeated",
								type: "Annotation",
								id: 1
							}
						},
						nested: {
							Annotation: {
								fields: {
									path: {
										rule: "repeated",
										type: "int32",
										id: 1
									},
									sourceFile: {
										type: "string",
										id: 2
									},
									begin: {
										type: "int32",
										id: 3
									},
									end: {
										type: "int32",
										id: 4
									}
								}
							}
						}
					}
				}
			}
		}
	}
};
const require$$4 = {
	nested: nested$3
};

var hasRequiredDescriptor;

function requireDescriptor () {
	if (hasRequiredDescriptor) return descriptor.exports;
	hasRequiredDescriptor = 1;
	(function (module, exports) {
		var $protobuf = requireProtobufjs();
		module.exports = exports = $protobuf.descriptor = $protobuf.Root.fromJSON(require$$4).lookup(".google.protobuf");

		var Namespace = $protobuf.Namespace,
		    Root      = $protobuf.Root,
		    Enum      = $protobuf.Enum,
		    Type      = $protobuf.Type,
		    Field     = $protobuf.Field,
		    MapField  = $protobuf.MapField,
		    OneOf     = $protobuf.OneOf,
		    Service   = $protobuf.Service,
		    Method    = $protobuf.Method;

		// --- Root ---

		/**
		 * Properties of a FileDescriptorSet message.
		 * @interface IFileDescriptorSet
		 * @property {IFileDescriptorProto[]} file Files
		 */

		/**
		 * Properties of a FileDescriptorProto message.
		 * @interface IFileDescriptorProto
		 * @property {string} [name] File name
		 * @property {string} [package] Package
		 * @property {*} [dependency] Not supported
		 * @property {*} [publicDependency] Not supported
		 * @property {*} [weakDependency] Not supported
		 * @property {IDescriptorProto[]} [messageType] Nested message types
		 * @property {IEnumDescriptorProto[]} [enumType] Nested enums
		 * @property {IServiceDescriptorProto[]} [service] Nested services
		 * @property {IFieldDescriptorProto[]} [extension] Nested extension fields
		 * @property {IFileOptions} [options] Options
		 * @property {*} [sourceCodeInfo] Not supported
		 * @property {string} [syntax="proto2"] Syntax
		 */

		/**
		 * Properties of a FileOptions message.
		 * @interface IFileOptions
		 * @property {string} [javaPackage]
		 * @property {string} [javaOuterClassname]
		 * @property {boolean} [javaMultipleFiles]
		 * @property {boolean} [javaGenerateEqualsAndHash]
		 * @property {boolean} [javaStringCheckUtf8]
		 * @property {IFileOptionsOptimizeMode} [optimizeFor=1]
		 * @property {string} [goPackage]
		 * @property {boolean} [ccGenericServices]
		 * @property {boolean} [javaGenericServices]
		 * @property {boolean} [pyGenericServices]
		 * @property {boolean} [deprecated]
		 * @property {boolean} [ccEnableArenas]
		 * @property {string} [objcClassPrefix]
		 * @property {string} [csharpNamespace]
		 */

		/**
		 * Values of he FileOptions.OptimizeMode enum.
		 * @typedef IFileOptionsOptimizeMode
		 * @type {number}
		 * @property {number} SPEED=1
		 * @property {number} CODE_SIZE=2
		 * @property {number} LITE_RUNTIME=3
		 */

		/**
		 * Creates a root from a descriptor set.
		 * @param {IFileDescriptorSet|Reader|Uint8Array} descriptor Descriptor
		 * @returns {Root} Root instance
		 */
		Root.fromDescriptor = function fromDescriptor(descriptor) {

		    // Decode the descriptor message if specified as a buffer:
		    if (typeof descriptor.length === "number")
		        descriptor = exports.FileDescriptorSet.decode(descriptor);

		    var root = new Root();

		    if (descriptor.file) {
		        var fileDescriptor,
		            filePackage;
		        for (var j = 0, i; j < descriptor.file.length; ++j) {
		            filePackage = root;
		            if ((fileDescriptor = descriptor.file[j])["package"] && fileDescriptor["package"].length)
		                filePackage = root.define(fileDescriptor["package"]);
		            if (fileDescriptor.name && fileDescriptor.name.length)
		                root.files.push(filePackage.filename = fileDescriptor.name);
		            if (fileDescriptor.messageType)
		                for (i = 0; i < fileDescriptor.messageType.length; ++i)
		                    filePackage.add(Type.fromDescriptor(fileDescriptor.messageType[i], fileDescriptor.syntax));
		            if (fileDescriptor.enumType)
		                for (i = 0; i < fileDescriptor.enumType.length; ++i)
		                    filePackage.add(Enum.fromDescriptor(fileDescriptor.enumType[i]));
		            if (fileDescriptor.extension)
		                for (i = 0; i < fileDescriptor.extension.length; ++i)
		                    filePackage.add(Field.fromDescriptor(fileDescriptor.extension[i]));
		            if (fileDescriptor.service)
		                for (i = 0; i < fileDescriptor.service.length; ++i)
		                    filePackage.add(Service.fromDescriptor(fileDescriptor.service[i]));
		            var opts = fromDescriptorOptions(fileDescriptor.options, exports.FileOptions);
		            if (opts) {
		                var ks = Object.keys(opts);
		                for (i = 0; i < ks.length; ++i)
		                    filePackage.setOption(ks[i], opts[ks[i]]);
		            }
		        }
		    }

		    return root;
		};

		/**
		 * Converts a root to a descriptor set.
		 * @returns {Message<IFileDescriptorSet>} Descriptor
		 * @param {string} [syntax="proto2"] Syntax
		 */
		Root.prototype.toDescriptor = function toDescriptor(syntax) {
		    var set = exports.FileDescriptorSet.create();
		    Root_toDescriptorRecursive(this, set.file, syntax);
		    return set;
		};

		// Traverses a namespace and assembles the descriptor set
		function Root_toDescriptorRecursive(ns, files, syntax) {

		    // Create a new file
		    var file = exports.FileDescriptorProto.create({ name: ns.filename || (ns.fullName.substring(1).replace(/\./g, "_") || "root") + ".proto" });
		    if (syntax)
		        file.syntax = syntax;
		    if (!(ns instanceof Root))
		        file["package"] = ns.fullName.substring(1);

		    // Add nested types
		    for (var i = 0, nested; i < ns.nestedArray.length; ++i)
		        if ((nested = ns._nestedArray[i]) instanceof Type)
		            file.messageType.push(nested.toDescriptor(syntax));
		        else if (nested instanceof Enum)
		            file.enumType.push(nested.toDescriptor());
		        else if (nested instanceof Field)
		            file.extension.push(nested.toDescriptor(syntax));
		        else if (nested instanceof Service)
		            file.service.push(nested.toDescriptor());
		        else if (nested instanceof /* plain */ Namespace)
		            Root_toDescriptorRecursive(nested, files, syntax); // requires new file

		    // Keep package-level options
		    file.options = toDescriptorOptions(ns.options, exports.FileOptions);

		    // And keep the file only if there is at least one nested object
		    if (file.messageType.length + file.enumType.length + file.extension.length + file.service.length)
		        files.push(file);
		}

		// --- Type ---

		/**
		 * Properties of a DescriptorProto message.
		 * @interface IDescriptorProto
		 * @property {string} [name] Message type name
		 * @property {IFieldDescriptorProto[]} [field] Fields
		 * @property {IFieldDescriptorProto[]} [extension] Extension fields
		 * @property {IDescriptorProto[]} [nestedType] Nested message types
		 * @property {IEnumDescriptorProto[]} [enumType] Nested enums
		 * @property {IDescriptorProtoExtensionRange[]} [extensionRange] Extension ranges
		 * @property {IOneofDescriptorProto[]} [oneofDecl] Oneofs
		 * @property {IMessageOptions} [options] Not supported
		 * @property {IDescriptorProtoReservedRange[]} [reservedRange] Reserved ranges
		 * @property {string[]} [reservedName] Reserved names
		 */

		/**
		 * Properties of a MessageOptions message.
		 * @interface IMessageOptions
		 * @property {boolean} [mapEntry=false] Whether this message is a map entry
		 */

		/**
		 * Properties of an ExtensionRange message.
		 * @interface IDescriptorProtoExtensionRange
		 * @property {number} [start] Start field id
		 * @property {number} [end] End field id
		 */

		/**
		 * Properties of a ReservedRange message.
		 * @interface IDescriptorProtoReservedRange
		 * @property {number} [start] Start field id
		 * @property {number} [end] End field id
		 */

		var unnamedMessageIndex = 0;

		/**
		 * Creates a type from a descriptor.
		 * @param {IDescriptorProto|Reader|Uint8Array} descriptor Descriptor
		 * @param {string} [syntax="proto2"] Syntax
		 * @returns {Type} Type instance
		 */
		Type.fromDescriptor = function fromDescriptor(descriptor, syntax) {

		    // Decode the descriptor message if specified as a buffer:
		    if (typeof descriptor.length === "number")
		        descriptor = exports.DescriptorProto.decode(descriptor);

		    // Create the message type
		    var type = new Type(descriptor.name.length ? descriptor.name : "Type" + unnamedMessageIndex++, fromDescriptorOptions(descriptor.options, exports.MessageOptions)),
		        i;

		    /* Oneofs */ if (descriptor.oneofDecl)
		        for (i = 0; i < descriptor.oneofDecl.length; ++i)
		            type.add(OneOf.fromDescriptor(descriptor.oneofDecl[i]));
		    /* Fields */ if (descriptor.field)
		        for (i = 0; i < descriptor.field.length; ++i) {
		            var field = Field.fromDescriptor(descriptor.field[i], syntax);
		            type.add(field);
		            if (descriptor.field[i].hasOwnProperty("oneofIndex")) // eslint-disable-line no-prototype-builtins
		                type.oneofsArray[descriptor.field[i].oneofIndex].add(field);
		        }
		    /* Extension fields */ if (descriptor.extension)
		        for (i = 0; i < descriptor.extension.length; ++i)
		            type.add(Field.fromDescriptor(descriptor.extension[i], syntax));
		    /* Nested types */ if (descriptor.nestedType)
		        for (i = 0; i < descriptor.nestedType.length; ++i) {
		            type.add(Type.fromDescriptor(descriptor.nestedType[i], syntax));
		            if (descriptor.nestedType[i].options && descriptor.nestedType[i].options.mapEntry)
		                type.setOption("map_entry", true);
		        }
		    /* Nested enums */ if (descriptor.enumType)
		        for (i = 0; i < descriptor.enumType.length; ++i)
		            type.add(Enum.fromDescriptor(descriptor.enumType[i]));
		    /* Extension ranges */ if (descriptor.extensionRange && descriptor.extensionRange.length) {
		        type.extensions = [];
		        for (i = 0; i < descriptor.extensionRange.length; ++i)
		            type.extensions.push([ descriptor.extensionRange[i].start, descriptor.extensionRange[i].end ]);
		    }
		    /* Reserved... */ if (descriptor.reservedRange && descriptor.reservedRange.length || descriptor.reservedName && descriptor.reservedName.length) {
		        type.reserved = [];
		        /* Ranges */ if (descriptor.reservedRange)
		            for (i = 0; i < descriptor.reservedRange.length; ++i)
		                type.reserved.push([ descriptor.reservedRange[i].start, descriptor.reservedRange[i].end ]);
		        /* Names */ if (descriptor.reservedName)
		            for (i = 0; i < descriptor.reservedName.length; ++i)
		                type.reserved.push(descriptor.reservedName[i]);
		    }

		    return type;
		};

		/**
		 * Converts a type to a descriptor.
		 * @returns {Message<IDescriptorProto>} Descriptor
		 * @param {string} [syntax="proto2"] Syntax
		 */
		Type.prototype.toDescriptor = function toDescriptor(syntax) {
		    var descriptor = exports.DescriptorProto.create({ name: this.name }),
		        i;

		    /* Fields */ for (i = 0; i < this.fieldsArray.length; ++i) {
		        var fieldDescriptor;
		        descriptor.field.push(fieldDescriptor = this._fieldsArray[i].toDescriptor(syntax));
		        if (this._fieldsArray[i] instanceof MapField) { // map fields are repeated FieldNameEntry
		            var keyType = toDescriptorType(this._fieldsArray[i].keyType, this._fieldsArray[i].resolvedKeyType),
		                valueType = toDescriptorType(this._fieldsArray[i].type, this._fieldsArray[i].resolvedType),
		                valueTypeName = valueType === /* type */ 11 || valueType === /* enum */ 14
		                    ? this._fieldsArray[i].resolvedType && shortname(this.parent, this._fieldsArray[i].resolvedType) || this._fieldsArray[i].type
		                    : undefined;
		            descriptor.nestedType.push(exports.DescriptorProto.create({
		                name: fieldDescriptor.typeName,
		                field: [
		                    exports.FieldDescriptorProto.create({ name: "key", number: 1, label: 1, type: keyType }), // can't reference a type or enum
		                    exports.FieldDescriptorProto.create({ name: "value", number: 2, label: 1, type: valueType, typeName: valueTypeName })
		                ],
		                options: exports.MessageOptions.create({ mapEntry: true })
		            }));
		        }
		    }
		    /* Oneofs */ for (i = 0; i < this.oneofsArray.length; ++i)
		        descriptor.oneofDecl.push(this._oneofsArray[i].toDescriptor());
		    /* Nested... */ for (i = 0; i < this.nestedArray.length; ++i) {
		        /* Extension fields */ if (this._nestedArray[i] instanceof Field)
		            descriptor.field.push(this._nestedArray[i].toDescriptor(syntax));
		        /* Types */ else if (this._nestedArray[i] instanceof Type)
		            descriptor.nestedType.push(this._nestedArray[i].toDescriptor(syntax));
		        /* Enums */ else if (this._nestedArray[i] instanceof Enum)
		            descriptor.enumType.push(this._nestedArray[i].toDescriptor());
		        // plain nested namespaces become packages instead in Root#toDescriptor
		    }
		    /* Extension ranges */ if (this.extensions)
		        for (i = 0; i < this.extensions.length; ++i)
		            descriptor.extensionRange.push(exports.DescriptorProto.ExtensionRange.create({ start: this.extensions[i][0], end: this.extensions[i][1] }));
		    /* Reserved... */ if (this.reserved)
		        for (i = 0; i < this.reserved.length; ++i)
		            /* Names */ if (typeof this.reserved[i] === "string")
		                descriptor.reservedName.push(this.reserved[i]);
		            /* Ranges */ else
		                descriptor.reservedRange.push(exports.DescriptorProto.ReservedRange.create({ start: this.reserved[i][0], end: this.reserved[i][1] }));

		    descriptor.options = toDescriptorOptions(this.options, exports.MessageOptions);

		    return descriptor;
		};

		// --- Field ---

		/**
		 * Properties of a FieldDescriptorProto message.
		 * @interface IFieldDescriptorProto
		 * @property {string} [name] Field name
		 * @property {number} [number] Field id
		 * @property {IFieldDescriptorProtoLabel} [label] Field rule
		 * @property {IFieldDescriptorProtoType} [type] Field basic type
		 * @property {string} [typeName] Field type name
		 * @property {string} [extendee] Extended type name
		 * @property {string} [defaultValue] Literal default value
		 * @property {number} [oneofIndex] Oneof index if part of a oneof
		 * @property {*} [jsonName] Not supported
		 * @property {IFieldOptions} [options] Field options
		 */

		/**
		 * Values of the FieldDescriptorProto.Label enum.
		 * @typedef IFieldDescriptorProtoLabel
		 * @type {number}
		 * @property {number} LABEL_OPTIONAL=1
		 * @property {number} LABEL_REQUIRED=2
		 * @property {number} LABEL_REPEATED=3
		 */

		/**
		 * Values of the FieldDescriptorProto.Type enum.
		 * @typedef IFieldDescriptorProtoType
		 * @type {number}
		 * @property {number} TYPE_DOUBLE=1
		 * @property {number} TYPE_FLOAT=2
		 * @property {number} TYPE_INT64=3
		 * @property {number} TYPE_UINT64=4
		 * @property {number} TYPE_INT32=5
		 * @property {number} TYPE_FIXED64=6
		 * @property {number} TYPE_FIXED32=7
		 * @property {number} TYPE_BOOL=8
		 * @property {number} TYPE_STRING=9
		 * @property {number} TYPE_GROUP=10
		 * @property {number} TYPE_MESSAGE=11
		 * @property {number} TYPE_BYTES=12
		 * @property {number} TYPE_UINT32=13
		 * @property {number} TYPE_ENUM=14
		 * @property {number} TYPE_SFIXED32=15
		 * @property {number} TYPE_SFIXED64=16
		 * @property {number} TYPE_SINT32=17
		 * @property {number} TYPE_SINT64=18
		 */

		/**
		 * Properties of a FieldOptions message.
		 * @interface IFieldOptions
		 * @property {boolean} [packed] Whether packed or not (defaults to `false` for proto2 and `true` for proto3)
		 * @property {IFieldOptionsJSType} [jstype] JavaScript value type (not used by protobuf.js)
		 */

		/**
		 * Values of the FieldOptions.JSType enum.
		 * @typedef IFieldOptionsJSType
		 * @type {number}
		 * @property {number} JS_NORMAL=0
		 * @property {number} JS_STRING=1
		 * @property {number} JS_NUMBER=2
		 */

		// copied here from parse.js
		var numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;

		/**
		 * Creates a field from a descriptor.
		 * @param {IFieldDescriptorProto|Reader|Uint8Array} descriptor Descriptor
		 * @param {string} [syntax="proto2"] Syntax
		 * @returns {Field} Field instance
		 */
		Field.fromDescriptor = function fromDescriptor(descriptor, syntax) {

		    // Decode the descriptor message if specified as a buffer:
		    if (typeof descriptor.length === "number")
		        descriptor = exports.DescriptorProto.decode(descriptor);

		    if (typeof descriptor.number !== "number")
		        throw Error("missing field id");

		    // Rewire field type
		    var fieldType;
		    if (descriptor.typeName && descriptor.typeName.length)
		        fieldType = descriptor.typeName;
		    else
		        fieldType = fromDescriptorType(descriptor.type);

		    // Rewire field rule
		    var fieldRule;
		    switch (descriptor.label) {
		        // 0 is reserved for errors
		        case 1: fieldRule = undefined; break;
		        case 2: fieldRule = "required"; break;
		        case 3: fieldRule = "repeated"; break;
		        default: throw Error("illegal label: " + descriptor.label);
		    }

			var extendee = descriptor.extendee;
			if (descriptor.extendee !== undefined) {
				extendee = extendee.length ? extendee : undefined;
			}
		    var field = new Field(
		        descriptor.name.length ? descriptor.name : "field" + descriptor.number,
		        descriptor.number,
		        fieldType,
		        fieldRule,
		        extendee
		    );

		    field.options = fromDescriptorOptions(descriptor.options, exports.FieldOptions);

		    if (descriptor.defaultValue && descriptor.defaultValue.length) {
		        var defaultValue = descriptor.defaultValue;
		        switch (defaultValue) {
		            case "true": case "TRUE":
		                defaultValue = true;
		                break;
		            case "false": case "FALSE":
		                defaultValue = false;
		                break;
		            default:
		                var match = numberRe.exec(defaultValue);
		                if (match)
		                    defaultValue = parseInt(defaultValue); // eslint-disable-line radix
		                break;
		        }
		        field.setOption("default", defaultValue);
		    }

		    if (packableDescriptorType(descriptor.type)) {
		        if (syntax === "proto3") { // defaults to packed=true (internal preset is packed=true)
		            if (descriptor.options && !descriptor.options.packed)
		                field.setOption("packed", false);
		        } else if (!(descriptor.options && descriptor.options.packed)) // defaults to packed=false
		            field.setOption("packed", false);
		    }

		    return field;
		};

		/**
		 * Converts a field to a descriptor.
		 * @returns {Message<IFieldDescriptorProto>} Descriptor
		 * @param {string} [syntax="proto2"] Syntax
		 */
		Field.prototype.toDescriptor = function toDescriptor(syntax) {
		    var descriptor = exports.FieldDescriptorProto.create({ name: this.name, number: this.id });

		    if (this.map) {

		        descriptor.type = 11; // message
		        descriptor.typeName = $protobuf.util.ucFirst(this.name); // fieldName -> FieldNameEntry (built in Type#toDescriptor)
		        descriptor.label = 3; // repeated

		    } else {

		        // Rewire field type
		        switch (descriptor.type = toDescriptorType(this.type, this.resolve().resolvedType)) {
		            case 10: // group
		            case 11: // type
		            case 14: // enum
		                descriptor.typeName = this.resolvedType ? shortname(this.parent, this.resolvedType) : this.type;
		                break;
		        }

		        // Rewire field rule
		        switch (this.rule) {
		            case "repeated": descriptor.label = 3; break;
		            case "required": descriptor.label = 2; break;
		            default: descriptor.label = 1; break;
		        }

		    }

		    // Handle extension field
		    descriptor.extendee = this.extensionField ? this.extensionField.parent.fullName : this.extend;

		    // Handle part of oneof
		    if (this.partOf)
		        if ((descriptor.oneofIndex = this.parent.oneofsArray.indexOf(this.partOf)) < 0)
		            throw Error("missing oneof");

		    if (this.options) {
		        descriptor.options = toDescriptorOptions(this.options, exports.FieldOptions);
		        if (this.options["default"] != null)
		            descriptor.defaultValue = String(this.options["default"]);
		    }

		    if (syntax === "proto3") { // defaults to packed=true
		        if (!this.packed)
		            (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = false;
		    } else if (this.packed) // defaults to packed=false
		        (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = true;

		    return descriptor;
		};

		// --- Enum ---

		/**
		 * Properties of an EnumDescriptorProto message.
		 * @interface IEnumDescriptorProto
		 * @property {string} [name] Enum name
		 * @property {IEnumValueDescriptorProto[]} [value] Enum values
		 * @property {IEnumOptions} [options] Enum options
		 */

		/**
		 * Properties of an EnumValueDescriptorProto message.
		 * @interface IEnumValueDescriptorProto
		 * @property {string} [name] Name
		 * @property {number} [number] Value
		 * @property {*} [options] Not supported
		 */

		/**
		 * Properties of an EnumOptions message.
		 * @interface IEnumOptions
		 * @property {boolean} [allowAlias] Whether aliases are allowed
		 * @property {boolean} [deprecated]
		 */

		var unnamedEnumIndex = 0;

		/**
		 * Creates an enum from a descriptor.
		 * @param {IEnumDescriptorProto|Reader|Uint8Array} descriptor Descriptor
		 * @returns {Enum} Enum instance
		 */
		Enum.fromDescriptor = function fromDescriptor(descriptor) {

		    // Decode the descriptor message if specified as a buffer:
		    if (typeof descriptor.length === "number")
		        descriptor = exports.EnumDescriptorProto.decode(descriptor);

		    // Construct values object
		    var values = {};
		    if (descriptor.value)
		        for (var i = 0; i < descriptor.value.length; ++i) {
		            var name  = descriptor.value[i].name,
		                value = descriptor.value[i].number || 0;
		            values[name && name.length ? name : "NAME" + value] = value;
		        }

		    return new Enum(
		        descriptor.name && descriptor.name.length ? descriptor.name : "Enum" + unnamedEnumIndex++,
		        values,
		        fromDescriptorOptions(descriptor.options, exports.EnumOptions)
		    );
		};

		/**
		 * Converts an enum to a descriptor.
		 * @returns {Message<IEnumDescriptorProto>} Descriptor
		 */
		Enum.prototype.toDescriptor = function toDescriptor() {

		    // Values
		    var values = [];
		    for (var i = 0, ks = Object.keys(this.values); i < ks.length; ++i)
		        values.push(exports.EnumValueDescriptorProto.create({ name: ks[i], number: this.values[ks[i]] }));

		    return exports.EnumDescriptorProto.create({
		        name: this.name,
		        value: values,
		        options: toDescriptorOptions(this.options, exports.EnumOptions)
		    });
		};

		// --- OneOf ---

		/**
		 * Properties of a OneofDescriptorProto message.
		 * @interface IOneofDescriptorProto
		 * @property {string} [name] Oneof name
		 * @property {*} [options] Not supported
		 */

		var unnamedOneofIndex = 0;

		/**
		 * Creates a oneof from a descriptor.
		 * @param {IOneofDescriptorProto|Reader|Uint8Array} descriptor Descriptor
		 * @returns {OneOf} OneOf instance
		 */
		OneOf.fromDescriptor = function fromDescriptor(descriptor) {

		    // Decode the descriptor message if specified as a buffer:
		    if (typeof descriptor.length === "number")
		        descriptor = exports.OneofDescriptorProto.decode(descriptor);

		    return new OneOf(
		        // unnamedOneOfIndex is global, not per type, because we have no ref to a type here
		        descriptor.name && descriptor.name.length ? descriptor.name : "oneof" + unnamedOneofIndex++
		        // fromDescriptorOptions(descriptor.options, exports.OneofOptions) - only uninterpreted_option
		    );
		};

		/**
		 * Converts a oneof to a descriptor.
		 * @returns {Message<IOneofDescriptorProto>} Descriptor
		 */
		OneOf.prototype.toDescriptor = function toDescriptor() {
		    return exports.OneofDescriptorProto.create({
		        name: this.name
		        // options: toDescriptorOptions(this.options, exports.OneofOptions) - only uninterpreted_option
		    });
		};

		// --- Service ---

		/**
		 * Properties of a ServiceDescriptorProto message.
		 * @interface IServiceDescriptorProto
		 * @property {string} [name] Service name
		 * @property {IMethodDescriptorProto[]} [method] Methods
		 * @property {IServiceOptions} [options] Options
		 */

		/**
		 * Properties of a ServiceOptions message.
		 * @interface IServiceOptions
		 * @property {boolean} [deprecated]
		 */

		var unnamedServiceIndex = 0;

		/**
		 * Creates a service from a descriptor.
		 * @param {IServiceDescriptorProto|Reader|Uint8Array} descriptor Descriptor
		 * @returns {Service} Service instance
		 */
		Service.fromDescriptor = function fromDescriptor(descriptor) {

		    // Decode the descriptor message if specified as a buffer:
		    if (typeof descriptor.length === "number")
		        descriptor = exports.ServiceDescriptorProto.decode(descriptor);

		    var service = new Service(descriptor.name && descriptor.name.length ? descriptor.name : "Service" + unnamedServiceIndex++, fromDescriptorOptions(descriptor.options, exports.ServiceOptions));
		    if (descriptor.method)
		        for (var i = 0; i < descriptor.method.length; ++i)
		            service.add(Method.fromDescriptor(descriptor.method[i]));

		    return service;
		};

		/**
		 * Converts a service to a descriptor.
		 * @returns {Message<IServiceDescriptorProto>} Descriptor
		 */
		Service.prototype.toDescriptor = function toDescriptor() {

		    // Methods
		    var methods = [];
		    for (var i = 0; i < this.methodsArray.length; ++i)
		        methods.push(this._methodsArray[i].toDescriptor());

		    return exports.ServiceDescriptorProto.create({
		        name: this.name,
		        method: methods,
		        options: toDescriptorOptions(this.options, exports.ServiceOptions)
		    });
		};

		// --- Method ---

		/**
		 * Properties of a MethodDescriptorProto message.
		 * @interface IMethodDescriptorProto
		 * @property {string} [name] Method name
		 * @property {string} [inputType] Request type name
		 * @property {string} [outputType] Response type name
		 * @property {IMethodOptions} [options] Not supported
		 * @property {boolean} [clientStreaming=false] Whether requests are streamed
		 * @property {boolean} [serverStreaming=false] Whether responses are streamed
		 */

		/**
		 * Properties of a MethodOptions message.
		 * @interface IMethodOptions
		 * @property {boolean} [deprecated]
		 */

		var unnamedMethodIndex = 0;

		/**
		 * Creates a method from a descriptor.
		 * @param {IMethodDescriptorProto|Reader|Uint8Array} descriptor Descriptor
		 * @returns {Method} Reflected method instance
		 */
		Method.fromDescriptor = function fromDescriptor(descriptor) {

		    // Decode the descriptor message if specified as a buffer:
		    if (typeof descriptor.length === "number")
		        descriptor = exports.MethodDescriptorProto.decode(descriptor);

		    return new Method(
		        // unnamedMethodIndex is global, not per service, because we have no ref to a service here
		        descriptor.name && descriptor.name.length ? descriptor.name : "Method" + unnamedMethodIndex++,
		        "rpc",
		        descriptor.inputType,
		        descriptor.outputType,
		        Boolean(descriptor.clientStreaming),
		        Boolean(descriptor.serverStreaming),
		        fromDescriptorOptions(descriptor.options, exports.MethodOptions)
		    );
		};

		/**
		 * Converts a method to a descriptor.
		 * @returns {Message<IMethodDescriptorProto>} Descriptor
		 */
		Method.prototype.toDescriptor = function toDescriptor() {
		    return exports.MethodDescriptorProto.create({
		        name: this.name,
		        inputType: this.resolvedRequestType ? this.resolvedRequestType.fullName : this.requestType,
		        outputType: this.resolvedResponseType ? this.resolvedResponseType.fullName : this.responseType,
		        clientStreaming: this.requestStream,
		        serverStreaming: this.responseStream,
		        options: toDescriptorOptions(this.options, exports.MethodOptions)
		    });
		};

		// --- utility ---

		// Converts a descriptor type to a protobuf.js basic type
		function fromDescriptorType(type) {
		    switch (type) {
		        // 0 is reserved for errors
		        case 1: return "double";
		        case 2: return "float";
		        case 3: return "int64";
		        case 4: return "uint64";
		        case 5: return "int32";
		        case 6: return "fixed64";
		        case 7: return "fixed32";
		        case 8: return "bool";
		        case 9: return "string";
		        case 12: return "bytes";
		        case 13: return "uint32";
		        case 15: return "sfixed32";
		        case 16: return "sfixed64";
		        case 17: return "sint32";
		        case 18: return "sint64";
		    }
		    throw Error("illegal type: " + type);
		}

		// Tests if a descriptor type is packable
		function packableDescriptorType(type) {
		    switch (type) {
		        case 1: // double
		        case 2: // float
		        case 3: // int64
		        case 4: // uint64
		        case 5: // int32
		        case 6: // fixed64
		        case 7: // fixed32
		        case 8: // bool
		        case 13: // uint32
		        case 14: // enum (!)
		        case 15: // sfixed32
		        case 16: // sfixed64
		        case 17: // sint32
		        case 18: // sint64
		            return true;
		    }
		    return false;
		}

		// Converts a protobuf.js basic type to a descriptor type
		function toDescriptorType(type, resolvedType) {
		    switch (type) {
		        // 0 is reserved for errors
		        case "double": return 1;
		        case "float": return 2;
		        case "int64": return 3;
		        case "uint64": return 4;
		        case "int32": return 5;
		        case "fixed64": return 6;
		        case "fixed32": return 7;
		        case "bool": return 8;
		        case "string": return 9;
		        case "bytes": return 12;
		        case "uint32": return 13;
		        case "sfixed32": return 15;
		        case "sfixed64": return 16;
		        case "sint32": return 17;
		        case "sint64": return 18;
		    }
		    if (resolvedType instanceof Enum)
		        return 14;
		    if (resolvedType instanceof Type)
		        return resolvedType.group ? 10 : 11;
		    throw Error("illegal type: " + type);
		}

		// Converts descriptor options to an options object
		function fromDescriptorOptions(options, type) {
		    if (!options)
		        return undefined;
		    var out = [];
		    for (var i = 0, field, key, val; i < type.fieldsArray.length; ++i)
		        if ((key = (field = type._fieldsArray[i]).name) !== "uninterpretedOption")
		            if (options.hasOwnProperty(key)) { // eslint-disable-line no-prototype-builtins
		                val = options[key];
		                if (field.resolvedType instanceof Enum && typeof val === "number" && field.resolvedType.valuesById[val] !== undefined)
		                    val = field.resolvedType.valuesById[val];
		                out.push(underScore(key), val);
		            }
		    return out.length ? $protobuf.util.toObject(out) : undefined;
		}

		// Converts an options object to descriptor options
		function toDescriptorOptions(options, type) {
		    if (!options)
		        return undefined;
		    var out = [];
		    for (var i = 0, ks = Object.keys(options), key, val; i < ks.length; ++i) {
		        val = options[key = ks[i]];
		        if (key === "default")
		            continue;
		        var field = type.fields[key];
		        if (!field && !(field = type.fields[key = $protobuf.util.camelCase(key)]))
		            continue;
		        out.push(key, val);
		    }
		    return out.length ? type.fromObject($protobuf.util.toObject(out)) : undefined;
		}

		// Calculates the shortest relative path from `from` to `to`.
		function shortname(from, to) {
		    var fromPath = from.fullName.split("."),
		        toPath = to.fullName.split("."),
		        i = 0,
		        j = 0,
		        k = toPath.length - 1;
		    if (!(from instanceof Root) && to instanceof Namespace)
		        while (i < fromPath.length && j < k && fromPath[i] === toPath[j]) {
		            var other = to.lookup(fromPath[i++], true);
		            if (other !== null && other !== to)
		                break;
		            ++j;
		        }
		    else
		        for (; i < fromPath.length && j < k && fromPath[i] === toPath[j]; ++i, ++j);
		    return toPath.slice(j).join(".");
		}

		// copied here from cli/targets/proto.js
		function underScore(str) {
		    return str.substring(0,1)
		         + str.substring(1)
		               .replace(/([A-Z])(?=[a-z]|$)/g, function($0, $1) { return "_" + $1.toLowerCase(); });
		}

		// --- exports ---

		/**
		 * Reflected file descriptor set.
		 * @name FileDescriptorSet
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected file descriptor proto.
		 * @name FileDescriptorProto
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected descriptor proto.
		 * @name DescriptorProto
		 * @type {Type}
		 * @property {Type} ExtensionRange
		 * @property {Type} ReservedRange
		 * @const
		 * @tstype $protobuf.Type & {
		 *     ExtensionRange: $protobuf.Type,
		 *     ReservedRange: $protobuf.Type
		 * }
		 */

		/**
		 * Reflected field descriptor proto.
		 * @name FieldDescriptorProto
		 * @type {Type}
		 * @property {Enum} Label
		 * @property {Enum} Type
		 * @const
		 * @tstype $protobuf.Type & {
		 *     Label: $protobuf.Enum,
		 *     Type: $protobuf.Enum
		 * }
		 */

		/**
		 * Reflected oneof descriptor proto.
		 * @name OneofDescriptorProto
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected enum descriptor proto.
		 * @name EnumDescriptorProto
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected service descriptor proto.
		 * @name ServiceDescriptorProto
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected enum value descriptor proto.
		 * @name EnumValueDescriptorProto
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected method descriptor proto.
		 * @name MethodDescriptorProto
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected file options.
		 * @name FileOptions
		 * @type {Type}
		 * @property {Enum} OptimizeMode
		 * @const
		 * @tstype $protobuf.Type & {
		 *     OptimizeMode: $protobuf.Enum
		 * }
		 */

		/**
		 * Reflected message options.
		 * @name MessageOptions
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected field options.
		 * @name FieldOptions
		 * @type {Type}
		 * @property {Enum} CType
		 * @property {Enum} JSType
		 * @const
		 * @tstype $protobuf.Type & {
		 *     CType: $protobuf.Enum,
		 *     JSType: $protobuf.Enum
		 * }
		 */

		/**
		 * Reflected oneof options.
		 * @name OneofOptions
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected enum options.
		 * @name EnumOptions
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected enum value options.
		 * @name EnumValueOptions
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected service options.
		 * @name ServiceOptions
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected method options.
		 * @name MethodOptions
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected uninterpretet option.
		 * @name UninterpretedOption
		 * @type {Type}
		 * @property {Type} NamePart
		 * @const
		 * @tstype $protobuf.Type & {
		 *     NamePart: $protobuf.Type
		 * }
		 */

		/**
		 * Reflected source code info.
		 * @name SourceCodeInfo
		 * @type {Type}
		 * @property {Type} Location
		 * @const
		 * @tstype $protobuf.Type & {
		 *     Location: $protobuf.Type
		 * }
		 */

		/**
		 * Reflected generated code info.
		 * @name GeneratedCodeInfo
		 * @type {Type}
		 * @property {Type} Annotation
		 * @const
		 * @tstype $protobuf.Type & {
		 *     Annotation: $protobuf.Type
		 * }
		 */ 
	} (descriptor, descriptor.exports));
	return descriptor.exports;
}

var util = {};

var nested$2 = {
	google: {
		nested: {
			protobuf: {
				nested: {
					Api: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							methods: {
								rule: "repeated",
								type: "Method",
								id: 2
							},
							options: {
								rule: "repeated",
								type: "Option",
								id: 3
							},
							version: {
								type: "string",
								id: 4
							},
							sourceContext: {
								type: "SourceContext",
								id: 5
							},
							mixins: {
								rule: "repeated",
								type: "Mixin",
								id: 6
							},
							syntax: {
								type: "Syntax",
								id: 7
							}
						}
					},
					Method: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							requestTypeUrl: {
								type: "string",
								id: 2
							},
							requestStreaming: {
								type: "bool",
								id: 3
							},
							responseTypeUrl: {
								type: "string",
								id: 4
							},
							responseStreaming: {
								type: "bool",
								id: 5
							},
							options: {
								rule: "repeated",
								type: "Option",
								id: 6
							},
							syntax: {
								type: "Syntax",
								id: 7
							}
						}
					},
					Mixin: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							root: {
								type: "string",
								id: 2
							}
						}
					},
					SourceContext: {
						fields: {
							fileName: {
								type: "string",
								id: 1
							}
						}
					},
					Option: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							value: {
								type: "Any",
								id: 2
							}
						}
					},
					Syntax: {
						values: {
							SYNTAX_PROTO2: 0,
							SYNTAX_PROTO3: 1
						}
					}
				}
			}
		}
	}
};
const require$$3 = {
	nested: nested$2
};

var nested$1 = {
	google: {
		nested: {
			protobuf: {
				nested: {
					SourceContext: {
						fields: {
							fileName: {
								type: "string",
								id: 1
							}
						}
					}
				}
			}
		}
	}
};
const require$$5 = {
	nested: nested$1
};

var nested = {
	google: {
		nested: {
			protobuf: {
				nested: {
					Type: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							fields: {
								rule: "repeated",
								type: "Field",
								id: 2
							},
							oneofs: {
								rule: "repeated",
								type: "string",
								id: 3
							},
							options: {
								rule: "repeated",
								type: "Option",
								id: 4
							},
							sourceContext: {
								type: "SourceContext",
								id: 5
							},
							syntax: {
								type: "Syntax",
								id: 6
							}
						}
					},
					Field: {
						fields: {
							kind: {
								type: "Kind",
								id: 1
							},
							cardinality: {
								type: "Cardinality",
								id: 2
							},
							number: {
								type: "int32",
								id: 3
							},
							name: {
								type: "string",
								id: 4
							},
							typeUrl: {
								type: "string",
								id: 6
							},
							oneofIndex: {
								type: "int32",
								id: 7
							},
							packed: {
								type: "bool",
								id: 8
							},
							options: {
								rule: "repeated",
								type: "Option",
								id: 9
							},
							jsonName: {
								type: "string",
								id: 10
							},
							defaultValue: {
								type: "string",
								id: 11
							}
						},
						nested: {
							Kind: {
								values: {
									TYPE_UNKNOWN: 0,
									TYPE_DOUBLE: 1,
									TYPE_FLOAT: 2,
									TYPE_INT64: 3,
									TYPE_UINT64: 4,
									TYPE_INT32: 5,
									TYPE_FIXED64: 6,
									TYPE_FIXED32: 7,
									TYPE_BOOL: 8,
									TYPE_STRING: 9,
									TYPE_GROUP: 10,
									TYPE_MESSAGE: 11,
									TYPE_BYTES: 12,
									TYPE_UINT32: 13,
									TYPE_ENUM: 14,
									TYPE_SFIXED32: 15,
									TYPE_SFIXED64: 16,
									TYPE_SINT32: 17,
									TYPE_SINT64: 18
								}
							},
							Cardinality: {
								values: {
									CARDINALITY_UNKNOWN: 0,
									CARDINALITY_OPTIONAL: 1,
									CARDINALITY_REQUIRED: 2,
									CARDINALITY_REPEATED: 3
								}
							}
						}
					},
					Enum: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							enumvalue: {
								rule: "repeated",
								type: "EnumValue",
								id: 2
							},
							options: {
								rule: "repeated",
								type: "Option",
								id: 3
							},
							sourceContext: {
								type: "SourceContext",
								id: 4
							},
							syntax: {
								type: "Syntax",
								id: 5
							}
						}
					},
					EnumValue: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							number: {
								type: "int32",
								id: 2
							},
							options: {
								rule: "repeated",
								type: "Option",
								id: 3
							}
						}
					},
					Option: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							value: {
								type: "Any",
								id: 2
							}
						}
					},
					Syntax: {
						values: {
							SYNTAX_PROTO2: 0,
							SYNTAX_PROTO3: 1
						}
					},
					Any: {
						fields: {
							type_url: {
								type: "string",
								id: 1
							},
							value: {
								type: "bytes",
								id: 2
							}
						}
					},
					SourceContext: {
						fields: {
							fileName: {
								type: "string",
								id: 1
							}
						}
					}
				}
			}
		}
	}
};
const require$$6 = {
	nested: nested
};

var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util;
	hasRequiredUtil = 1;
	/**
	 * @license
	 * Copyright 2018 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(util, "__esModule", { value: true });
	util.addCommonProtos = util.loadProtosWithOptionsSync = util.loadProtosWithOptions = undefined;
	const fs = require$$0;
	const path = require$$1$1;
	const Protobuf = requireProtobufjs();
	function addIncludePathResolver(root, includePaths) {
	    const originalResolvePath = root.resolvePath;
	    root.resolvePath = (origin, target) => {
	        if (path.isAbsolute(target)) {
	            return target;
	        }
	        for (const directory of includePaths) {
	            const fullPath = path.join(directory, target);
	            try {
	                fs.accessSync(fullPath, fs.constants.R_OK);
	                return fullPath;
	            }
	            catch (err) {
	                continue;
	            }
	        }
	        process.emitWarning(`${target} not found in any of the include paths ${includePaths}`);
	        return originalResolvePath(origin, target);
	    };
	}
	async function loadProtosWithOptions(filename, options) {
	    const root = new Protobuf.Root();
	    options = options || {};
	    if (!!options.includeDirs) {
	        if (!Array.isArray(options.includeDirs)) {
	            return Promise.reject(new Error('The includeDirs option must be an array'));
	        }
	        addIncludePathResolver(root, options.includeDirs);
	    }
	    const loadedRoot = await root.load(filename, options);
	    loadedRoot.resolveAll();
	    return loadedRoot;
	}
	util.loadProtosWithOptions = loadProtosWithOptions;
	function loadProtosWithOptionsSync(filename, options) {
	    const root = new Protobuf.Root();
	    options = options || {};
	    if (!!options.includeDirs) {
	        if (!Array.isArray(options.includeDirs)) {
	            throw new Error('The includeDirs option must be an array');
	        }
	        addIncludePathResolver(root, options.includeDirs);
	    }
	    const loadedRoot = root.loadSync(filename, options);
	    loadedRoot.resolveAll();
	    return loadedRoot;
	}
	util.loadProtosWithOptionsSync = loadProtosWithOptionsSync;
	/**
	 * Load Google's well-known proto files that aren't exposed by Protobuf.js.
	 */
	function addCommonProtos() {
	    // Protobuf.js exposes: any, duration, empty, field_mask, struct, timestamp,
	    // and wrappers. compiler/plugin is excluded in Protobuf.js and here.
	    // Using constant strings for compatibility with tools like Webpack
	    const apiDescriptor = require$$3;
	    const descriptorDescriptor = require$$4;
	    const sourceContextDescriptor = require$$5;
	    const typeDescriptor = require$$6;
	    Protobuf.common('api', apiDescriptor.nested.google.nested.protobuf.nested);
	    Protobuf.common('descriptor', descriptorDescriptor.nested.google.nested.protobuf.nested);
	    Protobuf.common('source_context', sourceContextDescriptor.nested.google.nested.protobuf.nested);
	    Protobuf.common('type', typeDescriptor.nested.google.nested.protobuf.nested);
	}
	util.addCommonProtos = addCommonProtos;
	
	return util;
}

var umd = {exports: {}};

var hasRequiredUmd;

function requireUmd () {
	if (hasRequiredUmd) return umd.exports;
	hasRequiredUmd = 1;
	(function (module, exports) {
		// GENERATED FILE. DO NOT EDIT.
		var Long = (function(exports) {
		  
		  Object.defineProperty(exports, "__esModule", {
		    value: true
		  });
		  exports.default = undefined;
		  
		  /**
		   * @license
		   * Copyright 2009 The Closure Library Authors
		   * Copyright 2020 Daniel Wirtz / The long.js Authors.
		   *
		   * Licensed under the Apache License, Version 2.0 (the "License");
		   * you may not use this file except in compliance with the License.
		   * You may obtain a copy of the License at
		   *
		   *     http://www.apache.org/licenses/LICENSE-2.0
		   *
		   * Unless required by applicable law or agreed to in writing, software
		   * distributed under the License is distributed on an "AS IS" BASIS,
		   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		   * See the License for the specific language governing permissions and
		   * limitations under the License.
		   *
		   * SPDX-License-Identifier: Apache-2.0
		   */
		  // WebAssembly optimizations to do native i64 multiplication and divide
		  var wasm = null;
		  
		  try {
		    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
		  } catch (e) {// no wasm support :(
		  }
		  /**
		   * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
		   *  See the from* functions below for more convenient ways of constructing Longs.
		   * @exports Long
		   * @class A Long class for representing a 64 bit two's-complement integer value.
		   * @param {number} low The low (signed) 32 bits of the long
		   * @param {number} high The high (signed) 32 bits of the long
		   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		   * @constructor
		   */
		  
		  
		  function Long(low, high, unsigned) {
		    /**
		     * The low 32 bits as a signed value.
		     * @type {number}
		     */
		    this.low = low | 0;
		    /**
		     * The high 32 bits as a signed value.
		     * @type {number}
		     */
		  
		    this.high = high | 0;
		    /**
		     * Whether unsigned or not.
		     * @type {boolean}
		     */
		  
		    this.unsigned = !!unsigned;
		  } // The internal representation of a long is the two given signed, 32-bit values.
		  // We use 32-bit pieces because these are the size of integers on which
		  // Javascript performs bit-operations.  For operations like addition and
		  // multiplication, we split each number into 16 bit pieces, which can easily be
		  // multiplied within Javascript's floating-point representation without overflow
		  // or change in sign.
		  //
		  // In the algorithms below, we frequently reduce the negative case to the
		  // positive case by negating the input(s) and then post-processing the result.
		  // Note that we must ALWAYS check specially whether those values are MIN_VALUE
		  // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
		  // a positive number, it overflows back into a negative).  Not handling this
		  // case would often result in infinite recursion.
		  //
		  // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
		  // methods on which they depend.
		  
		  /**
		   * An indicator used to reliably determine if an object is a Long or not.
		   * @type {boolean}
		   * @const
		   * @private
		   */
		  
		  
		  Long.prototype.__isLong__;
		  Object.defineProperty(Long.prototype, "__isLong__", {
		    value: true
		  });
		  /**
		   * @function
		   * @param {*} obj Object
		   * @returns {boolean}
		   * @inner
		   */
		  
		  function isLong(obj) {
		    return (obj && obj["__isLong__"]) === true;
		  }
		  /**
		   * @function
		   * @param {*} value number
		   * @returns {number}
		   * @inner
		   */
		  
		  
		  function ctz32(value) {
		    var c = Math.clz32(value & -value);
		    return value ? 31 - c : c;
		  }
		  /**
		   * Tests if the specified object is a Long.
		   * @function
		   * @param {*} obj Object
		   * @returns {boolean}
		   */
		  
		  
		  Long.isLong = isLong;
		  /**
		   * A cache of the Long representations of small integer values.
		   * @type {!Object}
		   * @inner
		   */
		  
		  var INT_CACHE = {};
		  /**
		   * A cache of the Long representations of small unsigned integer values.
		   * @type {!Object}
		   * @inner
		   */
		  
		  var UINT_CACHE = {};
		  /**
		   * @param {number} value
		   * @param {boolean=} unsigned
		   * @returns {!Long}
		   * @inner
		   */
		  
		  function fromInt(value, unsigned) {
		    var obj, cachedObj, cache;
		  
		    if (unsigned) {
		      value >>>= 0;
		  
		      if (cache = 0 <= value && value < 256) {
		        cachedObj = UINT_CACHE[value];
		        if (cachedObj) return cachedObj;
		      }
		  
		      obj = fromBits(value, 0, true);
		      if (cache) UINT_CACHE[value] = obj;
		      return obj;
		    } else {
		      value |= 0;
		  
		      if (cache = -128 <= value && value < 128) {
		        cachedObj = INT_CACHE[value];
		        if (cachedObj) return cachedObj;
		      }
		  
		      obj = fromBits(value, value < 0 ? -1 : 0, false);
		      if (cache) INT_CACHE[value] = obj;
		      return obj;
		    }
		  }
		  /**
		   * Returns a Long representing the given 32 bit integer value.
		   * @function
		   * @param {number} value The 32 bit integer in question
		   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		   * @returns {!Long} The corresponding Long value
		   */
		  
		  
		  Long.fromInt = fromInt;
		  /**
		   * @param {number} value
		   * @param {boolean=} unsigned
		   * @returns {!Long}
		   * @inner
		   */
		  
		  function fromNumber(value, unsigned) {
		    if (isNaN(value)) return unsigned ? UZERO : ZERO;
		  
		    if (unsigned) {
		      if (value < 0) return UZERO;
		      if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
		    } else {
		      if (value <= -9223372036854776e3) return MIN_VALUE;
		      if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
		    }
		  
		    if (value < 0) return fromNumber(-value, unsigned).neg();
		    return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
		  }
		  /**
		   * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
		   * @function
		   * @param {number} value The number in question
		   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		   * @returns {!Long} The corresponding Long value
		   */
		  
		  
		  Long.fromNumber = fromNumber;
		  /**
		   * @param {number} lowBits
		   * @param {number} highBits
		   * @param {boolean=} unsigned
		   * @returns {!Long}
		   * @inner
		   */
		  
		  function fromBits(lowBits, highBits, unsigned) {
		    return new Long(lowBits, highBits, unsigned);
		  }
		  /**
		   * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
		   *  assumed to use 32 bits.
		   * @function
		   * @param {number} lowBits The low 32 bits
		   * @param {number} highBits The high 32 bits
		   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		   * @returns {!Long} The corresponding Long value
		   */
		  
		  
		  Long.fromBits = fromBits;
		  /**
		   * @function
		   * @param {number} base
		   * @param {number} exponent
		   * @returns {number}
		   * @inner
		   */
		  
		  var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)
		  
		  /**
		   * @param {string} str
		   * @param {(boolean|number)=} unsigned
		   * @param {number=} radix
		   * @returns {!Long}
		   * @inner
		   */
		  
		  function fromString(str, unsigned, radix) {
		    if (str.length === 0) throw Error('empty string');
		  
		    if (typeof unsigned === 'number') {
		      // For goog.math.long compatibility
		      radix = unsigned;
		      unsigned = false;
		    } else {
		      unsigned = !!unsigned;
		    }
		  
		    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") return unsigned ? UZERO : ZERO;
		    radix = radix || 10;
		    if (radix < 2 || 36 < radix) throw RangeError('radix');
		    var p;
		    if ((p = str.indexOf('-')) > 0) throw Error('interior hyphen');else if (p === 0) {
		      return fromString(str.substring(1), unsigned, radix).neg();
		    } // Do several (8) digits each time through the loop, so as to
		    // minimize the calls to the very expensive emulated div.
		  
		    var radixToPower = fromNumber(pow_dbl(radix, 8));
		    var result = ZERO;
		  
		    for (var i = 0; i < str.length; i += 8) {
		      var size = Math.min(8, str.length - i),
		          value = parseInt(str.substring(i, i + size), radix);
		  
		      if (size < 8) {
		        var power = fromNumber(pow_dbl(radix, size));
		        result = result.mul(power).add(fromNumber(value));
		      } else {
		        result = result.mul(radixToPower);
		        result = result.add(fromNumber(value));
		      }
		    }
		  
		    result.unsigned = unsigned;
		    return result;
		  }
		  /**
		   * Returns a Long representation of the given string, written using the specified radix.
		   * @function
		   * @param {string} str The textual representation of the Long
		   * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
		   * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
		   * @returns {!Long} The corresponding Long value
		   */
		  
		  
		  Long.fromString = fromString;
		  /**
		   * @function
		   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
		   * @param {boolean=} unsigned
		   * @returns {!Long}
		   * @inner
		   */
		  
		  function fromValue(val, unsigned) {
		    if (typeof val === 'number') return fromNumber(val, unsigned);
		    if (typeof val === 'string') return fromString(val, unsigned); // Throws for non-objects, converts non-instanceof Long:
		  
		    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
		  }
		  /**
		   * Converts the specified value to a Long using the appropriate from* function for its type.
		   * @function
		   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
		   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		   * @returns {!Long}
		   */
		  
		  
		  Long.fromValue = fromValue; // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
		  // no runtime penalty for these.
		  
		  /**
		   * @type {number}
		   * @const
		   * @inner
		   */
		  
		  var TWO_PWR_16_DBL = 1 << 16;
		  /**
		   * @type {number}
		   * @const
		   * @inner
		   */
		  
		  var TWO_PWR_24_DBL = 1 << 24;
		  /**
		   * @type {number}
		   * @const
		   * @inner
		   */
		  
		  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
		  /**
		   * @type {number}
		   * @const
		   * @inner
		   */
		  
		  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
		  /**
		   * @type {number}
		   * @const
		   * @inner
		   */
		  
		  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
		  /**
		   * @type {!Long}
		   * @const
		   * @inner
		   */
		  
		  var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
		  /**
		   * @type {!Long}
		   * @inner
		   */
		  
		  var ZERO = fromInt(0);
		  /**
		   * Signed zero.
		   * @type {!Long}
		   */
		  
		  Long.ZERO = ZERO;
		  /**
		   * @type {!Long}
		   * @inner
		   */
		  
		  var UZERO = fromInt(0, true);
		  /**
		   * Unsigned zero.
		   * @type {!Long}
		   */
		  
		  Long.UZERO = UZERO;
		  /**
		   * @type {!Long}
		   * @inner
		   */
		  
		  var ONE = fromInt(1);
		  /**
		   * Signed one.
		   * @type {!Long}
		   */
		  
		  Long.ONE = ONE;
		  /**
		   * @type {!Long}
		   * @inner
		   */
		  
		  var UONE = fromInt(1, true);
		  /**
		   * Unsigned one.
		   * @type {!Long}
		   */
		  
		  Long.UONE = UONE;
		  /**
		   * @type {!Long}
		   * @inner
		   */
		  
		  var NEG_ONE = fromInt(-1);
		  /**
		   * Signed negative one.
		   * @type {!Long}
		   */
		  
		  Long.NEG_ONE = NEG_ONE;
		  /**
		   * @type {!Long}
		   * @inner
		   */
		  
		  var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);
		  /**
		   * Maximum signed value.
		   * @type {!Long}
		   */
		  
		  Long.MAX_VALUE = MAX_VALUE;
		  /**
		   * @type {!Long}
		   * @inner
		   */
		  
		  var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);
		  /**
		   * Maximum unsigned value.
		   * @type {!Long}
		   */
		  
		  Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
		  /**
		   * @type {!Long}
		   * @inner
		   */
		  
		  var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);
		  /**
		   * Minimum signed value.
		   * @type {!Long}
		   */
		  
		  Long.MIN_VALUE = MIN_VALUE;
		  /**
		   * @alias Long.prototype
		   * @inner
		   */
		  
		  var LongPrototype = Long.prototype;
		  /**
		   * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
		   * @this {!Long}
		   * @returns {number}
		   */
		  
		  LongPrototype.toInt = function toInt() {
		    return this.unsigned ? this.low >>> 0 : this.low;
		  };
		  /**
		   * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
		   * @this {!Long}
		   * @returns {number}
		   */
		  
		  
		  LongPrototype.toNumber = function toNumber() {
		    if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
		    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
		  };
		  /**
		   * Converts the Long to a string written in the specified radix.
		   * @this {!Long}
		   * @param {number=} radix Radix (2-36), defaults to 10
		   * @returns {string}
		   * @override
		   * @throws {RangeError} If `radix` is out of range
		   */
		  
		  
		  LongPrototype.toString = function toString(radix) {
		    radix = radix || 10;
		    if (radix < 2 || 36 < radix) throw RangeError('radix');
		    if (this.isZero()) return '0';
		  
		    if (this.isNegative()) {
		      // Unsigned Longs are never negative
		      if (this.eq(MIN_VALUE)) {
		        // We need to change the Long value before it can be negated, so we remove
		        // the bottom-most digit in this base and then recurse to do the rest.
		        var radixLong = fromNumber(radix),
		            div = this.div(radixLong),
		            rem1 = div.mul(radixLong).sub(this);
		        return div.toString(radix) + rem1.toInt().toString(radix);
		      } else return '-' + this.neg().toString(radix);
		    } // Do several (6) digits each time through the loop, so as to
		    // minimize the calls to the very expensive emulated div.
		  
		  
		    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
		        rem = this;
		    var result = '';
		  
		    while (true) {
		      var remDiv = rem.div(radixToPower),
		          intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
		          digits = intval.toString(radix);
		      rem = remDiv;
		      if (rem.isZero()) return digits + result;else {
		        while (digits.length < 6) digits = '0' + digits;
		  
		        result = '' + digits + result;
		      }
		    }
		  };
		  /**
		   * Gets the high 32 bits as a signed integer.
		   * @this {!Long}
		   * @returns {number} Signed high bits
		   */
		  
		  
		  LongPrototype.getHighBits = function getHighBits() {
		    return this.high;
		  };
		  /**
		   * Gets the high 32 bits as an unsigned integer.
		   * @this {!Long}
		   * @returns {number} Unsigned high bits
		   */
		  
		  
		  LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
		    return this.high >>> 0;
		  };
		  /**
		   * Gets the low 32 bits as a signed integer.
		   * @this {!Long}
		   * @returns {number} Signed low bits
		   */
		  
		  
		  LongPrototype.getLowBits = function getLowBits() {
		    return this.low;
		  };
		  /**
		   * Gets the low 32 bits as an unsigned integer.
		   * @this {!Long}
		   * @returns {number} Unsigned low bits
		   */
		  
		  
		  LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
		    return this.low >>> 0;
		  };
		  /**
		   * Gets the number of bits needed to represent the absolute value of this Long.
		   * @this {!Long}
		   * @returns {number}
		   */
		  
		  
		  LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
		    if (this.isNegative()) // Unsigned Longs are never negative
		      return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
		    var val = this.high != 0 ? this.high : this.low;
		  
		    for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;
		  
		    return this.high != 0 ? bit + 33 : bit + 1;
		  };
		  /**
		   * Tests if this Long's value equals zero.
		   * @this {!Long}
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.isZero = function isZero() {
		    return this.high === 0 && this.low === 0;
		  };
		  /**
		   * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.eqz = LongPrototype.isZero;
		  /**
		   * Tests if this Long's value is negative.
		   * @this {!Long}
		   * @returns {boolean}
		   */
		  
		  LongPrototype.isNegative = function isNegative() {
		    return !this.unsigned && this.high < 0;
		  };
		  /**
		   * Tests if this Long's value is positive or zero.
		   * @this {!Long}
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.isPositive = function isPositive() {
		    return this.unsigned || this.high >= 0;
		  };
		  /**
		   * Tests if this Long's value is odd.
		   * @this {!Long}
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.isOdd = function isOdd() {
		    return (this.low & 1) === 1;
		  };
		  /**
		   * Tests if this Long's value is even.
		   * @this {!Long}
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.isEven = function isEven() {
		    return (this.low & 1) === 0;
		  };
		  /**
		   * Tests if this Long's value equals the specified's.
		   * @this {!Long}
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.equals = function equals(other) {
		    if (!isLong(other)) other = fromValue(other);
		    if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
		    return this.high === other.high && this.low === other.low;
		  };
		  /**
		   * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
		   * @function
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.eq = LongPrototype.equals;
		  /**
		   * Tests if this Long's value differs from the specified's.
		   * @this {!Long}
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  LongPrototype.notEquals = function notEquals(other) {
		    return !this.eq(
		    /* validates */
		    other);
		  };
		  /**
		   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
		   * @function
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.neq = LongPrototype.notEquals;
		  /**
		   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
		   * @function
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  LongPrototype.ne = LongPrototype.notEquals;
		  /**
		   * Tests if this Long's value is less than the specified's.
		   * @this {!Long}
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  LongPrototype.lessThan = function lessThan(other) {
		    return this.comp(
		    /* validates */
		    other) < 0;
		  };
		  /**
		   * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
		   * @function
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.lt = LongPrototype.lessThan;
		  /**
		   * Tests if this Long's value is less than or equal the specified's.
		   * @this {!Long}
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
		    return this.comp(
		    /* validates */
		    other) <= 0;
		  };
		  /**
		   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
		   * @function
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.lte = LongPrototype.lessThanOrEqual;
		  /**
		   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
		   * @function
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  LongPrototype.le = LongPrototype.lessThanOrEqual;
		  /**
		   * Tests if this Long's value is greater than the specified's.
		   * @this {!Long}
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  LongPrototype.greaterThan = function greaterThan(other) {
		    return this.comp(
		    /* validates */
		    other) > 0;
		  };
		  /**
		   * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
		   * @function
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.gt = LongPrototype.greaterThan;
		  /**
		   * Tests if this Long's value is greater than or equal the specified's.
		   * @this {!Long}
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
		    return this.comp(
		    /* validates */
		    other) >= 0;
		  };
		  /**
		   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
		   * @function
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.gte = LongPrototype.greaterThanOrEqual;
		  /**
		   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
		   * @function
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  LongPrototype.ge = LongPrototype.greaterThanOrEqual;
		  /**
		   * Compares this Long's value with the specified's.
		   * @this {!Long}
		   * @param {!Long|number|string} other Other value
		   * @returns {number} 0 if they are the same, 1 if the this is greater and -1
		   *  if the given one is greater
		   */
		  
		  LongPrototype.compare = function compare(other) {
		    if (!isLong(other)) other = fromValue(other);
		    if (this.eq(other)) return 0;
		    var thisNeg = this.isNegative(),
		        otherNeg = other.isNegative();
		    if (thisNeg && !otherNeg) return -1;
		    if (!thisNeg && otherNeg) return 1; // At this point the sign bits are the same
		  
		    if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1; // Both are positive if at least one is unsigned
		  
		    return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
		  };
		  /**
		   * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
		   * @function
		   * @param {!Long|number|string} other Other value
		   * @returns {number} 0 if they are the same, 1 if the this is greater and -1
		   *  if the given one is greater
		   */
		  
		  
		  LongPrototype.comp = LongPrototype.compare;
		  /**
		   * Negates this Long's value.
		   * @this {!Long}
		   * @returns {!Long} Negated Long
		   */
		  
		  LongPrototype.negate = function negate() {
		    if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
		    return this.not().add(ONE);
		  };
		  /**
		   * Negates this Long's value. This is an alias of {@link Long#negate}.
		   * @function
		   * @returns {!Long} Negated Long
		   */
		  
		  
		  LongPrototype.neg = LongPrototype.negate;
		  /**
		   * Returns the sum of this and the specified Long.
		   * @this {!Long}
		   * @param {!Long|number|string} addend Addend
		   * @returns {!Long} Sum
		   */
		  
		  LongPrototype.add = function add(addend) {
		    if (!isLong(addend)) addend = fromValue(addend); // Divide each number into 4 chunks of 16 bits, and then sum the chunks.
		  
		    var a48 = this.high >>> 16;
		    var a32 = this.high & 0xFFFF;
		    var a16 = this.low >>> 16;
		    var a00 = this.low & 0xFFFF;
		    var b48 = addend.high >>> 16;
		    var b32 = addend.high & 0xFFFF;
		    var b16 = addend.low >>> 16;
		    var b00 = addend.low & 0xFFFF;
		    var c48 = 0,
		        c32 = 0,
		        c16 = 0,
		        c00 = 0;
		    c00 += a00 + b00;
		    c16 += c00 >>> 16;
		    c00 &= 0xFFFF;
		    c16 += a16 + b16;
		    c32 += c16 >>> 16;
		    c16 &= 0xFFFF;
		    c32 += a32 + b32;
		    c48 += c32 >>> 16;
		    c32 &= 0xFFFF;
		    c48 += a48 + b48;
		    c48 &= 0xFFFF;
		    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
		  };
		  /**
		   * Returns the difference of this and the specified Long.
		   * @this {!Long}
		   * @param {!Long|number|string} subtrahend Subtrahend
		   * @returns {!Long} Difference
		   */
		  
		  
		  LongPrototype.subtract = function subtract(subtrahend) {
		    if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
		    return this.add(subtrahend.neg());
		  };
		  /**
		   * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
		   * @function
		   * @param {!Long|number|string} subtrahend Subtrahend
		   * @returns {!Long} Difference
		   */
		  
		  
		  LongPrototype.sub = LongPrototype.subtract;
		  /**
		   * Returns the product of this and the specified Long.
		   * @this {!Long}
		   * @param {!Long|number|string} multiplier Multiplier
		   * @returns {!Long} Product
		   */
		  
		  LongPrototype.multiply = function multiply(multiplier) {
		    if (this.isZero()) return this;
		    if (!isLong(multiplier)) multiplier = fromValue(multiplier); // use wasm support if present
		  
		    if (wasm) {
		      var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
		      return fromBits(low, wasm["get_high"](), this.unsigned);
		    }
		  
		    if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
		    if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
		    if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
		  
		    if (this.isNegative()) {
		      if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());else return this.neg().mul(multiplier).neg();
		    } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg(); // If both longs are small, use float multiplication
		  
		  
		    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned); // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
		    // We can skip products that would overflow.
		  
		    var a48 = this.high >>> 16;
		    var a32 = this.high & 0xFFFF;
		    var a16 = this.low >>> 16;
		    var a00 = this.low & 0xFFFF;
		    var b48 = multiplier.high >>> 16;
		    var b32 = multiplier.high & 0xFFFF;
		    var b16 = multiplier.low >>> 16;
		    var b00 = multiplier.low & 0xFFFF;
		    var c48 = 0,
		        c32 = 0,
		        c16 = 0,
		        c00 = 0;
		    c00 += a00 * b00;
		    c16 += c00 >>> 16;
		    c00 &= 0xFFFF;
		    c16 += a16 * b00;
		    c32 += c16 >>> 16;
		    c16 &= 0xFFFF;
		    c16 += a00 * b16;
		    c32 += c16 >>> 16;
		    c16 &= 0xFFFF;
		    c32 += a32 * b00;
		    c48 += c32 >>> 16;
		    c32 &= 0xFFFF;
		    c32 += a16 * b16;
		    c48 += c32 >>> 16;
		    c32 &= 0xFFFF;
		    c32 += a00 * b32;
		    c48 += c32 >>> 16;
		    c32 &= 0xFFFF;
		    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
		    c48 &= 0xFFFF;
		    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
		  };
		  /**
		   * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
		   * @function
		   * @param {!Long|number|string} multiplier Multiplier
		   * @returns {!Long} Product
		   */
		  
		  
		  LongPrototype.mul = LongPrototype.multiply;
		  /**
		   * Returns this Long divided by the specified. The result is signed if this Long is signed or
		   *  unsigned if this Long is unsigned.
		   * @this {!Long}
		   * @param {!Long|number|string} divisor Divisor
		   * @returns {!Long} Quotient
		   */
		  
		  LongPrototype.divide = function divide(divisor) {
		    if (!isLong(divisor)) divisor = fromValue(divisor);
		    if (divisor.isZero()) throw Error('division by zero'); // use wasm support if present
		  
		    if (wasm) {
		      // guard against signed division overflow: the largest
		      // negative number / -1 would be 1 larger than the largest
		      // positive number, due to two's complement.
		      if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
		        // be consistent with non-wasm code path
		        return this;
		      }
		  
		      var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(this.low, this.high, divisor.low, divisor.high);
		      return fromBits(low, wasm["get_high"](), this.unsigned);
		    }
		  
		    if (this.isZero()) return this.unsigned ? UZERO : ZERO;
		    var approx, rem, res;
		  
		    if (!this.unsigned) {
		      // This section is only relevant for signed longs and is derived from the
		      // closure library as a whole.
		      if (this.eq(MIN_VALUE)) {
		        if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE
		        else if (divisor.eq(MIN_VALUE)) return ONE;else {
		          // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
		          var halfThis = this.shr(1);
		          approx = halfThis.div(divisor).shl(1);
		  
		          if (approx.eq(ZERO)) {
		            return divisor.isNegative() ? ONE : NEG_ONE;
		          } else {
		            rem = this.sub(divisor.mul(approx));
		            res = approx.add(rem.div(divisor));
		            return res;
		          }
		        }
		      } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
		  
		      if (this.isNegative()) {
		        if (divisor.isNegative()) return this.neg().div(divisor.neg());
		        return this.neg().div(divisor).neg();
		      } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
		  
		      res = ZERO;
		    } else {
		      // The algorithm below has not been made for unsigned longs. It's therefore
		      // required to take special care of the MSB prior to running it.
		      if (!divisor.unsigned) divisor = divisor.toUnsigned();
		      if (divisor.gt(this)) return UZERO;
		      if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
		        return UONE;
		      res = UZERO;
		    } // Repeat the following until the remainder is less than other:  find a
		    // floating-point that approximates remainder / other *from below*, add this
		    // into the result, and subtract it from the remainder.  It is critical that
		    // the approximate value is less than or equal to the real value so that the
		    // remainder never becomes negative.
		  
		  
		    rem = this;
		  
		    while (rem.gte(divisor)) {
		      // Approximate the result of division. This may be a little greater or
		      // smaller than the actual value.
		      approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber())); // We will tweak the approximate result by changing it in the 48-th digit or
		      // the smallest non-fractional digit, whichever is larger.
		  
		      var log2 = Math.ceil(Math.log(approx) / Math.LN2),
		          delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48),
		          // Decrease the approximation until it is smaller than the remainder.  Note
		      // that if it is too large, the product overflows and is negative.
		      approxRes = fromNumber(approx),
		          approxRem = approxRes.mul(divisor);
		  
		      while (approxRem.isNegative() || approxRem.gt(rem)) {
		        approx -= delta;
		        approxRes = fromNumber(approx, this.unsigned);
		        approxRem = approxRes.mul(divisor);
		      } // We know the answer can't be zero... and actually, zero would cause
		      // infinite recursion since we would make no progress.
		  
		  
		      if (approxRes.isZero()) approxRes = ONE;
		      res = res.add(approxRes);
		      rem = rem.sub(approxRem);
		    }
		  
		    return res;
		  };
		  /**
		   * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
		   * @function
		   * @param {!Long|number|string} divisor Divisor
		   * @returns {!Long} Quotient
		   */
		  
		  
		  LongPrototype.div = LongPrototype.divide;
		  /**
		   * Returns this Long modulo the specified.
		   * @this {!Long}
		   * @param {!Long|number|string} divisor Divisor
		   * @returns {!Long} Remainder
		   */
		  
		  LongPrototype.modulo = function modulo(divisor) {
		    if (!isLong(divisor)) divisor = fromValue(divisor); // use wasm support if present
		  
		    if (wasm) {
		      var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(this.low, this.high, divisor.low, divisor.high);
		      return fromBits(low, wasm["get_high"](), this.unsigned);
		    }
		  
		    return this.sub(this.div(divisor).mul(divisor));
		  };
		  /**
		   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
		   * @function
		   * @param {!Long|number|string} divisor Divisor
		   * @returns {!Long} Remainder
		   */
		  
		  
		  LongPrototype.mod = LongPrototype.modulo;
		  /**
		   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
		   * @function
		   * @param {!Long|number|string} divisor Divisor
		   * @returns {!Long} Remainder
		   */
		  
		  LongPrototype.rem = LongPrototype.modulo;
		  /**
		   * Returns the bitwise NOT of this Long.
		   * @this {!Long}
		   * @returns {!Long}
		   */
		  
		  LongPrototype.not = function not() {
		    return fromBits(~this.low, ~this.high, this.unsigned);
		  };
		  /**
		   * Returns count leading zeros of this Long.
		   * @this {!Long}
		   * @returns {!number}
		   */
		  
		  
		  LongPrototype.countLeadingZeros = function countLeadingZeros() {
		    return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
		  };
		  /**
		   * Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.
		   * @function
		   * @param {!Long}
		   * @returns {!number}
		   */
		  
		  
		  LongPrototype.clz = LongPrototype.countLeadingZeros;
		  /**
		   * Returns count trailing zeros of this Long.
		   * @this {!Long}
		   * @returns {!number}
		   */
		  
		  LongPrototype.countTrailingZeros = function countTrailingZeros() {
		    return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
		  };
		  /**
		   * Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.
		   * @function
		   * @param {!Long}
		   * @returns {!number}
		   */
		  
		  
		  LongPrototype.ctz = LongPrototype.countTrailingZeros;
		  /**
		   * Returns the bitwise AND of this Long and the specified.
		   * @this {!Long}
		   * @param {!Long|number|string} other Other Long
		   * @returns {!Long}
		   */
		  
		  LongPrototype.and = function and(other) {
		    if (!isLong(other)) other = fromValue(other);
		    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
		  };
		  /**
		   * Returns the bitwise OR of this Long and the specified.
		   * @this {!Long}
		   * @param {!Long|number|string} other Other Long
		   * @returns {!Long}
		   */
		  
		  
		  LongPrototype.or = function or(other) {
		    if (!isLong(other)) other = fromValue(other);
		    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
		  };
		  /**
		   * Returns the bitwise XOR of this Long and the given one.
		   * @this {!Long}
		   * @param {!Long|number|string} other Other Long
		   * @returns {!Long}
		   */
		  
		  
		  LongPrototype.xor = function xor(other) {
		    if (!isLong(other)) other = fromValue(other);
		    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
		  };
		  /**
		   * Returns this Long with bits shifted to the left by the given amount.
		   * @this {!Long}
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Shifted Long
		   */
		  
		  
		  LongPrototype.shiftLeft = function shiftLeft(numBits) {
		    if (isLong(numBits)) numBits = numBits.toInt();
		    if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);else return fromBits(0, this.low << numBits - 32, this.unsigned);
		  };
		  /**
		   * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
		   * @function
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Shifted Long
		   */
		  
		  
		  LongPrototype.shl = LongPrototype.shiftLeft;
		  /**
		   * Returns this Long with bits arithmetically shifted to the right by the given amount.
		   * @this {!Long}
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Shifted Long
		   */
		  
		  LongPrototype.shiftRight = function shiftRight(numBits) {
		    if (isLong(numBits)) numBits = numBits.toInt();
		    if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
		  };
		  /**
		   * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
		   * @function
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Shifted Long
		   */
		  
		  
		  LongPrototype.shr = LongPrototype.shiftRight;
		  /**
		   * Returns this Long with bits logically shifted to the right by the given amount.
		   * @this {!Long}
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Shifted Long
		   */
		  
		  LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
		    if (isLong(numBits)) numBits = numBits.toInt();
		    if ((numBits &= 63) === 0) return this;
		    if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
		    if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
		    return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
		  };
		  /**
		   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
		   * @function
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Shifted Long
		   */
		  
		  
		  LongPrototype.shru = LongPrototype.shiftRightUnsigned;
		  /**
		   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
		   * @function
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Shifted Long
		   */
		  
		  LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
		  /**
		   * Returns this Long with bits rotated to the left by the given amount.
		   * @this {!Long}
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Rotated Long
		   */
		  
		  LongPrototype.rotateLeft = function rotateLeft(numBits) {
		    var b;
		    if (isLong(numBits)) numBits = numBits.toInt();
		    if ((numBits &= 63) === 0) return this;
		    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
		  
		    if (numBits < 32) {
		      b = 32 - numBits;
		      return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
		    }
		  
		    numBits -= 32;
		    b = 32 - numBits;
		    return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
		  };
		  /**
		   * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.
		   * @function
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Rotated Long
		   */
		  
		  
		  LongPrototype.rotl = LongPrototype.rotateLeft;
		  /**
		   * Returns this Long with bits rotated to the right by the given amount.
		   * @this {!Long}
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Rotated Long
		   */
		  
		  LongPrototype.rotateRight = function rotateRight(numBits) {
		    var b;
		    if (isLong(numBits)) numBits = numBits.toInt();
		    if ((numBits &= 63) === 0) return this;
		    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
		  
		    if (numBits < 32) {
		      b = 32 - numBits;
		      return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
		    }
		  
		    numBits -= 32;
		    b = 32 - numBits;
		    return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
		  };
		  /**
		   * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.
		   * @function
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Rotated Long
		   */
		  
		  
		  LongPrototype.rotr = LongPrototype.rotateRight;
		  /**
		   * Converts this Long to signed.
		   * @this {!Long}
		   * @returns {!Long} Signed long
		   */
		  
		  LongPrototype.toSigned = function toSigned() {
		    if (!this.unsigned) return this;
		    return fromBits(this.low, this.high, false);
		  };
		  /**
		   * Converts this Long to unsigned.
		   * @this {!Long}
		   * @returns {!Long} Unsigned long
		   */
		  
		  
		  LongPrototype.toUnsigned = function toUnsigned() {
		    if (this.unsigned) return this;
		    return fromBits(this.low, this.high, true);
		  };
		  /**
		   * Converts this Long to its byte representation.
		   * @param {boolean=} le Whether little or big endian, defaults to big endian
		   * @this {!Long}
		   * @returns {!Array.<number>} Byte representation
		   */
		  
		  
		  LongPrototype.toBytes = function toBytes(le) {
		    return le ? this.toBytesLE() : this.toBytesBE();
		  };
		  /**
		   * Converts this Long to its little endian byte representation.
		   * @this {!Long}
		   * @returns {!Array.<number>} Little endian byte representation
		   */
		  
		  
		  LongPrototype.toBytesLE = function toBytesLE() {
		    var hi = this.high,
		        lo = this.low;
		    return [lo & 0xff, lo >>> 8 & 0xff, lo >>> 16 & 0xff, lo >>> 24, hi & 0xff, hi >>> 8 & 0xff, hi >>> 16 & 0xff, hi >>> 24];
		  };
		  /**
		   * Converts this Long to its big endian byte representation.
		   * @this {!Long}
		   * @returns {!Array.<number>} Big endian byte representation
		   */
		  
		  
		  LongPrototype.toBytesBE = function toBytesBE() {
		    var hi = this.high,
		        lo = this.low;
		    return [hi >>> 24, hi >>> 16 & 0xff, hi >>> 8 & 0xff, hi & 0xff, lo >>> 24, lo >>> 16 & 0xff, lo >>> 8 & 0xff, lo & 0xff];
		  };
		  /**
		   * Creates a Long from its byte representation.
		   * @param {!Array.<number>} bytes Byte representation
		   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		   * @param {boolean=} le Whether little or big endian, defaults to big endian
		   * @returns {Long} The corresponding Long value
		   */
		  
		  
		  Long.fromBytes = function fromBytes(bytes, unsigned, le) {
		    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
		  };
		  /**
		   * Creates a Long from its little endian byte representation.
		   * @param {!Array.<number>} bytes Little endian byte representation
		   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		   * @returns {Long} The corresponding Long value
		   */
		  
		  
		  Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
		    return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
		  };
		  /**
		   * Creates a Long from its big endian byte representation.
		   * @param {!Array.<number>} bytes Big endian byte representation
		   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		   * @returns {Long} The corresponding Long value
		   */
		  
		  
		  Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
		    return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
		  };
		  
		  var _default = Long;
		  exports.default = _default;
		  return "default" in exports ? exports.default : exports;
		})({});
		module.exports = Long; 
	} (umd));
	return umd.exports;
}

var hasRequiredSrc$1;

function requireSrc$1 () {
	if (hasRequiredSrc$1) return src$1;
	hasRequiredSrc$1 = 1;
	(function (exports) {
		/**
		 * @license
		 * Copyright 2018 gRPC authors.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *     http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 *
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.loadFileDescriptorSetFromObject = exports.loadFileDescriptorSetFromBuffer = exports.fromJSON = exports.loadSync = exports.load = exports.IdempotencyLevel = exports.isAnyExtension = exports.Long = undefined;
		const camelCase = requireLodash_camelcase();
		const Protobuf = requireProtobufjs();
		const descriptor = requireDescriptor();
		const util_1 = requireUtil();
		const Long = requireUmd();
		exports.Long = Long;
		function isAnyExtension(obj) {
		    return ('@type' in obj) && (typeof obj['@type'] === 'string');
		}
		exports.isAnyExtension = isAnyExtension;
		var IdempotencyLevel;
		(function (IdempotencyLevel) {
		    IdempotencyLevel["IDEMPOTENCY_UNKNOWN"] = "IDEMPOTENCY_UNKNOWN";
		    IdempotencyLevel["NO_SIDE_EFFECTS"] = "NO_SIDE_EFFECTS";
		    IdempotencyLevel["IDEMPOTENT"] = "IDEMPOTENT";
		})(IdempotencyLevel = exports.IdempotencyLevel || (exports.IdempotencyLevel = {}));
		const descriptorOptions = {
		    longs: String,
		    enums: String,
		    bytes: String,
		    defaults: true,
		    oneofs: true,
		    json: true,
		};
		function joinName(baseName, name) {
		    if (baseName === '') {
		        return name;
		    }
		    else {
		        return baseName + '.' + name;
		    }
		}
		function isHandledReflectionObject(obj) {
		    return (obj instanceof Protobuf.Service ||
		        obj instanceof Protobuf.Type ||
		        obj instanceof Protobuf.Enum);
		}
		function isNamespaceBase(obj) {
		    return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;
		}
		function getAllHandledReflectionObjects(obj, parentName) {
		    const objName = joinName(parentName, obj.name);
		    if (isHandledReflectionObject(obj)) {
		        return [[objName, obj]];
		    }
		    else {
		        if (isNamespaceBase(obj) && typeof obj.nested !== 'undefined') {
		            return Object.keys(obj.nested)
		                .map(name => {
		                return getAllHandledReflectionObjects(obj.nested[name], objName);
		            })
		                .reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);
		        }
		    }
		    return [];
		}
		function createDeserializer(cls, options) {
		    return function deserialize(argBuf) {
		        return cls.toObject(cls.decode(argBuf), options);
		    };
		}
		function createSerializer(cls) {
		    return function serialize(arg) {
		        if (Array.isArray(arg)) {
		            throw new Error(`Failed to serialize message: expected object with ${cls.name} structure, got array instead`);
		        }
		        const message = cls.fromObject(arg);
		        return cls.encode(message).finish();
		    };
		}
		function mapMethodOptions(options) {
		    return (options || []).reduce((obj, item) => {
		        for (const [key, value] of Object.entries(item)) {
		            switch (key) {
		                case 'uninterpreted_option':
		                    obj.uninterpreted_option.push(item.uninterpreted_option);
		                    break;
		                default:
		                    obj[key] = value;
		            }
		        }
		        return obj;
		    }, {
		        deprecated: false,
		        idempotency_level: IdempotencyLevel.IDEMPOTENCY_UNKNOWN,
		        uninterpreted_option: [],
		    });
		}
		function createMethodDefinition(method, serviceName, options, fileDescriptors) {
		    /* This is only ever called after the corresponding root.resolveAll(), so we
		     * can assume that the resolved request and response types are non-null */
		    const requestType = method.resolvedRequestType;
		    const responseType = method.resolvedResponseType;
		    return {
		        path: '/' + serviceName + '/' + method.name,
		        requestStream: !!method.requestStream,
		        responseStream: !!method.responseStream,
		        requestSerialize: createSerializer(requestType),
		        requestDeserialize: createDeserializer(requestType, options),
		        responseSerialize: createSerializer(responseType),
		        responseDeserialize: createDeserializer(responseType, options),
		        // TODO(murgatroid99): Find a better way to handle this
		        originalName: camelCase(method.name),
		        requestType: createMessageDefinition(requestType, fileDescriptors),
		        responseType: createMessageDefinition(responseType, fileDescriptors),
		        options: mapMethodOptions(method.parsedOptions),
		    };
		}
		function createServiceDefinition(service, name, options, fileDescriptors) {
		    const def = {};
		    for (const method of service.methodsArray) {
		        def[method.name] = createMethodDefinition(method, name, options, fileDescriptors);
		    }
		    return def;
		}
		function createMessageDefinition(message, fileDescriptors) {
		    const messageDescriptor = message.toDescriptor('proto3');
		    return {
		        format: 'Protocol Buffer 3 DescriptorProto',
		        type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),
		        fileDescriptorProtos: fileDescriptors,
		    };
		}
		function createEnumDefinition(enumType, fileDescriptors) {
		    const enumDescriptor = enumType.toDescriptor('proto3');
		    return {
		        format: 'Protocol Buffer 3 EnumDescriptorProto',
		        type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),
		        fileDescriptorProtos: fileDescriptors,
		    };
		}
		/**
		 * function createDefinition(obj: Protobuf.Service, name: string, options:
		 * Options): ServiceDefinition; function createDefinition(obj: Protobuf.Type,
		 * name: string, options: Options): MessageTypeDefinition; function
		 * createDefinition(obj: Protobuf.Enum, name: string, options: Options):
		 * EnumTypeDefinition;
		 */
		function createDefinition(obj, name, options, fileDescriptors) {
		    if (obj instanceof Protobuf.Service) {
		        return createServiceDefinition(obj, name, options, fileDescriptors);
		    }
		    else if (obj instanceof Protobuf.Type) {
		        return createMessageDefinition(obj, fileDescriptors);
		    }
		    else if (obj instanceof Protobuf.Enum) {
		        return createEnumDefinition(obj, fileDescriptors);
		    }
		    else {
		        throw new Error('Type mismatch in reflection object handling');
		    }
		}
		function createPackageDefinition(root, options) {
		    const def = {};
		    root.resolveAll();
		    const descriptorList = root.toDescriptor('proto3').file;
		    const bufferList = descriptorList.map(value => Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));
		    for (const [name, obj] of getAllHandledReflectionObjects(root, '')) {
		        def[name] = createDefinition(obj, name, options, bufferList);
		    }
		    return def;
		}
		function createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {
		    options = options || {};
		    const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);
		    root.resolveAll();
		    return createPackageDefinition(root, options);
		}
		/**
		 * Load a .proto file with the specified options.
		 * @param filename One or multiple file paths to load. Can be an absolute path
		 *     or relative to an include path.
		 * @param options.keepCase Preserve field names. The default is to change them
		 *     to camel case.
		 * @param options.longs The type that should be used to represent `long` values.
		 *     Valid options are `Number` and `String`. Defaults to a `Long` object type
		 *     from a library.
		 * @param options.enums The type that should be used to represent `enum` values.
		 *     The only valid option is `String`. Defaults to the numeric value.
		 * @param options.bytes The type that should be used to represent `bytes`
		 *     values. Valid options are `Array` and `String`. The default is to use
		 *     `Buffer`.
		 * @param options.defaults Set default values on output objects. Defaults to
		 *     `false`.
		 * @param options.arrays Set empty arrays for missing array values even if
		 *     `defaults` is `false`. Defaults to `false`.
		 * @param options.objects Set empty objects for missing object values even if
		 *     `defaults` is `false`. Defaults to `false`.
		 * @param options.oneofs Set virtual oneof properties to the present field's
		 *     name
		 * @param options.json Represent Infinity and NaN as strings in float fields,
		 *     and automatically decode google.protobuf.Any values.
		 * @param options.includeDirs Paths to search for imported `.proto` files.
		 */
		function load(filename, options) {
		    return (0, util_1.loadProtosWithOptions)(filename, options).then(loadedRoot => {
		        return createPackageDefinition(loadedRoot, options);
		    });
		}
		exports.load = load;
		function loadSync(filename, options) {
		    const loadedRoot = (0, util_1.loadProtosWithOptionsSync)(filename, options);
		    return createPackageDefinition(loadedRoot, options);
		}
		exports.loadSync = loadSync;
		function fromJSON(json, options) {
		    options = options || {};
		    const loadedRoot = Protobuf.Root.fromJSON(json);
		    loadedRoot.resolveAll();
		    return createPackageDefinition(loadedRoot, options);
		}
		exports.fromJSON = fromJSON;
		function loadFileDescriptorSetFromBuffer(descriptorSet, options) {
		    const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);
		    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);
		}
		exports.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;
		function loadFileDescriptorSetFromObject(descriptorSet, options) {
		    const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);
		    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);
		}
		exports.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;
		(0, util_1.addCommonProtos)();
		
	} (src$1));
	return src$1;
}

var hasRequiredChannelz;

function requireChannelz () {
	if (hasRequiredChannelz) return channelz;
	hasRequiredChannelz = 1;
	/*
	 * Copyright 2021 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(channelz, "__esModule", { value: true });
	channelz.setup = channelz.getChannelzServiceDefinition = channelz.getChannelzHandlers = channelz.unregisterChannelzRef = channelz.registerChannelzSocket = channelz.registerChannelzServer = channelz.registerChannelzSubchannel = channelz.registerChannelzChannel = channelz.ChannelzCallTrackerStub = channelz.ChannelzCallTracker = channelz.ChannelzChildrenTrackerStub = channelz.ChannelzChildrenTracker = channelz.ChannelzTrace = channelz.ChannelzTraceStub = undefined;
	const net_1 = require$$0$2;
	const ordered_map_1 = requireCjs();
	const connectivity_state_1 = requireConnectivityState();
	const constants_1 = requireConstants();
	const subchannel_address_1 = requireSubchannelAddress();
	const admin_1 = requireAdmin();
	const make_client_1 = requireMakeClient();
	function channelRefToMessage(ref) {
	    return {
	        channel_id: ref.id,
	        name: ref.name,
	    };
	}
	function subchannelRefToMessage(ref) {
	    return {
	        subchannel_id: ref.id,
	        name: ref.name,
	    };
	}
	function serverRefToMessage(ref) {
	    return {
	        server_id: ref.id,
	    };
	}
	function socketRefToMessage(ref) {
	    return {
	        socket_id: ref.id,
	        name: ref.name,
	    };
	}
	/**
	 * The loose upper bound on the number of events that should be retained in a
	 * trace. This may be exceeded by up to a factor of 2. Arbitrarily chosen as a
	 * number that should be large enough to contain the recent relevant
	 * information, but small enough to not use excessive memory.
	 */
	const TARGET_RETAINED_TRACES = 32;
	/**
	 * Default number of sockets/servers/channels/subchannels to return
	 */
	const DEFAULT_MAX_RESULTS = 100;
	class ChannelzTraceStub {
	    constructor() {
	        this.events = [];
	        this.creationTimestamp = new Date();
	        this.eventsLogged = 0;
	    }
	    addTrace() { }
	    getTraceMessage() {
	        return {
	            creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),
	            num_events_logged: this.eventsLogged,
	            events: [],
	        };
	    }
	}
	channelz.ChannelzTraceStub = ChannelzTraceStub;
	class ChannelzTrace {
	    constructor() {
	        this.events = [];
	        this.eventsLogged = 0;
	        this.creationTimestamp = new Date();
	    }
	    addTrace(severity, description, child) {
	        const timestamp = new Date();
	        this.events.push({
	            description: description,
	            severity: severity,
	            timestamp: timestamp,
	            childChannel: (child === null || child === undefined ? undefined : child.kind) === 'channel' ? child : undefined,
	            childSubchannel: (child === null || child === undefined ? undefined : child.kind) === 'subchannel' ? child : undefined,
	        });
	        // Whenever the trace array gets too large, discard the first half
	        if (this.events.length >= TARGET_RETAINED_TRACES * 2) {
	            this.events = this.events.slice(TARGET_RETAINED_TRACES);
	        }
	        this.eventsLogged += 1;
	    }
	    getTraceMessage() {
	        return {
	            creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),
	            num_events_logged: this.eventsLogged,
	            events: this.events.map(event => {
	                return {
	                    description: event.description,
	                    severity: event.severity,
	                    timestamp: dateToProtoTimestamp(event.timestamp),
	                    channel_ref: event.childChannel
	                        ? channelRefToMessage(event.childChannel)
	                        : null,
	                    subchannel_ref: event.childSubchannel
	                        ? subchannelRefToMessage(event.childSubchannel)
	                        : null,
	                };
	            }),
	        };
	    }
	}
	channelz.ChannelzTrace = ChannelzTrace;
	class ChannelzChildrenTracker {
	    constructor() {
	        this.channelChildren = new ordered_map_1.OrderedMap();
	        this.subchannelChildren = new ordered_map_1.OrderedMap();
	        this.socketChildren = new ordered_map_1.OrderedMap();
	        this.trackerMap = {
	            ["channel" /* EntityTypes.channel */]: this.channelChildren,
	            ["subchannel" /* EntityTypes.subchannel */]: this.subchannelChildren,
	            ["socket" /* EntityTypes.socket */]: this.socketChildren,
	        };
	    }
	    refChild(child) {
	        const tracker = this.trackerMap[child.kind];
	        const trackedChild = tracker.find(child.id);
	        if (trackedChild.equals(tracker.end())) {
	            tracker.setElement(child.id, {
	                ref: child,
	                count: 1,
	            }, trackedChild);
	        }
	        else {
	            trackedChild.pointer[1].count += 1;
	        }
	    }
	    unrefChild(child) {
	        const tracker = this.trackerMap[child.kind];
	        const trackedChild = tracker.getElementByKey(child.id);
	        if (trackedChild !== undefined) {
	            trackedChild.count -= 1;
	            if (trackedChild.count === 0) {
	                tracker.eraseElementByKey(child.id);
	            }
	        }
	    }
	    getChildLists() {
	        return {
	            channels: this.channelChildren,
	            subchannels: this.subchannelChildren,
	            sockets: this.socketChildren,
	        };
	    }
	}
	channelz.ChannelzChildrenTracker = ChannelzChildrenTracker;
	class ChannelzChildrenTrackerStub extends ChannelzChildrenTracker {
	    refChild() { }
	    unrefChild() { }
	}
	channelz.ChannelzChildrenTrackerStub = ChannelzChildrenTrackerStub;
	class ChannelzCallTracker {
	    constructor() {
	        this.callsStarted = 0;
	        this.callsSucceeded = 0;
	        this.callsFailed = 0;
	        this.lastCallStartedTimestamp = null;
	    }
	    addCallStarted() {
	        this.callsStarted += 1;
	        this.lastCallStartedTimestamp = new Date();
	    }
	    addCallSucceeded() {
	        this.callsSucceeded += 1;
	    }
	    addCallFailed() {
	        this.callsFailed += 1;
	    }
	}
	channelz.ChannelzCallTracker = ChannelzCallTracker;
	class ChannelzCallTrackerStub extends ChannelzCallTracker {
	    addCallStarted() { }
	    addCallSucceeded() { }
	    addCallFailed() { }
	}
	channelz.ChannelzCallTrackerStub = ChannelzCallTrackerStub;
	const entityMaps = {
	    ["channel" /* EntityTypes.channel */]: new ordered_map_1.OrderedMap(),
	    ["subchannel" /* EntityTypes.subchannel */]: new ordered_map_1.OrderedMap(),
	    ["server" /* EntityTypes.server */]: new ordered_map_1.OrderedMap(),
	    ["socket" /* EntityTypes.socket */]: new ordered_map_1.OrderedMap(),
	};
	const generateRegisterFn = (kind) => {
	    let nextId = 1;
	    function getNextId() {
	        return nextId++;
	    }
	    const entityMap = entityMaps[kind];
	    return (name, getInfo, channelzEnabled) => {
	        const id = getNextId();
	        const ref = { id, name, kind };
	        if (channelzEnabled) {
	            entityMap.setElement(id, { ref, getInfo });
	        }
	        return ref;
	    };
	};
	channelz.registerChannelzChannel = generateRegisterFn("channel" /* EntityTypes.channel */);
	channelz.registerChannelzSubchannel = generateRegisterFn("subchannel" /* EntityTypes.subchannel */);
	channelz.registerChannelzServer = generateRegisterFn("server" /* EntityTypes.server */);
	channelz.registerChannelzSocket = generateRegisterFn("socket" /* EntityTypes.socket */);
	function unregisterChannelzRef(ref) {
	    entityMaps[ref.kind].eraseElementByKey(ref.id);
	}
	channelz.unregisterChannelzRef = unregisterChannelzRef;
	/**
	 * Parse a single section of an IPv6 address as two bytes
	 * @param addressSection A hexadecimal string of length up to 4
	 * @returns The pair of bytes representing this address section
	 */
	function parseIPv6Section(addressSection) {
	    const numberValue = Number.parseInt(addressSection, 16);
	    return [(numberValue / 256) | 0, numberValue % 256];
	}
	/**
	 * Parse a chunk of an IPv6 address string to some number of bytes
	 * @param addressChunk Some number of segments of up to 4 hexadecimal
	 *   characters each, joined by colons.
	 * @returns The list of bytes representing this address chunk
	 */
	function parseIPv6Chunk(addressChunk) {
	    if (addressChunk === '') {
	        return [];
	    }
	    const bytePairs = addressChunk
	        .split(':')
	        .map(section => parseIPv6Section(section));
	    const result = [];
	    return result.concat(...bytePairs);
	}
	/**
	 * Converts an IPv4 or IPv6 address from string representation to binary
	 * representation
	 * @param ipAddress an IP address in standard IPv4 or IPv6 text format
	 * @returns
	 */
	function ipAddressStringToBuffer(ipAddress) {
	    if ((0, net_1.isIPv4)(ipAddress)) {
	        return Buffer.from(Uint8Array.from(ipAddress.split('.').map(segment => Number.parseInt(segment))));
	    }
	    else if ((0, net_1.isIPv6)(ipAddress)) {
	        let leftSection;
	        let rightSection;
	        const doubleColonIndex = ipAddress.indexOf('::');
	        if (doubleColonIndex === -1) {
	            leftSection = ipAddress;
	            rightSection = '';
	        }
	        else {
	            leftSection = ipAddress.substring(0, doubleColonIndex);
	            rightSection = ipAddress.substring(doubleColonIndex + 2);
	        }
	        const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));
	        const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));
	        const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);
	        return Buffer.concat([leftBuffer, middleBuffer, rightBuffer]);
	    }
	    else {
	        return null;
	    }
	}
	function connectivityStateToMessage(state) {
	    switch (state) {
	        case connectivity_state_1.ConnectivityState.CONNECTING:
	            return {
	                state: 'CONNECTING',
	            };
	        case connectivity_state_1.ConnectivityState.IDLE:
	            return {
	                state: 'IDLE',
	            };
	        case connectivity_state_1.ConnectivityState.READY:
	            return {
	                state: 'READY',
	            };
	        case connectivity_state_1.ConnectivityState.SHUTDOWN:
	            return {
	                state: 'SHUTDOWN',
	            };
	        case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:
	            return {
	                state: 'TRANSIENT_FAILURE',
	            };
	        default:
	            return {
	                state: 'UNKNOWN',
	            };
	    }
	}
	function dateToProtoTimestamp(date) {
	    if (!date) {
	        return null;
	    }
	    const millisSinceEpoch = date.getTime();
	    return {
	        seconds: (millisSinceEpoch / 1000) | 0,
	        nanos: (millisSinceEpoch % 1000) * 1000000,
	    };
	}
	function getChannelMessage(channelEntry) {
	    const resolvedInfo = channelEntry.getInfo();
	    const channelRef = [];
	    const subchannelRef = [];
	    resolvedInfo.children.channels.forEach(el => {
	        channelRef.push(channelRefToMessage(el[1].ref));
	    });
	    resolvedInfo.children.subchannels.forEach(el => {
	        subchannelRef.push(subchannelRefToMessage(el[1].ref));
	    });
	    return {
	        ref: channelRefToMessage(channelEntry.ref),
	        data: {
	            target: resolvedInfo.target,
	            state: connectivityStateToMessage(resolvedInfo.state),
	            calls_started: resolvedInfo.callTracker.callsStarted,
	            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
	            calls_failed: resolvedInfo.callTracker.callsFailed,
	            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
	            trace: resolvedInfo.trace.getTraceMessage(),
	        },
	        channel_ref: channelRef,
	        subchannel_ref: subchannelRef,
	    };
	}
	function GetChannel(call, callback) {
	    const channelId = parseInt(call.request.channel_id, 10);
	    const channelEntry = entityMaps["channel" /* EntityTypes.channel */].getElementByKey(channelId);
	    if (channelEntry === undefined) {
	        callback({
	            code: constants_1.Status.NOT_FOUND,
	            details: 'No channel data found for id ' + channelId,
	        });
	        return;
	    }
	    callback(null, { channel: getChannelMessage(channelEntry) });
	}
	function GetTopChannels(call, callback) {
	    const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;
	    const resultList = [];
	    const startId = parseInt(call.request.start_channel_id, 10);
	    const channelEntries = entityMaps["channel" /* EntityTypes.channel */];
	    let i;
	    for (i = channelEntries.lowerBound(startId); !i.equals(channelEntries.end()) && resultList.length < maxResults; i = i.next()) {
	        resultList.push(getChannelMessage(i.pointer[1]));
	    }
	    callback(null, {
	        channel: resultList,
	        end: i.equals(channelEntries.end()),
	    });
	}
	function getServerMessage(serverEntry) {
	    const resolvedInfo = serverEntry.getInfo();
	    const listenSocket = [];
	    resolvedInfo.listenerChildren.sockets.forEach(el => {
	        listenSocket.push(socketRefToMessage(el[1].ref));
	    });
	    return {
	        ref: serverRefToMessage(serverEntry.ref),
	        data: {
	            calls_started: resolvedInfo.callTracker.callsStarted,
	            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
	            calls_failed: resolvedInfo.callTracker.callsFailed,
	            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
	            trace: resolvedInfo.trace.getTraceMessage(),
	        },
	        listen_socket: listenSocket,
	    };
	}
	function GetServer(call, callback) {
	    const serverId = parseInt(call.request.server_id, 10);
	    const serverEntries = entityMaps["server" /* EntityTypes.server */];
	    const serverEntry = serverEntries.getElementByKey(serverId);
	    if (serverEntry === undefined) {
	        callback({
	            code: constants_1.Status.NOT_FOUND,
	            details: 'No server data found for id ' + serverId,
	        });
	        return;
	    }
	    callback(null, { server: getServerMessage(serverEntry) });
	}
	function GetServers(call, callback) {
	    const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;
	    const startId = parseInt(call.request.start_server_id, 10);
	    const serverEntries = entityMaps["server" /* EntityTypes.server */];
	    const resultList = [];
	    let i;
	    for (i = serverEntries.lowerBound(startId); !i.equals(serverEntries.end()) && resultList.length < maxResults; i = i.next()) {
	        resultList.push(getServerMessage(i.pointer[1]));
	    }
	    callback(null, {
	        server: resultList,
	        end: i.equals(serverEntries.end()),
	    });
	}
	function GetSubchannel(call, callback) {
	    const subchannelId = parseInt(call.request.subchannel_id, 10);
	    const subchannelEntry = entityMaps["subchannel" /* EntityTypes.subchannel */].getElementByKey(subchannelId);
	    if (subchannelEntry === undefined) {
	        callback({
	            code: constants_1.Status.NOT_FOUND,
	            details: 'No subchannel data found for id ' + subchannelId,
	        });
	        return;
	    }
	    const resolvedInfo = subchannelEntry.getInfo();
	    const listenSocket = [];
	    resolvedInfo.children.sockets.forEach(el => {
	        listenSocket.push(socketRefToMessage(el[1].ref));
	    });
	    const subchannelMessage = {
	        ref: subchannelRefToMessage(subchannelEntry.ref),
	        data: {
	            target: resolvedInfo.target,
	            state: connectivityStateToMessage(resolvedInfo.state),
	            calls_started: resolvedInfo.callTracker.callsStarted,
	            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
	            calls_failed: resolvedInfo.callTracker.callsFailed,
	            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
	            trace: resolvedInfo.trace.getTraceMessage(),
	        },
	        socket_ref: listenSocket,
	    };
	    callback(null, { subchannel: subchannelMessage });
	}
	function subchannelAddressToAddressMessage(subchannelAddress) {
	    var _a;
	    if ((0, subchannel_address_1.isTcpSubchannelAddress)(subchannelAddress)) {
	        return {
	            address: 'tcpip_address',
	            tcpip_address: {
	                ip_address: (_a = ipAddressStringToBuffer(subchannelAddress.host)) !== null && _a !== undefined ? _a : undefined,
	                port: subchannelAddress.port,
	            },
	        };
	    }
	    else {
	        return {
	            address: 'uds_address',
	            uds_address: {
	                filename: subchannelAddress.path,
	            },
	        };
	    }
	}
	function GetSocket(call, callback) {
	    var _a, _b, _c, _d, _e;
	    const socketId = parseInt(call.request.socket_id, 10);
	    const socketEntry = entityMaps["socket" /* EntityTypes.socket */].getElementByKey(socketId);
	    if (socketEntry === undefined) {
	        callback({
	            code: constants_1.Status.NOT_FOUND,
	            details: 'No socket data found for id ' + socketId,
	        });
	        return;
	    }
	    const resolvedInfo = socketEntry.getInfo();
	    const securityMessage = resolvedInfo.security
	        ? {
	            model: 'tls',
	            tls: {
	                cipher_suite: resolvedInfo.security.cipherSuiteStandardName
	                    ? 'standard_name'
	                    : 'other_name',
	                standard_name: (_a = resolvedInfo.security.cipherSuiteStandardName) !== null && _a !== undefined ? _a : undefined,
	                other_name: (_b = resolvedInfo.security.cipherSuiteOtherName) !== null && _b !== undefined ? _b : undefined,
	                local_certificate: (_c = resolvedInfo.security.localCertificate) !== null && _c !== undefined ? _c : undefined,
	                remote_certificate: (_d = resolvedInfo.security.remoteCertificate) !== null && _d !== undefined ? _d : undefined,
	            },
	        }
	        : null;
	    const socketMessage = {
	        ref: socketRefToMessage(socketEntry.ref),
	        local: resolvedInfo.localAddress
	            ? subchannelAddressToAddressMessage(resolvedInfo.localAddress)
	            : null,
	        remote: resolvedInfo.remoteAddress
	            ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress)
	            : null,
	        remote_name: (_e = resolvedInfo.remoteName) !== null && _e !== undefined ? _e : undefined,
	        security: securityMessage,
	        data: {
	            keep_alives_sent: resolvedInfo.keepAlivesSent,
	            streams_started: resolvedInfo.streamsStarted,
	            streams_succeeded: resolvedInfo.streamsSucceeded,
	            streams_failed: resolvedInfo.streamsFailed,
	            last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),
	            last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),
	            messages_received: resolvedInfo.messagesReceived,
	            messages_sent: resolvedInfo.messagesSent,
	            last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),
	            last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),
	            local_flow_control_window: resolvedInfo.localFlowControlWindow
	                ? { value: resolvedInfo.localFlowControlWindow }
	                : null,
	            remote_flow_control_window: resolvedInfo.remoteFlowControlWindow
	                ? { value: resolvedInfo.remoteFlowControlWindow }
	                : null,
	        },
	    };
	    callback(null, { socket: socketMessage });
	}
	function GetServerSockets(call, callback) {
	    const serverId = parseInt(call.request.server_id, 10);
	    const serverEntry = entityMaps["server" /* EntityTypes.server */].getElementByKey(serverId);
	    if (serverEntry === undefined) {
	        callback({
	            code: constants_1.Status.NOT_FOUND,
	            details: 'No server data found for id ' + serverId,
	        });
	        return;
	    }
	    const startId = parseInt(call.request.start_socket_id, 10);
	    const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;
	    const resolvedInfo = serverEntry.getInfo();
	    // If we wanted to include listener sockets in the result, this line would
	    // instead say
	    // const allSockets = resolvedInfo.listenerChildren.sockets.concat(resolvedInfo.sessionChildren.sockets).sort((ref1, ref2) => ref1.id - ref2.id);
	    const allSockets = resolvedInfo.sessionChildren.sockets;
	    const resultList = [];
	    let i;
	    for (i = allSockets.lowerBound(startId); !i.equals(allSockets.end()) && resultList.length < maxResults; i = i.next()) {
	        resultList.push(socketRefToMessage(i.pointer[1].ref));
	    }
	    callback(null, {
	        socket_ref: resultList,
	        end: i.equals(allSockets.end()),
	    });
	}
	function getChannelzHandlers() {
	    return {
	        GetChannel,
	        GetTopChannels,
	        GetServer,
	        GetServers,
	        GetSubchannel,
	        GetSocket,
	        GetServerSockets,
	    };
	}
	channelz.getChannelzHandlers = getChannelzHandlers;
	let loadedChannelzDefinition = null;
	function getChannelzServiceDefinition() {
	    if (loadedChannelzDefinition) {
	        return loadedChannelzDefinition;
	    }
	    /* The purpose of this complexity is to avoid loading @grpc/proto-loader at
	     * runtime for users who will not use/enable channelz. */
	    const loaderLoadSync = requireSrc$1()
	        .loadSync;
	    const loadedProto = loaderLoadSync('channelz.proto', {
	        keepCase: true,
	        longs: String,
	        enums: String,
	        defaults: true,
	        oneofs: true,
	        includeDirs: [`${__dirname}/../../proto`],
	    });
	    const channelzGrpcObject = (0, make_client_1.loadPackageDefinition)(loadedProto);
	    loadedChannelzDefinition =
	        channelzGrpcObject.grpc.channelz.v1.Channelz.service;
	    return loadedChannelzDefinition;
	}
	channelz.getChannelzServiceDefinition = getChannelzServiceDefinition;
	function setup() {
	    (0, admin_1.registerAdminService)(getChannelzServiceDefinition, getChannelzHandlers);
	}
	channelz.setup = setup;
	
	return channelz;
}

var hasRequiredSubchannel;

function requireSubchannel () {
	if (hasRequiredSubchannel) return subchannel;
	hasRequiredSubchannel = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(subchannel, "__esModule", { value: true });
	subchannel.Subchannel = undefined;
	const connectivity_state_1 = requireConnectivityState();
	const backoff_timeout_1 = requireBackoffTimeout();
	const logging = requireLogging();
	const constants_1 = requireConstants();
	const uri_parser_1 = requireUriParser();
	const subchannel_address_1 = requireSubchannelAddress();
	const channelz_1 = requireChannelz();
	const TRACER_NAME = 'subchannel';
	/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't
	 * have a constant for the max signed 32 bit integer, so this is a simple way
	 * to calculate it */
	const KEEPALIVE_MAX_TIME_MS = 2147483647;
	class Subchannel {
	    /**
	     * A class representing a connection to a single backend.
	     * @param channelTarget The target string for the channel as a whole
	     * @param subchannelAddress The address for the backend that this subchannel
	     *     will connect to
	     * @param options The channel options, plus any specific subchannel options
	     *     for this subchannel
	     * @param credentials The channel credentials used to establish this
	     *     connection
	     */
	    constructor(channelTarget, subchannelAddress, options, credentials, connector) {
	        var _a;
	        this.channelTarget = channelTarget;
	        this.subchannelAddress = subchannelAddress;
	        this.options = options;
	        this.credentials = credentials;
	        this.connector = connector;
	        /**
	         * The subchannel's current connectivity state. Invariant: `session` === `null`
	         * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.
	         */
	        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;
	        /**
	         * The underlying http2 session used to make requests.
	         */
	        this.transport = null;
	        /**
	         * Indicates that the subchannel should transition from TRANSIENT_FAILURE to
	         * CONNECTING instead of IDLE when the backoff timeout ends.
	         */
	        this.continueConnecting = false;
	        /**
	         * A list of listener functions that will be called whenever the connectivity
	         * state changes. Will be modified by `addConnectivityStateListener` and
	         * `removeConnectivityStateListener`
	         */
	        this.stateListeners = new Set();
	        /**
	         * Tracks channels and subchannel pools with references to this subchannel
	         */
	        this.refcount = 0;
	        // Channelz info
	        this.channelzEnabled = true;
	        const backoffOptions = {
	            initialDelay: options['grpc.initial_reconnect_backoff_ms'],
	            maxDelay: options['grpc.max_reconnect_backoff_ms'],
	        };
	        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {
	            this.handleBackoffTimer();
	        }, backoffOptions);
	        this.backoffTimeout.unref();
	        this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);
	        this.keepaliveTime = (_a = options['grpc.keepalive_time_ms']) !== null && _a !== undefined ? _a : -1;
	        if (options['grpc.enable_channelz'] === 0) {
	            this.channelzEnabled = false;
	            this.channelzTrace = new channelz_1.ChannelzTraceStub();
	            this.callTracker = new channelz_1.ChannelzCallTrackerStub();
	            this.childrenTracker = new channelz_1.ChannelzChildrenTrackerStub();
	            this.streamTracker = new channelz_1.ChannelzCallTrackerStub();
	        }
	        else {
	            this.channelzTrace = new channelz_1.ChannelzTrace();
	            this.callTracker = new channelz_1.ChannelzCallTracker();
	            this.childrenTracker = new channelz_1.ChannelzChildrenTracker();
	            this.streamTracker = new channelz_1.ChannelzCallTracker();
	        }
	        this.channelzRef = (0, channelz_1.registerChannelzSubchannel)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);
	        this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');
	        this.trace('Subchannel constructed with options ' +
	            JSON.stringify(options, undefined, 2));
	        credentials._ref();
	    }
	    getChannelzInfo() {
	        return {
	            state: this.connectivityState,
	            trace: this.channelzTrace,
	            callTracker: this.callTracker,
	            children: this.childrenTracker.getChildLists(),
	            target: this.subchannelAddressString,
	        };
	    }
	    trace(text) {
	        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' +
	            this.channelzRef.id +
	            ') ' +
	            this.subchannelAddressString +
	            ' ' +
	            text);
	    }
	    refTrace(text) {
	        logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_refcount', '(' +
	            this.channelzRef.id +
	            ') ' +
	            this.subchannelAddressString +
	            ' ' +
	            text);
	    }
	    handleBackoffTimer() {
	        if (this.continueConnecting) {
	            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);
	        }
	        else {
	            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.IDLE);
	        }
	    }
	    /**
	     * Start a backoff timer with the current nextBackoff timeout
	     */
	    startBackoff() {
	        this.backoffTimeout.runOnce();
	    }
	    stopBackoff() {
	        this.backoffTimeout.stop();
	        this.backoffTimeout.reset();
	    }
	    startConnectingInternal() {
	        let options = this.options;
	        if (options['grpc.keepalive_time_ms']) {
	            const adjustedKeepaliveTime = Math.min(this.keepaliveTime, KEEPALIVE_MAX_TIME_MS);
	            options = Object.assign(Object.assign({}, options), { 'grpc.keepalive_time_ms': adjustedKeepaliveTime });
	        }
	        this.connector
	            .connect(this.subchannelAddress, this.credentials, options)
	            .then(transport => {
	            if (this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.READY)) {
	                this.transport = transport;
	                if (this.channelzEnabled) {
	                    this.childrenTracker.refChild(transport.getChannelzRef());
	                }
	                transport.addDisconnectListener(tooManyPings => {
	                    this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);
	                    if (tooManyPings && this.keepaliveTime > 0) {
	                        this.keepaliveTime *= 2;
	                        logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${(0, uri_parser_1.uriToString)(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTime} ms`);
	                    }
	                });
	            }
	            else {
	                /* If we can't transition from CONNECTING to READY here, we will
	                 * not be using this transport, so release its resources. */
	                transport.shutdown();
	            }
	        }, error => {
	            this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, `${error}`);
	        });
	    }
	    /**
	     * Initiate a state transition from any element of oldStates to the new
	     * state. If the current connectivityState is not in oldStates, do nothing.
	     * @param oldStates The set of states to transition from
	     * @param newState The state to transition to
	     * @returns True if the state changed, false otherwise
	     */
	    transitionToState(oldStates, newState, errorMessage) {
	        var _a, _b;
	        if (oldStates.indexOf(this.connectivityState) === -1) {
	            return false;
	        }
	        if (errorMessage) {
	            this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] +
	                ' -> ' +
	                connectivity_state_1.ConnectivityState[newState] +
	                ' with error "' + errorMessage + '"');
	        }
	        else {
	            this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] +
	                ' -> ' +
	                connectivity_state_1.ConnectivityState[newState]);
	        }
	        if (this.channelzEnabled) {
	            this.channelzTrace.addTrace('CT_INFO', 'Connectivity state change to ' + connectivity_state_1.ConnectivityState[newState]);
	        }
	        const previousState = this.connectivityState;
	        this.connectivityState = newState;
	        switch (newState) {
	            case connectivity_state_1.ConnectivityState.READY:
	                this.stopBackoff();
	                break;
	            case connectivity_state_1.ConnectivityState.CONNECTING:
	                this.startBackoff();
	                this.startConnectingInternal();
	                this.continueConnecting = false;
	                break;
	            case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:
	                if (this.channelzEnabled && this.transport) {
	                    this.childrenTracker.unrefChild(this.transport.getChannelzRef());
	                }
	                (_a = this.transport) === null || _a === undefined ? undefined : _a.shutdown();
	                this.transport = null;
	                /* If the backoff timer has already ended by the time we get to the
	                 * TRANSIENT_FAILURE state, we want to immediately transition out of
	                 * TRANSIENT_FAILURE as though the backoff timer is ending right now */
	                if (!this.backoffTimeout.isRunning()) {
	                    process.nextTick(() => {
	                        this.handleBackoffTimer();
	                    });
	                }
	                break;
	            case connectivity_state_1.ConnectivityState.IDLE:
	                if (this.channelzEnabled && this.transport) {
	                    this.childrenTracker.unrefChild(this.transport.getChannelzRef());
	                }
	                (_b = this.transport) === null || _b === undefined ? undefined : _b.shutdown();
	                this.transport = null;
	                break;
	            default:
	                throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);
	        }
	        for (const listener of this.stateListeners) {
	            listener(this, previousState, newState, this.keepaliveTime, errorMessage);
	        }
	        return true;
	    }
	    ref() {
	        this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount + 1));
	        this.refcount += 1;
	    }
	    unref() {
	        this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount - 1));
	        this.refcount -= 1;
	        if (this.refcount === 0) {
	            this.channelzTrace.addTrace('CT_INFO', 'Shutting down');
	            (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
	            this.credentials._unref();
	            process.nextTick(() => {
	                this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);
	            });
	        }
	    }
	    unrefIfOneRef() {
	        if (this.refcount === 1) {
	            this.unref();
	            return true;
	        }
	        return false;
	    }
	    createCall(metadata, host, method, listener) {
	        if (!this.transport) {
	            throw new Error('Cannot create call, subchannel not READY');
	        }
	        let statsTracker;
	        if (this.channelzEnabled) {
	            this.callTracker.addCallStarted();
	            this.streamTracker.addCallStarted();
	            statsTracker = {
	                onCallEnd: status => {
	                    if (status.code === constants_1.Status.OK) {
	                        this.callTracker.addCallSucceeded();
	                    }
	                    else {
	                        this.callTracker.addCallFailed();
	                    }
	                },
	            };
	        }
	        else {
	            statsTracker = {};
	        }
	        return this.transport.createCall(metadata, host, method, listener, statsTracker);
	    }
	    /**
	     * If the subchannel is currently IDLE, start connecting and switch to the
	     * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,
	     * the next time it would transition to IDLE, start connecting again instead.
	     * Otherwise, do nothing.
	     */
	    startConnecting() {
	        process.nextTick(() => {
	            /* First, try to transition from IDLE to connecting. If that doesn't happen
	             * because the state is not currently IDLE, check if it is
	             * TRANSIENT_FAILURE, and if so indicate that it should go back to
	             * connecting after the backoff timer ends. Otherwise do nothing */
	            if (!this.transitionToState([connectivity_state_1.ConnectivityState.IDLE], connectivity_state_1.ConnectivityState.CONNECTING)) {
	                if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
	                    this.continueConnecting = true;
	                }
	            }
	        });
	    }
	    /**
	     * Get the subchannel's current connectivity state.
	     */
	    getConnectivityState() {
	        return this.connectivityState;
	    }
	    /**
	     * Add a listener function to be called whenever the subchannel's
	     * connectivity state changes.
	     * @param listener
	     */
	    addConnectivityStateListener(listener) {
	        this.stateListeners.add(listener);
	    }
	    /**
	     * Remove a listener previously added with `addConnectivityStateListener`
	     * @param listener A reference to a function previously passed to
	     *     `addConnectivityStateListener`
	     */
	    removeConnectivityStateListener(listener) {
	        this.stateListeners.delete(listener);
	    }
	    /**
	     * Reset the backoff timeout, and immediately start connecting if in backoff.
	     */
	    resetBackoff() {
	        process.nextTick(() => {
	            this.backoffTimeout.reset();
	            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);
	        });
	    }
	    getAddress() {
	        return this.subchannelAddressString;
	    }
	    getChannelzRef() {
	        return this.channelzRef;
	    }
	    isHealthy() {
	        return true;
	    }
	    addHealthStateWatcher(listener) {
	        // Do nothing with the listener
	    }
	    removeHealthStateWatcher(listener) {
	        // Do nothing with the listener
	    }
	    getRealSubchannel() {
	        return this;
	    }
	    realSubchannelEquals(other) {
	        return other.getRealSubchannel() === this;
	    }
	    throttleKeepalive(newKeepaliveTime) {
	        if (newKeepaliveTime > this.keepaliveTime) {
	            this.keepaliveTime = newKeepaliveTime;
	        }
	    }
	}
	subchannel.Subchannel = Subchannel;
	
	return subchannel;
}

var transport = {};

var http_proxy = {};

var resolverDns = {};

var environment = {};

var hasRequiredEnvironment;

function requireEnvironment () {
	if (hasRequiredEnvironment) return environment;
	hasRequiredEnvironment = 1;
	/*
	 * Copyright 2024 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	var _a;
	Object.defineProperty(environment, "__esModule", { value: true });
	environment.GRPC_NODE_USE_ALTERNATIVE_RESOLVER = undefined;
	environment.GRPC_NODE_USE_ALTERNATIVE_RESOLVER = ((_a = process.env.GRPC_NODE_USE_ALTERNATIVE_RESOLVER) !== null && _a !== undefined ? _a : 'false') === 'true';
	
	return environment;
}

var hasRequiredResolverDns;

function requireResolverDns () {
	if (hasRequiredResolverDns) return resolverDns;
	hasRequiredResolverDns = 1;
	(function (exports) {
		/*
		 * Copyright 2019 gRPC authors.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *     http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.setup = exports.DEFAULT_PORT = undefined;
		const resolver_1 = requireResolver();
		const dns_1 = require$$1$2;
		const service_config_1 = requireServiceConfig();
		const constants_1 = requireConstants();
		const metadata_1 = requireMetadata();
		const logging = requireLogging();
		const constants_2 = requireConstants();
		const uri_parser_1 = requireUriParser();
		const net_1 = require$$0$2;
		const backoff_timeout_1 = requireBackoffTimeout();
		const environment_1 = requireEnvironment();
		const TRACER_NAME = 'dns_resolver';
		function trace(text) {
		    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);
		}
		/**
		 * The default TCP port to connect to if not explicitly specified in the target.
		 */
		exports.DEFAULT_PORT = 443;
		const DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS = 30000;
		/**
		 * Resolver implementation that handles DNS names and IP addresses.
		 */
		class DnsResolver {
		    constructor(target, listener, channelOptions) {
		        var _a, _b, _c;
		        this.target = target;
		        this.listener = listener;
		        this.pendingLookupPromise = null;
		        this.pendingTxtPromise = null;
		        this.latestLookupResult = null;
		        this.latestServiceConfig = null;
		        this.latestServiceConfigError = null;
		        this.continueResolving = false;
		        this.isNextResolutionTimerRunning = false;
		        this.isServiceConfigEnabled = true;
		        this.returnedIpResult = false;
		        this.alternativeResolver = new dns_1.promises.Resolver();
		        trace('Resolver constructed for target ' + (0, uri_parser_1.uriToString)(target));
		        if (target.authority) {
		            this.alternativeResolver.setServers([target.authority]);
		        }
		        const hostPort = (0, uri_parser_1.splitHostPort)(target.path);
		        if (hostPort === null) {
		            this.ipResult = null;
		            this.dnsHostname = null;
		            this.port = null;
		        }
		        else {
		            if ((0, net_1.isIPv4)(hostPort.host) || (0, net_1.isIPv6)(hostPort.host)) {
		                this.ipResult = [
		                    {
		                        addresses: [
		                            {
		                                host: hostPort.host,
		                                port: (_a = hostPort.port) !== null && _a !== undefined ? _a : exports.DEFAULT_PORT,
		                            },
		                        ],
		                    },
		                ];
		                this.dnsHostname = null;
		                this.port = null;
		            }
		            else {
		                this.ipResult = null;
		                this.dnsHostname = hostPort.host;
		                this.port = (_b = hostPort.port) !== null && _b !== undefined ? _b : exports.DEFAULT_PORT;
		            }
		        }
		        this.percentage = Math.random() * 100;
		        if (channelOptions['grpc.service_config_disable_resolution'] === 1) {
		            this.isServiceConfigEnabled = false;
		        }
		        this.defaultResolutionError = {
		            code: constants_1.Status.UNAVAILABLE,
		            details: `Name resolution failed for target ${(0, uri_parser_1.uriToString)(this.target)}`,
		            metadata: new metadata_1.Metadata(),
		        };
		        const backoffOptions = {
		            initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],
		            maxDelay: channelOptions['grpc.max_reconnect_backoff_ms'],
		        };
		        this.backoff = new backoff_timeout_1.BackoffTimeout(() => {
		            if (this.continueResolving) {
		                this.startResolutionWithBackoff();
		            }
		        }, backoffOptions);
		        this.backoff.unref();
		        this.minTimeBetweenResolutionsMs =
		            (_c = channelOptions['grpc.dns_min_time_between_resolutions_ms']) !== null && _c !== undefined ? _c : DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS;
		        this.nextResolutionTimer = setTimeout(() => { }, 0);
		        clearTimeout(this.nextResolutionTimer);
		    }
		    /**
		     * If the target is an IP address, just provide that address as a result.
		     * Otherwise, initiate A, AAAA, and TXT lookups
		     */
		    startResolution() {
		        if (this.ipResult !== null) {
		            if (!this.returnedIpResult) {
		                trace('Returning IP address for target ' + (0, uri_parser_1.uriToString)(this.target));
		                setImmediate(() => {
		                    this.listener.onSuccessfulResolution(this.ipResult, null, null, null, {});
		                });
		                this.returnedIpResult = true;
		            }
		            this.backoff.stop();
		            this.backoff.reset();
		            this.stopNextResolutionTimer();
		            return;
		        }
		        if (this.dnsHostname === null) {
		            trace('Failed to parse DNS address ' + (0, uri_parser_1.uriToString)(this.target));
		            setImmediate(() => {
		                this.listener.onError({
		                    code: constants_1.Status.UNAVAILABLE,
		                    details: `Failed to parse DNS address ${(0, uri_parser_1.uriToString)(this.target)}`,
		                    metadata: new metadata_1.Metadata(),
		                });
		            });
		            this.stopNextResolutionTimer();
		        }
		        else {
		            if (this.pendingLookupPromise !== null) {
		                return;
		            }
		            trace('Looking up DNS hostname ' + this.dnsHostname);
		            /* We clear out latestLookupResult here to ensure that it contains the
		             * latest result since the last time we started resolving. That way, the
		             * TXT resolution handler can use it, but only if it finishes second. We
		             * don't clear out any previous service config results because it's
		             * better to use a service config that's slightly out of date than to
		             * revert to an effectively blank one. */
		            this.latestLookupResult = null;
		            const hostname = this.dnsHostname;
		            this.pendingLookupPromise = this.lookup(hostname);
		            this.pendingLookupPromise.then(addressList => {
		                if (this.pendingLookupPromise === null) {
		                    return;
		                }
		                this.pendingLookupPromise = null;
		                this.backoff.reset();
		                this.backoff.stop();
		                this.latestLookupResult = addressList.map(address => ({
		                    addresses: [address],
		                }));
		                const allAddressesString = '[' +
		                    addressList.map(addr => addr.host + ':' + addr.port).join(',') +
		                    ']';
		                trace('Resolved addresses for target ' +
		                    (0, uri_parser_1.uriToString)(this.target) +
		                    ': ' +
		                    allAddressesString);
		                if (this.latestLookupResult.length === 0) {
		                    this.listener.onError(this.defaultResolutionError);
		                    return;
		                }
		                /* If the TXT lookup has not yet finished, both of the last two
		                 * arguments will be null, which is the equivalent of getting an
		                 * empty TXT response. When the TXT lookup does finish, its handler
		                 * can update the service config by using the same address list */
		                this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});
		            }, err => {
		                if (this.pendingLookupPromise === null) {
		                    return;
		                }
		                trace('Resolution error for target ' +
		                    (0, uri_parser_1.uriToString)(this.target) +
		                    ': ' +
		                    err.message);
		                this.pendingLookupPromise = null;
		                this.stopNextResolutionTimer();
		                this.listener.onError(this.defaultResolutionError);
		            });
		            /* If there already is a still-pending TXT resolution, we can just use
		             * that result when it comes in */
		            if (this.isServiceConfigEnabled && this.pendingTxtPromise === null) {
		                /* We handle the TXT query promise differently than the others because
		                 * the name resolution attempt as a whole is a success even if the TXT
		                 * lookup fails */
		                this.pendingTxtPromise = this.resolveTxt(hostname);
		                this.pendingTxtPromise.then(txtRecord => {
		                    if (this.pendingTxtPromise === null) {
		                        return;
		                    }
		                    this.pendingTxtPromise = null;
		                    try {
		                        this.latestServiceConfig = (0, service_config_1.extractAndSelectServiceConfig)(txtRecord, this.percentage);
		                    }
		                    catch (err) {
		                        this.latestServiceConfigError = {
		                            code: constants_1.Status.UNAVAILABLE,
		                            details: `Parsing service config failed with error ${err.message}`,
		                            metadata: new metadata_1.Metadata(),
		                        };
		                    }
		                    if (this.latestLookupResult !== null) {
		                        /* We rely here on the assumption that calling this function with
		                         * identical parameters will be essentialy idempotent, and calling
		                         * it with the same address list and a different service config
		                         * should result in a fast and seamless switchover. */
		                        this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});
		                    }
		                }, err => {
		                    /* If TXT lookup fails we should do nothing, which means that we
		                     * continue to use the result of the most recent successful lookup,
		                     * or the default null config object if there has never been a
		                     * successful lookup. We do not set the latestServiceConfigError
		                     * here because that is specifically used for response validation
		                     * errors. We still need to handle this error so that it does not
		                     * bubble up as an unhandled promise rejection. */
		                });
		            }
		        }
		    }
		    async lookup(hostname) {
		        if (environment_1.GRPC_NODE_USE_ALTERNATIVE_RESOLVER) {
		            trace('Using alternative DNS resolver.');
		            const records = await Promise.allSettled([
		                this.alternativeResolver.resolve4(hostname),
		                this.alternativeResolver.resolve6(hostname),
		            ]);
		            if (records.every(result => result.status === 'rejected')) {
		                throw new Error(records[0].reason);
		            }
		            return records
		                .reduce((acc, result) => {
		                return result.status === 'fulfilled'
		                    ? [...acc, ...result.value]
		                    : acc;
		            }, [])
		                .map(addr => ({
		                host: addr,
		                port: +this.port,
		            }));
		        }
		        /* We lookup both address families here and then split them up later
		         * because when looking up a single family, dns.lookup outputs an error
		         * if the name exists but there are no records for that family, and that
		         * error is indistinguishable from other kinds of errors */
		        const addressList = await dns_1.promises.lookup(hostname, { all: true });
		        return addressList.map(addr => ({ host: addr.address, port: +this.port }));
		    }
		    async resolveTxt(hostname) {
		        if (environment_1.GRPC_NODE_USE_ALTERNATIVE_RESOLVER) {
		            trace('Using alternative DNS resolver.');
		            return this.alternativeResolver.resolveTxt(hostname);
		        }
		        return dns_1.promises.resolveTxt(hostname);
		    }
		    startNextResolutionTimer() {
		        var _a, _b;
		        clearTimeout(this.nextResolutionTimer);
		        this.nextResolutionTimer = setTimeout(() => {
		            this.stopNextResolutionTimer();
		            if (this.continueResolving) {
		                this.startResolutionWithBackoff();
		            }
		        }, this.minTimeBetweenResolutionsMs);
		        (_b = (_a = this.nextResolutionTimer).unref) === null || _b === undefined ? undefined : _b.call(_a);
		        this.isNextResolutionTimerRunning = true;
		    }
		    stopNextResolutionTimer() {
		        clearTimeout(this.nextResolutionTimer);
		        this.isNextResolutionTimerRunning = false;
		    }
		    startResolutionWithBackoff() {
		        if (this.pendingLookupPromise === null) {
		            this.continueResolving = false;
		            this.backoff.runOnce();
		            this.startNextResolutionTimer();
		            this.startResolution();
		        }
		    }
		    updateResolution() {
		        /* If there is a pending lookup, just let it finish. Otherwise, if the
		         * nextResolutionTimer or backoff timer is running, set the
		         * continueResolving flag to resolve when whichever of those timers
		         * fires. Otherwise, start resolving immediately. */
		        if (this.pendingLookupPromise === null) {
		            if (this.isNextResolutionTimerRunning || this.backoff.isRunning()) {
		                if (this.isNextResolutionTimerRunning) {
		                    trace('resolution update delayed by "min time between resolutions" rate limit');
		                }
		                else {
		                    trace('resolution update delayed by backoff timer until ' +
		                        this.backoff.getEndTime().toISOString());
		                }
		                this.continueResolving = true;
		            }
		            else {
		                this.startResolutionWithBackoff();
		            }
		        }
		    }
		    /**
		     * Reset the resolver to the same state it had when it was created. In-flight
		     * DNS requests cannot be cancelled, but they are discarded and their results
		     * will be ignored.
		     */
		    destroy() {
		        this.continueResolving = false;
		        this.backoff.reset();
		        this.backoff.stop();
		        this.stopNextResolutionTimer();
		        this.pendingLookupPromise = null;
		        this.pendingTxtPromise = null;
		        this.latestLookupResult = null;
		        this.latestServiceConfig = null;
		        this.latestServiceConfigError = null;
		        this.returnedIpResult = false;
		    }
		    /**
		     * Get the default authority for the given target. For IP targets, that is
		     * the IP address. For DNS targets, it is the hostname.
		     * @param target
		     */
		    static getDefaultAuthority(target) {
		        return target.path;
		    }
		}
		/**
		 * Set up the DNS resolver class by registering it as the handler for the
		 * "dns:" prefix and as the default resolver.
		 */
		function setup() {
		    (0, resolver_1.registerResolver)('dns', DnsResolver);
		    (0, resolver_1.registerDefaultScheme)('dns');
		}
		exports.setup = setup;
		
	} (resolverDns));
	return resolverDns;
}

var hasRequiredHttp_proxy;

function requireHttp_proxy () {
	if (hasRequiredHttp_proxy) return http_proxy;
	hasRequiredHttp_proxy = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(http_proxy, "__esModule", { value: true });
	http_proxy.getProxiedConnection = http_proxy.mapProxyName = undefined;
	const logging_1 = requireLogging();
	const constants_1 = requireConstants();
	const resolver_1 = requireResolver();
	const http = require$$3$1;
	const tls = require$$4$1;
	const logging = requireLogging();
	const subchannel_address_1 = requireSubchannelAddress();
	const uri_parser_1 = requireUriParser();
	const url_1 = require$$7;
	const resolver_dns_1 = requireResolverDns();
	const TRACER_NAME = 'proxy';
	function trace(text) {
	    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
	}
	function getProxyInfo() {
	    let proxyEnv = '';
	    let envVar = '';
	    /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.
	     * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The
	     * fallback behavior can be removed if there's a demand for it.
	     */
	    if (process.env.grpc_proxy) {
	        envVar = 'grpc_proxy';
	        proxyEnv = process.env.grpc_proxy;
	    }
	    else if (process.env.https_proxy) {
	        envVar = 'https_proxy';
	        proxyEnv = process.env.https_proxy;
	    }
	    else if (process.env.http_proxy) {
	        envVar = 'http_proxy';
	        proxyEnv = process.env.http_proxy;
	    }
	    else {
	        return {};
	    }
	    let proxyUrl;
	    try {
	        proxyUrl = new url_1.URL(proxyEnv);
	    }
	    catch (e) {
	        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `cannot parse value of "${envVar}" env var`);
	        return {};
	    }
	    if (proxyUrl.protocol !== 'http:') {
	        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `"${proxyUrl.protocol}" scheme not supported in proxy URI`);
	        return {};
	    }
	    let userCred = null;
	    if (proxyUrl.username) {
	        if (proxyUrl.password) {
	            (0, logging_1.log)(constants_1.LogVerbosity.INFO, 'userinfo found in proxy URI');
	            userCred = decodeURIComponent(`${proxyUrl.username}:${proxyUrl.password}`);
	        }
	        else {
	            userCred = proxyUrl.username;
	        }
	    }
	    const hostname = proxyUrl.hostname;
	    let port = proxyUrl.port;
	    /* The proxy URL uses the scheme "http:", which has a default port number of
	     * 80. We need to set that explicitly here if it is omitted because otherwise
	     * it will use gRPC's default port 443. */
	    if (port === '') {
	        port = '80';
	    }
	    const result = {
	        address: `${hostname}:${port}`,
	    };
	    if (userCred) {
	        result.creds = userCred;
	    }
	    trace('Proxy server ' + result.address + ' set by environment variable ' + envVar);
	    return result;
	}
	function getNoProxyHostList() {
	    /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */
	    let noProxyStr = process.env.no_grpc_proxy;
	    let envVar = 'no_grpc_proxy';
	    if (!noProxyStr) {
	        noProxyStr = process.env.no_proxy;
	        envVar = 'no_proxy';
	    }
	    if (noProxyStr) {
	        trace('No proxy server list set by environment variable ' + envVar);
	        return noProxyStr.split(',');
	    }
	    else {
	        return [];
	    }
	}
	function mapProxyName(target, options) {
	    var _a;
	    const noProxyResult = {
	        target: target,
	        extraOptions: {},
	    };
	    if (((_a = options['grpc.enable_http_proxy']) !== null && _a !== undefined ? _a : 1) === 0) {
	        return noProxyResult;
	    }
	    if (target.scheme === 'unix') {
	        return noProxyResult;
	    }
	    const proxyInfo = getProxyInfo();
	    if (!proxyInfo.address) {
	        return noProxyResult;
	    }
	    const hostPort = (0, uri_parser_1.splitHostPort)(target.path);
	    if (!hostPort) {
	        return noProxyResult;
	    }
	    const serverHost = hostPort.host;
	    for (const host of getNoProxyHostList()) {
	        if (host === serverHost) {
	            trace('Not using proxy for target in no_proxy list: ' + (0, uri_parser_1.uriToString)(target));
	            return noProxyResult;
	        }
	    }
	    const extraOptions = {
	        'grpc.http_connect_target': (0, uri_parser_1.uriToString)(target),
	    };
	    if (proxyInfo.creds) {
	        extraOptions['grpc.http_connect_creds'] = proxyInfo.creds;
	    }
	    return {
	        target: {
	            scheme: 'dns',
	            path: proxyInfo.address,
	        },
	        extraOptions: extraOptions,
	    };
	}
	http_proxy.mapProxyName = mapProxyName;
	function getProxiedConnection(address, channelOptions, connectionOptions) {
	    var _a;
	    if (!('grpc.http_connect_target' in channelOptions)) {
	        return Promise.resolve({});
	    }
	    const realTarget = channelOptions['grpc.http_connect_target'];
	    const parsedTarget = (0, uri_parser_1.parseUri)(realTarget);
	    if (parsedTarget === null) {
	        return Promise.resolve({});
	    }
	    const splitHostPost = (0, uri_parser_1.splitHostPort)(parsedTarget.path);
	    if (splitHostPost === null) {
	        return Promise.resolve({});
	    }
	    const hostPort = `${splitHostPost.host}:${(_a = splitHostPost.port) !== null && _a !== undefined ? _a : resolver_dns_1.DEFAULT_PORT}`;
	    const options = {
	        method: 'CONNECT',
	        path: hostPort,
	    };
	    const headers = {
	        Host: hostPort,
	    };
	    // Connect to the subchannel address as a proxy
	    if ((0, subchannel_address_1.isTcpSubchannelAddress)(address)) {
	        options.host = address.host;
	        options.port = address.port;
	    }
	    else {
	        options.socketPath = address.path;
	    }
	    if ('grpc.http_connect_creds' in channelOptions) {
	        headers['Proxy-Authorization'] =
	            'Basic ' +
	                Buffer.from(channelOptions['grpc.http_connect_creds']).toString('base64');
	    }
	    options.headers = headers;
	    const proxyAddressString = (0, subchannel_address_1.subchannelAddressToString)(address);
	    trace('Using proxy ' + proxyAddressString + ' to connect to ' + options.path);
	    return new Promise((resolve, reject) => {
	        const request = http.request(options);
	        request.once('connect', (res, socket, head) => {
	            var _a;
	            request.removeAllListeners();
	            socket.removeAllListeners();
	            if (res.statusCode === 200) {
	                trace('Successfully connected to ' +
	                    options.path +
	                    ' through proxy ' +
	                    proxyAddressString);
	                // The HTTP client may have already read a few bytes of the proxied
	                // connection. If that's the case, put them back into the socket.
	                // See https://github.com/grpc/grpc-node/issues/2744.
	                if (head.length > 0) {
	                    socket.unshift(head);
	                }
	                if ('secureContext' in connectionOptions) {
	                    /* The proxy is connecting to a TLS server, so upgrade this socket
	                     * connection to a TLS connection.
	                     * This is a workaround for https://github.com/nodejs/node/issues/32922
	                     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */
	                    const targetPath = (0, resolver_1.getDefaultAuthority)(parsedTarget);
	                    const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);
	                    const remoteHost = (_a = hostPort === null || hostPort === undefined ? undefined : hostPort.host) !== null && _a !== undefined ? _a : targetPath;
	                    const cts = tls.connect(Object.assign({ host: remoteHost, servername: remoteHost, socket: socket }, connectionOptions), () => {
	                        trace('Successfully established a TLS connection to ' +
	                            options.path +
	                            ' through proxy ' +
	                            proxyAddressString);
	                        resolve({ socket: cts, realTarget: parsedTarget });
	                    });
	                    cts.on('error', (error) => {
	                        trace('Failed to establish a TLS connection to ' +
	                            options.path +
	                            ' through proxy ' +
	                            proxyAddressString +
	                            ' with error ' +
	                            error.message);
	                        reject();
	                    });
	                }
	                else {
	                    trace('Successfully established a plaintext connection to ' +
	                        options.path +
	                        ' through proxy ' +
	                        proxyAddressString);
	                    resolve({
	                        socket,
	                        realTarget: parsedTarget,
	                    });
	                }
	            }
	            else {
	                (0, logging_1.log)(constants_1.LogVerbosity.ERROR, 'Failed to connect to ' +
	                    options.path +
	                    ' through proxy ' +
	                    proxyAddressString +
	                    ' with status ' +
	                    res.statusCode);
	                reject();
	            }
	        });
	        request.once('error', err => {
	            request.removeAllListeners();
	            (0, logging_1.log)(constants_1.LogVerbosity.ERROR, 'Failed to connect to proxy ' +
	                proxyAddressString +
	                ' with error ' +
	                err.message);
	            reject();
	        });
	        request.end();
	    });
	}
	http_proxy.getProxiedConnection = getProxiedConnection;
	
	return http_proxy;
}

var subchannelCall = {};

var streamDecoder = {};

var hasRequiredStreamDecoder;

function requireStreamDecoder () {
	if (hasRequiredStreamDecoder) return streamDecoder;
	hasRequiredStreamDecoder = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(streamDecoder, "__esModule", { value: true });
	streamDecoder.StreamDecoder = undefined;
	var ReadState;
	(function (ReadState) {
	    ReadState[ReadState["NO_DATA"] = 0] = "NO_DATA";
	    ReadState[ReadState["READING_SIZE"] = 1] = "READING_SIZE";
	    ReadState[ReadState["READING_MESSAGE"] = 2] = "READING_MESSAGE";
	})(ReadState || (ReadState = {}));
	class StreamDecoder {
	    constructor(maxReadMessageLength) {
	        this.maxReadMessageLength = maxReadMessageLength;
	        this.readState = ReadState.NO_DATA;
	        this.readCompressFlag = Buffer.alloc(1);
	        this.readPartialSize = Buffer.alloc(4);
	        this.readSizeRemaining = 4;
	        this.readMessageSize = 0;
	        this.readPartialMessage = [];
	        this.readMessageRemaining = 0;
	    }
	    write(data) {
	        let readHead = 0;
	        let toRead;
	        const result = [];
	        while (readHead < data.length) {
	            switch (this.readState) {
	                case ReadState.NO_DATA:
	                    this.readCompressFlag = data.slice(readHead, readHead + 1);
	                    readHead += 1;
	                    this.readState = ReadState.READING_SIZE;
	                    this.readPartialSize.fill(0);
	                    this.readSizeRemaining = 4;
	                    this.readMessageSize = 0;
	                    this.readMessageRemaining = 0;
	                    this.readPartialMessage = [];
	                    break;
	                case ReadState.READING_SIZE:
	                    toRead = Math.min(data.length - readHead, this.readSizeRemaining);
	                    data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);
	                    this.readSizeRemaining -= toRead;
	                    readHead += toRead;
	                    // readSizeRemaining >=0 here
	                    if (this.readSizeRemaining === 0) {
	                        this.readMessageSize = this.readPartialSize.readUInt32BE(0);
	                        if (this.maxReadMessageLength !== -1 && this.readMessageSize > this.maxReadMessageLength) {
	                            throw new Error(`Received message larger than max (${this.readMessageSize} vs ${this.maxReadMessageLength})`);
	                        }
	                        this.readMessageRemaining = this.readMessageSize;
	                        if (this.readMessageRemaining > 0) {
	                            this.readState = ReadState.READING_MESSAGE;
	                        }
	                        else {
	                            const message = Buffer.concat([this.readCompressFlag, this.readPartialSize], 5);
	                            this.readState = ReadState.NO_DATA;
	                            result.push(message);
	                        }
	                    }
	                    break;
	                case ReadState.READING_MESSAGE:
	                    toRead = Math.min(data.length - readHead, this.readMessageRemaining);
	                    this.readPartialMessage.push(data.slice(readHead, readHead + toRead));
	                    this.readMessageRemaining -= toRead;
	                    readHead += toRead;
	                    // readMessageRemaining >=0 here
	                    if (this.readMessageRemaining === 0) {
	                        // At this point, we have read a full message
	                        const framedMessageBuffers = [
	                            this.readCompressFlag,
	                            this.readPartialSize,
	                        ].concat(this.readPartialMessage);
	                        const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);
	                        this.readState = ReadState.NO_DATA;
	                        result.push(framedMessage);
	                    }
	                    break;
	                default:
	                    throw new Error('Unexpected read state');
	            }
	        }
	        return result;
	    }
	}
	streamDecoder.StreamDecoder = StreamDecoder;
	
	return streamDecoder;
}

var hasRequiredSubchannelCall;

function requireSubchannelCall () {
	if (hasRequiredSubchannelCall) return subchannelCall;
	hasRequiredSubchannelCall = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(subchannelCall, "__esModule", { value: true });
	subchannelCall.Http2SubchannelCall = undefined;
	const http2 = require$$0$5;
	const os = require$$0$1;
	const constants_1 = requireConstants();
	const metadata_1 = requireMetadata();
	const stream_decoder_1 = requireStreamDecoder();
	const logging = requireLogging();
	const constants_2 = requireConstants();
	const TRACER_NAME = 'subchannel_call';
	/**
	 * Should do approximately the same thing as util.getSystemErrorName but the
	 * TypeScript types don't have that function for some reason so I just made my
	 * own.
	 * @param errno
	 */
	function getSystemErrorName(errno) {
	    for (const [name, num] of Object.entries(os.constants.errno)) {
	        if (num === errno) {
	            return name;
	        }
	    }
	    return 'Unknown system error ' + errno;
	}
	function mapHttpStatusCode(code) {
	    const details = `Received HTTP status code ${code}`;
	    let mappedStatusCode;
	    switch (code) {
	        // TODO(murgatroid99): handle 100 and 101
	        case 400:
	            mappedStatusCode = constants_1.Status.INTERNAL;
	            break;
	        case 401:
	            mappedStatusCode = constants_1.Status.UNAUTHENTICATED;
	            break;
	        case 403:
	            mappedStatusCode = constants_1.Status.PERMISSION_DENIED;
	            break;
	        case 404:
	            mappedStatusCode = constants_1.Status.UNIMPLEMENTED;
	            break;
	        case 429:
	        case 502:
	        case 503:
	        case 504:
	            mappedStatusCode = constants_1.Status.UNAVAILABLE;
	            break;
	        default:
	            mappedStatusCode = constants_1.Status.UNKNOWN;
	    }
	    return {
	        code: mappedStatusCode,
	        details: details,
	        metadata: new metadata_1.Metadata()
	    };
	}
	class Http2SubchannelCall {
	    constructor(http2Stream, callEventTracker, listener, transport, callId) {
	        var _a;
	        this.http2Stream = http2Stream;
	        this.callEventTracker = callEventTracker;
	        this.listener = listener;
	        this.transport = transport;
	        this.callId = callId;
	        this.isReadFilterPending = false;
	        this.isPushPending = false;
	        this.canPush = false;
	        /**
	         * Indicates that an 'end' event has come from the http2 stream, so there
	         * will be no more data events.
	         */
	        this.readsClosed = false;
	        this.statusOutput = false;
	        this.unpushedReadMessages = [];
	        // This is populated (non-null) if and only if the call has ended
	        this.finalStatus = null;
	        this.internalError = null;
	        this.serverEndedCall = false;
	        this.connectionDropped = false;
	        const maxReceiveMessageLength = (_a = transport.getOptions()['grpc.max_receive_message_length']) !== null && _a !== undefined ? _a : constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
	        this.decoder = new stream_decoder_1.StreamDecoder(maxReceiveMessageLength);
	        http2Stream.on('response', (headers, flags) => {
	            let headersString = '';
	            for (const header of Object.keys(headers)) {
	                headersString += '\t\t' + header + ': ' + headers[header] + '\n';
	            }
	            this.trace('Received server headers:\n' + headersString);
	            this.httpStatusCode = headers[':status'];
	            if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {
	                this.handleTrailers(headers);
	            }
	            else {
	                let metadata;
	                try {
	                    metadata = metadata_1.Metadata.fromHttp2Headers(headers);
	                }
	                catch (error) {
	                    this.endCall({
	                        code: constants_1.Status.UNKNOWN,
	                        details: error.message,
	                        metadata: new metadata_1.Metadata(),
	                    });
	                    return;
	                }
	                this.listener.onReceiveMetadata(metadata);
	            }
	        });
	        http2Stream.on('trailers', (headers) => {
	            this.handleTrailers(headers);
	        });
	        http2Stream.on('data', (data) => {
	            /* If the status has already been output, allow the http2 stream to
	             * drain without processing the data. */
	            if (this.statusOutput) {
	                return;
	            }
	            this.trace('receive HTTP/2 data frame of length ' + data.length);
	            let messages;
	            try {
	                messages = this.decoder.write(data);
	            }
	            catch (e) {
	                /* Some servers send HTML error pages along with HTTP status codes.
	                 * When the client attempts to parse this as a length-delimited
	                 * message, the parsed message size is greater than the default limit,
	                 * resulting in a message decoding error. In that situation, the HTTP
	                 * error code information is more useful to the user than the
	                 * RESOURCE_EXHAUSTED error is, so we report that instead. Normally,
	                 * we delay processing the HTTP status until after the stream ends, to
	                 * prioritize reporting the gRPC status from trailers if it is present,
	                 * but when there is a message parsing error we end the stream early
	                 * before processing trailers. */
	                if (this.httpStatusCode !== undefined && this.httpStatusCode !== 200) {
	                    const mappedStatus = mapHttpStatusCode(this.httpStatusCode);
	                    this.cancelWithStatus(mappedStatus.code, mappedStatus.details);
	                }
	                else {
	                    this.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, e.message);
	                }
	                return;
	            }
	            for (const message of messages) {
	                this.trace('parsed message of length ' + message.length);
	                this.callEventTracker.addMessageReceived();
	                this.tryPush(message);
	            }
	        });
	        http2Stream.on('end', () => {
	            this.readsClosed = true;
	            this.maybeOutputStatus();
	        });
	        http2Stream.on('close', () => {
	            this.serverEndedCall = true;
	            /* Use process.next tick to ensure that this code happens after any
	             * "error" event that may be emitted at about the same time, so that
	             * we can bubble up the error message from that event. */
	            process.nextTick(() => {
	                var _a;
	                this.trace('HTTP/2 stream closed with code ' + http2Stream.rstCode);
	                /* If we have a final status with an OK status code, that means that
	                 * we have received all of the messages and we have processed the
	                 * trailers and the call completed successfully, so it doesn't matter
	                 * how the stream ends after that */
	                if (((_a = this.finalStatus) === null || _a === undefined ? undefined : _a.code) === constants_1.Status.OK) {
	                    return;
	                }
	                let code;
	                let details = '';
	                switch (http2Stream.rstCode) {
	                    case http2.constants.NGHTTP2_NO_ERROR:
	                        /* If we get a NO_ERROR code and we already have a status, the
	                         * stream completed properly and we just haven't fully processed
	                         * it yet */
	                        if (this.finalStatus !== null) {
	                            return;
	                        }
	                        if (this.httpStatusCode && this.httpStatusCode !== 200) {
	                            const mappedStatus = mapHttpStatusCode(this.httpStatusCode);
	                            code = mappedStatus.code;
	                            details = mappedStatus.details;
	                        }
	                        else {
	                            code = constants_1.Status.INTERNAL;
	                            details = `Received RST_STREAM with code ${http2Stream.rstCode} (Call ended without gRPC status)`;
	                        }
	                        break;
	                    case http2.constants.NGHTTP2_REFUSED_STREAM:
	                        code = constants_1.Status.UNAVAILABLE;
	                        details = 'Stream refused by server';
	                        break;
	                    case http2.constants.NGHTTP2_CANCEL:
	                        /* Bug reports indicate that Node synthesizes a NGHTTP2_CANCEL
	                         * code from connection drops. We want to prioritize reporting
	                         * an unavailable status when that happens. */
	                        if (this.connectionDropped) {
	                            code = constants_1.Status.UNAVAILABLE;
	                            details = 'Connection dropped';
	                        }
	                        else {
	                            code = constants_1.Status.CANCELLED;
	                            details = 'Call cancelled';
	                        }
	                        break;
	                    case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:
	                        code = constants_1.Status.RESOURCE_EXHAUSTED;
	                        details = 'Bandwidth exhausted or memory limit exceeded';
	                        break;
	                    case http2.constants.NGHTTP2_INADEQUATE_SECURITY:
	                        code = constants_1.Status.PERMISSION_DENIED;
	                        details = 'Protocol not secure enough';
	                        break;
	                    case http2.constants.NGHTTP2_INTERNAL_ERROR:
	                        code = constants_1.Status.INTERNAL;
	                        if (this.internalError === null) {
	                            /* This error code was previously handled in the default case, and
	                             * there are several instances of it online, so I wanted to
	                             * preserve the original error message so that people find existing
	                             * information in searches, but also include the more recognizable
	                             * "Internal server error" message. */
	                            details = `Received RST_STREAM with code ${http2Stream.rstCode} (Internal server error)`;
	                        }
	                        else {
	                            if (this.internalError.code === 'ECONNRESET' ||
	                                this.internalError.code === 'ETIMEDOUT') {
	                                code = constants_1.Status.UNAVAILABLE;
	                                details = this.internalError.message;
	                            }
	                            else {
	                                /* The "Received RST_STREAM with code ..." error is preserved
	                                 * here for continuity with errors reported online, but the
	                                 * error message at the end will probably be more relevant in
	                                 * most cases. */
	                                details = `Received RST_STREAM with code ${http2Stream.rstCode} triggered by internal client error: ${this.internalError.message}`;
	                            }
	                        }
	                        break;
	                    default:
	                        code = constants_1.Status.INTERNAL;
	                        details = `Received RST_STREAM with code ${http2Stream.rstCode}`;
	                }
	                // This is a no-op if trailers were received at all.
	                // This is OK, because status codes emitted here correspond to more
	                // catastrophic issues that prevent us from receiving trailers in the
	                // first place.
	                this.endCall({
	                    code,
	                    details,
	                    metadata: new metadata_1.Metadata(),
	                    rstCode: http2Stream.rstCode,
	                });
	            });
	        });
	        http2Stream.on('error', (err) => {
	            /* We need an error handler here to stop "Uncaught Error" exceptions
	             * from bubbling up. However, errors here should all correspond to
	             * "close" events, where we will handle the error more granularly */
	            /* Specifically looking for stream errors that were *not* constructed
	             * from a RST_STREAM response here:
	             * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267
	             */
	            if (err.code !== 'ERR_HTTP2_STREAM_ERROR') {
	                this.trace('Node error event: message=' +
	                    err.message +
	                    ' code=' +
	                    err.code +
	                    ' errno=' +
	                    getSystemErrorName(err.errno) +
	                    ' syscall=' +
	                    err.syscall);
	                this.internalError = err;
	            }
	            this.callEventTracker.onStreamEnd(false);
	        });
	    }
	    getDeadlineInfo() {
	        return [`remote_addr=${this.getPeer()}`];
	    }
	    onDisconnect() {
	        this.connectionDropped = true;
	        /* Give the call an event loop cycle to finish naturally before reporting
	         * the disconnection as an error. */
	        setImmediate(() => {
	            this.endCall({
	                code: constants_1.Status.UNAVAILABLE,
	                details: 'Connection dropped',
	                metadata: new metadata_1.Metadata(),
	            });
	        });
	    }
	    outputStatus() {
	        /* Precondition: this.finalStatus !== null */
	        if (!this.statusOutput) {
	            this.statusOutput = true;
	            this.trace('ended with status: code=' +
	                this.finalStatus.code +
	                ' details="' +
	                this.finalStatus.details +
	                '"');
	            this.callEventTracker.onCallEnd(this.finalStatus);
	            /* We delay the actual action of bubbling up the status to insulate the
	             * cleanup code in this class from any errors that may be thrown in the
	             * upper layers as a result of bubbling up the status. In particular,
	             * if the status is not OK, the "error" event may be emitted
	             * synchronously at the top level, which will result in a thrown error if
	             * the user does not handle that event. */
	            process.nextTick(() => {
	                this.listener.onReceiveStatus(this.finalStatus);
	            });
	            /* Leave the http2 stream in flowing state to drain incoming messages, to
	             * ensure that the stream closure completes. The call stream already does
	             * not push more messages after the status is output, so the messages go
	             * nowhere either way. */
	            this.http2Stream.resume();
	        }
	    }
	    trace(text) {
	        logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callId + '] ' + text);
	    }
	    /**
	     * On first call, emits a 'status' event with the given StatusObject.
	     * Subsequent calls are no-ops.
	     * @param status The status of the call.
	     */
	    endCall(status) {
	        /* If the status is OK and a new status comes in (e.g. from a
	         * deserialization failure), that new status takes priority */
	        if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {
	            this.finalStatus = status;
	            this.maybeOutputStatus();
	        }
	        this.destroyHttp2Stream();
	    }
	    maybeOutputStatus() {
	        if (this.finalStatus !== null) {
	            /* The combination check of readsClosed and that the two message buffer
	             * arrays are empty checks that there all incoming data has been fully
	             * processed */
	            if (this.finalStatus.code !== constants_1.Status.OK ||
	                (this.readsClosed &&
	                    this.unpushedReadMessages.length === 0 &&
	                    !this.isReadFilterPending &&
	                    !this.isPushPending)) {
	                this.outputStatus();
	            }
	        }
	    }
	    push(message) {
	        this.trace('pushing to reader message of length ' +
	            (message instanceof Buffer ? message.length : null));
	        this.canPush = false;
	        this.isPushPending = true;
	        process.nextTick(() => {
	            this.isPushPending = false;
	            /* If we have already output the status any later messages should be
	             * ignored, and can cause out-of-order operation errors higher up in the
	             * stack. Checking as late as possible here to avoid any race conditions.
	             */
	            if (this.statusOutput) {
	                return;
	            }
	            this.listener.onReceiveMessage(message);
	            this.maybeOutputStatus();
	        });
	    }
	    tryPush(messageBytes) {
	        if (this.canPush) {
	            this.http2Stream.pause();
	            this.push(messageBytes);
	        }
	        else {
	            this.trace('unpushedReadMessages.push message of length ' + messageBytes.length);
	            this.unpushedReadMessages.push(messageBytes);
	        }
	    }
	    handleTrailers(headers) {
	        this.serverEndedCall = true;
	        this.callEventTracker.onStreamEnd(true);
	        let headersString = '';
	        for (const header of Object.keys(headers)) {
	            headersString += '\t\t' + header + ': ' + headers[header] + '\n';
	        }
	        this.trace('Received server trailers:\n' + headersString);
	        let metadata;
	        try {
	            metadata = metadata_1.Metadata.fromHttp2Headers(headers);
	        }
	        catch (e) {
	            metadata = new metadata_1.Metadata();
	        }
	        const metadataMap = metadata.getMap();
	        let status;
	        if (typeof metadataMap['grpc-status'] === 'string') {
	            const receivedStatus = Number(metadataMap['grpc-status']);
	            this.trace('received status code ' + receivedStatus + ' from server');
	            metadata.remove('grpc-status');
	            let details = '';
	            if (typeof metadataMap['grpc-message'] === 'string') {
	                try {
	                    details = decodeURI(metadataMap['grpc-message']);
	                }
	                catch (e) {
	                    details = metadataMap['grpc-message'];
	                }
	                metadata.remove('grpc-message');
	                this.trace('received status details string "' + details + '" from server');
	            }
	            status = {
	                code: receivedStatus,
	                details: details,
	                metadata: metadata
	            };
	        }
	        else if (this.httpStatusCode) {
	            status = mapHttpStatusCode(this.httpStatusCode);
	            status.metadata = metadata;
	        }
	        else {
	            status = {
	                code: constants_1.Status.UNKNOWN,
	                details: 'No status information received',
	                metadata: metadata
	            };
	        }
	        // This is a no-op if the call was already ended when handling headers.
	        this.endCall(status);
	    }
	    destroyHttp2Stream() {
	        var _a;
	        // The http2 stream could already have been destroyed if cancelWithStatus
	        // is called in response to an internal http2 error.
	        if (this.http2Stream.destroyed) {
	            return;
	        }
	        /* If the server ended the call, sending an RST_STREAM is redundant, so we
	         * just half close on the client side instead to finish closing the stream.
	         */
	        if (this.serverEndedCall) {
	            this.http2Stream.end();
	        }
	        else {
	            /* If the call has ended with an OK status, communicate that when closing
	             * the stream, partly to avoid a situation in which we detect an error
	             * RST_STREAM as a result after we have the status */
	            let code;
	            if (((_a = this.finalStatus) === null || _a === undefined ? undefined : _a.code) === constants_1.Status.OK) {
	                code = http2.constants.NGHTTP2_NO_ERROR;
	            }
	            else {
	                code = http2.constants.NGHTTP2_CANCEL;
	            }
	            this.trace('close http2 stream with code ' + code);
	            this.http2Stream.close(code);
	        }
	    }
	    cancelWithStatus(status, details) {
	        this.trace('cancelWithStatus code: ' + status + ' details: "' + details + '"');
	        this.endCall({ code: status, details, metadata: new metadata_1.Metadata() });
	    }
	    getStatus() {
	        return this.finalStatus;
	    }
	    getPeer() {
	        return this.transport.getPeerName();
	    }
	    getCallNumber() {
	        return this.callId;
	    }
	    startRead() {
	        /* If the stream has ended with an error, we should not emit any more
	         * messages and we should communicate that the stream has ended */
	        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {
	            this.readsClosed = true;
	            this.maybeOutputStatus();
	            return;
	        }
	        this.canPush = true;
	        if (this.unpushedReadMessages.length > 0) {
	            const nextMessage = this.unpushedReadMessages.shift();
	            this.push(nextMessage);
	            return;
	        }
	        /* Only resume reading from the http2Stream if we don't have any pending
	         * messages to emit */
	        this.http2Stream.resume();
	    }
	    sendMessageWithContext(context, message) {
	        this.trace('write() called with message of length ' + message.length);
	        const cb = (error) => {
	            /* nextTick here ensures that no stream action can be taken in the call
	             * stack of the write callback, in order to hopefully work around
	             * https://github.com/nodejs/node/issues/49147 */
	            process.nextTick(() => {
	                var _a;
	                let code = constants_1.Status.UNAVAILABLE;
	                if ((error === null || error === undefined ? undefined : error.code) ===
	                    'ERR_STREAM_WRITE_AFTER_END') {
	                    code = constants_1.Status.INTERNAL;
	                }
	                if (error) {
	                    this.cancelWithStatus(code, `Write error: ${error.message}`);
	                }
	                (_a = context.callback) === null || _a === undefined ? undefined : _a.call(context);
	            });
	        };
	        this.trace('sending data chunk of length ' + message.length);
	        this.callEventTracker.addMessageSent();
	        try {
	            this.http2Stream.write(message, cb);
	        }
	        catch (error) {
	            this.endCall({
	                code: constants_1.Status.UNAVAILABLE,
	                details: `Write failed with error ${error.message}`,
	                metadata: new metadata_1.Metadata(),
	            });
	        }
	    }
	    halfClose() {
	        this.trace('end() called');
	        this.trace('calling end() on HTTP/2 stream');
	        this.http2Stream.end();
	    }
	}
	subchannelCall.Http2SubchannelCall = Http2SubchannelCall;
	
	return subchannelCall;
}

var callNumber = {};

var hasRequiredCallNumber;

function requireCallNumber () {
	if (hasRequiredCallNumber) return callNumber;
	hasRequiredCallNumber = 1;
	/*
	 * Copyright 2022 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(callNumber, "__esModule", { value: true });
	callNumber.getNextCallNumber = undefined;
	let nextCallNumber = 0;
	function getNextCallNumber() {
	    return nextCallNumber++;
	}
	callNumber.getNextCallNumber = getNextCallNumber;
	
	return callNumber;
}

var hasRequiredTransport;

function requireTransport () {
	if (hasRequiredTransport) return transport;
	hasRequiredTransport = 1;
	/*
	 * Copyright 2023 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(transport, "__esModule", { value: true });
	transport.Http2SubchannelConnector = undefined;
	const http2 = require$$0$5;
	const tls_1 = require$$4$1;
	const channelz_1 = requireChannelz();
	const constants_1 = requireConstants();
	const http_proxy_1 = requireHttp_proxy();
	const logging = requireLogging();
	const resolver_1 = requireResolver();
	const subchannel_address_1 = requireSubchannelAddress();
	const uri_parser_1 = requireUriParser();
	const net = require$$0$2;
	const subchannel_call_1 = requireSubchannelCall();
	const call_number_1 = requireCallNumber();
	const TRACER_NAME = 'transport';
	const FLOW_CONTROL_TRACER_NAME = 'transport_flowctrl';
	const clientVersion = require$$12.version;
	const { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_TE, HTTP2_HEADER_USER_AGENT, } = http2.constants;
	const KEEPALIVE_TIMEOUT_MS = 20000;
	const tooManyPingsData = Buffer.from('too_many_pings', 'ascii');
	class Http2Transport {
	    constructor(session, subchannelAddress, options, 
	    /**
	     * Name of the remote server, if it is not the same as the subchannel
	     * address, i.e. if connecting through an HTTP CONNECT proxy.
	     */
	    remoteName) {
	        this.session = session;
	        this.options = options;
	        this.remoteName = remoteName;
	        /**
	         * Timer reference indicating when to send the next ping or when the most recent ping will be considered lost.
	         */
	        this.keepaliveTimer = null;
	        /**
	         * Indicates that the keepalive timer ran out while there were no active
	         * calls, and a ping should be sent the next time a call starts.
	         */
	        this.pendingSendKeepalivePing = false;
	        this.activeCalls = new Set();
	        this.disconnectListeners = [];
	        this.disconnectHandled = false;
	        this.channelzEnabled = true;
	        this.keepalivesSent = 0;
	        this.messagesSent = 0;
	        this.messagesReceived = 0;
	        this.lastMessageSentTimestamp = null;
	        this.lastMessageReceivedTimestamp = null;
	        /* Populate subchannelAddressString and channelzRef before doing anything
	         * else, because they are used in the trace methods. */
	        this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);
	        if (options['grpc.enable_channelz'] === 0) {
	            this.channelzEnabled = false;
	            this.streamTracker = new channelz_1.ChannelzCallTrackerStub();
	        }
	        else {
	            this.streamTracker = new channelz_1.ChannelzCallTracker();
	        }
	        this.channelzRef = (0, channelz_1.registerChannelzSocket)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);
	        // Build user-agent string.
	        this.userAgent = [
	            options['grpc.primary_user_agent'],
	            `grpc-node-js/${clientVersion}`,
	            options['grpc.secondary_user_agent'],
	        ]
	            .filter(e => e)
	            .join(' '); // remove falsey values first
	        if ('grpc.keepalive_time_ms' in options) {
	            this.keepaliveTimeMs = options['grpc.keepalive_time_ms'];
	        }
	        else {
	            this.keepaliveTimeMs = -1;
	        }
	        if ('grpc.keepalive_timeout_ms' in options) {
	            this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms'];
	        }
	        else {
	            this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;
	        }
	        if ('grpc.keepalive_permit_without_calls' in options) {
	            this.keepaliveWithoutCalls =
	                options['grpc.keepalive_permit_without_calls'] === 1;
	        }
	        else {
	            this.keepaliveWithoutCalls = false;
	        }
	        session.once('close', () => {
	            this.trace('session closed');
	            this.handleDisconnect();
	        });
	        session.once('goaway', (errorCode, lastStreamID, opaqueData) => {
	            let tooManyPings = false;
	            /* See the last paragraph of
	             * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */
	            if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM &&
	                opaqueData &&
	                opaqueData.equals(tooManyPingsData)) {
	                tooManyPings = true;
	            }
	            this.trace('connection closed by GOAWAY with code ' +
	                errorCode +
	                ' and data ' +
	                (opaqueData === null || opaqueData === undefined ? undefined : opaqueData.toString()));
	            this.reportDisconnectToOwner(tooManyPings);
	        });
	        session.once('error', error => {
	            this.trace('connection closed with error ' + error.message);
	            this.handleDisconnect();
	        });
	        session.socket.once('close', () => {
	            this.trace('connection closed');
	            this.handleDisconnect();
	        });
	        if (logging.isTracerEnabled(TRACER_NAME)) {
	            session.on('remoteSettings', (settings) => {
	                this.trace('new settings received' +
	                    (this.session !== session ? ' on the old connection' : '') +
	                    ': ' +
	                    JSON.stringify(settings));
	            });
	            session.on('localSettings', (settings) => {
	                this.trace('local settings acknowledged by remote' +
	                    (this.session !== session ? ' on the old connection' : '') +
	                    ': ' +
	                    JSON.stringify(settings));
	            });
	        }
	        /* Start the keepalive timer last, because this can trigger trace logs,
	         * which should only happen after everything else is set up. */
	        if (this.keepaliveWithoutCalls) {
	            this.maybeStartKeepalivePingTimer();
	        }
	    }
	    getChannelzInfo() {
	        var _a, _b, _c;
	        const sessionSocket = this.session.socket;
	        const remoteAddress = sessionSocket.remoteAddress
	            ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort)
	            : null;
	        const localAddress = sessionSocket.localAddress
	            ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort)
	            : null;
	        let tlsInfo;
	        if (this.session.encrypted) {
	            const tlsSocket = sessionSocket;
	            const cipherInfo = tlsSocket.getCipher();
	            const certificate = tlsSocket.getCertificate();
	            const peerCertificate = tlsSocket.getPeerCertificate();
	            tlsInfo = {
	                cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== undefined ? _a : null,
	                cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,
	                localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,
	                remoteCertificate: peerCertificate && 'raw' in peerCertificate
	                    ? peerCertificate.raw
	                    : null,
	            };
	        }
	        else {
	            tlsInfo = null;
	        }
	        const socketInfo = {
	            remoteAddress: remoteAddress,
	            localAddress: localAddress,
	            security: tlsInfo,
	            remoteName: this.remoteName,
	            streamsStarted: this.streamTracker.callsStarted,
	            streamsSucceeded: this.streamTracker.callsSucceeded,
	            streamsFailed: this.streamTracker.callsFailed,
	            messagesSent: this.messagesSent,
	            messagesReceived: this.messagesReceived,
	            keepAlivesSent: this.keepalivesSent,
	            lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,
	            lastRemoteStreamCreatedTimestamp: null,
	            lastMessageSentTimestamp: this.lastMessageSentTimestamp,
	            lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,
	            localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== undefined ? _b : null,
	            remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== undefined ? _c : null,
	        };
	        return socketInfo;
	    }
	    trace(text) {
	        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' +
	            this.channelzRef.id +
	            ') ' +
	            this.subchannelAddressString +
	            ' ' +
	            text);
	    }
	    keepaliveTrace(text) {
	        logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' +
	            this.channelzRef.id +
	            ') ' +
	            this.subchannelAddressString +
	            ' ' +
	            text);
	    }
	    flowControlTrace(text) {
	        logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, '(' +
	            this.channelzRef.id +
	            ') ' +
	            this.subchannelAddressString +
	            ' ' +
	            text);
	    }
	    internalsTrace(text) {
	        logging.trace(constants_1.LogVerbosity.DEBUG, 'transport_internals', '(' +
	            this.channelzRef.id +
	            ') ' +
	            this.subchannelAddressString +
	            ' ' +
	            text);
	    }
	    /**
	     * Indicate to the owner of this object that this transport should no longer
	     * be used. That happens if the connection drops, or if the server sends a
	     * GOAWAY.
	     * @param tooManyPings If true, this was triggered by a GOAWAY with data
	     * indicating that the session was closed becaues the client sent too many
	     * pings.
	     * @returns
	     */
	    reportDisconnectToOwner(tooManyPings) {
	        if (this.disconnectHandled) {
	            return;
	        }
	        this.disconnectHandled = true;
	        this.disconnectListeners.forEach(listener => listener(tooManyPings));
	    }
	    /**
	     * Handle connection drops, but not GOAWAYs.
	     */
	    handleDisconnect() {
	        this.clearKeepaliveTimeout();
	        this.reportDisconnectToOwner(false);
	        for (const call of this.activeCalls) {
	            call.onDisconnect();
	        }
	        // Wait an event loop cycle before destroying the connection
	        setImmediate(() => {
	            this.session.destroy();
	        });
	    }
	    addDisconnectListener(listener) {
	        this.disconnectListeners.push(listener);
	    }
	    canSendPing() {
	        return (!this.session.destroyed &&
	            this.keepaliveTimeMs > 0 &&
	            (this.keepaliveWithoutCalls || this.activeCalls.size > 0));
	    }
	    maybeSendPing() {
	        var _a, _b;
	        if (!this.canSendPing()) {
	            this.pendingSendKeepalivePing = true;
	            return;
	        }
	        if (this.keepaliveTimer) {
	            console.error('keepaliveTimeout is not null');
	            return;
	        }
	        if (this.channelzEnabled) {
	            this.keepalivesSent += 1;
	        }
	        this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');
	        this.keepaliveTimer = setTimeout(() => {
	            this.keepaliveTimer = null;
	            this.keepaliveTrace('Ping timeout passed without response');
	            this.handleDisconnect();
	        }, this.keepaliveTimeoutMs);
	        (_b = (_a = this.keepaliveTimer).unref) === null || _b === undefined ? undefined : _b.call(_a);
	        let pingSendError = '';
	        try {
	            const pingSentSuccessfully = this.session.ping((err, duration, payload) => {
	                this.clearKeepaliveTimeout();
	                if (err) {
	                    this.keepaliveTrace('Ping failed with error ' + err.message);
	                    this.handleDisconnect();
	                }
	                else {
	                    this.keepaliveTrace('Received ping response');
	                    this.maybeStartKeepalivePingTimer();
	                }
	            });
	            if (!pingSentSuccessfully) {
	                pingSendError = 'Ping returned false';
	            }
	        }
	        catch (e) {
	            // grpc/grpc-node#2139
	            pingSendError = (e instanceof Error ? e.message : '') || 'Unknown error';
	        }
	        if (pingSendError) {
	            this.keepaliveTrace('Ping send failed: ' + pingSendError);
	            this.handleDisconnect();
	        }
	    }
	    /**
	     * Starts the keepalive ping timer if appropriate. If the timer already ran
	     * out while there were no active requests, instead send a ping immediately.
	     * If the ping timer is already running or a ping is currently in flight,
	     * instead do nothing and wait for them to resolve.
	     */
	    maybeStartKeepalivePingTimer() {
	        var _a, _b;
	        if (!this.canSendPing()) {
	            return;
	        }
	        if (this.pendingSendKeepalivePing) {
	            this.pendingSendKeepalivePing = false;
	            this.maybeSendPing();
	        }
	        else if (!this.keepaliveTimer) {
	            this.keepaliveTrace('Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms');
	            this.keepaliveTimer = setTimeout(() => {
	                this.keepaliveTimer = null;
	                this.maybeSendPing();
	            }, this.keepaliveTimeMs);
	            (_b = (_a = this.keepaliveTimer).unref) === null || _b === undefined ? undefined : _b.call(_a);
	        }
	        /* Otherwise, there is already either a keepalive timer or a ping pending,
	         * wait for those to resolve. */
	    }
	    /**
	     * Clears whichever keepalive timeout is currently active, if any.
	     */
	    clearKeepaliveTimeout() {
	        if (this.keepaliveTimer) {
	            clearTimeout(this.keepaliveTimer);
	            this.keepaliveTimer = null;
	        }
	    }
	    removeActiveCall(call) {
	        this.activeCalls.delete(call);
	        if (this.activeCalls.size === 0) {
	            this.session.unref();
	        }
	    }
	    addActiveCall(call) {
	        this.activeCalls.add(call);
	        if (this.activeCalls.size === 1) {
	            this.session.ref();
	            if (!this.keepaliveWithoutCalls) {
	                this.maybeStartKeepalivePingTimer();
	            }
	        }
	    }
	    createCall(metadata, host, method, listener, subchannelCallStatsTracker) {
	        const headers = metadata.toHttp2Headers();
	        headers[HTTP2_HEADER_AUTHORITY] = host;
	        headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;
	        headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';
	        headers[HTTP2_HEADER_METHOD] = 'POST';
	        headers[HTTP2_HEADER_PATH] = method;
	        headers[HTTP2_HEADER_TE] = 'trailers';
	        let http2Stream;
	        /* In theory, if an error is thrown by session.request because session has
	         * become unusable (e.g. because it has received a goaway), this subchannel
	         * should soon see the corresponding close or goaway event anyway and leave
	         * READY. But we have seen reports that this does not happen
	         * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)
	         * so for defense in depth, we just discard the session when we see an
	         * error here.
	         */
	        try {
	            http2Stream = this.session.request(headers);
	        }
	        catch (e) {
	            this.handleDisconnect();
	            throw e;
	        }
	        this.flowControlTrace('local window size: ' +
	            this.session.state.localWindowSize +
	            ' remote window size: ' +
	            this.session.state.remoteWindowSize);
	        this.internalsTrace('session.closed=' +
	            this.session.closed +
	            ' session.destroyed=' +
	            this.session.destroyed +
	            ' session.socket.destroyed=' +
	            this.session.socket.destroyed);
	        let eventTracker;
	        // eslint-disable-next-line prefer-const
	        let call;
	        if (this.channelzEnabled) {
	            this.streamTracker.addCallStarted();
	            eventTracker = {
	                addMessageSent: () => {
	                    var _a;
	                    this.messagesSent += 1;
	                    this.lastMessageSentTimestamp = new Date();
	                    (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === undefined ? undefined : _a.call(subchannelCallStatsTracker);
	                },
	                addMessageReceived: () => {
	                    var _a;
	                    this.messagesReceived += 1;
	                    this.lastMessageReceivedTimestamp = new Date();
	                    (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === undefined ? undefined : _a.call(subchannelCallStatsTracker);
	                },
	                onCallEnd: status => {
	                    var _a;
	                    (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === undefined ? undefined : _a.call(subchannelCallStatsTracker, status);
	                    this.removeActiveCall(call);
	                },
	                onStreamEnd: success => {
	                    var _a;
	                    if (success) {
	                        this.streamTracker.addCallSucceeded();
	                    }
	                    else {
	                        this.streamTracker.addCallFailed();
	                    }
	                    (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === undefined ? undefined : _a.call(subchannelCallStatsTracker, success);
	                },
	            };
	        }
	        else {
	            eventTracker = {
	                addMessageSent: () => {
	                    var _a;
	                    (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === undefined ? undefined : _a.call(subchannelCallStatsTracker);
	                },
	                addMessageReceived: () => {
	                    var _a;
	                    (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === undefined ? undefined : _a.call(subchannelCallStatsTracker);
	                },
	                onCallEnd: status => {
	                    var _a;
	                    (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === undefined ? undefined : _a.call(subchannelCallStatsTracker, status);
	                    this.removeActiveCall(call);
	                },
	                onStreamEnd: success => {
	                    var _a;
	                    (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === undefined ? undefined : _a.call(subchannelCallStatsTracker, success);
	                },
	            };
	        }
	        call = new subchannel_call_1.Http2SubchannelCall(http2Stream, eventTracker, listener, this, (0, call_number_1.getNextCallNumber)());
	        this.addActiveCall(call);
	        return call;
	    }
	    getChannelzRef() {
	        return this.channelzRef;
	    }
	    getPeerName() {
	        return this.subchannelAddressString;
	    }
	    getOptions() {
	        return this.options;
	    }
	    shutdown() {
	        this.session.close();
	        (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
	    }
	}
	class Http2SubchannelConnector {
	    constructor(channelTarget) {
	        this.channelTarget = channelTarget;
	        this.session = null;
	        this.isShutdown = false;
	    }
	    trace(text) {
	        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, (0, uri_parser_1.uriToString)(this.channelTarget) + ' ' + text);
	    }
	    createSession(address, credentials, options, proxyConnectionResult) {
	        if (this.isShutdown) {
	            return Promise.reject();
	        }
	        return new Promise((resolve, reject) => {
	            var _a, _b, _c, _d;
	            let remoteName;
	            if (proxyConnectionResult.realTarget) {
	                remoteName = (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget);
	                this.trace('creating HTTP/2 session through proxy to ' +
	                    (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget));
	            }
	            else {
	                remoteName = null;
	                this.trace('creating HTTP/2 session to ' + (0, subchannel_address_1.subchannelAddressToString)(address));
	            }
	            const targetAuthority = (0, resolver_1.getDefaultAuthority)((_a = proxyConnectionResult.realTarget) !== null && _a !== undefined ? _a : this.channelTarget);
	            let connectionOptions = credentials._getConnectionOptions();
	            if (!connectionOptions) {
	                reject('Credentials not loaded');
	                return;
	            }
	            connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;
	            if ('grpc-node.max_session_memory' in options) {
	                connectionOptions.maxSessionMemory =
	                    options['grpc-node.max_session_memory'];
	            }
	            else {
	                /* By default, set a very large max session memory limit, to effectively
	                 * disable enforcement of the limit. Some testing indicates that Node's
	                 * behavior degrades badly when this limit is reached, so we solve that
	                 * by disabling the check entirely. */
	                connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;
	            }
	            let addressScheme = 'http://';
	            if ('secureContext' in connectionOptions) {
	                addressScheme = 'https://';
	                // If provided, the value of grpc.ssl_target_name_override should be used
	                // to override the target hostname when checking server identity.
	                // This option is used for testing only.
	                if (options['grpc.ssl_target_name_override']) {
	                    const sslTargetNameOverride = options['grpc.ssl_target_name_override'];
	                    const originalCheckServerIdentity = (_b = connectionOptions.checkServerIdentity) !== null && _b !== undefined ? _b : tls_1.checkServerIdentity;
	                    connectionOptions.checkServerIdentity = (host, cert) => {
	                        return originalCheckServerIdentity(sslTargetNameOverride, cert);
	                    };
	                    connectionOptions.servername = sslTargetNameOverride;
	                }
	                else {
	                    const authorityHostname = (_d = (_c = (0, uri_parser_1.splitHostPort)(targetAuthority)) === null || _c === undefined ? undefined : _c.host) !== null && _d !== undefined ? _d : 'localhost';
	                    // We want to always set servername to support SNI
	                    connectionOptions.servername = authorityHostname;
	                }
	                if (proxyConnectionResult.socket) {
	                    /* This is part of the workaround for
	                     * https://github.com/nodejs/node/issues/32922. Without that bug,
	                     * proxyConnectionResult.socket would always be a plaintext socket and
	                     * this would say
	                     * connectionOptions.socket = proxyConnectionResult.socket; */
	                    connectionOptions.createConnection = (authority, option) => {
	                        return proxyConnectionResult.socket;
	                    };
	                }
	            }
	            else {
	                /* In all but the most recent versions of Node, http2.connect does not use
	                 * the options when establishing plaintext connections, so we need to
	                 * establish that connection explicitly. */
	                connectionOptions.createConnection = (authority, option) => {
	                    if (proxyConnectionResult.socket) {
	                        return proxyConnectionResult.socket;
	                    }
	                    else {
	                        /* net.NetConnectOpts is declared in a way that is more restrictive
	                         * than what net.connect will actually accept, so we use the type
	                         * assertion to work around that. */
	                        return net.connect(address);
	                    }
	                };
	            }
	            connectionOptions = Object.assign(Object.assign(Object.assign({}, connectionOptions), address), { enableTrace: options['grpc-node.tls_enable_trace'] === 1 });
	            /* http2.connect uses the options here:
	             * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036
	             * The spread operator overides earlier values with later ones, so any port
	             * or host values in the options will be used rather than any values extracted
	             * from the first argument. In addition, the path overrides the host and port,
	             * as documented for plaintext connections here:
	             * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener
	             * and for TLS connections here:
	             * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In
	             * earlier versions of Node, http2.connect passes these options to
	             * tls.connect but not net.connect, so in the insecure case we still need
	             * to set the createConnection option above to create the connection
	             * explicitly. We cannot do that in the TLS case because http2.connect
	             * passes necessary additional options to tls.connect.
	             * The first argument just needs to be parseable as a URL and the scheme
	             * determines whether the connection will be established over TLS or not.
	             */
	            const session = http2.connect(addressScheme + targetAuthority, connectionOptions);
	            this.session = session;
	            let errorMessage = 'Failed to connect';
	            let reportedError = false;
	            session.unref();
	            session.once('connect', () => {
	                session.removeAllListeners();
	                resolve(new Http2Transport(session, address, options, remoteName));
	                this.session = null;
	            });
	            session.once('close', () => {
	                this.session = null;
	                // Leave time for error event to happen before rejecting
	                setImmediate(() => {
	                    if (!reportedError) {
	                        reportedError = true;
	                        reject(`${errorMessage} (${new Date().toISOString()})`);
	                    }
	                });
	            });
	            session.once('error', error => {
	                errorMessage = error.message;
	                this.trace('connection failed with error ' + errorMessage);
	                if (!reportedError) {
	                    reportedError = true;
	                    reject(`${errorMessage} (${new Date().toISOString()})`);
	                }
	            });
	        });
	    }
	    connect(address, credentials, options) {
	        var _a, _b, _c;
	        if (this.isShutdown) {
	            return Promise.reject();
	        }
	        /* Pass connection options through to the proxy so that it's able to
	         * upgrade it's connection to support tls if needed.
	         * This is a workaround for https://github.com/nodejs/node/issues/32922
	         * See https://github.com/grpc/grpc-node/pull/1369 for more info. */
	        const connectionOptions = credentials._getConnectionOptions();
	        if (!connectionOptions) {
	            return Promise.reject('Credentials not loaded');
	        }
	        if ('secureContext' in connectionOptions) {
	            connectionOptions.ALPNProtocols = ['h2'];
	            // If provided, the value of grpc.ssl_target_name_override should be used
	            // to override the target hostname when checking server identity.
	            // This option is used for testing only.
	            if (options['grpc.ssl_target_name_override']) {
	                const sslTargetNameOverride = options['grpc.ssl_target_name_override'];
	                const originalCheckServerIdentity = (_a = connectionOptions.checkServerIdentity) !== null && _a !== undefined ? _a : tls_1.checkServerIdentity;
	                connectionOptions.checkServerIdentity = (host, cert) => {
	                    return originalCheckServerIdentity(sslTargetNameOverride, cert);
	                };
	                connectionOptions.servername = sslTargetNameOverride;
	            }
	            else {
	                if ('grpc.http_connect_target' in options) {
	                    /* This is more or less how servername will be set in createSession
	                     * if a connection is successfully established through the proxy.
	                     * If the proxy is not used, these connectionOptions are discarded
	                     * anyway */
	                    const targetPath = (0, resolver_1.getDefaultAuthority)((_b = (0, uri_parser_1.parseUri)(options['grpc.http_connect_target'])) !== null && _b !== undefined ? _b : {
	                        path: 'localhost',
	                    });
	                    const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);
	                    connectionOptions.servername = (_c = hostPort === null || hostPort === undefined ? undefined : hostPort.host) !== null && _c !== undefined ? _c : targetPath;
	                }
	            }
	            if (options['grpc-node.tls_enable_trace']) {
	                connectionOptions.enableTrace = true;
	            }
	        }
	        return (0, http_proxy_1.getProxiedConnection)(address, options, connectionOptions).then(result => this.createSession(address, credentials, options, result));
	    }
	    shutdown() {
	        var _a;
	        this.isShutdown = true;
	        (_a = this.session) === null || _a === undefined ? undefined : _a.close();
	        this.session = null;
	    }
	}
	transport.Http2SubchannelConnector = Http2SubchannelConnector;
	
	return transport;
}

var hasRequiredSubchannelPool;

function requireSubchannelPool () {
	if (hasRequiredSubchannelPool) return subchannelPool;
	hasRequiredSubchannelPool = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(subchannelPool, "__esModule", { value: true });
	subchannelPool.getSubchannelPool = subchannelPool.SubchannelPool = undefined;
	const channel_options_1 = requireChannelOptions();
	const subchannel_1 = requireSubchannel();
	const subchannel_address_1 = requireSubchannelAddress();
	const uri_parser_1 = requireUriParser();
	const transport_1 = requireTransport();
	// 10 seconds in milliseconds. This value is arbitrary.
	/**
	 * The amount of time in between checks for dropping subchannels that have no
	 * other references
	 */
	const REF_CHECK_INTERVAL = 10000;
	class SubchannelPool {
	    /**
	     * A pool of subchannels use for making connections. Subchannels with the
	     * exact same parameters will be reused.
	     */
	    constructor() {
	        this.pool = Object.create(null);
	        /**
	         * A timer of a task performing a periodic subchannel cleanup.
	         */
	        this.cleanupTimer = null;
	    }
	    /**
	     * Unrefs all unused subchannels and cancels the cleanup task if all
	     * subchannels have been unrefed.
	     */
	    unrefUnusedSubchannels() {
	        let allSubchannelsUnrefed = true;
	        /* These objects are created with Object.create(null), so they do not
	         * have a prototype, which means that for (... in ...) loops over them
	         * do not need to be filtered */
	        // eslint-disable-disable-next-line:forin
	        for (const channelTarget in this.pool) {
	            const subchannelObjArray = this.pool[channelTarget];
	            const refedSubchannels = subchannelObjArray.filter(value => !value.subchannel.unrefIfOneRef());
	            if (refedSubchannels.length > 0) {
	                allSubchannelsUnrefed = false;
	            }
	            /* For each subchannel in the pool, try to unref it if it has
	             * exactly one ref (which is the ref from the pool itself). If that
	             * does happen, remove the subchannel from the pool */
	            this.pool[channelTarget] = refedSubchannels;
	        }
	        /* Currently we do not delete keys with empty values. If that results
	         * in significant memory usage we should change it. */
	        // Cancel the cleanup task if all subchannels have been unrefed.
	        if (allSubchannelsUnrefed && this.cleanupTimer !== null) {
	            clearInterval(this.cleanupTimer);
	            this.cleanupTimer = null;
	        }
	    }
	    /**
	     * Ensures that the cleanup task is spawned.
	     */
	    ensureCleanupTask() {
	        var _a, _b;
	        if (this.cleanupTimer === null) {
	            this.cleanupTimer = setInterval(() => {
	                this.unrefUnusedSubchannels();
	            }, REF_CHECK_INTERVAL);
	            // Unref because this timer should not keep the event loop running.
	            // Call unref only if it exists to address electron/electron#21162
	            (_b = (_a = this.cleanupTimer).unref) === null || _b === undefined ? undefined : _b.call(_a);
	        }
	    }
	    /**
	     * Get a subchannel if one already exists with exactly matching parameters.
	     * Otherwise, create and save a subchannel with those parameters.
	     * @param channelTarget
	     * @param subchannelTarget
	     * @param channelArguments
	     * @param channelCredentials
	     */
	    getOrCreateSubchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials) {
	        this.ensureCleanupTask();
	        const channelTarget = (0, uri_parser_1.uriToString)(channelTargetUri);
	        if (channelTarget in this.pool) {
	            const subchannelObjArray = this.pool[channelTarget];
	            for (const subchannelObj of subchannelObjArray) {
	                if ((0, subchannel_address_1.subchannelAddressEqual)(subchannelTarget, subchannelObj.subchannelAddress) &&
	                    (0, channel_options_1.channelOptionsEqual)(channelArguments, subchannelObj.channelArguments) &&
	                    channelCredentials._equals(subchannelObj.channelCredentials)) {
	                    return subchannelObj.subchannel;
	                }
	            }
	        }
	        // If we get here, no matching subchannel was found
	        const subchannel = new subchannel_1.Subchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials, new transport_1.Http2SubchannelConnector(channelTargetUri));
	        if (!(channelTarget in this.pool)) {
	            this.pool[channelTarget] = [];
	        }
	        this.pool[channelTarget].push({
	            subchannelAddress: subchannelTarget,
	            channelArguments,
	            channelCredentials,
	            subchannel,
	        });
	        subchannel.ref();
	        return subchannel;
	    }
	}
	subchannelPool.SubchannelPool = SubchannelPool;
	const globalSubchannelPool = new SubchannelPool();
	/**
	 * Get either the global subchannel pool, or a new subchannel pool.
	 * @param global
	 */
	function getSubchannelPool(global) {
	    if (global) {
	        return globalSubchannelPool;
	    }
	    else {
	        return new SubchannelPool();
	    }
	}
	subchannelPool.getSubchannelPool = getSubchannelPool;
	
	return subchannelPool;
}

var filterStack = {};

var hasRequiredFilterStack;

function requireFilterStack () {
	if (hasRequiredFilterStack) return filterStack;
	hasRequiredFilterStack = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(filterStack, "__esModule", { value: true });
	filterStack.FilterStackFactory = filterStack.FilterStack = undefined;
	class FilterStack {
	    constructor(filters) {
	        this.filters = filters;
	    }
	    sendMetadata(metadata) {
	        let result = metadata;
	        for (let i = 0; i < this.filters.length; i++) {
	            result = this.filters[i].sendMetadata(result);
	        }
	        return result;
	    }
	    receiveMetadata(metadata) {
	        let result = metadata;
	        for (let i = this.filters.length - 1; i >= 0; i--) {
	            result = this.filters[i].receiveMetadata(result);
	        }
	        return result;
	    }
	    sendMessage(message) {
	        let result = message;
	        for (let i = 0; i < this.filters.length; i++) {
	            result = this.filters[i].sendMessage(result);
	        }
	        return result;
	    }
	    receiveMessage(message) {
	        let result = message;
	        for (let i = this.filters.length - 1; i >= 0; i--) {
	            result = this.filters[i].receiveMessage(result);
	        }
	        return result;
	    }
	    receiveTrailers(status) {
	        let result = status;
	        for (let i = this.filters.length - 1; i >= 0; i--) {
	            result = this.filters[i].receiveTrailers(result);
	        }
	        return result;
	    }
	    push(filters) {
	        this.filters.unshift(...filters);
	    }
	    getFilters() {
	        return this.filters;
	    }
	}
	filterStack.FilterStack = FilterStack;
	class FilterStackFactory {
	    constructor(factories) {
	        this.factories = factories;
	    }
	    push(filterFactories) {
	        this.factories.unshift(...filterFactories);
	    }
	    clone() {
	        return new FilterStackFactory([...this.factories]);
	    }
	    createFilter() {
	        return new FilterStack(this.factories.map(factory => factory.createFilter()));
	    }
	}
	filterStack.FilterStackFactory = FilterStackFactory;
	
	return filterStack;
}

var compressionFilter = {};

var compressionAlgorithms = {};

var hasRequiredCompressionAlgorithms;

function requireCompressionAlgorithms () {
	if (hasRequiredCompressionAlgorithms) return compressionAlgorithms;
	hasRequiredCompressionAlgorithms = 1;
	/*
	 * Copyright 2021 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(compressionAlgorithms, "__esModule", { value: true });
	compressionAlgorithms.CompressionAlgorithms = undefined;
	var CompressionAlgorithms;
	(function (CompressionAlgorithms) {
	    CompressionAlgorithms[CompressionAlgorithms["identity"] = 0] = "identity";
	    CompressionAlgorithms[CompressionAlgorithms["deflate"] = 1] = "deflate";
	    CompressionAlgorithms[CompressionAlgorithms["gzip"] = 2] = "gzip";
	})(CompressionAlgorithms || (compressionAlgorithms.CompressionAlgorithms = CompressionAlgorithms = {}));
	
	return compressionAlgorithms;
}

var filter = {};

var hasRequiredFilter;

function requireFilter () {
	if (hasRequiredFilter) return filter;
	hasRequiredFilter = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(filter, "__esModule", { value: true });
	filter.BaseFilter = undefined;
	class BaseFilter {
	    async sendMetadata(metadata) {
	        return metadata;
	    }
	    receiveMetadata(metadata) {
	        return metadata;
	    }
	    async sendMessage(message) {
	        return message;
	    }
	    async receiveMessage(message) {
	        return message;
	    }
	    receiveTrailers(status) {
	        return status;
	    }
	}
	filter.BaseFilter = BaseFilter;
	
	return filter;
}

var hasRequiredCompressionFilter;

function requireCompressionFilter () {
	if (hasRequiredCompressionFilter) return compressionFilter;
	hasRequiredCompressionFilter = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(compressionFilter, "__esModule", { value: true });
	compressionFilter.CompressionFilterFactory = compressionFilter.CompressionFilter = undefined;
	const zlib = require$$0$6;
	const compression_algorithms_1 = requireCompressionAlgorithms();
	const constants_1 = requireConstants();
	const filter_1 = requireFilter();
	const logging = requireLogging();
	const isCompressionAlgorithmKey = (key) => {
	    return (typeof key === 'number' && typeof compression_algorithms_1.CompressionAlgorithms[key] === 'string');
	};
	class CompressionHandler {
	    /**
	     * @param message Raw uncompressed message bytes
	     * @param compress Indicates whether the message should be compressed
	     * @return Framed message, compressed if applicable
	     */
	    async writeMessage(message, compress) {
	        let messageBuffer = message;
	        if (compress) {
	            messageBuffer = await this.compressMessage(messageBuffer);
	        }
	        const output = Buffer.allocUnsafe(messageBuffer.length + 5);
	        output.writeUInt8(compress ? 1 : 0, 0);
	        output.writeUInt32BE(messageBuffer.length, 1);
	        messageBuffer.copy(output, 5);
	        return output;
	    }
	    /**
	     * @param data Framed message, possibly compressed
	     * @return Uncompressed message
	     */
	    async readMessage(data) {
	        const compressed = data.readUInt8(0) === 1;
	        let messageBuffer = data.slice(5);
	        if (compressed) {
	            messageBuffer = await this.decompressMessage(messageBuffer);
	        }
	        return messageBuffer;
	    }
	}
	class IdentityHandler extends CompressionHandler {
	    async compressMessage(message) {
	        return message;
	    }
	    async writeMessage(message, compress) {
	        const output = Buffer.allocUnsafe(message.length + 5);
	        /* With "identity" compression, messages should always be marked as
	         * uncompressed */
	        output.writeUInt8(0, 0);
	        output.writeUInt32BE(message.length, 1);
	        message.copy(output, 5);
	        return output;
	    }
	    decompressMessage(message) {
	        return Promise.reject(new Error('Received compressed message but "grpc-encoding" header was identity'));
	    }
	}
	class DeflateHandler extends CompressionHandler {
	    constructor(maxRecvMessageLength) {
	        super();
	        this.maxRecvMessageLength = maxRecvMessageLength;
	    }
	    compressMessage(message) {
	        return new Promise((resolve, reject) => {
	            zlib.deflate(message, (err, output) => {
	                if (err) {
	                    reject(err);
	                }
	                else {
	                    resolve(output);
	                }
	            });
	        });
	    }
	    decompressMessage(message) {
	        return new Promise((resolve, reject) => {
	            let totalLength = 0;
	            const messageParts = [];
	            const decompresser = zlib.createInflate();
	            decompresser.on('data', (chunk) => {
	                messageParts.push(chunk);
	                totalLength += chunk.byteLength;
	                if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {
	                    decompresser.destroy();
	                    reject({
	                        code: constants_1.Status.RESOURCE_EXHAUSTED,
	                        details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`
	                    });
	                }
	            });
	            decompresser.on('end', () => {
	                resolve(Buffer.concat(messageParts));
	            });
	            decompresser.write(message);
	            decompresser.end();
	        });
	    }
	}
	class GzipHandler extends CompressionHandler {
	    constructor(maxRecvMessageLength) {
	        super();
	        this.maxRecvMessageLength = maxRecvMessageLength;
	    }
	    compressMessage(message) {
	        return new Promise((resolve, reject) => {
	            zlib.gzip(message, (err, output) => {
	                if (err) {
	                    reject(err);
	                }
	                else {
	                    resolve(output);
	                }
	            });
	        });
	    }
	    decompressMessage(message) {
	        return new Promise((resolve, reject) => {
	            let totalLength = 0;
	            const messageParts = [];
	            const decompresser = zlib.createGunzip();
	            decompresser.on('data', (chunk) => {
	                messageParts.push(chunk);
	                totalLength += chunk.byteLength;
	                if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {
	                    decompresser.destroy();
	                    reject({
	                        code: constants_1.Status.RESOURCE_EXHAUSTED,
	                        details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`
	                    });
	                }
	            });
	            decompresser.on('end', () => {
	                resolve(Buffer.concat(messageParts));
	            });
	            decompresser.write(message);
	            decompresser.end();
	        });
	    }
	}
	class UnknownHandler extends CompressionHandler {
	    constructor(compressionName) {
	        super();
	        this.compressionName = compressionName;
	    }
	    compressMessage(message) {
	        return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));
	    }
	    decompressMessage(message) {
	        // This should be unreachable
	        return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));
	    }
	}
	function getCompressionHandler(compressionName, maxReceiveMessageSize) {
	    switch (compressionName) {
	        case 'identity':
	            return new IdentityHandler();
	        case 'deflate':
	            return new DeflateHandler(maxReceiveMessageSize);
	        case 'gzip':
	            return new GzipHandler(maxReceiveMessageSize);
	        default:
	            return new UnknownHandler(compressionName);
	    }
	}
	class CompressionFilter extends filter_1.BaseFilter {
	    constructor(channelOptions, sharedFilterConfig) {
	        var _a, _b, _c;
	        super();
	        this.sharedFilterConfig = sharedFilterConfig;
	        this.sendCompression = new IdentityHandler();
	        this.receiveCompression = new IdentityHandler();
	        this.currentCompressionAlgorithm = 'identity';
	        const compressionAlgorithmKey = channelOptions['grpc.default_compression_algorithm'];
	        this.maxReceiveMessageLength = (_a = channelOptions['grpc.max_receive_message_length']) !== null && _a !== undefined ? _a : constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
	        this.maxSendMessageLength = (_b = channelOptions['grpc.max_send_message_length']) !== null && _b !== undefined ? _b : constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;
	        if (compressionAlgorithmKey !== undefined) {
	            if (isCompressionAlgorithmKey(compressionAlgorithmKey)) {
	                const clientSelectedEncoding = compression_algorithms_1.CompressionAlgorithms[compressionAlgorithmKey];
	                const serverSupportedEncodings = (_c = sharedFilterConfig.serverSupportedEncodingHeader) === null || _c === undefined ? undefined : _c.split(',');
	                /**
	                 * There are two possible situations here:
	                 * 1) We don't have any info yet from the server about what compression it supports
	                 *    In that case we should just use what the client tells us to use
	                 * 2) We've previously received a response from the server including a grpc-accept-encoding header
	                 *    In that case we only want to use the encoding chosen by the client if the server supports it
	                 */
	                if (!serverSupportedEncodings ||
	                    serverSupportedEncodings.includes(clientSelectedEncoding)) {
	                    this.currentCompressionAlgorithm = clientSelectedEncoding;
	                    this.sendCompression = getCompressionHandler(this.currentCompressionAlgorithm, -1);
	                }
	            }
	            else {
	                logging.log(constants_1.LogVerbosity.ERROR, `Invalid value provided for grpc.default_compression_algorithm option: ${compressionAlgorithmKey}`);
	            }
	        }
	    }
	    async sendMetadata(metadata) {
	        const headers = await metadata;
	        headers.set('grpc-accept-encoding', 'identity,deflate,gzip');
	        headers.set('accept-encoding', 'identity');
	        // No need to send the header if it's "identity" -  behavior is identical; save the bandwidth
	        if (this.currentCompressionAlgorithm === 'identity') {
	            headers.remove('grpc-encoding');
	        }
	        else {
	            headers.set('grpc-encoding', this.currentCompressionAlgorithm);
	        }
	        return headers;
	    }
	    receiveMetadata(metadata) {
	        const receiveEncoding = metadata.get('grpc-encoding');
	        if (receiveEncoding.length > 0) {
	            const encoding = receiveEncoding[0];
	            if (typeof encoding === 'string') {
	                this.receiveCompression = getCompressionHandler(encoding, this.maxReceiveMessageLength);
	            }
	        }
	        metadata.remove('grpc-encoding');
	        /* Check to see if the compression we're using to send messages is supported by the server
	         * If not, reset the sendCompression filter and have it use the default IdentityHandler */
	        const serverSupportedEncodingsHeader = metadata.get('grpc-accept-encoding')[0];
	        if (serverSupportedEncodingsHeader) {
	            this.sharedFilterConfig.serverSupportedEncodingHeader =
	                serverSupportedEncodingsHeader;
	            const serverSupportedEncodings = serverSupportedEncodingsHeader.split(',');
	            if (!serverSupportedEncodings.includes(this.currentCompressionAlgorithm)) {
	                this.sendCompression = new IdentityHandler();
	                this.currentCompressionAlgorithm = 'identity';
	            }
	        }
	        metadata.remove('grpc-accept-encoding');
	        return metadata;
	    }
	    async sendMessage(message) {
	        var _a;
	        /* This filter is special. The input message is the bare message bytes,
	         * and the output is a framed and possibly compressed message. For this
	         * reason, this filter should be at the bottom of the filter stack */
	        const resolvedMessage = await message;
	        if (this.maxSendMessageLength !== -1 && resolvedMessage.message.length > this.maxSendMessageLength) {
	            throw {
	                code: constants_1.Status.RESOURCE_EXHAUSTED,
	                details: `Attempted to send message with a size larger than ${this.maxSendMessageLength}`
	            };
	        }
	        let compress;
	        if (this.sendCompression instanceof IdentityHandler) {
	            compress = false;
	        }
	        else {
	            compress = (((_a = resolvedMessage.flags) !== null && _a !== undefined ? _a : 0) & 2 /* WriteFlags.NoCompress */) === 0;
	        }
	        return {
	            message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),
	            flags: resolvedMessage.flags,
	        };
	    }
	    async receiveMessage(message) {
	        /* This filter is also special. The input message is framed and possibly
	         * compressed, and the output message is deframed and uncompressed. So
	         * this is another reason that this filter should be at the bottom of the
	         * filter stack. */
	        return this.receiveCompression.readMessage(await message);
	    }
	}
	compressionFilter.CompressionFilter = CompressionFilter;
	class CompressionFilterFactory {
	    constructor(channel, options) {
	        this.options = options;
	        this.sharedFilterConfig = {};
	    }
	    createFilter() {
	        return new CompressionFilter(this.options, this.sharedFilterConfig);
	    }
	}
	compressionFilter.CompressionFilterFactory = CompressionFilterFactory;
	
	return compressionFilter;
}

var loadBalancingCall = {};

var deadline = {};

var hasRequiredDeadline;

function requireDeadline () {
	if (hasRequiredDeadline) return deadline;
	hasRequiredDeadline = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(deadline, "__esModule", { value: true });
	deadline.formatDateDifference = deadline.deadlineToString = deadline.getRelativeTimeout = deadline.getDeadlineTimeoutString = deadline.minDeadline = undefined;
	function minDeadline(...deadlineList) {
	    let minValue = Infinity;
	    for (const deadline of deadlineList) {
	        const deadlineMsecs = deadline instanceof Date ? deadline.getTime() : deadline;
	        if (deadlineMsecs < minValue) {
	            minValue = deadlineMsecs;
	        }
	    }
	    return minValue;
	}
	deadline.minDeadline = minDeadline;
	const units = [
	    ['m', 1],
	    ['S', 1000],
	    ['M', 60 * 1000],
	    ['H', 60 * 60 * 1000],
	];
	function getDeadlineTimeoutString(deadline) {
	    const now = new Date().getTime();
	    if (deadline instanceof Date) {
	        deadline = deadline.getTime();
	    }
	    const timeoutMs = Math.max(deadline - now, 0);
	    for (const [unit, factor] of units) {
	        const amount = timeoutMs / factor;
	        if (amount < 1e8) {
	            return String(Math.ceil(amount)) + unit;
	        }
	    }
	    throw new Error('Deadline is too far in the future');
	}
	deadline.getDeadlineTimeoutString = getDeadlineTimeoutString;
	/**
	 * See https://nodejs.org/api/timers.html#settimeoutcallback-delay-args
	 * In particular, "When delay is larger than 2147483647 or less than 1, the
	 * delay will be set to 1. Non-integer delays are truncated to an integer."
	 * This number of milliseconds is almost 25 days.
	 */
	const MAX_TIMEOUT_TIME = 2147483647;
	/**
	 * Get the timeout value that should be passed to setTimeout now for the timer
	 * to end at the deadline. For any deadline before now, the timer should end
	 * immediately, represented by a value of 0. For any deadline more than
	 * MAX_TIMEOUT_TIME milliseconds in the future, a timer cannot be set that will
	 * end at that time, so it is treated as infinitely far in the future.
	 * @param deadline
	 * @returns
	 */
	function getRelativeTimeout(deadline) {
	    const deadlineMs = deadline instanceof Date ? deadline.getTime() : deadline;
	    const now = new Date().getTime();
	    const timeout = deadlineMs - now;
	    if (timeout < 0) {
	        return 0;
	    }
	    else if (timeout > MAX_TIMEOUT_TIME) {
	        return Infinity;
	    }
	    else {
	        return timeout;
	    }
	}
	deadline.getRelativeTimeout = getRelativeTimeout;
	function deadlineToString(deadline) {
	    if (deadline instanceof Date) {
	        return deadline.toISOString();
	    }
	    else {
	        const dateDeadline = new Date(deadline);
	        if (Number.isNaN(dateDeadline.getTime())) {
	            return '' + deadline;
	        }
	        else {
	            return dateDeadline.toISOString();
	        }
	    }
	}
	deadline.deadlineToString = deadlineToString;
	/**
	 * Calculate the difference between two dates as a number of seconds and format
	 * it as a string.
	 * @param startDate
	 * @param endDate
	 * @returns
	 */
	function formatDateDifference(startDate, endDate) {
	    return ((endDate.getTime() - startDate.getTime()) / 1000).toFixed(3) + 's';
	}
	deadline.formatDateDifference = formatDateDifference;
	
	return deadline;
}

var controlPlaneStatus = {};

var hasRequiredControlPlaneStatus;

function requireControlPlaneStatus () {
	if (hasRequiredControlPlaneStatus) return controlPlaneStatus;
	hasRequiredControlPlaneStatus = 1;
	/*
	 * Copyright 2022 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(controlPlaneStatus, "__esModule", { value: true });
	controlPlaneStatus.restrictControlPlaneStatusCode = undefined;
	const constants_1 = requireConstants();
	const INAPPROPRIATE_CONTROL_PLANE_CODES = [
	    constants_1.Status.OK,
	    constants_1.Status.INVALID_ARGUMENT,
	    constants_1.Status.NOT_FOUND,
	    constants_1.Status.ALREADY_EXISTS,
	    constants_1.Status.FAILED_PRECONDITION,
	    constants_1.Status.ABORTED,
	    constants_1.Status.OUT_OF_RANGE,
	    constants_1.Status.DATA_LOSS,
	];
	function restrictControlPlaneStatusCode(code, details) {
	    if (INAPPROPRIATE_CONTROL_PLANE_CODES.includes(code)) {
	        return {
	            code: constants_1.Status.INTERNAL,
	            details: `Invalid status from control plane: ${code} ${constants_1.Status[code]} ${details}`,
	        };
	    }
	    else {
	        return { code, details };
	    }
	}
	controlPlaneStatus.restrictControlPlaneStatusCode = restrictControlPlaneStatusCode;
	
	return controlPlaneStatus;
}

var hasRequiredLoadBalancingCall;

function requireLoadBalancingCall () {
	if (hasRequiredLoadBalancingCall) return loadBalancingCall;
	hasRequiredLoadBalancingCall = 1;
	/*
	 * Copyright 2022 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(loadBalancingCall, "__esModule", { value: true });
	loadBalancingCall.LoadBalancingCall = undefined;
	const connectivity_state_1 = requireConnectivityState();
	const constants_1 = requireConstants();
	const deadline_1 = requireDeadline();
	const metadata_1 = requireMetadata();
	const picker_1 = requirePicker();
	const uri_parser_1 = requireUriParser();
	const logging = requireLogging();
	const control_plane_status_1 = requireControlPlaneStatus();
	const http2 = require$$0$5;
	const TRACER_NAME = 'load_balancing_call';
	class LoadBalancingCall {
	    constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber) {
	        var _a, _b;
	        this.channel = channel;
	        this.callConfig = callConfig;
	        this.methodName = methodName;
	        this.host = host;
	        this.credentials = credentials;
	        this.deadline = deadline;
	        this.callNumber = callNumber;
	        this.child = null;
	        this.readPending = false;
	        this.pendingMessage = null;
	        this.pendingHalfClose = false;
	        this.ended = false;
	        this.metadata = null;
	        this.listener = null;
	        this.onCallEnded = null;
	        this.childStartTime = null;
	        const splitPath = this.methodName.split('/');
	        let serviceName = '';
	        /* The standard path format is "/{serviceName}/{methodName}", so if we split
	         * by '/', the first item should be empty and the second should be the
	         * service name */
	        if (splitPath.length >= 2) {
	            serviceName = splitPath[1];
	        }
	        const hostname = (_b = (_a = (0, uri_parser_1.splitHostPort)(this.host)) === null || _a === undefined ? undefined : _a.host) !== null && _b !== undefined ? _b : 'localhost';
	        /* Currently, call credentials are only allowed on HTTPS connections, so we
	         * can assume that the scheme is "https" */
	        this.serviceUrl = `https://${hostname}/${serviceName}`;
	        this.startTime = new Date();
	    }
	    getDeadlineInfo() {
	        var _a, _b;
	        const deadlineInfo = [];
	        if (this.childStartTime) {
	            if (this.childStartTime > this.startTime) {
	                if ((_a = this.metadata) === null || _a === undefined ? undefined : _a.getOptions().waitForReady) {
	                    deadlineInfo.push('wait_for_ready');
	                }
	                deadlineInfo.push(`LB pick: ${(0, deadline_1.formatDateDifference)(this.startTime, this.childStartTime)}`);
	            }
	            deadlineInfo.push(...this.child.getDeadlineInfo());
	            return deadlineInfo;
	        }
	        else {
	            if ((_b = this.metadata) === null || _b === undefined ? undefined : _b.getOptions().waitForReady) {
	                deadlineInfo.push('wait_for_ready');
	            }
	            deadlineInfo.push('Waiting for LB pick');
	        }
	        return deadlineInfo;
	    }
	    trace(text) {
	        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);
	    }
	    outputStatus(status, progress) {
	        var _a, _b;
	        if (!this.ended) {
	            this.ended = true;
	            this.trace('ended with status: code=' +
	                status.code +
	                ' details="' +
	                status.details +
	                '" start time=' +
	                this.startTime.toISOString());
	            const finalStatus = Object.assign(Object.assign({}, status), { progress });
	            (_a = this.listener) === null || _a === undefined ? undefined : _a.onReceiveStatus(finalStatus);
	            (_b = this.onCallEnded) === null || _b === undefined ? undefined : _b.call(this, finalStatus.code);
	        }
	    }
	    doPick() {
	        var _a, _b;
	        if (this.ended) {
	            return;
	        }
	        if (!this.metadata) {
	            throw new Error('doPick called before start');
	        }
	        this.trace('Pick called');
	        const finalMetadata = this.metadata.clone();
	        const pickResult = this.channel.doPick(finalMetadata, this.callConfig.pickInformation);
	        const subchannelString = pickResult.subchannel
	            ? '(' +
	                pickResult.subchannel.getChannelzRef().id +
	                ') ' +
	                pickResult.subchannel.getAddress()
	            : '' + pickResult.subchannel;
	        this.trace('Pick result: ' +
	            picker_1.PickResultType[pickResult.pickResultType] +
	            ' subchannel: ' +
	            subchannelString +
	            ' status: ' +
	            ((_a = pickResult.status) === null || _a === undefined ? undefined : _a.code) +
	            ' ' +
	            ((_b = pickResult.status) === null || _b === undefined ? undefined : _b.details));
	        switch (pickResult.pickResultType) {
	            case picker_1.PickResultType.COMPLETE:
	                this.credentials
	                    .generateMetadata({ method_name: this.methodName, service_url: this.serviceUrl })
	                    .then(credsMetadata => {
	                    var _a, _b, _c;
	                    /* If this call was cancelled (e.g. by the deadline) before
	                     * metadata generation finished, we shouldn't do anything with
	                     * it. */
	                    if (this.ended) {
	                        this.trace('Credentials metadata generation finished after call ended');
	                        return;
	                    }
	                    finalMetadata.merge(credsMetadata);
	                    if (finalMetadata.get('authorization').length > 1) {
	                        this.outputStatus({
	                            code: constants_1.Status.INTERNAL,
	                            details: '"authorization" metadata cannot have multiple values',
	                            metadata: new metadata_1.Metadata(),
	                        }, 'PROCESSED');
	                    }
	                    if (pickResult.subchannel.getConnectivityState() !==
	                        connectivity_state_1.ConnectivityState.READY) {
	                        this.trace('Picked subchannel ' +
	                            subchannelString +
	                            ' has state ' +
	                            connectivity_state_1.ConnectivityState[pickResult.subchannel.getConnectivityState()] +
	                            ' after getting credentials metadata. Retrying pick');
	                        this.doPick();
	                        return;
	                    }
	                    if (this.deadline !== Infinity) {
	                        finalMetadata.set('grpc-timeout', (0, deadline_1.getDeadlineTimeoutString)(this.deadline));
	                    }
	                    try {
	                        this.child = pickResult
	                            .subchannel.getRealSubchannel()
	                            .createCall(finalMetadata, this.host, this.methodName, {
	                            onReceiveMetadata: metadata => {
	                                this.trace('Received metadata');
	                                this.listener.onReceiveMetadata(metadata);
	                            },
	                            onReceiveMessage: message => {
	                                this.trace('Received message');
	                                this.listener.onReceiveMessage(message);
	                            },
	                            onReceiveStatus: status => {
	                                this.trace('Received status');
	                                if (status.rstCode ===
	                                    http2.constants.NGHTTP2_REFUSED_STREAM) {
	                                    this.outputStatus(status, 'REFUSED');
	                                }
	                                else {
	                                    this.outputStatus(status, 'PROCESSED');
	                                }
	                            },
	                        });
	                        this.childStartTime = new Date();
	                    }
	                    catch (error) {
	                        this.trace('Failed to start call on picked subchannel ' +
	                            subchannelString +
	                            ' with error ' +
	                            error.message);
	                        this.outputStatus({
	                            code: constants_1.Status.INTERNAL,
	                            details: 'Failed to start HTTP/2 stream with error ' +
	                                error.message,
	                            metadata: new metadata_1.Metadata(),
	                        }, 'NOT_STARTED');
	                        return;
	                    }
	                    (_b = (_a = this.callConfig).onCommitted) === null || _b === undefined ? undefined : _b.call(_a);
	                    (_c = pickResult.onCallStarted) === null || _c === undefined ? undefined : _c.call(pickResult);
	                    this.onCallEnded = pickResult.onCallEnded;
	                    this.trace('Created child call [' + this.child.getCallNumber() + ']');
	                    if (this.readPending) {
	                        this.child.startRead();
	                    }
	                    if (this.pendingMessage) {
	                        this.child.sendMessageWithContext(this.pendingMessage.context, this.pendingMessage.message);
	                    }
	                    if (this.pendingHalfClose) {
	                        this.child.halfClose();
	                    }
	                }, (error) => {
	                    // We assume the error code isn't 0 (Status.OK)
	                    const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(typeof error.code === 'number' ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);
	                    this.outputStatus({
	                        code: code,
	                        details: details,
	                        metadata: new metadata_1.Metadata(),
	                    }, 'PROCESSED');
	                });
	                break;
	            case picker_1.PickResultType.DROP:
	                const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);
	                setImmediate(() => {
	                    this.outputStatus({ code, details, metadata: pickResult.status.metadata }, 'DROP');
	                });
	                break;
	            case picker_1.PickResultType.TRANSIENT_FAILURE:
	                if (this.metadata.getOptions().waitForReady) {
	                    this.channel.queueCallForPick(this);
	                }
	                else {
	                    const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);
	                    setImmediate(() => {
	                        this.outputStatus({ code, details, metadata: pickResult.status.metadata }, 'PROCESSED');
	                    });
	                }
	                break;
	            case picker_1.PickResultType.QUEUE:
	                this.channel.queueCallForPick(this);
	        }
	    }
	    cancelWithStatus(status, details) {
	        var _a;
	        this.trace('cancelWithStatus code: ' + status + ' details: "' + details + '"');
	        (_a = this.child) === null || _a === undefined ? undefined : _a.cancelWithStatus(status, details);
	        this.outputStatus({ code: status, details: details, metadata: new metadata_1.Metadata() }, 'PROCESSED');
	    }
	    getPeer() {
	        var _a, _b;
	        return (_b = (_a = this.child) === null || _a === undefined ? undefined : _a.getPeer()) !== null && _b !== undefined ? _b : this.channel.getTarget();
	    }
	    start(metadata, listener) {
	        this.trace('start called');
	        this.listener = listener;
	        this.metadata = metadata;
	        this.doPick();
	    }
	    sendMessageWithContext(context, message) {
	        this.trace('write() called with message of length ' + message.length);
	        if (this.child) {
	            this.child.sendMessageWithContext(context, message);
	        }
	        else {
	            this.pendingMessage = { context, message };
	        }
	    }
	    startRead() {
	        this.trace('startRead called');
	        if (this.child) {
	            this.child.startRead();
	        }
	        else {
	            this.readPending = true;
	        }
	    }
	    halfClose() {
	        this.trace('halfClose called');
	        if (this.child) {
	            this.child.halfClose();
	        }
	        else {
	            this.pendingHalfClose = true;
	        }
	    }
	    setCredentials(credentials) {
	        throw new Error('Method not implemented.');
	    }
	    getCallNumber() {
	        return this.callNumber;
	    }
	}
	loadBalancingCall.LoadBalancingCall = LoadBalancingCall;
	
	return loadBalancingCall;
}

var resolvingCall = {};

var hasRequiredResolvingCall;

function requireResolvingCall () {
	if (hasRequiredResolvingCall) return resolvingCall;
	hasRequiredResolvingCall = 1;
	/*
	 * Copyright 2022 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(resolvingCall, "__esModule", { value: true });
	resolvingCall.ResolvingCall = undefined;
	const constants_1 = requireConstants();
	const deadline_1 = requireDeadline();
	const metadata_1 = requireMetadata();
	const logging = requireLogging();
	const control_plane_status_1 = requireControlPlaneStatus();
	const TRACER_NAME = 'resolving_call';
	class ResolvingCall {
	    constructor(channel, method, options, filterStackFactory, credentials, callNumber) {
	        this.channel = channel;
	        this.method = method;
	        this.filterStackFactory = filterStackFactory;
	        this.credentials = credentials;
	        this.callNumber = callNumber;
	        this.child = null;
	        this.readPending = false;
	        this.pendingMessage = null;
	        this.pendingHalfClose = false;
	        this.ended = false;
	        this.readFilterPending = false;
	        this.writeFilterPending = false;
	        this.pendingChildStatus = null;
	        this.metadata = null;
	        this.listener = null;
	        this.statusWatchers = [];
	        this.deadlineTimer = setTimeout(() => { }, 0);
	        this.filterStack = null;
	        this.deadlineStartTime = null;
	        this.configReceivedTime = null;
	        this.childStartTime = null;
	        this.deadline = options.deadline;
	        this.host = options.host;
	        if (options.parentCall) {
	            if (options.flags & constants_1.Propagate.CANCELLATION) {
	                options.parentCall.on('cancelled', () => {
	                    this.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled by parent call');
	                });
	            }
	            if (options.flags & constants_1.Propagate.DEADLINE) {
	                this.trace('Propagating deadline from parent: ' +
	                    options.parentCall.getDeadline());
	                this.deadline = (0, deadline_1.minDeadline)(this.deadline, options.parentCall.getDeadline());
	            }
	        }
	        this.trace('Created');
	        this.runDeadlineTimer();
	    }
	    trace(text) {
	        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);
	    }
	    runDeadlineTimer() {
	        clearTimeout(this.deadlineTimer);
	        this.deadlineStartTime = new Date();
	        this.trace('Deadline: ' + (0, deadline_1.deadlineToString)(this.deadline));
	        const timeout = (0, deadline_1.getRelativeTimeout)(this.deadline);
	        if (timeout !== Infinity) {
	            this.trace('Deadline will be reached in ' + timeout + 'ms');
	            const handleDeadline = () => {
	                if (!this.deadlineStartTime) {
	                    this.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, 'Deadline exceeded');
	                    return;
	                }
	                const deadlineInfo = [];
	                const deadlineEndTime = new Date();
	                deadlineInfo.push(`Deadline exceeded after ${(0, deadline_1.formatDateDifference)(this.deadlineStartTime, deadlineEndTime)}`);
	                if (this.configReceivedTime) {
	                    if (this.configReceivedTime > this.deadlineStartTime) {
	                        deadlineInfo.push(`name resolution: ${(0, deadline_1.formatDateDifference)(this.deadlineStartTime, this.configReceivedTime)}`);
	                    }
	                    if (this.childStartTime) {
	                        if (this.childStartTime > this.configReceivedTime) {
	                            deadlineInfo.push(`metadata filters: ${(0, deadline_1.formatDateDifference)(this.configReceivedTime, this.childStartTime)}`);
	                        }
	                    }
	                    else {
	                        deadlineInfo.push('waiting for metadata filters');
	                    }
	                }
	                else {
	                    deadlineInfo.push('waiting for name resolution');
	                }
	                if (this.child) {
	                    deadlineInfo.push(...this.child.getDeadlineInfo());
	                }
	                this.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, deadlineInfo.join(','));
	            };
	            if (timeout <= 0) {
	                process.nextTick(handleDeadline);
	            }
	            else {
	                this.deadlineTimer = setTimeout(handleDeadline, timeout);
	            }
	        }
	    }
	    outputStatus(status) {
	        if (!this.ended) {
	            this.ended = true;
	            if (!this.filterStack) {
	                this.filterStack = this.filterStackFactory.createFilter();
	            }
	            clearTimeout(this.deadlineTimer);
	            const filteredStatus = this.filterStack.receiveTrailers(status);
	            this.trace('ended with status: code=' +
	                filteredStatus.code +
	                ' details="' +
	                filteredStatus.details +
	                '"');
	            this.statusWatchers.forEach(watcher => watcher(filteredStatus));
	            process.nextTick(() => {
	                var _a;
	                (_a = this.listener) === null || _a === undefined ? undefined : _a.onReceiveStatus(filteredStatus);
	            });
	        }
	    }
	    sendMessageOnChild(context, message) {
	        if (!this.child) {
	            throw new Error('sendMessageonChild called with child not populated');
	        }
	        const child = this.child;
	        this.writeFilterPending = true;
	        this.filterStack.sendMessage(Promise.resolve({ message: message, flags: context.flags })).then(filteredMessage => {
	            this.writeFilterPending = false;
	            child.sendMessageWithContext(context, filteredMessage.message);
	            if (this.pendingHalfClose) {
	                child.halfClose();
	            }
	        }, (status) => {
	            this.cancelWithStatus(status.code, status.details);
	        });
	    }
	    getConfig() {
	        if (this.ended) {
	            return;
	        }
	        if (!this.metadata || !this.listener) {
	            throw new Error('getConfig called before start');
	        }
	        const configResult = this.channel.getConfig(this.method, this.metadata);
	        if (configResult.type === 'NONE') {
	            this.channel.queueCallForConfig(this);
	            return;
	        }
	        else if (configResult.type === 'ERROR') {
	            if (this.metadata.getOptions().waitForReady) {
	                this.channel.queueCallForConfig(this);
	            }
	            else {
	                this.outputStatus(configResult.error);
	            }
	            return;
	        }
	        // configResult.type === 'SUCCESS'
	        this.configReceivedTime = new Date();
	        const config = configResult.config;
	        if (config.status !== constants_1.Status.OK) {
	            const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(config.status, 'Failed to route call to method ' + this.method);
	            this.outputStatus({
	                code: code,
	                details: details,
	                metadata: new metadata_1.Metadata(),
	            });
	            return;
	        }
	        if (config.methodConfig.timeout) {
	            const configDeadline = new Date();
	            configDeadline.setSeconds(configDeadline.getSeconds() + config.methodConfig.timeout.seconds);
	            configDeadline.setMilliseconds(configDeadline.getMilliseconds() +
	                config.methodConfig.timeout.nanos / 1000000);
	            this.deadline = (0, deadline_1.minDeadline)(this.deadline, configDeadline);
	            this.runDeadlineTimer();
	        }
	        this.filterStackFactory.push(config.dynamicFilterFactories);
	        this.filterStack = this.filterStackFactory.createFilter();
	        this.filterStack.sendMetadata(Promise.resolve(this.metadata)).then(filteredMetadata => {
	            this.child = this.channel.createInnerCall(config, this.method, this.host, this.credentials, this.deadline);
	            this.trace('Created child [' + this.child.getCallNumber() + ']');
	            this.childStartTime = new Date();
	            this.child.start(filteredMetadata, {
	                onReceiveMetadata: metadata => {
	                    this.trace('Received metadata');
	                    this.listener.onReceiveMetadata(this.filterStack.receiveMetadata(metadata));
	                },
	                onReceiveMessage: message => {
	                    this.trace('Received message');
	                    this.readFilterPending = true;
	                    this.filterStack.receiveMessage(message).then(filteredMesssage => {
	                        this.trace('Finished filtering received message');
	                        this.readFilterPending = false;
	                        this.listener.onReceiveMessage(filteredMesssage);
	                        if (this.pendingChildStatus) {
	                            this.outputStatus(this.pendingChildStatus);
	                        }
	                    }, (status) => {
	                        this.cancelWithStatus(status.code, status.details);
	                    });
	                },
	                onReceiveStatus: status => {
	                    this.trace('Received status');
	                    if (this.readFilterPending) {
	                        this.pendingChildStatus = status;
	                    }
	                    else {
	                        this.outputStatus(status);
	                    }
	                },
	            });
	            if (this.readPending) {
	                this.child.startRead();
	            }
	            if (this.pendingMessage) {
	                this.sendMessageOnChild(this.pendingMessage.context, this.pendingMessage.message);
	            }
	            else if (this.pendingHalfClose) {
	                this.child.halfClose();
	            }
	        }, (status) => {
	            this.outputStatus(status);
	        });
	    }
	    reportResolverError(status) {
	        var _a;
	        if ((_a = this.metadata) === null || _a === undefined ? undefined : _a.getOptions().waitForReady) {
	            this.channel.queueCallForConfig(this);
	        }
	        else {
	            this.outputStatus(status);
	        }
	    }
	    cancelWithStatus(status, details) {
	        var _a;
	        this.trace('cancelWithStatus code: ' + status + ' details: "' + details + '"');
	        (_a = this.child) === null || _a === undefined ? undefined : _a.cancelWithStatus(status, details);
	        this.outputStatus({
	            code: status,
	            details: details,
	            metadata: new metadata_1.Metadata(),
	        });
	    }
	    getPeer() {
	        var _a, _b;
	        return (_b = (_a = this.child) === null || _a === undefined ? undefined : _a.getPeer()) !== null && _b !== undefined ? _b : this.channel.getTarget();
	    }
	    start(metadata, listener) {
	        this.trace('start called');
	        this.metadata = metadata.clone();
	        this.listener = listener;
	        this.getConfig();
	    }
	    sendMessageWithContext(context, message) {
	        this.trace('write() called with message of length ' + message.length);
	        if (this.child) {
	            this.sendMessageOnChild(context, message);
	        }
	        else {
	            this.pendingMessage = { context, message };
	        }
	    }
	    startRead() {
	        this.trace('startRead called');
	        if (this.child) {
	            this.child.startRead();
	        }
	        else {
	            this.readPending = true;
	        }
	    }
	    halfClose() {
	        this.trace('halfClose called');
	        if (this.child && !this.writeFilterPending) {
	            this.child.halfClose();
	        }
	        else {
	            this.pendingHalfClose = true;
	        }
	    }
	    setCredentials(credentials) {
	        this.credentials = this.credentials.compose(credentials);
	    }
	    addStatusWatcher(watcher) {
	        this.statusWatchers.push(watcher);
	    }
	    getCallNumber() {
	        return this.callNumber;
	    }
	}
	resolvingCall.ResolvingCall = ResolvingCall;
	
	return resolvingCall;
}

var retryingCall = {};

var hasRequiredRetryingCall;

function requireRetryingCall () {
	if (hasRequiredRetryingCall) return retryingCall;
	hasRequiredRetryingCall = 1;
	/*
	 * Copyright 2022 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(retryingCall, "__esModule", { value: true });
	retryingCall.RetryingCall = retryingCall.MessageBufferTracker = retryingCall.RetryThrottler = undefined;
	const constants_1 = requireConstants();
	const deadline_1 = requireDeadline();
	const metadata_1 = requireMetadata();
	const logging = requireLogging();
	const TRACER_NAME = 'retrying_call';
	class RetryThrottler {
	    constructor(maxTokens, tokenRatio, previousRetryThrottler) {
	        this.maxTokens = maxTokens;
	        this.tokenRatio = tokenRatio;
	        if (previousRetryThrottler) {
	            /* When carrying over tokens from a previous config, rescale them to the
	             * new max value */
	            this.tokens =
	                previousRetryThrottler.tokens *
	                    (maxTokens / previousRetryThrottler.maxTokens);
	        }
	        else {
	            this.tokens = maxTokens;
	        }
	    }
	    addCallSucceeded() {
	        this.tokens = Math.max(this.tokens + this.tokenRatio, this.maxTokens);
	    }
	    addCallFailed() {
	        this.tokens = Math.min(this.tokens - 1, 0);
	    }
	    canRetryCall() {
	        return this.tokens > this.maxTokens / 2;
	    }
	}
	retryingCall.RetryThrottler = RetryThrottler;
	class MessageBufferTracker {
	    constructor(totalLimit, limitPerCall) {
	        this.totalLimit = totalLimit;
	        this.limitPerCall = limitPerCall;
	        this.totalAllocated = 0;
	        this.allocatedPerCall = new Map();
	    }
	    allocate(size, callId) {
	        var _a;
	        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== undefined ? _a : 0;
	        if (this.limitPerCall - currentPerCall < size ||
	            this.totalLimit - this.totalAllocated < size) {
	            return false;
	        }
	        this.allocatedPerCall.set(callId, currentPerCall + size);
	        this.totalAllocated += size;
	        return true;
	    }
	    free(size, callId) {
	        var _a;
	        if (this.totalAllocated < size) {
	            throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > total allocated ${this.totalAllocated}`);
	        }
	        this.totalAllocated -= size;
	        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== undefined ? _a : 0;
	        if (currentPerCall < size) {
	            throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > allocated for call ${currentPerCall}`);
	        }
	        this.allocatedPerCall.set(callId, currentPerCall - size);
	    }
	    freeAll(callId) {
	        var _a;
	        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== undefined ? _a : 0;
	        if (this.totalAllocated < currentPerCall) {
	            throw new Error(`Invalid buffer allocation state: call ${callId} allocated ${currentPerCall} > total allocated ${this.totalAllocated}`);
	        }
	        this.totalAllocated -= currentPerCall;
	        this.allocatedPerCall.delete(callId);
	    }
	}
	retryingCall.MessageBufferTracker = MessageBufferTracker;
	const PREVIONS_RPC_ATTEMPTS_METADATA_KEY = 'grpc-previous-rpc-attempts';
	const DEFAULT_MAX_ATTEMPTS_LIMIT = 5;
	class RetryingCall {
	    constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber, bufferTracker, retryThrottler) {
	        var _a;
	        this.channel = channel;
	        this.callConfig = callConfig;
	        this.methodName = methodName;
	        this.host = host;
	        this.credentials = credentials;
	        this.deadline = deadline;
	        this.callNumber = callNumber;
	        this.bufferTracker = bufferTracker;
	        this.retryThrottler = retryThrottler;
	        this.listener = null;
	        this.initialMetadata = null;
	        this.underlyingCalls = [];
	        this.writeBuffer = [];
	        /**
	         * The offset of message indices in the writeBuffer. For example, if
	         * writeBufferOffset is 10, message 10 is in writeBuffer[0] and message 15
	         * is in writeBuffer[5].
	         */
	        this.writeBufferOffset = 0;
	        /**
	         * Tracks whether a read has been started, so that we know whether to start
	         * reads on new child calls. This only matters for the first read, because
	         * once a message comes in the child call becomes committed and there will
	         * be no new child calls.
	         */
	        this.readStarted = false;
	        this.transparentRetryUsed = false;
	        /**
	         * Number of attempts so far
	         */
	        this.attempts = 0;
	        this.hedgingTimer = null;
	        this.committedCallIndex = null;
	        this.initialRetryBackoffSec = 0;
	        this.nextRetryBackoffSec = 0;
	        const maxAttemptsLimit = (_a = channel.getOptions()['grpc-node.retry_max_attempts_limit']) !== null && _a !== undefined ? _a : DEFAULT_MAX_ATTEMPTS_LIMIT;
	        if (callConfig.methodConfig.retryPolicy) {
	            this.state = 'RETRY';
	            const retryPolicy = callConfig.methodConfig.retryPolicy;
	            this.nextRetryBackoffSec = this.initialRetryBackoffSec = Number(retryPolicy.initialBackoff.substring(0, retryPolicy.initialBackoff.length - 1));
	            this.maxAttempts = Math.min(retryPolicy.maxAttempts, maxAttemptsLimit);
	        }
	        else if (callConfig.methodConfig.hedgingPolicy) {
	            this.state = 'HEDGING';
	            this.maxAttempts = Math.min(callConfig.methodConfig.hedgingPolicy.maxAttempts, maxAttemptsLimit);
	        }
	        else {
	            this.state = 'TRANSPARENT_ONLY';
	            this.maxAttempts = 1;
	        }
	        this.startTime = new Date();
	    }
	    getDeadlineInfo() {
	        if (this.underlyingCalls.length === 0) {
	            return [];
	        }
	        const deadlineInfo = [];
	        const latestCall = this.underlyingCalls[this.underlyingCalls.length - 1];
	        if (this.underlyingCalls.length > 1) {
	            deadlineInfo.push(`previous attempts: ${this.underlyingCalls.length - 1}`);
	        }
	        if (latestCall.startTime > this.startTime) {
	            deadlineInfo.push(`time to current attempt start: ${(0, deadline_1.formatDateDifference)(this.startTime, latestCall.startTime)}`);
	        }
	        deadlineInfo.push(...latestCall.call.getDeadlineInfo());
	        return deadlineInfo;
	    }
	    getCallNumber() {
	        return this.callNumber;
	    }
	    trace(text) {
	        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);
	    }
	    reportStatus(statusObject) {
	        this.trace('ended with status: code=' +
	            statusObject.code +
	            ' details="' +
	            statusObject.details +
	            '" start time=' +
	            this.startTime.toISOString());
	        this.bufferTracker.freeAll(this.callNumber);
	        this.writeBufferOffset = this.writeBufferOffset + this.writeBuffer.length;
	        this.writeBuffer = [];
	        process.nextTick(() => {
	            var _a;
	            // Explicitly construct status object to remove progress field
	            (_a = this.listener) === null || _a === undefined ? undefined : _a.onReceiveStatus({
	                code: statusObject.code,
	                details: statusObject.details,
	                metadata: statusObject.metadata,
	            });
	        });
	    }
	    cancelWithStatus(status, details) {
	        this.trace('cancelWithStatus code: ' + status + ' details: "' + details + '"');
	        this.reportStatus({ code: status, details, metadata: new metadata_1.Metadata() });
	        for (const { call } of this.underlyingCalls) {
	            call.cancelWithStatus(status, details);
	        }
	    }
	    getPeer() {
	        if (this.committedCallIndex !== null) {
	            return this.underlyingCalls[this.committedCallIndex].call.getPeer();
	        }
	        else {
	            return 'unknown';
	        }
	    }
	    getBufferEntry(messageIndex) {
	        var _a;
	        return ((_a = this.writeBuffer[messageIndex - this.writeBufferOffset]) !== null && _a !== undefined ? _a : {
	            entryType: 'FREED',
	            allocated: false,
	        });
	    }
	    getNextBufferIndex() {
	        return this.writeBufferOffset + this.writeBuffer.length;
	    }
	    clearSentMessages() {
	        if (this.state !== 'COMMITTED') {
	            return;
	        }
	        const earliestNeededMessageIndex = this.underlyingCalls[this.committedCallIndex].nextMessageToSend;
	        for (let messageIndex = this.writeBufferOffset; messageIndex < earliestNeededMessageIndex; messageIndex++) {
	            const bufferEntry = this.getBufferEntry(messageIndex);
	            if (bufferEntry.allocated) {
	                this.bufferTracker.free(bufferEntry.message.message.length, this.callNumber);
	            }
	        }
	        this.writeBuffer = this.writeBuffer.slice(earliestNeededMessageIndex - this.writeBufferOffset);
	        this.writeBufferOffset = earliestNeededMessageIndex;
	    }
	    commitCall(index) {
	        if (this.state === 'COMMITTED') {
	            return;
	        }
	        if (this.underlyingCalls[index].state === 'COMPLETED') {
	            return;
	        }
	        this.trace('Committing call [' +
	            this.underlyingCalls[index].call.getCallNumber() +
	            '] at index ' +
	            index);
	        this.state = 'COMMITTED';
	        this.committedCallIndex = index;
	        for (let i = 0; i < this.underlyingCalls.length; i++) {
	            if (i === index) {
	                continue;
	            }
	            if (this.underlyingCalls[i].state === 'COMPLETED') {
	                continue;
	            }
	            this.underlyingCalls[i].state = 'COMPLETED';
	            this.underlyingCalls[i].call.cancelWithStatus(constants_1.Status.CANCELLED, 'Discarded in favor of other hedged attempt');
	        }
	        this.clearSentMessages();
	    }
	    commitCallWithMostMessages() {
	        if (this.state === 'COMMITTED') {
	            return;
	        }
	        let mostMessages = -1;
	        let callWithMostMessages = -1;
	        for (const [index, childCall] of this.underlyingCalls.entries()) {
	            if (childCall.state === 'ACTIVE' &&
	                childCall.nextMessageToSend > mostMessages) {
	                mostMessages = childCall.nextMessageToSend;
	                callWithMostMessages = index;
	            }
	        }
	        if (callWithMostMessages === -1) {
	            /* There are no active calls, disable retries to force the next call that
	             * is started to be committed. */
	            this.state = 'TRANSPARENT_ONLY';
	        }
	        else {
	            this.commitCall(callWithMostMessages);
	        }
	    }
	    isStatusCodeInList(list, code) {
	        return list.some(value => {
	            var _a;
	            return value === code ||
	                value.toString().toLowerCase() === ((_a = constants_1.Status[code]) === null || _a === undefined ? undefined : _a.toLowerCase());
	        });
	    }
	    getNextRetryBackoffMs() {
	        var _a;
	        const retryPolicy = (_a = this.callConfig) === null || _a === undefined ? undefined : _a.methodConfig.retryPolicy;
	        if (!retryPolicy) {
	            return 0;
	        }
	        const nextBackoffMs = Math.random() * this.nextRetryBackoffSec * 1000;
	        const maxBackoffSec = Number(retryPolicy.maxBackoff.substring(0, retryPolicy.maxBackoff.length - 1));
	        this.nextRetryBackoffSec = Math.min(this.nextRetryBackoffSec * retryPolicy.backoffMultiplier, maxBackoffSec);
	        return nextBackoffMs;
	    }
	    maybeRetryCall(pushback, callback) {
	        if (this.state !== 'RETRY') {
	            callback(false);
	            return;
	        }
	        if (this.attempts >= this.maxAttempts) {
	            callback(false);
	            return;
	        }
	        let retryDelayMs;
	        if (pushback === null) {
	            retryDelayMs = this.getNextRetryBackoffMs();
	        }
	        else if (pushback < 0) {
	            this.state = 'TRANSPARENT_ONLY';
	            callback(false);
	            return;
	        }
	        else {
	            retryDelayMs = pushback;
	            this.nextRetryBackoffSec = this.initialRetryBackoffSec;
	        }
	        setTimeout(() => {
	            var _a, _b;
	            if (this.state !== 'RETRY') {
	                callback(false);
	                return;
	            }
	            if ((_b = (_a = this.retryThrottler) === null || _a === undefined ? undefined : _a.canRetryCall()) !== null && _b !== undefined ? _b : true) {
	                callback(true);
	                this.attempts += 1;
	                this.startNewAttempt();
	            }
	        }, retryDelayMs);
	    }
	    countActiveCalls() {
	        let count = 0;
	        for (const call of this.underlyingCalls) {
	            if ((call === null || call === undefined ? undefined : call.state) === 'ACTIVE') {
	                count += 1;
	            }
	        }
	        return count;
	    }
	    handleProcessedStatus(status, callIndex, pushback) {
	        var _a, _b, _c;
	        switch (this.state) {
	            case 'COMMITTED':
	            case 'TRANSPARENT_ONLY':
	                this.commitCall(callIndex);
	                this.reportStatus(status);
	                break;
	            case 'HEDGING':
	                if (this.isStatusCodeInList((_a = this.callConfig.methodConfig.hedgingPolicy.nonFatalStatusCodes) !== null && _a !== undefined ? _a : [], status.code)) {
	                    (_b = this.retryThrottler) === null || _b === undefined ? undefined : _b.addCallFailed();
	                    let delayMs;
	                    if (pushback === null) {
	                        delayMs = 0;
	                    }
	                    else if (pushback < 0) {
	                        this.state = 'TRANSPARENT_ONLY';
	                        this.commitCall(callIndex);
	                        this.reportStatus(status);
	                        return;
	                    }
	                    else {
	                        delayMs = pushback;
	                    }
	                    setTimeout(() => {
	                        this.maybeStartHedgingAttempt();
	                        // If after trying to start a call there are no active calls, this was the last one
	                        if (this.countActiveCalls() === 0) {
	                            this.commitCall(callIndex);
	                            this.reportStatus(status);
	                        }
	                    }, delayMs);
	                }
	                else {
	                    this.commitCall(callIndex);
	                    this.reportStatus(status);
	                }
	                break;
	            case 'RETRY':
	                if (this.isStatusCodeInList(this.callConfig.methodConfig.retryPolicy.retryableStatusCodes, status.code)) {
	                    (_c = this.retryThrottler) === null || _c === undefined ? undefined : _c.addCallFailed();
	                    this.maybeRetryCall(pushback, retried => {
	                        if (!retried) {
	                            this.commitCall(callIndex);
	                            this.reportStatus(status);
	                        }
	                    });
	                }
	                else {
	                    this.commitCall(callIndex);
	                    this.reportStatus(status);
	                }
	                break;
	        }
	    }
	    getPushback(metadata) {
	        const mdValue = metadata.get('grpc-retry-pushback-ms');
	        if (mdValue.length === 0) {
	            return null;
	        }
	        try {
	            return parseInt(mdValue[0]);
	        }
	        catch (e) {
	            return -1;
	        }
	    }
	    handleChildStatus(status, callIndex) {
	        var _a;
	        if (this.underlyingCalls[callIndex].state === 'COMPLETED') {
	            return;
	        }
	        this.trace('state=' +
	            this.state +
	            ' handling status with progress ' +
	            status.progress +
	            ' from child [' +
	            this.underlyingCalls[callIndex].call.getCallNumber() +
	            '] in state ' +
	            this.underlyingCalls[callIndex].state);
	        this.underlyingCalls[callIndex].state = 'COMPLETED';
	        if (status.code === constants_1.Status.OK) {
	            (_a = this.retryThrottler) === null || _a === undefined ? undefined : _a.addCallSucceeded();
	            this.commitCall(callIndex);
	            this.reportStatus(status);
	            return;
	        }
	        if (this.state === 'COMMITTED') {
	            this.reportStatus(status);
	            return;
	        }
	        const pushback = this.getPushback(status.metadata);
	        switch (status.progress) {
	            case 'NOT_STARTED':
	                // RPC never leaves the client, always safe to retry
	                this.startNewAttempt();
	                break;
	            case 'REFUSED':
	                // RPC reaches the server library, but not the server application logic
	                if (this.transparentRetryUsed) {
	                    this.handleProcessedStatus(status, callIndex, pushback);
	                }
	                else {
	                    this.transparentRetryUsed = true;
	                    this.startNewAttempt();
	                }
	                break;
	            case 'DROP':
	                this.commitCall(callIndex);
	                this.reportStatus(status);
	                break;
	            case 'PROCESSED':
	                this.handleProcessedStatus(status, callIndex, pushback);
	                break;
	        }
	    }
	    maybeStartHedgingAttempt() {
	        if (this.state !== 'HEDGING') {
	            return;
	        }
	        if (!this.callConfig.methodConfig.hedgingPolicy) {
	            return;
	        }
	        if (this.attempts >= this.maxAttempts) {
	            return;
	        }
	        this.attempts += 1;
	        this.startNewAttempt();
	        this.maybeStartHedgingTimer();
	    }
	    maybeStartHedgingTimer() {
	        var _a, _b, _c;
	        if (this.hedgingTimer) {
	            clearTimeout(this.hedgingTimer);
	        }
	        if (this.state !== 'HEDGING') {
	            return;
	        }
	        if (!this.callConfig.methodConfig.hedgingPolicy) {
	            return;
	        }
	        const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;
	        if (this.attempts >= this.maxAttempts) {
	            return;
	        }
	        const hedgingDelayString = (_a = hedgingPolicy.hedgingDelay) !== null && _a !== undefined ? _a : '0s';
	        const hedgingDelaySec = Number(hedgingDelayString.substring(0, hedgingDelayString.length - 1));
	        this.hedgingTimer = setTimeout(() => {
	            this.maybeStartHedgingAttempt();
	        }, hedgingDelaySec * 1000);
	        (_c = (_b = this.hedgingTimer).unref) === null || _c === undefined ? undefined : _c.call(_b);
	    }
	    startNewAttempt() {
	        const child = this.channel.createLoadBalancingCall(this.callConfig, this.methodName, this.host, this.credentials, this.deadline);
	        this.trace('Created child call [' +
	            child.getCallNumber() +
	            '] for attempt ' +
	            this.attempts);
	        const index = this.underlyingCalls.length;
	        this.underlyingCalls.push({
	            state: 'ACTIVE',
	            call: child,
	            nextMessageToSend: 0,
	            startTime: new Date()
	        });
	        const previousAttempts = this.attempts - 1;
	        const initialMetadata = this.initialMetadata.clone();
	        if (previousAttempts > 0) {
	            initialMetadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);
	        }
	        let receivedMetadata = false;
	        child.start(initialMetadata, {
	            onReceiveMetadata: metadata => {
	                this.trace('Received metadata from child [' + child.getCallNumber() + ']');
	                this.commitCall(index);
	                receivedMetadata = true;
	                if (previousAttempts > 0) {
	                    metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);
	                }
	                if (this.underlyingCalls[index].state === 'ACTIVE') {
	                    this.listener.onReceiveMetadata(metadata);
	                }
	            },
	            onReceiveMessage: message => {
	                this.trace('Received message from child [' + child.getCallNumber() + ']');
	                this.commitCall(index);
	                if (this.underlyingCalls[index].state === 'ACTIVE') {
	                    this.listener.onReceiveMessage(message);
	                }
	            },
	            onReceiveStatus: status => {
	                this.trace('Received status from child [' + child.getCallNumber() + ']');
	                if (!receivedMetadata && previousAttempts > 0) {
	                    status.metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);
	                }
	                this.handleChildStatus(status, index);
	            },
	        });
	        this.sendNextChildMessage(index);
	        if (this.readStarted) {
	            child.startRead();
	        }
	    }
	    start(metadata, listener) {
	        this.trace('start called');
	        this.listener = listener;
	        this.initialMetadata = metadata;
	        this.attempts += 1;
	        this.startNewAttempt();
	        this.maybeStartHedgingTimer();
	    }
	    handleChildWriteCompleted(childIndex) {
	        var _a, _b;
	        const childCall = this.underlyingCalls[childIndex];
	        const messageIndex = childCall.nextMessageToSend;
	        (_b = (_a = this.getBufferEntry(messageIndex)).callback) === null || _b === undefined ? undefined : _b.call(_a);
	        this.clearSentMessages();
	        childCall.nextMessageToSend += 1;
	        this.sendNextChildMessage(childIndex);
	    }
	    sendNextChildMessage(childIndex) {
	        const childCall = this.underlyingCalls[childIndex];
	        if (childCall.state === 'COMPLETED') {
	            return;
	        }
	        if (this.getBufferEntry(childCall.nextMessageToSend)) {
	            const bufferEntry = this.getBufferEntry(childCall.nextMessageToSend);
	            switch (bufferEntry.entryType) {
	                case 'MESSAGE':
	                    childCall.call.sendMessageWithContext({
	                        callback: error => {
	                            // Ignore error
	                            this.handleChildWriteCompleted(childIndex);
	                        },
	                    }, bufferEntry.message.message);
	                    break;
	                case 'HALF_CLOSE':
	                    childCall.nextMessageToSend += 1;
	                    childCall.call.halfClose();
	                    break;
	            }
	        }
	    }
	    sendMessageWithContext(context, message) {
	        var _a;
	        this.trace('write() called with message of length ' + message.length);
	        const writeObj = {
	            message,
	            flags: context.flags,
	        };
	        const messageIndex = this.getNextBufferIndex();
	        const bufferEntry = {
	            entryType: 'MESSAGE',
	            message: writeObj,
	            allocated: this.bufferTracker.allocate(message.length, this.callNumber),
	        };
	        this.writeBuffer.push(bufferEntry);
	        if (bufferEntry.allocated) {
	            (_a = context.callback) === null || _a === undefined ? undefined : _a.call(context);
	            for (const [callIndex, call] of this.underlyingCalls.entries()) {
	                if (call.state === 'ACTIVE' &&
	                    call.nextMessageToSend === messageIndex) {
	                    call.call.sendMessageWithContext({
	                        callback: error => {
	                            // Ignore error
	                            this.handleChildWriteCompleted(callIndex);
	                        },
	                    }, message);
	                }
	            }
	        }
	        else {
	            this.commitCallWithMostMessages();
	            // commitCallWithMostMessages can fail if we are between ping attempts
	            if (this.committedCallIndex === null) {
	                return;
	            }
	            const call = this.underlyingCalls[this.committedCallIndex];
	            bufferEntry.callback = context.callback;
	            if (call.state === 'ACTIVE' && call.nextMessageToSend === messageIndex) {
	                call.call.sendMessageWithContext({
	                    callback: error => {
	                        // Ignore error
	                        this.handleChildWriteCompleted(this.committedCallIndex);
	                    },
	                }, message);
	            }
	        }
	    }
	    startRead() {
	        this.trace('startRead called');
	        this.readStarted = true;
	        for (const underlyingCall of this.underlyingCalls) {
	            if ((underlyingCall === null || underlyingCall === undefined ? undefined : underlyingCall.state) === 'ACTIVE') {
	                underlyingCall.call.startRead();
	            }
	        }
	    }
	    halfClose() {
	        this.trace('halfClose called');
	        const halfCloseIndex = this.getNextBufferIndex();
	        this.writeBuffer.push({
	            entryType: 'HALF_CLOSE',
	            allocated: false,
	        });
	        for (const call of this.underlyingCalls) {
	            if ((call === null || call === undefined ? undefined : call.state) === 'ACTIVE' &&
	                call.nextMessageToSend === halfCloseIndex) {
	                call.nextMessageToSend += 1;
	                call.call.halfClose();
	            }
	        }
	    }
	    setCredentials(newCredentials) {
	        throw new Error('Method not implemented.');
	    }
	    getMethod() {
	        return this.methodName;
	    }
	    getHost() {
	        return this.host;
	    }
	}
	retryingCall.RetryingCall = RetryingCall;
	
	return retryingCall;
}

var subchannelInterface = {};

var hasRequiredSubchannelInterface;

function requireSubchannelInterface () {
	if (hasRequiredSubchannelInterface) return subchannelInterface;
	hasRequiredSubchannelInterface = 1;
	/*
	 * Copyright 2022 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(subchannelInterface, "__esModule", { value: true });
	subchannelInterface.BaseSubchannelWrapper = undefined;
	class BaseSubchannelWrapper {
	    constructor(child) {
	        this.child = child;
	        this.healthy = true;
	        this.healthListeners = new Set();
	        child.addHealthStateWatcher(childHealthy => {
	            /* A change to the child health state only affects this wrapper's overall
	             * health state if this wrapper is reporting healthy. */
	            if (this.healthy) {
	                this.updateHealthListeners();
	            }
	        });
	    }
	    updateHealthListeners() {
	        for (const listener of this.healthListeners) {
	            listener(this.isHealthy());
	        }
	    }
	    getConnectivityState() {
	        return this.child.getConnectivityState();
	    }
	    addConnectivityStateListener(listener) {
	        this.child.addConnectivityStateListener(listener);
	    }
	    removeConnectivityStateListener(listener) {
	        this.child.removeConnectivityStateListener(listener);
	    }
	    startConnecting() {
	        this.child.startConnecting();
	    }
	    getAddress() {
	        return this.child.getAddress();
	    }
	    throttleKeepalive(newKeepaliveTime) {
	        this.child.throttleKeepalive(newKeepaliveTime);
	    }
	    ref() {
	        this.child.ref();
	    }
	    unref() {
	        this.child.unref();
	    }
	    getChannelzRef() {
	        return this.child.getChannelzRef();
	    }
	    isHealthy() {
	        return this.healthy && this.child.isHealthy();
	    }
	    addHealthStateWatcher(listener) {
	        this.healthListeners.add(listener);
	    }
	    removeHealthStateWatcher(listener) {
	        this.healthListeners.delete(listener);
	    }
	    setHealthy(healthy) {
	        if (healthy !== this.healthy) {
	            this.healthy = healthy;
	            /* A change to this wrapper's health state only affects the overall
	             * reported health state if the child is healthy. */
	            if (this.child.isHealthy()) {
	                this.updateHealthListeners();
	            }
	        }
	    }
	    getRealSubchannel() {
	        return this.child.getRealSubchannel();
	    }
	    realSubchannelEquals(other) {
	        return this.getRealSubchannel() === other.getRealSubchannel();
	    }
	}
	subchannelInterface.BaseSubchannelWrapper = BaseSubchannelWrapper;
	
	return subchannelInterface;
}

var hasRequiredInternalChannel;

function requireInternalChannel () {
	if (hasRequiredInternalChannel) return internalChannel;
	hasRequiredInternalChannel = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(internalChannel, "__esModule", { value: true });
	internalChannel.InternalChannel = undefined;
	const channel_credentials_1 = requireChannelCredentials();
	const resolving_load_balancer_1 = requireResolvingLoadBalancer();
	const subchannel_pool_1 = requireSubchannelPool();
	const picker_1 = requirePicker();
	const metadata_1 = requireMetadata();
	const constants_1 = requireConstants();
	const filter_stack_1 = requireFilterStack();
	const compression_filter_1 = requireCompressionFilter();
	const resolver_1 = requireResolver();
	const logging_1 = requireLogging();
	const http_proxy_1 = requireHttp_proxy();
	const uri_parser_1 = requireUriParser();
	const connectivity_state_1 = requireConnectivityState();
	const channelz_1 = requireChannelz();
	const load_balancing_call_1 = requireLoadBalancingCall();
	const deadline_1 = requireDeadline();
	const resolving_call_1 = requireResolvingCall();
	const call_number_1 = requireCallNumber();
	const control_plane_status_1 = requireControlPlaneStatus();
	const retrying_call_1 = requireRetryingCall();
	const subchannel_interface_1 = requireSubchannelInterface();
	/**
	 * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args
	 */
	const MAX_TIMEOUT_TIME = 2147483647;
	const MIN_IDLE_TIMEOUT_MS = 1000;
	// 30 minutes
	const DEFAULT_IDLE_TIMEOUT_MS = 30 * 60 * 1000;
	const RETRY_THROTTLER_MAP = new Map();
	const DEFAULT_RETRY_BUFFER_SIZE_BYTES = 1 << 24; // 16 MB
	const DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES = 1 << 20; // 1 MB
	class ChannelSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {
	    constructor(childSubchannel, channel) {
	        super(childSubchannel);
	        this.channel = channel;
	        this.refCount = 0;
	        this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime) => {
	            channel.throttleKeepalive(keepaliveTime);
	        };
	        childSubchannel.addConnectivityStateListener(this.subchannelStateListener);
	    }
	    ref() {
	        this.child.ref();
	        this.refCount += 1;
	    }
	    unref() {
	        this.child.unref();
	        this.refCount -= 1;
	        if (this.refCount <= 0) {
	            this.child.removeConnectivityStateListener(this.subchannelStateListener);
	            this.channel.removeWrappedSubchannel(this);
	        }
	    }
	}
	class ShutdownPicker {
	    pick(pickArgs) {
	        return {
	            pickResultType: picker_1.PickResultType.DROP,
	            status: {
	                code: constants_1.Status.UNAVAILABLE,
	                details: 'Channel closed before call started',
	                metadata: new metadata_1.Metadata()
	            },
	            subchannel: null,
	            onCallStarted: null,
	            onCallEnded: null
	        };
	    }
	}
	class InternalChannel {
	    constructor(target, credentials, options) {
	        var _a, _b, _c, _d, _e, _f, _g, _h;
	        this.credentials = credentials;
	        this.options = options;
	        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;
	        this.currentPicker = new picker_1.UnavailablePicker();
	        /**
	         * Calls queued up to get a call config. Should only be populated before the
	         * first time the resolver returns a result, which includes the ConfigSelector.
	         */
	        this.configSelectionQueue = [];
	        this.pickQueue = [];
	        this.connectivityStateWatchers = [];
	        this.configSelector = null;
	        /**
	         * This is the error from the name resolver if it failed most recently. It
	         * is only used to end calls that start while there is no config selector
	         * and the name resolver is in backoff, so it should be nulled if
	         * configSelector becomes set or the channel state becomes anything other
	         * than TRANSIENT_FAILURE.
	         */
	        this.currentResolutionError = null;
	        this.wrappedSubchannels = new Set();
	        this.callCount = 0;
	        this.idleTimer = null;
	        // Channelz info
	        this.channelzEnabled = true;
	        this.callTracker = new channelz_1.ChannelzCallTracker();
	        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();
	        /**
	         * Randomly generated ID to be passed to the config selector, for use by
	         * ring_hash in xDS. An integer distributed approximately uniformly between
	         * 0 and MAX_SAFE_INTEGER.
	         */
	        this.randomChannelId = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
	        if (typeof target !== 'string') {
	            throw new TypeError('Channel target must be a string');
	        }
	        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {
	            throw new TypeError('Channel credentials must be a ChannelCredentials object');
	        }
	        if (options) {
	            if (typeof options !== 'object') {
	                throw new TypeError('Channel options must be an object');
	            }
	        }
	        this.originalTarget = target;
	        const originalTargetUri = (0, uri_parser_1.parseUri)(target);
	        if (originalTargetUri === null) {
	            throw new Error(`Could not parse target name "${target}"`);
	        }
	        /* This ensures that the target has a scheme that is registered with the
	         * resolver */
	        const defaultSchemeMapResult = (0, resolver_1.mapUriDefaultScheme)(originalTargetUri);
	        if (defaultSchemeMapResult === null) {
	            throw new Error(`Could not find a default scheme for target name "${target}"`);
	        }
	        this.callRefTimer = setInterval(() => { }, MAX_TIMEOUT_TIME);
	        (_b = (_a = this.callRefTimer).unref) === null || _b === undefined ? undefined : _b.call(_a);
	        if (this.options['grpc.enable_channelz'] === 0) {
	            this.channelzEnabled = false;
	        }
	        this.channelzTrace = new channelz_1.ChannelzTrace();
	        this.channelzRef = (0, channelz_1.registerChannelzChannel)(target, () => this.getChannelzInfo(), this.channelzEnabled);
	        if (this.channelzEnabled) {
	            this.channelzTrace.addTrace('CT_INFO', 'Channel created');
	        }
	        if (this.options['grpc.default_authority']) {
	            this.defaultAuthority = this.options['grpc.default_authority'];
	        }
	        else {
	            this.defaultAuthority = (0, resolver_1.getDefaultAuthority)(defaultSchemeMapResult);
	        }
	        const proxyMapResult = (0, http_proxy_1.mapProxyName)(defaultSchemeMapResult, options);
	        this.target = proxyMapResult.target;
	        this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);
	        /* The global boolean parameter to getSubchannelPool has the inverse meaning to what
	         * the grpc.use_local_subchannel_pool channel option means. */
	        this.subchannelPool = (0, subchannel_pool_1.getSubchannelPool)(((_c = options['grpc.use_local_subchannel_pool']) !== null && _c !== undefined ? _c : 0) === 0);
	        this.retryBufferTracker = new retrying_call_1.MessageBufferTracker((_d = options['grpc.retry_buffer_size']) !== null && _d !== undefined ? _d : DEFAULT_RETRY_BUFFER_SIZE_BYTES, (_e = options['grpc.per_rpc_retry_buffer_size']) !== null && _e !== undefined ? _e : DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES);
	        this.keepaliveTime = (_f = options['grpc.keepalive_time_ms']) !== null && _f !== undefined ? _f : -1;
	        this.idleTimeoutMs = Math.max((_g = options['grpc.client_idle_timeout_ms']) !== null && _g !== undefined ? _g : DEFAULT_IDLE_TIMEOUT_MS, MIN_IDLE_TIMEOUT_MS);
	        const channelControlHelper = {
	            createSubchannel: (subchannelAddress, subchannelArgs, credentialsOverride) => {
	                const subchannel = this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), credentialsOverride !== null && credentialsOverride !== undefined ? credentialsOverride : this.credentials);
	                subchannel.throttleKeepalive(this.keepaliveTime);
	                if (this.channelzEnabled) {
	                    this.channelzTrace.addTrace('CT_INFO', 'Created subchannel or used existing subchannel', subchannel.getChannelzRef());
	                }
	                const wrappedSubchannel = new ChannelSubchannelWrapper(subchannel, this);
	                this.wrappedSubchannels.add(wrappedSubchannel);
	                return wrappedSubchannel;
	            },
	            updateState: (connectivityState, picker) => {
	                this.currentPicker = picker;
	                const queueCopy = this.pickQueue.slice();
	                this.pickQueue = [];
	                if (queueCopy.length > 0) {
	                    this.callRefTimerUnref();
	                }
	                for (const call of queueCopy) {
	                    call.doPick();
	                }
	                this.updateState(connectivityState);
	            },
	            requestReresolution: () => {
	                // This should never be called.
	                throw new Error('Resolving load balancer should never call requestReresolution');
	            },
	            addChannelzChild: (child) => {
	                if (this.channelzEnabled) {
	                    this.childrenTracker.refChild(child);
	                }
	            },
	            removeChannelzChild: (child) => {
	                if (this.channelzEnabled) {
	                    this.childrenTracker.unrefChild(child);
	                }
	            },
	        };
	        this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, credentials, options, (serviceConfig, configSelector) => {
	            if (serviceConfig.retryThrottling) {
	                RETRY_THROTTLER_MAP.set(this.getTarget(), new retrying_call_1.RetryThrottler(serviceConfig.retryThrottling.maxTokens, serviceConfig.retryThrottling.tokenRatio, RETRY_THROTTLER_MAP.get(this.getTarget())));
	            }
	            else {
	                RETRY_THROTTLER_MAP.delete(this.getTarget());
	            }
	            if (this.channelzEnabled) {
	                this.channelzTrace.addTrace('CT_INFO', 'Address resolution succeeded');
	            }
	            this.configSelector = configSelector;
	            this.currentResolutionError = null;
	            /* We process the queue asynchronously to ensure that the corresponding
	             * load balancer update has completed. */
	            process.nextTick(() => {
	                const localQueue = this.configSelectionQueue;
	                this.configSelectionQueue = [];
	                if (localQueue.length > 0) {
	                    this.callRefTimerUnref();
	                }
	                for (const call of localQueue) {
	                    call.getConfig();
	                }
	            });
	        }, status => {
	            if (this.channelzEnabled) {
	                this.channelzTrace.addTrace('CT_WARNING', 'Address resolution failed with code ' +
	                    status.code +
	                    ' and details "' +
	                    status.details +
	                    '"');
	            }
	            if (this.configSelectionQueue.length > 0) {
	                this.trace('Name resolution failed with calls queued for config selection');
	            }
	            if (this.configSelector === null) {
	                this.currentResolutionError = Object.assign(Object.assign({}, (0, control_plane_status_1.restrictControlPlaneStatusCode)(status.code, status.details)), { metadata: status.metadata });
	            }
	            const localQueue = this.configSelectionQueue;
	            this.configSelectionQueue = [];
	            if (localQueue.length > 0) {
	                this.callRefTimerUnref();
	            }
	            for (const call of localQueue) {
	                call.reportResolverError(status);
	            }
	        });
	        this.filterStackFactory = new filter_stack_1.FilterStackFactory([
	            new compression_filter_1.CompressionFilterFactory(this, this.options),
	        ]);
	        this.trace('Channel constructed with options ' +
	            JSON.stringify(options, undefined, 2));
	        const error = new Error();
	        if ((0, logging_1.isTracerEnabled)('channel_stacktrace')) {
	            (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, 'channel_stacktrace', '(' +
	                this.channelzRef.id +
	                ') ' +
	                'Channel constructed \n' +
	                ((_h = error.stack) === null || _h === undefined ? undefined : _h.substring(error.stack.indexOf('\n') + 1)));
	        }
	        this.lastActivityTimestamp = new Date();
	    }
	    getChannelzInfo() {
	        return {
	            target: this.originalTarget,
	            state: this.connectivityState,
	            trace: this.channelzTrace,
	            callTracker: this.callTracker,
	            children: this.childrenTracker.getChildLists(),
	        };
	    }
	    trace(text, verbosityOverride) {
	        (0, logging_1.trace)(verbosityOverride !== null && verbosityOverride !== undefined ? verbosityOverride : constants_1.LogVerbosity.DEBUG, 'channel', '(' + this.channelzRef.id + ') ' + (0, uri_parser_1.uriToString)(this.target) + ' ' + text);
	    }
	    callRefTimerRef() {
	        var _a, _b, _c, _d;
	        // If the hasRef function does not exist, always run the code
	        if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === undefined ? undefined : _b.call(_a))) {
	            this.trace('callRefTimer.ref | configSelectionQueue.length=' +
	                this.configSelectionQueue.length +
	                ' pickQueue.length=' +
	                this.pickQueue.length);
	            (_d = (_c = this.callRefTimer).ref) === null || _d === undefined ? undefined : _d.call(_c);
	        }
	    }
	    callRefTimerUnref() {
	        var _a, _b;
	        // If the hasRef function does not exist, always run the code
	        if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {
	            this.trace('callRefTimer.unref | configSelectionQueue.length=' +
	                this.configSelectionQueue.length +
	                ' pickQueue.length=' +
	                this.pickQueue.length);
	            (_b = (_a = this.callRefTimer).unref) === null || _b === undefined ? undefined : _b.call(_a);
	        }
	    }
	    removeConnectivityStateWatcher(watcherObject) {
	        const watcherIndex = this.connectivityStateWatchers.findIndex(value => value === watcherObject);
	        if (watcherIndex >= 0) {
	            this.connectivityStateWatchers.splice(watcherIndex, 1);
	        }
	    }
	    updateState(newState) {
	        (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, 'connectivity_state', '(' +
	            this.channelzRef.id +
	            ') ' +
	            (0, uri_parser_1.uriToString)(this.target) +
	            ' ' +
	            connectivity_state_1.ConnectivityState[this.connectivityState] +
	            ' -> ' +
	            connectivity_state_1.ConnectivityState[newState]);
	        if (this.channelzEnabled) {
	            this.channelzTrace.addTrace('CT_INFO', 'Connectivity state change to ' + connectivity_state_1.ConnectivityState[newState]);
	        }
	        this.connectivityState = newState;
	        const watchersCopy = this.connectivityStateWatchers.slice();
	        for (const watcherObject of watchersCopy) {
	            if (newState !== watcherObject.currentState) {
	                if (watcherObject.timer) {
	                    clearTimeout(watcherObject.timer);
	                }
	                this.removeConnectivityStateWatcher(watcherObject);
	                watcherObject.callback();
	            }
	        }
	        if (newState !== connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
	            this.currentResolutionError = null;
	        }
	    }
	    throttleKeepalive(newKeepaliveTime) {
	        if (newKeepaliveTime > this.keepaliveTime) {
	            this.keepaliveTime = newKeepaliveTime;
	            for (const wrappedSubchannel of this.wrappedSubchannels) {
	                wrappedSubchannel.throttleKeepalive(newKeepaliveTime);
	            }
	        }
	    }
	    removeWrappedSubchannel(wrappedSubchannel) {
	        this.wrappedSubchannels.delete(wrappedSubchannel);
	    }
	    doPick(metadata, extraPickInfo) {
	        return this.currentPicker.pick({
	            metadata: metadata,
	            extraPickInfo: extraPickInfo,
	        });
	    }
	    queueCallForPick(call) {
	        this.pickQueue.push(call);
	        this.callRefTimerRef();
	    }
	    getConfig(method, metadata) {
	        if (this.connectivityState !== connectivity_state_1.ConnectivityState.SHUTDOWN) {
	            this.resolvingLoadBalancer.exitIdle();
	        }
	        if (this.configSelector) {
	            return {
	                type: 'SUCCESS',
	                config: this.configSelector(method, metadata, this.randomChannelId),
	            };
	        }
	        else {
	            if (this.currentResolutionError) {
	                return {
	                    type: 'ERROR',
	                    error: this.currentResolutionError,
	                };
	            }
	            else {
	                return {
	                    type: 'NONE',
	                };
	            }
	        }
	    }
	    queueCallForConfig(call) {
	        this.configSelectionQueue.push(call);
	        this.callRefTimerRef();
	    }
	    enterIdle() {
	        this.resolvingLoadBalancer.destroy();
	        this.updateState(connectivity_state_1.ConnectivityState.IDLE);
	        this.currentPicker = new picker_1.QueuePicker(this.resolvingLoadBalancer);
	        if (this.idleTimer) {
	            clearTimeout(this.idleTimer);
	            this.idleTimer = null;
	        }
	    }
	    startIdleTimeout(timeoutMs) {
	        var _a, _b;
	        this.idleTimer = setTimeout(() => {
	            if (this.callCount > 0) {
	                /* If there is currently a call, the channel will not go idle for a
	                 * period of at least idleTimeoutMs, so check again after that time.
	                 */
	                this.startIdleTimeout(this.idleTimeoutMs);
	                return;
	            }
	            const now = new Date();
	            const timeSinceLastActivity = now.valueOf() - this.lastActivityTimestamp.valueOf();
	            if (timeSinceLastActivity >= this.idleTimeoutMs) {
	                this.trace('Idle timer triggered after ' +
	                    this.idleTimeoutMs +
	                    'ms of inactivity');
	                this.enterIdle();
	            }
	            else {
	                /* Whenever the timer fires with the latest activity being too recent,
	                 * set the timer again for the time when the time since the last
	                 * activity is equal to the timeout. This should result in the timer
	                 * firing no more than once every idleTimeoutMs/2 on average. */
	                this.startIdleTimeout(this.idleTimeoutMs - timeSinceLastActivity);
	            }
	        }, timeoutMs);
	        (_b = (_a = this.idleTimer).unref) === null || _b === undefined ? undefined : _b.call(_a);
	    }
	    maybeStartIdleTimer() {
	        if (this.connectivityState !== connectivity_state_1.ConnectivityState.SHUTDOWN &&
	            !this.idleTimer) {
	            this.startIdleTimeout(this.idleTimeoutMs);
	        }
	    }
	    onCallStart() {
	        if (this.channelzEnabled) {
	            this.callTracker.addCallStarted();
	        }
	        this.callCount += 1;
	    }
	    onCallEnd(status) {
	        if (this.channelzEnabled) {
	            if (status.code === constants_1.Status.OK) {
	                this.callTracker.addCallSucceeded();
	            }
	            else {
	                this.callTracker.addCallFailed();
	            }
	        }
	        this.callCount -= 1;
	        this.lastActivityTimestamp = new Date();
	        this.maybeStartIdleTimer();
	    }
	    createLoadBalancingCall(callConfig, method, host, credentials, deadline) {
	        const callNumber = (0, call_number_1.getNextCallNumber)();
	        this.trace('createLoadBalancingCall [' + callNumber + '] method="' + method + '"');
	        return new load_balancing_call_1.LoadBalancingCall(this, callConfig, method, host, credentials, deadline, callNumber);
	    }
	    createRetryingCall(callConfig, method, host, credentials, deadline) {
	        const callNumber = (0, call_number_1.getNextCallNumber)();
	        this.trace('createRetryingCall [' + callNumber + '] method="' + method + '"');
	        return new retrying_call_1.RetryingCall(this, callConfig, method, host, credentials, deadline, callNumber, this.retryBufferTracker, RETRY_THROTTLER_MAP.get(this.getTarget()));
	    }
	    createInnerCall(callConfig, method, host, credentials, deadline) {
	        // Create a RetryingCall if retries are enabled
	        if (this.options['grpc.enable_retries'] === 0) {
	            return this.createLoadBalancingCall(callConfig, method, host, credentials, deadline);
	        }
	        else {
	            return this.createRetryingCall(callConfig, method, host, credentials, deadline);
	        }
	    }
	    createResolvingCall(method, deadline, host, parentCall, propagateFlags) {
	        const callNumber = (0, call_number_1.getNextCallNumber)();
	        this.trace('createResolvingCall [' +
	            callNumber +
	            '] method="' +
	            method +
	            '", deadline=' +
	            (0, deadline_1.deadlineToString)(deadline));
	        const finalOptions = {
	            deadline: deadline,
	            flags: propagateFlags !== null && propagateFlags !== undefined ? propagateFlags : constants_1.Propagate.DEFAULTS,
	            host: host !== null && host !== undefined ? host : this.defaultAuthority,
	            parentCall: parentCall,
	        };
	        const call = new resolving_call_1.ResolvingCall(this, method, finalOptions, this.filterStackFactory.clone(), this.credentials._getCallCredentials(), callNumber);
	        this.onCallStart();
	        call.addStatusWatcher(status => {
	            this.onCallEnd(status);
	        });
	        return call;
	    }
	    close() {
	        this.resolvingLoadBalancer.destroy();
	        this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN);
	        this.currentPicker = new ShutdownPicker();
	        for (const call of this.configSelectionQueue) {
	            call.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Channel closed before call started');
	        }
	        this.configSelectionQueue = [];
	        for (const call of this.pickQueue) {
	            call.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Channel closed before call started');
	        }
	        this.pickQueue = [];
	        clearInterval(this.callRefTimer);
	        if (this.idleTimer) {
	            clearTimeout(this.idleTimer);
	        }
	        if (this.channelzEnabled) {
	            (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
	        }
	        this.subchannelPool.unrefUnusedSubchannels();
	    }
	    getTarget() {
	        return (0, uri_parser_1.uriToString)(this.target);
	    }
	    getConnectivityState(tryToConnect) {
	        const connectivityState = this.connectivityState;
	        if (tryToConnect) {
	            this.resolvingLoadBalancer.exitIdle();
	            this.lastActivityTimestamp = new Date();
	            this.maybeStartIdleTimer();
	        }
	        return connectivityState;
	    }
	    watchConnectivityState(currentState, deadline, callback) {
	        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {
	            throw new Error('Channel has been shut down');
	        }
	        let timer = null;
	        if (deadline !== Infinity) {
	            const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);
	            const now = new Date();
	            if (deadline === -Infinity || deadlineDate <= now) {
	                process.nextTick(callback, new Error('Deadline passed without connectivity state change'));
	                return;
	            }
	            timer = setTimeout(() => {
	                this.removeConnectivityStateWatcher(watcherObject);
	                callback(new Error('Deadline passed without connectivity state change'));
	            }, deadlineDate.getTime() - now.getTime());
	        }
	        const watcherObject = {
	            currentState,
	            callback,
	            timer,
	        };
	        this.connectivityStateWatchers.push(watcherObject);
	    }
	    /**
	     * Get the channelz reference object for this channel. The returned value is
	     * garbage if channelz is disabled for this channel.
	     * @returns
	     */
	    getChannelzRef() {
	        return this.channelzRef;
	    }
	    createCall(method, deadline, host, parentCall, propagateFlags) {
	        if (typeof method !== 'string') {
	            throw new TypeError('Channel#createCall: method must be a string');
	        }
	        if (!(typeof deadline === 'number' || deadline instanceof Date)) {
	            throw new TypeError('Channel#createCall: deadline must be a number or Date');
	        }
	        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {
	            throw new Error('Channel has been shut down');
	        }
	        return this.createResolvingCall(method, deadline, host, parentCall, propagateFlags);
	    }
	    getOptions() {
	        return this.options;
	    }
	}
	internalChannel.InternalChannel = InternalChannel;
	
	return internalChannel;
}

var hasRequiredChannel$1;

function requireChannel$1 () {
	if (hasRequiredChannel$1) return channel$1;
	hasRequiredChannel$1 = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(channel$1, "__esModule", { value: true });
	channel$1.ChannelImplementation = undefined;
	const channel_credentials_1 = requireChannelCredentials();
	const internal_channel_1 = requireInternalChannel();
	class ChannelImplementation {
	    constructor(target, credentials, options) {
	        if (typeof target !== 'string') {
	            throw new TypeError('Channel target must be a string');
	        }
	        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {
	            throw new TypeError('Channel credentials must be a ChannelCredentials object');
	        }
	        if (options) {
	            if (typeof options !== 'object') {
	                throw new TypeError('Channel options must be an object');
	            }
	        }
	        this.internalChannel = new internal_channel_1.InternalChannel(target, credentials, options);
	    }
	    close() {
	        this.internalChannel.close();
	    }
	    getTarget() {
	        return this.internalChannel.getTarget();
	    }
	    getConnectivityState(tryToConnect) {
	        return this.internalChannel.getConnectivityState(tryToConnect);
	    }
	    watchConnectivityState(currentState, deadline, callback) {
	        this.internalChannel.watchConnectivityState(currentState, deadline, callback);
	    }
	    /**
	     * Get the channelz reference object for this channel. The returned value is
	     * garbage if channelz is disabled for this channel.
	     * @returns
	     */
	    getChannelzRef() {
	        return this.internalChannel.getChannelzRef();
	    }
	    createCall(method, deadline, host, parentCall, propagateFlags) {
	        if (typeof method !== 'string') {
	            throw new TypeError('Channel#createCall: method must be a string');
	        }
	        if (!(typeof deadline === 'number' || deadline instanceof Date)) {
	            throw new TypeError('Channel#createCall: deadline must be a number or Date');
	        }
	        return this.internalChannel.createCall(method, deadline, host, parentCall, propagateFlags);
	    }
	}
	channel$1.ChannelImplementation = ChannelImplementation;
	
	return channel$1;
}

var server = {};

var serverCall = {};

var hasRequiredServerCall;

function requireServerCall () {
	if (hasRequiredServerCall) return serverCall;
	hasRequiredServerCall = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(serverCall, "__esModule", { value: true });
	serverCall.ServerDuplexStreamImpl = serverCall.ServerWritableStreamImpl = serverCall.ServerReadableStreamImpl = serverCall.ServerUnaryCallImpl = serverCall.serverErrorToStatus = undefined;
	const events_1 = require$$0$3;
	const stream_1 = require$$0$4;
	const constants_1 = requireConstants();
	const metadata_1 = requireMetadata();
	function serverErrorToStatus(error, overrideTrailers) {
	    var _a;
	    const status = {
	        code: constants_1.Status.UNKNOWN,
	        details: 'message' in error ? error.message : 'Unknown Error',
	        metadata: (_a = overrideTrailers !== null && overrideTrailers !== undefined ? overrideTrailers : error.metadata) !== null && _a !== undefined ? _a : null,
	    };
	    if ('code' in error &&
	        typeof error.code === 'number' &&
	        Number.isInteger(error.code)) {
	        status.code = error.code;
	        if ('details' in error && typeof error.details === 'string') {
	            status.details = error.details;
	        }
	    }
	    return status;
	}
	serverCall.serverErrorToStatus = serverErrorToStatus;
	class ServerUnaryCallImpl extends events_1.EventEmitter {
	    constructor(path, call, metadata, request) {
	        super();
	        this.path = path;
	        this.call = call;
	        this.metadata = metadata;
	        this.request = request;
	        this.cancelled = false;
	    }
	    getPeer() {
	        return this.call.getPeer();
	    }
	    sendMetadata(responseMetadata) {
	        this.call.sendMetadata(responseMetadata);
	    }
	    getDeadline() {
	        return this.call.getDeadline();
	    }
	    getPath() {
	        return this.path;
	    }
	    getHost() {
	        return this.call.getHost();
	    }
	}
	serverCall.ServerUnaryCallImpl = ServerUnaryCallImpl;
	class ServerReadableStreamImpl extends stream_1.Readable {
	    constructor(path, call, metadata) {
	        super({ objectMode: true });
	        this.path = path;
	        this.call = call;
	        this.metadata = metadata;
	        this.cancelled = false;
	    }
	    _read(size) {
	        this.call.startRead();
	    }
	    getPeer() {
	        return this.call.getPeer();
	    }
	    sendMetadata(responseMetadata) {
	        this.call.sendMetadata(responseMetadata);
	    }
	    getDeadline() {
	        return this.call.getDeadline();
	    }
	    getPath() {
	        return this.path;
	    }
	    getHost() {
	        return this.call.getHost();
	    }
	}
	serverCall.ServerReadableStreamImpl = ServerReadableStreamImpl;
	class ServerWritableStreamImpl extends stream_1.Writable {
	    constructor(path, call, metadata, request) {
	        super({ objectMode: true });
	        this.path = path;
	        this.call = call;
	        this.metadata = metadata;
	        this.request = request;
	        this.pendingStatus = {
	            code: constants_1.Status.OK,
	            details: 'OK',
	        };
	        this.cancelled = false;
	        this.trailingMetadata = new metadata_1.Metadata();
	        this.on('error', err => {
	            this.pendingStatus = serverErrorToStatus(err);
	            this.end();
	        });
	    }
	    getPeer() {
	        return this.call.getPeer();
	    }
	    sendMetadata(responseMetadata) {
	        this.call.sendMetadata(responseMetadata);
	    }
	    getDeadline() {
	        return this.call.getDeadline();
	    }
	    getPath() {
	        return this.path;
	    }
	    getHost() {
	        return this.call.getHost();
	    }
	    _write(chunk, encoding, 
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    callback) {
	        this.call.sendMessage(chunk, callback);
	    }
	    _final(callback) {
	        var _a;
	        callback(null);
	        this.call.sendStatus(Object.assign(Object.assign({}, this.pendingStatus), { metadata: (_a = this.pendingStatus.metadata) !== null && _a !== undefined ? _a : this.trailingMetadata }));
	    }
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    end(metadata) {
	        if (metadata) {
	            this.trailingMetadata = metadata;
	        }
	        return super.end();
	    }
	}
	serverCall.ServerWritableStreamImpl = ServerWritableStreamImpl;
	class ServerDuplexStreamImpl extends stream_1.Duplex {
	    constructor(path, call, metadata) {
	        super({ objectMode: true });
	        this.path = path;
	        this.call = call;
	        this.metadata = metadata;
	        this.pendingStatus = {
	            code: constants_1.Status.OK,
	            details: 'OK',
	        };
	        this.cancelled = false;
	        this.trailingMetadata = new metadata_1.Metadata();
	        this.on('error', err => {
	            this.pendingStatus = serverErrorToStatus(err);
	            this.end();
	        });
	    }
	    getPeer() {
	        return this.call.getPeer();
	    }
	    sendMetadata(responseMetadata) {
	        this.call.sendMetadata(responseMetadata);
	    }
	    getDeadline() {
	        return this.call.getDeadline();
	    }
	    getPath() {
	        return this.path;
	    }
	    getHost() {
	        return this.call.getHost();
	    }
	    _read(size) {
	        this.call.startRead();
	    }
	    _write(chunk, encoding, 
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    callback) {
	        this.call.sendMessage(chunk, callback);
	    }
	    _final(callback) {
	        var _a;
	        callback(null);
	        this.call.sendStatus(Object.assign(Object.assign({}, this.pendingStatus), { metadata: (_a = this.pendingStatus.metadata) !== null && _a !== undefined ? _a : this.trailingMetadata }));
	    }
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    end(metadata) {
	        if (metadata) {
	            this.trailingMetadata = metadata;
	        }
	        return super.end();
	    }
	}
	serverCall.ServerDuplexStreamImpl = ServerDuplexStreamImpl;
	
	return serverCall;
}

var serverCredentials = {};

var hasRequiredServerCredentials;

function requireServerCredentials () {
	if (hasRequiredServerCredentials) return serverCredentials;
	hasRequiredServerCredentials = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(serverCredentials, "__esModule", { value: true });
	serverCredentials.createServerCredentialsWithInterceptors = serverCredentials.createCertificateProviderServerCredentials = serverCredentials.ServerCredentials = undefined;
	const tls_helpers_1 = requireTlsHelpers();
	class ServerCredentials {
	    constructor() {
	        this.watchers = new Set();
	        this.latestContextOptions = null;
	    }
	    _addWatcher(watcher) {
	        this.watchers.add(watcher);
	    }
	    _removeWatcher(watcher) {
	        this.watchers.delete(watcher);
	    }
	    getWatcherCount() {
	        return this.watchers.size;
	    }
	    updateSecureContextOptions(options) {
	        this.latestContextOptions = options;
	        for (const watcher of this.watchers) {
	            watcher(this.latestContextOptions);
	        }
	    }
	    _getSettings() {
	        return this.latestContextOptions;
	    }
	    _getInterceptors() {
	        return [];
	    }
	    static createInsecure() {
	        return new InsecureServerCredentials();
	    }
	    static createSsl(rootCerts, keyCertPairs, checkClientCertificate = false) {
	        var _a;
	        if (rootCerts !== null && !Buffer.isBuffer(rootCerts)) {
	            throw new TypeError('rootCerts must be null or a Buffer');
	        }
	        if (!Array.isArray(keyCertPairs)) {
	            throw new TypeError('keyCertPairs must be an array');
	        }
	        if (typeof checkClientCertificate !== 'boolean') {
	            throw new TypeError('checkClientCertificate must be a boolean');
	        }
	        const cert = [];
	        const key = [];
	        for (let i = 0; i < keyCertPairs.length; i++) {
	            const pair = keyCertPairs[i];
	            if (pair === null || typeof pair !== 'object') {
	                throw new TypeError(`keyCertPair[${i}] must be an object`);
	            }
	            if (!Buffer.isBuffer(pair.private_key)) {
	                throw new TypeError(`keyCertPair[${i}].private_key must be a Buffer`);
	            }
	            if (!Buffer.isBuffer(pair.cert_chain)) {
	                throw new TypeError(`keyCertPair[${i}].cert_chain must be a Buffer`);
	            }
	            cert.push(pair.cert_chain);
	            key.push(pair.private_key);
	        }
	        return new SecureServerCredentials({
	            ca: (_a = rootCerts !== null && rootCerts !== undefined ? rootCerts : (0, tls_helpers_1.getDefaultRootsData)()) !== null && _a !== undefined ? _a : undefined,
	            cert,
	            key,
	            requestCert: checkClientCertificate,
	            ciphers: tls_helpers_1.CIPHER_SUITES,
	        });
	    }
	}
	serverCredentials.ServerCredentials = ServerCredentials;
	class InsecureServerCredentials extends ServerCredentials {
	    _isSecure() {
	        return false;
	    }
	    _getSettings() {
	        return null;
	    }
	    _equals(other) {
	        return other instanceof InsecureServerCredentials;
	    }
	}
	class SecureServerCredentials extends ServerCredentials {
	    constructor(options) {
	        super();
	        this.options = options;
	    }
	    _isSecure() {
	        return true;
	    }
	    _getSettings() {
	        return this.options;
	    }
	    /**
	     * Checks equality by checking the options that are actually set by
	     * createSsl.
	     * @param other
	     * @returns
	     */
	    _equals(other) {
	        if (this === other) {
	            return true;
	        }
	        if (!(other instanceof SecureServerCredentials)) {
	            return false;
	        }
	        // options.ca equality check
	        if (Buffer.isBuffer(this.options.ca) && Buffer.isBuffer(other.options.ca)) {
	            if (!this.options.ca.equals(other.options.ca)) {
	                return false;
	            }
	        }
	        else {
	            if (this.options.ca !== other.options.ca) {
	                return false;
	            }
	        }
	        // options.cert equality check
	        if (Array.isArray(this.options.cert) && Array.isArray(other.options.cert)) {
	            if (this.options.cert.length !== other.options.cert.length) {
	                return false;
	            }
	            for (let i = 0; i < this.options.cert.length; i++) {
	                const thisCert = this.options.cert[i];
	                const otherCert = other.options.cert[i];
	                if (Buffer.isBuffer(thisCert) && Buffer.isBuffer(otherCert)) {
	                    if (!thisCert.equals(otherCert)) {
	                        return false;
	                    }
	                }
	                else {
	                    if (thisCert !== otherCert) {
	                        return false;
	                    }
	                }
	            }
	        }
	        else {
	            if (this.options.cert !== other.options.cert) {
	                return false;
	            }
	        }
	        // options.key equality check
	        if (Array.isArray(this.options.key) && Array.isArray(other.options.key)) {
	            if (this.options.key.length !== other.options.key.length) {
	                return false;
	            }
	            for (let i = 0; i < this.options.key.length; i++) {
	                const thisKey = this.options.key[i];
	                const otherKey = other.options.key[i];
	                if (Buffer.isBuffer(thisKey) && Buffer.isBuffer(otherKey)) {
	                    if (!thisKey.equals(otherKey)) {
	                        return false;
	                    }
	                }
	                else {
	                    if (thisKey !== otherKey) {
	                        return false;
	                    }
	                }
	            }
	        }
	        else {
	            if (this.options.key !== other.options.key) {
	                return false;
	            }
	        }
	        // options.requestCert equality check
	        if (this.options.requestCert !== other.options.requestCert) {
	            return false;
	        }
	        /* ciphers is derived from a value that is constant for the process, so no
	         * equality check is needed. */
	        return true;
	    }
	}
	class CertificateProviderServerCredentials extends ServerCredentials {
	    constructor(identityCertificateProvider, caCertificateProvider, requireClientCertificate) {
	        super();
	        this.identityCertificateProvider = identityCertificateProvider;
	        this.caCertificateProvider = caCertificateProvider;
	        this.requireClientCertificate = requireClientCertificate;
	        this.latestCaUpdate = null;
	        this.latestIdentityUpdate = null;
	        this.caCertificateUpdateListener = this.handleCaCertificateUpdate.bind(this);
	        this.identityCertificateUpdateListener = this.handleIdentityCertitificateUpdate.bind(this);
	    }
	    _addWatcher(watcher) {
	        var _a;
	        if (this.getWatcherCount() === 0) {
	            (_a = this.caCertificateProvider) === null || _a === undefined ? undefined : _a.addCaCertificateListener(this.caCertificateUpdateListener);
	            this.identityCertificateProvider.addIdentityCertificateListener(this.identityCertificateUpdateListener);
	        }
	        super._addWatcher(watcher);
	    }
	    _removeWatcher(watcher) {
	        var _a;
	        super._removeWatcher(watcher);
	        if (this.getWatcherCount() === 0) {
	            (_a = this.caCertificateProvider) === null || _a === undefined ? undefined : _a.removeCaCertificateListener(this.caCertificateUpdateListener);
	            this.identityCertificateProvider.removeIdentityCertificateListener(this.identityCertificateUpdateListener);
	        }
	    }
	    _isSecure() {
	        return true;
	    }
	    _equals(other) {
	        if (this === other) {
	            return true;
	        }
	        if (!(other instanceof CertificateProviderServerCredentials)) {
	            return false;
	        }
	        return (this.caCertificateProvider === other.caCertificateProvider &&
	            this.identityCertificateProvider === other.identityCertificateProvider &&
	            this.requireClientCertificate === other.requireClientCertificate);
	    }
	    calculateSecureContextOptions() {
	        var _a;
	        if (this.latestIdentityUpdate === null) {
	            return null;
	        }
	        if (this.caCertificateProvider !== null && this.latestCaUpdate === null) {
	            return null;
	        }
	        return {
	            ca: (_a = this.latestCaUpdate) === null || _a === undefined ? undefined : _a.caCertificate,
	            cert: this.latestIdentityUpdate.certificate,
	            key: this.latestIdentityUpdate.privateKey,
	            requestCert: this.latestIdentityUpdate !== null,
	            rejectUnauthorized: this.requireClientCertificate
	        };
	    }
	    finalizeUpdate() {
	        this.updateSecureContextOptions(this.calculateSecureContextOptions());
	    }
	    handleCaCertificateUpdate(update) {
	        this.latestCaUpdate = update;
	        this.finalizeUpdate();
	    }
	    handleIdentityCertitificateUpdate(update) {
	        this.latestIdentityUpdate = update;
	        this.finalizeUpdate();
	    }
	}
	function createCertificateProviderServerCredentials(caCertificateProvider, identityCertificateProvider, requireClientCertificate) {
	    return new CertificateProviderServerCredentials(caCertificateProvider, identityCertificateProvider, requireClientCertificate);
	}
	serverCredentials.createCertificateProviderServerCredentials = createCertificateProviderServerCredentials;
	class InterceptorServerCredentials extends ServerCredentials {
	    constructor(childCredentials, interceptors) {
	        super();
	        this.childCredentials = childCredentials;
	        this.interceptors = interceptors;
	    }
	    _isSecure() {
	        return this.childCredentials._isSecure();
	    }
	    _equals(other) {
	        if (!(other instanceof InterceptorServerCredentials)) {
	            return false;
	        }
	        if (!(this.childCredentials._equals(other.childCredentials))) {
	            return false;
	        }
	        if (this.interceptors.length !== other.interceptors.length) {
	            return false;
	        }
	        for (let i = 0; i < this.interceptors.length; i++) {
	            if (this.interceptors[i] !== other.interceptors[i]) {
	                return false;
	            }
	        }
	        return true;
	    }
	    _getInterceptors() {
	        return this.interceptors;
	    }
	    _addWatcher(watcher) {
	        this.childCredentials._addWatcher(watcher);
	    }
	    _removeWatcher(watcher) {
	        this.childCredentials._removeWatcher(watcher);
	    }
	}
	function createServerCredentialsWithInterceptors(credentials, interceptors) {
	    return new InterceptorServerCredentials(credentials, interceptors);
	}
	serverCredentials.createServerCredentialsWithInterceptors = createServerCredentialsWithInterceptors;
	
	return serverCredentials;
}

var serverInterceptors = {};

var hasRequiredServerInterceptors;

function requireServerInterceptors () {
	if (hasRequiredServerInterceptors) return serverInterceptors;
	hasRequiredServerInterceptors = 1;
	/*
	 * Copyright 2024 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(serverInterceptors, "__esModule", { value: true });
	serverInterceptors.getServerInterceptingCall = serverInterceptors.BaseServerInterceptingCall = serverInterceptors.ServerInterceptingCall = serverInterceptors.ResponderBuilder = serverInterceptors.isInterceptingServerListener = serverInterceptors.ServerListenerBuilder = undefined;
	const metadata_1 = requireMetadata();
	const constants_1 = requireConstants();
	const http2 = require$$0$5;
	const error_1 = requireError();
	const zlib = require$$0$6;
	const stream_decoder_1 = requireStreamDecoder();
	const logging = requireLogging();
	const TRACER_NAME = 'server_call';
	function trace(text) {
	    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
	}
	class ServerListenerBuilder {
	    constructor() {
	        this.metadata = undefined;
	        this.message = undefined;
	        this.halfClose = undefined;
	        this.cancel = undefined;
	    }
	    withOnReceiveMetadata(onReceiveMetadata) {
	        this.metadata = onReceiveMetadata;
	        return this;
	    }
	    withOnReceiveMessage(onReceiveMessage) {
	        this.message = onReceiveMessage;
	        return this;
	    }
	    withOnReceiveHalfClose(onReceiveHalfClose) {
	        this.halfClose = onReceiveHalfClose;
	        return this;
	    }
	    withOnCancel(onCancel) {
	        this.cancel = onCancel;
	        return this;
	    }
	    build() {
	        return {
	            onReceiveMetadata: this.metadata,
	            onReceiveMessage: this.message,
	            onReceiveHalfClose: this.halfClose,
	            onCancel: this.cancel,
	        };
	    }
	}
	serverInterceptors.ServerListenerBuilder = ServerListenerBuilder;
	function isInterceptingServerListener(listener) {
	    return (listener.onReceiveMetadata !== undefined &&
	        listener.onReceiveMetadata.length === 1);
	}
	serverInterceptors.isInterceptingServerListener = isInterceptingServerListener;
	class InterceptingServerListenerImpl {
	    constructor(listener, nextListener) {
	        this.listener = listener;
	        this.nextListener = nextListener;
	        /**
	         * Once the call is cancelled, ignore all other events.
	         */
	        this.cancelled = false;
	        this.processingMetadata = false;
	        this.hasPendingMessage = false;
	        this.pendingMessage = null;
	        this.processingMessage = false;
	        this.hasPendingHalfClose = false;
	    }
	    processPendingMessage() {
	        if (this.hasPendingMessage) {
	            this.nextListener.onReceiveMessage(this.pendingMessage);
	            this.pendingMessage = null;
	            this.hasPendingMessage = false;
	        }
	    }
	    processPendingHalfClose() {
	        if (this.hasPendingHalfClose) {
	            this.nextListener.onReceiveHalfClose();
	            this.hasPendingHalfClose = false;
	        }
	    }
	    onReceiveMetadata(metadata) {
	        if (this.cancelled) {
	            return;
	        }
	        this.processingMetadata = true;
	        this.listener.onReceiveMetadata(metadata, interceptedMetadata => {
	            this.processingMetadata = false;
	            if (this.cancelled) {
	                return;
	            }
	            this.nextListener.onReceiveMetadata(interceptedMetadata);
	            this.processPendingMessage();
	            this.processPendingHalfClose();
	        });
	    }
	    onReceiveMessage(message) {
	        if (this.cancelled) {
	            return;
	        }
	        this.processingMessage = true;
	        this.listener.onReceiveMessage(message, msg => {
	            this.processingMessage = false;
	            if (this.cancelled) {
	                return;
	            }
	            if (this.processingMetadata) {
	                this.pendingMessage = msg;
	                this.hasPendingMessage = true;
	            }
	            else {
	                this.nextListener.onReceiveMessage(msg);
	                this.processPendingHalfClose();
	            }
	        });
	    }
	    onReceiveHalfClose() {
	        if (this.cancelled) {
	            return;
	        }
	        this.listener.onReceiveHalfClose(() => {
	            if (this.cancelled) {
	                return;
	            }
	            if (this.processingMetadata || this.processingMessage) {
	                this.hasPendingHalfClose = true;
	            }
	            else {
	                this.nextListener.onReceiveHalfClose();
	            }
	        });
	    }
	    onCancel() {
	        this.cancelled = true;
	        this.listener.onCancel();
	        this.nextListener.onCancel();
	    }
	}
	class ResponderBuilder {
	    constructor() {
	        this.start = undefined;
	        this.metadata = undefined;
	        this.message = undefined;
	        this.status = undefined;
	    }
	    withStart(start) {
	        this.start = start;
	        return this;
	    }
	    withSendMetadata(sendMetadata) {
	        this.metadata = sendMetadata;
	        return this;
	    }
	    withSendMessage(sendMessage) {
	        this.message = sendMessage;
	        return this;
	    }
	    withSendStatus(sendStatus) {
	        this.status = sendStatus;
	        return this;
	    }
	    build() {
	        return {
	            start: this.start,
	            sendMetadata: this.metadata,
	            sendMessage: this.message,
	            sendStatus: this.status,
	        };
	    }
	}
	serverInterceptors.ResponderBuilder = ResponderBuilder;
	const defaultServerListener = {
	    onReceiveMetadata: (metadata, next) => {
	        next(metadata);
	    },
	    onReceiveMessage: (message, next) => {
	        next(message);
	    },
	    onReceiveHalfClose: next => {
	        next();
	    },
	    onCancel: () => { },
	};
	const defaultResponder = {
	    start: next => {
	        next();
	    },
	    sendMetadata: (metadata, next) => {
	        next(metadata);
	    },
	    sendMessage: (message, next) => {
	        next(message);
	    },
	    sendStatus: (status, next) => {
	        next(status);
	    },
	};
	class ServerInterceptingCall {
	    constructor(nextCall, responder) {
	        var _a, _b, _c, _d;
	        this.nextCall = nextCall;
	        this.processingMetadata = false;
	        this.processingMessage = false;
	        this.pendingMessage = null;
	        this.pendingMessageCallback = null;
	        this.pendingStatus = null;
	        this.responder = {
	            start: (_a = responder === null || responder === undefined ? undefined : responder.start) !== null && _a !== undefined ? _a : defaultResponder.start,
	            sendMetadata: (_b = responder === null || responder === undefined ? undefined : responder.sendMetadata) !== null && _b !== undefined ? _b : defaultResponder.sendMetadata,
	            sendMessage: (_c = responder === null || responder === undefined ? undefined : responder.sendMessage) !== null && _c !== undefined ? _c : defaultResponder.sendMessage,
	            sendStatus: (_d = responder === null || responder === undefined ? undefined : responder.sendStatus) !== null && _d !== undefined ? _d : defaultResponder.sendStatus,
	        };
	    }
	    processPendingMessage() {
	        if (this.pendingMessageCallback) {
	            this.nextCall.sendMessage(this.pendingMessage, this.pendingMessageCallback);
	            this.pendingMessage = null;
	            this.pendingMessageCallback = null;
	        }
	    }
	    processPendingStatus() {
	        if (this.pendingStatus) {
	            this.nextCall.sendStatus(this.pendingStatus);
	            this.pendingStatus = null;
	        }
	    }
	    start(listener) {
	        this.responder.start(interceptedListener => {
	            var _a, _b, _c, _d;
	            const fullInterceptedListener = {
	                onReceiveMetadata: (_a = interceptedListener === null || interceptedListener === undefined ? undefined : interceptedListener.onReceiveMetadata) !== null && _a !== undefined ? _a : defaultServerListener.onReceiveMetadata,
	                onReceiveMessage: (_b = interceptedListener === null || interceptedListener === undefined ? undefined : interceptedListener.onReceiveMessage) !== null && _b !== undefined ? _b : defaultServerListener.onReceiveMessage,
	                onReceiveHalfClose: (_c = interceptedListener === null || interceptedListener === undefined ? undefined : interceptedListener.onReceiveHalfClose) !== null && _c !== undefined ? _c : defaultServerListener.onReceiveHalfClose,
	                onCancel: (_d = interceptedListener === null || interceptedListener === undefined ? undefined : interceptedListener.onCancel) !== null && _d !== undefined ? _d : defaultServerListener.onCancel,
	            };
	            const finalInterceptingListener = new InterceptingServerListenerImpl(fullInterceptedListener, listener);
	            this.nextCall.start(finalInterceptingListener);
	        });
	    }
	    sendMetadata(metadata) {
	        this.processingMetadata = true;
	        this.responder.sendMetadata(metadata, interceptedMetadata => {
	            this.processingMetadata = false;
	            this.nextCall.sendMetadata(interceptedMetadata);
	            this.processPendingMessage();
	            this.processPendingStatus();
	        });
	    }
	    sendMessage(message, callback) {
	        this.processingMessage = true;
	        this.responder.sendMessage(message, interceptedMessage => {
	            this.processingMessage = false;
	            if (this.processingMetadata) {
	                this.pendingMessage = interceptedMessage;
	                this.pendingMessageCallback = callback;
	            }
	            else {
	                this.nextCall.sendMessage(interceptedMessage, callback);
	            }
	        });
	    }
	    sendStatus(status) {
	        this.responder.sendStatus(status, interceptedStatus => {
	            if (this.processingMetadata || this.processingMessage) {
	                this.pendingStatus = interceptedStatus;
	            }
	            else {
	                this.nextCall.sendStatus(interceptedStatus);
	            }
	        });
	    }
	    startRead() {
	        this.nextCall.startRead();
	    }
	    getPeer() {
	        return this.nextCall.getPeer();
	    }
	    getDeadline() {
	        return this.nextCall.getDeadline();
	    }
	    getHost() {
	        return this.nextCall.getHost();
	    }
	}
	serverInterceptors.ServerInterceptingCall = ServerInterceptingCall;
	const GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';
	const GRPC_ENCODING_HEADER = 'grpc-encoding';
	const GRPC_MESSAGE_HEADER = 'grpc-message';
	const GRPC_STATUS_HEADER = 'grpc-status';
	const GRPC_TIMEOUT_HEADER = 'grpc-timeout';
	const DEADLINE_REGEX = /(\d{1,8})\s*([HMSmun])/;
	const deadlineUnitsToMs = {
	    H: 3600000,
	    M: 60000,
	    S: 1000,
	    m: 1,
	    u: 0.001,
	    n: 0.000001,
	};
	const defaultCompressionHeaders = {
	    // TODO(cjihrig): Remove these encoding headers from the default response
	    // once compression is integrated.
	    [GRPC_ACCEPT_ENCODING_HEADER]: 'identity,deflate,gzip',
	    [GRPC_ENCODING_HEADER]: 'identity',
	};
	const defaultResponseHeaders = {
	    [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,
	    [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto',
	};
	const defaultResponseOptions = {
	    waitForTrailers: true,
	};
	class BaseServerInterceptingCall {
	    constructor(stream, headers, callEventTracker, handler, options) {
	        var _a;
	        this.stream = stream;
	        this.callEventTracker = callEventTracker;
	        this.handler = handler;
	        this.listener = null;
	        this.deadlineTimer = null;
	        this.deadline = Infinity;
	        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;
	        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
	        this.cancelled = false;
	        this.metadataSent = false;
	        this.wantTrailers = false;
	        this.cancelNotified = false;
	        this.incomingEncoding = 'identity';
	        this.readQueue = [];
	        this.isReadPending = false;
	        this.receivedHalfClose = false;
	        this.streamEnded = false;
	        this.stream.once('error', (err) => {
	            /* We need an error handler to avoid uncaught error event exceptions, but
	             * there is nothing we can reasonably do here. Any error event should
	             * have a corresponding close event, which handles emitting the cancelled
	             * event. And the stream is now in a bad state, so we can't reasonably
	             * expect to be able to send an error over it. */
	        });
	        this.stream.once('close', () => {
	            var _a;
	            trace('Request to method ' +
	                ((_a = this.handler) === null || _a === undefined ? undefined : _a.path) +
	                ' stream closed with rstCode ' +
	                this.stream.rstCode);
	            if (this.callEventTracker && !this.streamEnded) {
	                this.streamEnded = true;
	                this.callEventTracker.onStreamEnd(false);
	                this.callEventTracker.onCallEnd({
	                    code: constants_1.Status.CANCELLED,
	                    details: 'Stream closed before sending status',
	                    metadata: null,
	                });
	            }
	            this.notifyOnCancel();
	        });
	        this.stream.on('data', (data) => {
	            this.handleDataFrame(data);
	        });
	        this.stream.pause();
	        this.stream.on('end', () => {
	            this.handleEndEvent();
	        });
	        if ('grpc.max_send_message_length' in options) {
	            this.maxSendMessageSize = options['grpc.max_send_message_length'];
	        }
	        if ('grpc.max_receive_message_length' in options) {
	            this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];
	        }
	        this.host = (_a = headers[':authority']) !== null && _a !== undefined ? _a : headers.host;
	        this.decoder = new stream_decoder_1.StreamDecoder(this.maxReceiveMessageSize);
	        const metadata = metadata_1.Metadata.fromHttp2Headers(headers);
	        if (logging.isTracerEnabled(TRACER_NAME)) {
	            trace('Request to ' +
	                this.handler.path +
	                ' received headers ' +
	                JSON.stringify(metadata.toJSON()));
	        }
	        const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);
	        if (timeoutHeader.length > 0) {
	            this.handleTimeoutHeader(timeoutHeader[0]);
	        }
	        const encodingHeader = metadata.get(GRPC_ENCODING_HEADER);
	        if (encodingHeader.length > 0) {
	            this.incomingEncoding = encodingHeader[0];
	        }
	        // Remove several headers that should not be propagated to the application
	        metadata.remove(GRPC_TIMEOUT_HEADER);
	        metadata.remove(GRPC_ENCODING_HEADER);
	        metadata.remove(GRPC_ACCEPT_ENCODING_HEADER);
	        metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);
	        metadata.remove(http2.constants.HTTP2_HEADER_TE);
	        metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);
	        this.metadata = metadata;
	    }
	    handleTimeoutHeader(timeoutHeader) {
	        const match = timeoutHeader.toString().match(DEADLINE_REGEX);
	        if (match === null) {
	            const status = {
	                code: constants_1.Status.INTERNAL,
	                details: `Invalid ${GRPC_TIMEOUT_HEADER} value "${timeoutHeader}"`,
	                metadata: null,
	            };
	            // Wait for the constructor to complete before sending the error.
	            process.nextTick(() => {
	                this.sendStatus(status);
	            });
	            return;
	        }
	        const timeout = (+match[1] * deadlineUnitsToMs[match[2]]) | 0;
	        const now = new Date();
	        this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);
	        this.deadlineTimer = setTimeout(() => {
	            const status = {
	                code: constants_1.Status.DEADLINE_EXCEEDED,
	                details: 'Deadline exceeded',
	                metadata: null,
	            };
	            this.sendStatus(status);
	        }, timeout);
	    }
	    checkCancelled() {
	        /* In some cases the stream can become destroyed before the close event
	         * fires. That creates a race condition that this check works around */
	        if (!this.cancelled && (this.stream.destroyed || this.stream.closed)) {
	            this.notifyOnCancel();
	            this.cancelled = true;
	        }
	        return this.cancelled;
	    }
	    notifyOnCancel() {
	        if (this.cancelNotified) {
	            return;
	        }
	        this.cancelNotified = true;
	        this.cancelled = true;
	        process.nextTick(() => {
	            var _a;
	            (_a = this.listener) === null || _a === undefined ? undefined : _a.onCancel();
	        });
	        if (this.deadlineTimer) {
	            clearTimeout(this.deadlineTimer);
	        }
	        // Flush incoming data frames
	        this.stream.resume();
	    }
	    /**
	     * A server handler can start sending messages without explicitly sending
	     * metadata. In that case, we need to send headers before sending any
	     * messages. This function does that if necessary.
	     */
	    maybeSendMetadata() {
	        if (!this.metadataSent) {
	            this.sendMetadata(new metadata_1.Metadata());
	        }
	    }
	    /**
	     * Serialize a message to a length-delimited byte string.
	     * @param value
	     * @returns
	     */
	    serializeMessage(value) {
	        const messageBuffer = this.handler.serialize(value);
	        const byteLength = messageBuffer.byteLength;
	        const output = Buffer.allocUnsafe(byteLength + 5);
	        /* Note: response compression is currently not supported, so this
	         * compressed bit is always 0. */
	        output.writeUInt8(0, 0);
	        output.writeUInt32BE(byteLength, 1);
	        messageBuffer.copy(output, 5);
	        return output;
	    }
	    decompressMessage(message, encoding) {
	        const messageContents = message.subarray(5);
	        if (encoding === 'identity') {
	            return messageContents;
	        }
	        else if (encoding === 'deflate' || encoding === 'gzip') {
	            let decompresser;
	            if (encoding === 'deflate') {
	                decompresser = zlib.createInflate();
	            }
	            else {
	                decompresser = zlib.createGunzip();
	            }
	            return new Promise((resolve, reject) => {
	                let totalLength = 0;
	                const messageParts = [];
	                decompresser.on('data', (chunk) => {
	                    messageParts.push(chunk);
	                    totalLength += chunk.byteLength;
	                    if (this.maxReceiveMessageSize !== -1 && totalLength > this.maxReceiveMessageSize) {
	                        decompresser.destroy();
	                        reject({
	                            code: constants_1.Status.RESOURCE_EXHAUSTED,
	                            details: `Received message that decompresses to a size larger than ${this.maxReceiveMessageSize}`
	                        });
	                    }
	                });
	                decompresser.on('end', () => {
	                    resolve(Buffer.concat(messageParts));
	                });
	                decompresser.write(messageContents);
	                decompresser.end();
	            });
	        }
	        else {
	            return Promise.reject({
	                code: constants_1.Status.UNIMPLEMENTED,
	                details: `Received message compressed with unsupported encoding "${encoding}"`,
	            });
	        }
	    }
	    async decompressAndMaybePush(queueEntry) {
	        if (queueEntry.type !== 'COMPRESSED') {
	            throw new Error(`Invalid queue entry type: ${queueEntry.type}`);
	        }
	        const compressed = queueEntry.compressedMessage.readUInt8(0) === 1;
	        const compressedMessageEncoding = compressed
	            ? this.incomingEncoding
	            : 'identity';
	        let decompressedMessage;
	        try {
	            decompressedMessage = await this.decompressMessage(queueEntry.compressedMessage, compressedMessageEncoding);
	        }
	        catch (err) {
	            this.sendStatus(err);
	            return;
	        }
	        try {
	            queueEntry.parsedMessage = this.handler.deserialize(decompressedMessage);
	        }
	        catch (err) {
	            this.sendStatus({
	                code: constants_1.Status.INTERNAL,
	                details: `Error deserializing request: ${err.message}`,
	            });
	            return;
	        }
	        queueEntry.type = 'READABLE';
	        this.maybePushNextMessage();
	    }
	    maybePushNextMessage() {
	        if (this.listener &&
	            this.isReadPending &&
	            this.readQueue.length > 0 &&
	            this.readQueue[0].type !== 'COMPRESSED') {
	            this.isReadPending = false;
	            const nextQueueEntry = this.readQueue.shift();
	            if (nextQueueEntry.type === 'READABLE') {
	                this.listener.onReceiveMessage(nextQueueEntry.parsedMessage);
	            }
	            else {
	                // nextQueueEntry.type === 'HALF_CLOSE'
	                this.listener.onReceiveHalfClose();
	            }
	        }
	    }
	    handleDataFrame(data) {
	        var _a;
	        if (this.checkCancelled()) {
	            return;
	        }
	        trace('Request to ' +
	            this.handler.path +
	            ' received data frame of size ' +
	            data.length);
	        let rawMessages;
	        try {
	            rawMessages = this.decoder.write(data);
	        }
	        catch (e) {
	            this.sendStatus({ code: constants_1.Status.RESOURCE_EXHAUSTED, details: e.message });
	            return;
	        }
	        for (const messageBytes of rawMessages) {
	            this.stream.pause();
	            const queueEntry = {
	                type: 'COMPRESSED',
	                compressedMessage: messageBytes,
	                parsedMessage: null,
	            };
	            this.readQueue.push(queueEntry);
	            this.decompressAndMaybePush(queueEntry);
	            (_a = this.callEventTracker) === null || _a === undefined ? undefined : _a.addMessageReceived();
	        }
	    }
	    handleEndEvent() {
	        this.readQueue.push({
	            type: 'HALF_CLOSE',
	            compressedMessage: null,
	            parsedMessage: null,
	        });
	        this.receivedHalfClose = true;
	        this.maybePushNextMessage();
	    }
	    start(listener) {
	        trace('Request to ' + this.handler.path + ' start called');
	        if (this.checkCancelled()) {
	            return;
	        }
	        this.listener = listener;
	        listener.onReceiveMetadata(this.metadata);
	    }
	    sendMetadata(metadata) {
	        if (this.checkCancelled()) {
	            return;
	        }
	        if (this.metadataSent) {
	            return;
	        }
	        this.metadataSent = true;
	        const custom = metadata ? metadata.toHttp2Headers() : null;
	        const headers = Object.assign(Object.assign(Object.assign({}, defaultResponseHeaders), defaultCompressionHeaders), custom);
	        this.stream.respond(headers, defaultResponseOptions);
	    }
	    sendMessage(message, callback) {
	        if (this.checkCancelled()) {
	            return;
	        }
	        let response;
	        try {
	            response = this.serializeMessage(message);
	        }
	        catch (e) {
	            this.sendStatus({
	                code: constants_1.Status.INTERNAL,
	                details: `Error serializing response: ${(0, error_1.getErrorMessage)(e)}`,
	                metadata: null,
	            });
	            return;
	        }
	        if (this.maxSendMessageSize !== -1 &&
	            response.length - 5 > this.maxSendMessageSize) {
	            this.sendStatus({
	                code: constants_1.Status.RESOURCE_EXHAUSTED,
	                details: `Sent message larger than max (${response.length} vs. ${this.maxSendMessageSize})`,
	                metadata: null,
	            });
	            return;
	        }
	        this.maybeSendMetadata();
	        trace('Request to ' +
	            this.handler.path +
	            ' sent data frame of size ' +
	            response.length);
	        this.stream.write(response, error => {
	            var _a;
	            if (error) {
	                this.sendStatus({
	                    code: constants_1.Status.INTERNAL,
	                    details: `Error writing message: ${(0, error_1.getErrorMessage)(error)}`,
	                    metadata: null,
	                });
	                return;
	            }
	            (_a = this.callEventTracker) === null || _a === undefined ? undefined : _a.addMessageSent();
	            callback();
	        });
	    }
	    sendStatus(status) {
	        var _a, _b;
	        if (this.checkCancelled()) {
	            return;
	        }
	        trace('Request to method ' +
	            ((_a = this.handler) === null || _a === undefined ? undefined : _a.path) +
	            ' ended with status code: ' +
	            constants_1.Status[status.code] +
	            ' details: ' +
	            status.details);
	        if (this.metadataSent) {
	            if (!this.wantTrailers) {
	                this.wantTrailers = true;
	                this.stream.once('wantTrailers', () => {
	                    var _a;
	                    if (this.callEventTracker && !this.streamEnded) {
	                        this.streamEnded = true;
	                        this.callEventTracker.onStreamEnd(true);
	                        this.callEventTracker.onCallEnd(status);
	                    }
	                    const trailersToSend = Object.assign({ [GRPC_STATUS_HEADER]: status.code, [GRPC_MESSAGE_HEADER]: encodeURI(status.details) }, (_a = status.metadata) === null || _a === undefined ? undefined : _a.toHttp2Headers());
	                    this.stream.sendTrailers(trailersToSend);
	                    this.notifyOnCancel();
	                });
	                this.stream.end();
	            }
	            else {
	                this.notifyOnCancel();
	            }
	        }
	        else {
	            if (this.callEventTracker && !this.streamEnded) {
	                this.streamEnded = true;
	                this.callEventTracker.onStreamEnd(true);
	                this.callEventTracker.onCallEnd(status);
	            }
	            // Trailers-only response
	            const trailersToSend = Object.assign(Object.assign({ [GRPC_STATUS_HEADER]: status.code, [GRPC_MESSAGE_HEADER]: encodeURI(status.details) }, defaultResponseHeaders), (_b = status.metadata) === null || _b === undefined ? undefined : _b.toHttp2Headers());
	            this.stream.respond(trailersToSend, { endStream: true });
	            this.notifyOnCancel();
	        }
	    }
	    startRead() {
	        trace('Request to ' + this.handler.path + ' startRead called');
	        if (this.checkCancelled()) {
	            return;
	        }
	        this.isReadPending = true;
	        if (this.readQueue.length === 0) {
	            if (!this.receivedHalfClose) {
	                this.stream.resume();
	            }
	        }
	        else {
	            this.maybePushNextMessage();
	        }
	    }
	    getPeer() {
	        var _a;
	        const socket = (_a = this.stream.session) === null || _a === undefined ? undefined : _a.socket;
	        if (socket === null || socket === undefined ? undefined : socket.remoteAddress) {
	            if (socket.remotePort) {
	                return `${socket.remoteAddress}:${socket.remotePort}`;
	            }
	            else {
	                return socket.remoteAddress;
	            }
	        }
	        else {
	            return 'unknown';
	        }
	    }
	    getDeadline() {
	        return this.deadline;
	    }
	    getHost() {
	        return this.host;
	    }
	}
	serverInterceptors.BaseServerInterceptingCall = BaseServerInterceptingCall;
	function getServerInterceptingCall(interceptors, stream, headers, callEventTracker, handler, options) {
	    const methodDefinition = {
	        path: handler.path,
	        requestStream: handler.type === 'clientStream' || handler.type === 'bidi',
	        responseStream: handler.type === 'serverStream' || handler.type === 'bidi',
	        requestDeserialize: handler.deserialize,
	        responseSerialize: handler.serialize,
	    };
	    const baseCall = new BaseServerInterceptingCall(stream, headers, callEventTracker, handler, options);
	    return interceptors.reduce((call, interceptor) => {
	        return interceptor(methodDefinition, call);
	    }, baseCall);
	}
	serverInterceptors.getServerInterceptingCall = getServerInterceptingCall;
	
	return serverInterceptors;
}

var hasRequiredServer$1;

function requireServer$1 () {
	if (hasRequiredServer$1) return server;
	hasRequiredServer$1 = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	var __runInitializers = (commonjsGlobal && commonjsGlobal.__runInitializers) || function (thisArg, initializers, value) {
	    var useValue = arguments.length > 2;
	    for (var i = 0; i < initializers.length; i++) {
	        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
	    }
	    return useValue ? value : undefined;
	};
	var __esDecorate = (commonjsGlobal && commonjsGlobal.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
	    function accept(f) { if (f !== undefined && typeof f !== "function") throw new TypeError("Function expected"); return f; }
	    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
	    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
	    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
	    var _, done = false;
	    for (var i = decorators.length - 1; i >= 0; i--) {
	        var context = {};
	        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
	        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
	        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
	        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
	        if (kind === "accessor") {
	            if (result === undefined) continue;
	            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
	            if (_ = accept(result.get)) descriptor.get = _;
	            if (_ = accept(result.set)) descriptor.set = _;
	            if (_ = accept(result.init)) initializers.unshift(_);
	        }
	        else if (_ = accept(result)) {
	            if (kind === "field") initializers.unshift(_);
	            else descriptor[key] = _;
	        }
	    }
	    if (target) Object.defineProperty(target, contextIn.name, descriptor);
	    done = true;
	};
	Object.defineProperty(server, "__esModule", { value: true });
	server.Server = undefined;
	const http2 = require$$0$5;
	const util = require$$1$3;
	const constants_1 = requireConstants();
	const server_call_1 = requireServerCall();
	const server_credentials_1 = requireServerCredentials();
	const resolver_1 = requireResolver();
	const logging = requireLogging();
	const subchannel_address_1 = requireSubchannelAddress();
	const uri_parser_1 = requireUriParser();
	const channelz_1 = requireChannelz();
	const server_interceptors_1 = requireServerInterceptors();
	const UNLIMITED_CONNECTION_AGE_MS = 2147483647;
	const KEEPALIVE_MAX_TIME_MS = 2147483647;
	const KEEPALIVE_TIMEOUT_MS = 20000;
	const MAX_CONNECTION_IDLE_MS = 2147483647;
	const { HTTP2_HEADER_PATH } = http2.constants;
	const TRACER_NAME = 'server';
	const kMaxAge = Buffer.from('max_age');
	function noop() { }
	/**
	 * Decorator to wrap a class method with util.deprecate
	 * @param message The message to output if the deprecated method is called
	 * @returns
	 */
	function deprecate(message) {
	    return function (target, context) {
	        return util.deprecate(target, message);
	    };
	}
	function getUnimplementedStatusResponse(methodName) {
	    return {
	        code: constants_1.Status.UNIMPLEMENTED,
	        details: `The server does not implement the method ${methodName}`,
	    };
	}
	function getDefaultHandler(handlerType, methodName) {
	    const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);
	    switch (handlerType) {
	        case 'unary':
	            return (call, callback) => {
	                callback(unimplementedStatusResponse, null);
	            };
	        case 'clientStream':
	            return (call, callback) => {
	                callback(unimplementedStatusResponse, null);
	            };
	        case 'serverStream':
	            return (call) => {
	                call.emit('error', unimplementedStatusResponse);
	            };
	        case 'bidi':
	            return (call) => {
	                call.emit('error', unimplementedStatusResponse);
	            };
	        default:
	            throw new Error(`Invalid handlerType ${handlerType}`);
	    }
	}
	let Server = (() => {
	    var _a;
	    let _instanceExtraInitializers = [];
	    let _start_decorators;
	    return _a = class Server {
	            constructor(options) {
	                var _b, _c, _d, _e, _f, _g;
	                this.boundPorts = (__runInitializers(this, _instanceExtraInitializers), new Map());
	                this.http2Servers = new Map();
	                this.sessionIdleTimeouts = new Map();
	                this.handlers = new Map();
	                this.sessions = new Map();
	                /**
	                 * This field only exists to ensure that the start method throws an error if
	                 * it is called twice, as it did previously.
	                 */
	                this.started = false;
	                this.shutdown = false;
	                this.serverAddressString = 'null';
	                // Channelz Info
	                this.channelzEnabled = true;
	                this.options = options !== null && options !== undefined ? options : {};
	                if (this.options['grpc.enable_channelz'] === 0) {
	                    this.channelzEnabled = false;
	                    this.channelzTrace = new channelz_1.ChannelzTraceStub();
	                    this.callTracker = new channelz_1.ChannelzCallTrackerStub();
	                    this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTrackerStub();
	                    this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTrackerStub();
	                }
	                else {
	                    this.channelzTrace = new channelz_1.ChannelzTrace();
	                    this.callTracker = new channelz_1.ChannelzCallTracker();
	                    this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTracker();
	                    this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTracker();
	                }
	                this.channelzRef = (0, channelz_1.registerChannelzServer)('server', () => this.getChannelzInfo(), this.channelzEnabled);
	                this.channelzTrace.addTrace('CT_INFO', 'Server created');
	                this.maxConnectionAgeMs =
	                    (_b = this.options['grpc.max_connection_age_ms']) !== null && _b !== undefined ? _b : UNLIMITED_CONNECTION_AGE_MS;
	                this.maxConnectionAgeGraceMs =
	                    (_c = this.options['grpc.max_connection_age_grace_ms']) !== null && _c !== undefined ? _c : UNLIMITED_CONNECTION_AGE_MS;
	                this.keepaliveTimeMs =
	                    (_d = this.options['grpc.keepalive_time_ms']) !== null && _d !== undefined ? _d : KEEPALIVE_MAX_TIME_MS;
	                this.keepaliveTimeoutMs =
	                    (_e = this.options['grpc.keepalive_timeout_ms']) !== null && _e !== undefined ? _e : KEEPALIVE_TIMEOUT_MS;
	                this.sessionIdleTimeout =
	                    (_f = this.options['grpc.max_connection_idle_ms']) !== null && _f !== undefined ? _f : MAX_CONNECTION_IDLE_MS;
	                this.commonServerOptions = {
	                    maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER,
	                };
	                if ('grpc-node.max_session_memory' in this.options) {
	                    this.commonServerOptions.maxSessionMemory =
	                        this.options['grpc-node.max_session_memory'];
	                }
	                else {
	                    /* By default, set a very large max session memory limit, to effectively
	                     * disable enforcement of the limit. Some testing indicates that Node's
	                     * behavior degrades badly when this limit is reached, so we solve that
	                     * by disabling the check entirely. */
	                    this.commonServerOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;
	                }
	                if ('grpc.max_concurrent_streams' in this.options) {
	                    this.commonServerOptions.settings = {
	                        maxConcurrentStreams: this.options['grpc.max_concurrent_streams'],
	                    };
	                }
	                this.interceptors = (_g = this.options.interceptors) !== null && _g !== undefined ? _g : [];
	                this.trace('Server constructed');
	            }
	            getChannelzInfo() {
	                return {
	                    trace: this.channelzTrace,
	                    callTracker: this.callTracker,
	                    listenerChildren: this.listenerChildrenTracker.getChildLists(),
	                    sessionChildren: this.sessionChildrenTracker.getChildLists(),
	                };
	            }
	            getChannelzSessionInfo(session) {
	                var _b, _c, _d;
	                const sessionInfo = this.sessions.get(session);
	                const sessionSocket = session.socket;
	                const remoteAddress = sessionSocket.remoteAddress
	                    ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort)
	                    : null;
	                const localAddress = sessionSocket.localAddress
	                    ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort)
	                    : null;
	                let tlsInfo;
	                if (session.encrypted) {
	                    const tlsSocket = sessionSocket;
	                    const cipherInfo = tlsSocket.getCipher();
	                    const certificate = tlsSocket.getCertificate();
	                    const peerCertificate = tlsSocket.getPeerCertificate();
	                    tlsInfo = {
	                        cipherSuiteStandardName: (_b = cipherInfo.standardName) !== null && _b !== undefined ? _b : null,
	                        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,
	                        localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,
	                        remoteCertificate: peerCertificate && 'raw' in peerCertificate
	                            ? peerCertificate.raw
	                            : null,
	                    };
	                }
	                else {
	                    tlsInfo = null;
	                }
	                const socketInfo = {
	                    remoteAddress: remoteAddress,
	                    localAddress: localAddress,
	                    security: tlsInfo,
	                    remoteName: null,
	                    streamsStarted: sessionInfo.streamTracker.callsStarted,
	                    streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,
	                    streamsFailed: sessionInfo.streamTracker.callsFailed,
	                    messagesSent: sessionInfo.messagesSent,
	                    messagesReceived: sessionInfo.messagesReceived,
	                    keepAlivesSent: sessionInfo.keepAlivesSent,
	                    lastLocalStreamCreatedTimestamp: null,
	                    lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,
	                    lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,
	                    lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,
	                    localFlowControlWindow: (_c = session.state.localWindowSize) !== null && _c !== undefined ? _c : null,
	                    remoteFlowControlWindow: (_d = session.state.remoteWindowSize) !== null && _d !== undefined ? _d : null,
	                };
	                return socketInfo;
	            }
	            trace(text) {
	                logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + text);
	            }
	            keepaliveTrace(text) {
	                logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' + this.channelzRef.id + ') ' + text);
	            }
	            addProtoService() {
	                throw new Error('Not implemented. Use addService() instead');
	            }
	            addService(service, implementation) {
	                if (service === null ||
	                    typeof service !== 'object' ||
	                    implementation === null ||
	                    typeof implementation !== 'object') {
	                    throw new Error('addService() requires two objects as arguments');
	                }
	                const serviceKeys = Object.keys(service);
	                if (serviceKeys.length === 0) {
	                    throw new Error('Cannot add an empty service to a server');
	                }
	                serviceKeys.forEach(name => {
	                    const attrs = service[name];
	                    let methodType;
	                    if (attrs.requestStream) {
	                        if (attrs.responseStream) {
	                            methodType = 'bidi';
	                        }
	                        else {
	                            methodType = 'clientStream';
	                        }
	                    }
	                    else {
	                        if (attrs.responseStream) {
	                            methodType = 'serverStream';
	                        }
	                        else {
	                            methodType = 'unary';
	                        }
	                    }
	                    let implFn = implementation[name];
	                    let impl;
	                    if (implFn === undefined && typeof attrs.originalName === 'string') {
	                        implFn = implementation[attrs.originalName];
	                    }
	                    if (implFn !== undefined) {
	                        impl = implFn.bind(implementation);
	                    }
	                    else {
	                        impl = getDefaultHandler(methodType, name);
	                    }
	                    const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);
	                    if (success === false) {
	                        throw new Error(`Method handler for ${attrs.path} already provided.`);
	                    }
	                });
	            }
	            removeService(service) {
	                if (service === null || typeof service !== 'object') {
	                    throw new Error('removeService() requires object as argument');
	                }
	                const serviceKeys = Object.keys(service);
	                serviceKeys.forEach(name => {
	                    const attrs = service[name];
	                    this.unregister(attrs.path);
	                });
	            }
	            bind(port, creds) {
	                throw new Error('Not implemented. Use bindAsync() instead');
	            }
	            registerListenerToChannelz(boundAddress) {
	                return (0, channelz_1.registerChannelzSocket)((0, subchannel_address_1.subchannelAddressToString)(boundAddress), () => {
	                    return {
	                        localAddress: boundAddress,
	                        remoteAddress: null,
	                        security: null,
	                        remoteName: null,
	                        streamsStarted: 0,
	                        streamsSucceeded: 0,
	                        streamsFailed: 0,
	                        messagesSent: 0,
	                        messagesReceived: 0,
	                        keepAlivesSent: 0,
	                        lastLocalStreamCreatedTimestamp: null,
	                        lastRemoteStreamCreatedTimestamp: null,
	                        lastMessageSentTimestamp: null,
	                        lastMessageReceivedTimestamp: null,
	                        localFlowControlWindow: null,
	                        remoteFlowControlWindow: null,
	                    };
	                }, this.channelzEnabled);
	            }
	            createHttp2Server(credentials) {
	                let http2Server;
	                if (credentials._isSecure()) {
	                    const credentialsSettings = credentials._getSettings();
	                    const secureServerOptions = Object.assign(Object.assign(Object.assign({}, this.commonServerOptions), credentialsSettings), { enableTrace: this.options['grpc-node.tls_enable_trace'] === 1 });
	                    let areCredentialsValid = credentialsSettings !== null;
	                    http2Server = http2.createSecureServer(secureServerOptions);
	                    http2Server.on('connection', (socket) => {
	                        if (!areCredentialsValid) {
	                            socket.destroy();
	                        }
	                    });
	                    http2Server.on('secureConnection', (socket) => {
	                        /* These errors need to be handled by the user of Http2SecureServer,
	                         * according to https://github.com/nodejs/node/issues/35824 */
	                        socket.on('error', (e) => {
	                            this.trace('An incoming TLS connection closed with error: ' + e.message);
	                        });
	                    });
	                    const credsWatcher = options => {
	                        if (options) {
	                            http2Server.setSecureContext(options);
	                        }
	                        areCredentialsValid = options !== null;
	                    };
	                    credentials._addWatcher(credsWatcher);
	                    http2Server.on('close', () => {
	                        credentials._removeWatcher(credsWatcher);
	                    });
	                }
	                else {
	                    http2Server = http2.createServer(this.commonServerOptions);
	                }
	                http2Server.setTimeout(0, noop);
	                this._setupHandlers(http2Server, credentials._getInterceptors());
	                return http2Server;
	            }
	            bindOneAddress(address, boundPortObject) {
	                this.trace('Attempting to bind ' + (0, subchannel_address_1.subchannelAddressToString)(address));
	                const http2Server = this.createHttp2Server(boundPortObject.credentials);
	                return new Promise((resolve, reject) => {
	                    const onError = (err) => {
	                        this.trace('Failed to bind ' +
	                            (0, subchannel_address_1.subchannelAddressToString)(address) +
	                            ' with error ' +
	                            err.message);
	                        resolve({
	                            port: 'port' in address ? address.port : 1,
	                            error: err.message,
	                        });
	                    };
	                    http2Server.once('error', onError);
	                    http2Server.listen(address, () => {
	                        const boundAddress = http2Server.address();
	                        let boundSubchannelAddress;
	                        if (typeof boundAddress === 'string') {
	                            boundSubchannelAddress = {
	                                path: boundAddress,
	                            };
	                        }
	                        else {
	                            boundSubchannelAddress = {
	                                host: boundAddress.address,
	                                port: boundAddress.port,
	                            };
	                        }
	                        const channelzRef = this.registerListenerToChannelz(boundSubchannelAddress);
	                        this.listenerChildrenTracker.refChild(channelzRef);
	                        this.http2Servers.set(http2Server, {
	                            channelzRef: channelzRef,
	                            sessions: new Set(),
	                        });
	                        boundPortObject.listeningServers.add(http2Server);
	                        this.trace('Successfully bound ' +
	                            (0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress));
	                        resolve({
	                            port: 'port' in boundSubchannelAddress ? boundSubchannelAddress.port : 1,
	                        });
	                        http2Server.removeListener('error', onError);
	                    });
	                });
	            }
	            async bindManyPorts(addressList, boundPortObject) {
	                if (addressList.length === 0) {
	                    return {
	                        count: 0,
	                        port: 0,
	                        errors: [],
	                    };
	                }
	                if ((0, subchannel_address_1.isTcpSubchannelAddress)(addressList[0]) && addressList[0].port === 0) {
	                    /* If binding to port 0, first try to bind the first address, then bind
	                     * the rest of the address list to the specific port that it binds. */
	                    const firstAddressResult = await this.bindOneAddress(addressList[0], boundPortObject);
	                    if (firstAddressResult.error) {
	                        /* If the first address fails to bind, try the same operation starting
	                         * from the second item in the list. */
	                        const restAddressResult = await this.bindManyPorts(addressList.slice(1), boundPortObject);
	                        return Object.assign(Object.assign({}, restAddressResult), { errors: [firstAddressResult.error, ...restAddressResult.errors] });
	                    }
	                    else {
	                        const restAddresses = addressList
	                            .slice(1)
	                            .map(address => (0, subchannel_address_1.isTcpSubchannelAddress)(address)
	                            ? { host: address.host, port: firstAddressResult.port }
	                            : address);
	                        const restAddressResult = await Promise.all(restAddresses.map(address => this.bindOneAddress(address, boundPortObject)));
	                        const allResults = [firstAddressResult, ...restAddressResult];
	                        return {
	                            count: allResults.filter(result => result.error === undefined).length,
	                            port: firstAddressResult.port,
	                            errors: allResults
	                                .filter(result => result.error)
	                                .map(result => result.error),
	                        };
	                    }
	                }
	                else {
	                    const allResults = await Promise.all(addressList.map(address => this.bindOneAddress(address, boundPortObject)));
	                    return {
	                        count: allResults.filter(result => result.error === undefined).length,
	                        port: allResults[0].port,
	                        errors: allResults
	                            .filter(result => result.error)
	                            .map(result => result.error),
	                    };
	                }
	            }
	            async bindAddressList(addressList, boundPortObject) {
	                const bindResult = await this.bindManyPorts(addressList, boundPortObject);
	                if (bindResult.count > 0) {
	                    if (bindResult.count < addressList.length) {
	                        logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);
	                    }
	                    return bindResult.port;
	                }
	                else {
	                    const errorString = `No address added out of total ${addressList.length} resolved`;
	                    logging.log(constants_1.LogVerbosity.ERROR, errorString);
	                    throw new Error(`${errorString} errors: [${bindResult.errors.join(',')}]`);
	                }
	            }
	            resolvePort(port) {
	                return new Promise((resolve, reject) => {
	                    const resolverListener = {
	                        onSuccessfulResolution: (endpointList, serviceConfig, serviceConfigError) => {
	                            // We only want one resolution result. Discard all future results
	                            resolverListener.onSuccessfulResolution = () => { };
	                            const addressList = [].concat(...endpointList.map(endpoint => endpoint.addresses));
	                            if (addressList.length === 0) {
	                                reject(new Error(`No addresses resolved for port ${port}`));
	                                return;
	                            }
	                            resolve(addressList);
	                        },
	                        onError: error => {
	                            reject(new Error(error.details));
	                        },
	                    };
	                    const resolver = (0, resolver_1.createResolver)(port, resolverListener, this.options);
	                    resolver.updateResolution();
	                });
	            }
	            async bindPort(port, boundPortObject) {
	                const addressList = await this.resolvePort(port);
	                if (boundPortObject.cancelled) {
	                    this.completeUnbind(boundPortObject);
	                    throw new Error('bindAsync operation cancelled by unbind call');
	                }
	                const portNumber = await this.bindAddressList(addressList, boundPortObject);
	                if (boundPortObject.cancelled) {
	                    this.completeUnbind(boundPortObject);
	                    throw new Error('bindAsync operation cancelled by unbind call');
	                }
	                return portNumber;
	            }
	            normalizePort(port) {
	                const initialPortUri = (0, uri_parser_1.parseUri)(port);
	                if (initialPortUri === null) {
	                    throw new Error(`Could not parse port "${port}"`);
	                }
	                const portUri = (0, resolver_1.mapUriDefaultScheme)(initialPortUri);
	                if (portUri === null) {
	                    throw new Error(`Could not get a default scheme for port "${port}"`);
	                }
	                return portUri;
	            }
	            bindAsync(port, creds, callback) {
	                if (this.shutdown) {
	                    throw new Error('bindAsync called after shutdown');
	                }
	                if (typeof port !== 'string') {
	                    throw new TypeError('port must be a string');
	                }
	                if (creds === null || !(creds instanceof server_credentials_1.ServerCredentials)) {
	                    throw new TypeError('creds must be a ServerCredentials object');
	                }
	                if (typeof callback !== 'function') {
	                    throw new TypeError('callback must be a function');
	                }
	                this.trace('bindAsync port=' + port);
	                const portUri = this.normalizePort(port);
	                const deferredCallback = (error, port) => {
	                    process.nextTick(() => callback(error, port));
	                };
	                /* First, if this port is already bound or that bind operation is in
	                 * progress, use that result. */
	                let boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));
	                if (boundPortObject) {
	                    if (!creds._equals(boundPortObject.credentials)) {
	                        deferredCallback(new Error(`${port} already bound with incompatible credentials`), 0);
	                        return;
	                    }
	                    /* If that operation has previously been cancelled by an unbind call,
	                     * uncancel it. */
	                    boundPortObject.cancelled = false;
	                    if (boundPortObject.completionPromise) {
	                        boundPortObject.completionPromise.then(portNum => callback(null, portNum), error => callback(error, 0));
	                    }
	                    else {
	                        deferredCallback(null, boundPortObject.portNumber);
	                    }
	                    return;
	                }
	                boundPortObject = {
	                    mapKey: (0, uri_parser_1.uriToString)(portUri),
	                    originalUri: portUri,
	                    completionPromise: null,
	                    cancelled: false,
	                    portNumber: 0,
	                    credentials: creds,
	                    listeningServers: new Set(),
	                };
	                const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);
	                const completionPromise = this.bindPort(portUri, boundPortObject);
	                boundPortObject.completionPromise = completionPromise;
	                /* If the port number is 0, defer populating the map entry until after the
	                 * bind operation completes and we have a specific port number. Otherwise,
	                 * populate it immediately. */
	                if ((splitPort === null || splitPort === undefined ? undefined : splitPort.port) === 0) {
	                    completionPromise.then(portNum => {
	                        const finalUri = {
	                            scheme: portUri.scheme,
	                            authority: portUri.authority,
	                            path: (0, uri_parser_1.combineHostPort)({ host: splitPort.host, port: portNum }),
	                        };
	                        boundPortObject.mapKey = (0, uri_parser_1.uriToString)(finalUri);
	                        boundPortObject.completionPromise = null;
	                        boundPortObject.portNumber = portNum;
	                        this.boundPorts.set(boundPortObject.mapKey, boundPortObject);
	                        callback(null, portNum);
	                    }, error => {
	                        callback(error, 0);
	                    });
	                }
	                else {
	                    this.boundPorts.set(boundPortObject.mapKey, boundPortObject);
	                    completionPromise.then(portNum => {
	                        boundPortObject.completionPromise = null;
	                        boundPortObject.portNumber = portNum;
	                        callback(null, portNum);
	                    }, error => {
	                        callback(error, 0);
	                    });
	                }
	            }
	            registerInjectorToChannelz() {
	                return (0, channelz_1.registerChannelzSocket)('injector', () => {
	                    return {
	                        localAddress: null,
	                        remoteAddress: null,
	                        security: null,
	                        remoteName: null,
	                        streamsStarted: 0,
	                        streamsSucceeded: 0,
	                        streamsFailed: 0,
	                        messagesSent: 0,
	                        messagesReceived: 0,
	                        keepAlivesSent: 0,
	                        lastLocalStreamCreatedTimestamp: null,
	                        lastRemoteStreamCreatedTimestamp: null,
	                        lastMessageSentTimestamp: null,
	                        lastMessageReceivedTimestamp: null,
	                        localFlowControlWindow: null,
	                        remoteFlowControlWindow: null,
	                    };
	                }, this.channelzEnabled);
	            }
	            createConnectionInjector(credentials) {
	                if (credentials === null || !(credentials instanceof server_credentials_1.ServerCredentials)) {
	                    throw new TypeError('creds must be a ServerCredentials object');
	                }
	                const server = this.createHttp2Server(credentials);
	                const channelzRef = this.registerInjectorToChannelz();
	                if (this.channelzEnabled) {
	                    this.listenerChildrenTracker.refChild(channelzRef);
	                }
	                const sessionsSet = new Set();
	                this.http2Servers.set(server, {
	                    channelzRef: channelzRef,
	                    sessions: sessionsSet
	                });
	                return {
	                    injectConnection: (connection) => {
	                        server.emit('connection', connection);
	                    },
	                    drain: (graceTimeMs) => {
	                        var _b, _c;
	                        for (const session of sessionsSet) {
	                            this.closeSession(session);
	                        }
	                        (_c = (_b = setTimeout(() => {
	                            for (const session of sessionsSet) {
	                                session.destroy(http2.constants.NGHTTP2_CANCEL);
	                            }
	                        }, graceTimeMs)).unref) === null || _c === undefined ? undefined : _c.call(_b);
	                    },
	                    destroy: () => {
	                        this.closeServer(server);
	                        for (const session of sessionsSet) {
	                            this.closeSession(session);
	                        }
	                    }
	                };
	            }
	            closeServer(server, callback) {
	                this.trace('Closing server with address ' + JSON.stringify(server.address()));
	                const serverInfo = this.http2Servers.get(server);
	                server.close(() => {
	                    if (serverInfo) {
	                        this.listenerChildrenTracker.unrefChild(serverInfo.channelzRef);
	                        (0, channelz_1.unregisterChannelzRef)(serverInfo.channelzRef);
	                    }
	                    this.http2Servers.delete(server);
	                    callback === null || callback === undefined ? undefined : callback();
	                });
	            }
	            closeSession(session, callback) {
	                var _b;
	                this.trace('Closing session initiated by ' + ((_b = session.socket) === null || _b === undefined ? undefined : _b.remoteAddress));
	                const sessionInfo = this.sessions.get(session);
	                const closeCallback = () => {
	                    if (sessionInfo) {
	                        this.sessionChildrenTracker.unrefChild(sessionInfo.ref);
	                        (0, channelz_1.unregisterChannelzRef)(sessionInfo.ref);
	                    }
	                    callback === null || callback === undefined ? undefined : callback();
	                };
	                if (session.closed) {
	                    queueMicrotask(closeCallback);
	                }
	                else {
	                    session.close(closeCallback);
	                }
	            }
	            completeUnbind(boundPortObject) {
	                for (const server of boundPortObject.listeningServers) {
	                    const serverInfo = this.http2Servers.get(server);
	                    this.closeServer(server, () => {
	                        boundPortObject.listeningServers.delete(server);
	                    });
	                    if (serverInfo) {
	                        for (const session of serverInfo.sessions) {
	                            this.closeSession(session);
	                        }
	                    }
	                }
	                this.boundPorts.delete(boundPortObject.mapKey);
	            }
	            /**
	             * Unbind a previously bound port, or cancel an in-progress bindAsync
	             * operation. If port 0 was bound, only the actual bound port can be
	             * unbound. For example, if bindAsync was called with "localhost:0" and the
	             * bound port result was 54321, it can be unbound as "localhost:54321".
	             * @param port
	             */
	            unbind(port) {
	                this.trace('unbind port=' + port);
	                const portUri = this.normalizePort(port);
	                const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);
	                if ((splitPort === null || splitPort === undefined ? undefined : splitPort.port) === 0) {
	                    throw new Error('Cannot unbind port 0');
	                }
	                const boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));
	                if (boundPortObject) {
	                    this.trace('unbinding ' +
	                        boundPortObject.mapKey +
	                        ' originally bound as ' +
	                        (0, uri_parser_1.uriToString)(boundPortObject.originalUri));
	                    /* If the bind operation is pending, the cancelled flag will trigger
	                     * the unbind operation later. */
	                    if (boundPortObject.completionPromise) {
	                        boundPortObject.cancelled = true;
	                    }
	                    else {
	                        this.completeUnbind(boundPortObject);
	                    }
	                }
	            }
	            /**
	             * Gracefully close all connections associated with a previously bound port.
	             * After the grace time, forcefully close all remaining open connections.
	             *
	             * If port 0 was bound, only the actual bound port can be
	             * drained. For example, if bindAsync was called with "localhost:0" and the
	             * bound port result was 54321, it can be drained as "localhost:54321".
	             * @param port
	             * @param graceTimeMs
	             * @returns
	             */
	            drain(port, graceTimeMs) {
	                var _b, _c;
	                this.trace('drain port=' + port + ' graceTimeMs=' + graceTimeMs);
	                const portUri = this.normalizePort(port);
	                const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);
	                if ((splitPort === null || splitPort === undefined ? undefined : splitPort.port) === 0) {
	                    throw new Error('Cannot drain port 0');
	                }
	                const boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));
	                if (!boundPortObject) {
	                    return;
	                }
	                const allSessions = new Set();
	                for (const http2Server of boundPortObject.listeningServers) {
	                    const serverEntry = this.http2Servers.get(http2Server);
	                    if (serverEntry) {
	                        for (const session of serverEntry.sessions) {
	                            allSessions.add(session);
	                            this.closeSession(session, () => {
	                                allSessions.delete(session);
	                            });
	                        }
	                    }
	                }
	                /* After the grace time ends, send another goaway to all remaining sessions
	                 * with the CANCEL code. */
	                (_c = (_b = setTimeout(() => {
	                    for (const session of allSessions) {
	                        session.destroy(http2.constants.NGHTTP2_CANCEL);
	                    }
	                }, graceTimeMs)).unref) === null || _c === undefined ? undefined : _c.call(_b);
	            }
	            forceShutdown() {
	                for (const boundPortObject of this.boundPorts.values()) {
	                    boundPortObject.cancelled = true;
	                }
	                this.boundPorts.clear();
	                // Close the server if it is still running.
	                for (const server of this.http2Servers.keys()) {
	                    this.closeServer(server);
	                }
	                // Always destroy any available sessions. It's possible that one or more
	                // tryShutdown() calls are in progress. Don't wait on them to finish.
	                this.sessions.forEach((channelzInfo, session) => {
	                    this.closeSession(session);
	                    // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to
	                    // recognize destroy(code) as a valid signature.
	                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	                    session.destroy(http2.constants.NGHTTP2_CANCEL);
	                });
	                this.sessions.clear();
	                (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
	                this.shutdown = true;
	            }
	            register(name, handler, serialize, deserialize, type) {
	                if (this.handlers.has(name)) {
	                    return false;
	                }
	                this.handlers.set(name, {
	                    func: handler,
	                    serialize,
	                    deserialize,
	                    type,
	                    path: name,
	                });
	                return true;
	            }
	            unregister(name) {
	                return this.handlers.delete(name);
	            }
	            /**
	             * @deprecated No longer needed as of version 1.10.x
	             */
	            start() {
	                if (this.http2Servers.size === 0 ||
	                    [...this.http2Servers.keys()].every(server => !server.listening)) {
	                    throw new Error('server must be bound in order to start');
	                }
	                if (this.started === true) {
	                    throw new Error('server is already started');
	                }
	                this.started = true;
	            }
	            tryShutdown(callback) {
	                var _b;
	                const wrappedCallback = (error) => {
	                    (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
	                    callback(error);
	                };
	                let pendingChecks = 0;
	                function maybeCallback() {
	                    pendingChecks--;
	                    if (pendingChecks === 0) {
	                        wrappedCallback();
	                    }
	                }
	                this.shutdown = true;
	                for (const [serverKey, server] of this.http2Servers.entries()) {
	                    pendingChecks++;
	                    const serverString = server.channelzRef.name;
	                    this.trace('Waiting for server ' + serverString + ' to close');
	                    this.closeServer(serverKey, () => {
	                        this.trace('Server ' + serverString + ' finished closing');
	                        maybeCallback();
	                    });
	                    for (const session of server.sessions.keys()) {
	                        pendingChecks++;
	                        const sessionString = (_b = session.socket) === null || _b === undefined ? undefined : _b.remoteAddress;
	                        this.trace('Waiting for session ' + sessionString + ' to close');
	                        this.closeSession(session, () => {
	                            this.trace('Session ' + sessionString + ' finished closing');
	                            maybeCallback();
	                        });
	                    }
	                }
	                if (pendingChecks === 0) {
	                    wrappedCallback();
	                }
	            }
	            addHttp2Port() {
	                throw new Error('Not yet implemented');
	            }
	            /**
	             * Get the channelz reference object for this server. The returned value is
	             * garbage if channelz is disabled for this server.
	             * @returns
	             */
	            getChannelzRef() {
	                return this.channelzRef;
	            }
	            _verifyContentType(stream, headers) {
	                const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];
	                if (typeof contentType !== 'string' ||
	                    !contentType.startsWith('application/grpc')) {
	                    stream.respond({
	                        [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE,
	                    }, { endStream: true });
	                    return false;
	                }
	                return true;
	            }
	            _retrieveHandler(path) {
	                this.trace('Received call to method ' +
	                    path +
	                    ' at address ' +
	                    this.serverAddressString);
	                const handler = this.handlers.get(path);
	                if (handler === undefined) {
	                    this.trace('No handler registered for method ' +
	                        path +
	                        '. Sending UNIMPLEMENTED status.');
	                    return null;
	                }
	                return handler;
	            }
	            _respondWithError(err, stream, channelzSessionInfo = null) {
	                var _b, _c;
	                const trailersToSend = Object.assign({ 'grpc-status': (_b = err.code) !== null && _b !== undefined ? _b : constants_1.Status.INTERNAL, 'grpc-message': err.details, [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK, [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto' }, (_c = err.metadata) === null || _c === undefined ? undefined : _c.toHttp2Headers());
	                stream.respond(trailersToSend, { endStream: true });
	                this.callTracker.addCallFailed();
	                channelzSessionInfo === null || channelzSessionInfo === undefined ? undefined : channelzSessionInfo.streamTracker.addCallFailed();
	            }
	            _channelzHandler(extraInterceptors, stream, headers) {
	                // for handling idle timeout
	                this.onStreamOpened(stream);
	                const channelzSessionInfo = this.sessions.get(stream.session);
	                this.callTracker.addCallStarted();
	                channelzSessionInfo === null || channelzSessionInfo === undefined ? undefined : channelzSessionInfo.streamTracker.addCallStarted();
	                if (!this._verifyContentType(stream, headers)) {
	                    this.callTracker.addCallFailed();
	                    channelzSessionInfo === null || channelzSessionInfo === undefined ? undefined : channelzSessionInfo.streamTracker.addCallFailed();
	                    return;
	                }
	                const path = headers[HTTP2_HEADER_PATH];
	                const handler = this._retrieveHandler(path);
	                if (!handler) {
	                    this._respondWithError(getUnimplementedStatusResponse(path), stream, channelzSessionInfo);
	                    return;
	                }
	                const callEventTracker = {
	                    addMessageSent: () => {
	                        if (channelzSessionInfo) {
	                            channelzSessionInfo.messagesSent += 1;
	                            channelzSessionInfo.lastMessageSentTimestamp = new Date();
	                        }
	                    },
	                    addMessageReceived: () => {
	                        if (channelzSessionInfo) {
	                            channelzSessionInfo.messagesReceived += 1;
	                            channelzSessionInfo.lastMessageReceivedTimestamp = new Date();
	                        }
	                    },
	                    onCallEnd: status => {
	                        if (status.code === constants_1.Status.OK) {
	                            this.callTracker.addCallSucceeded();
	                        }
	                        else {
	                            this.callTracker.addCallFailed();
	                        }
	                    },
	                    onStreamEnd: success => {
	                        if (channelzSessionInfo) {
	                            if (success) {
	                                channelzSessionInfo.streamTracker.addCallSucceeded();
	                            }
	                            else {
	                                channelzSessionInfo.streamTracker.addCallFailed();
	                            }
	                        }
	                    },
	                };
	                const call = (0, server_interceptors_1.getServerInterceptingCall)([...extraInterceptors, ...this.interceptors], stream, headers, callEventTracker, handler, this.options);
	                if (!this._runHandlerForCall(call, handler)) {
	                    this.callTracker.addCallFailed();
	                    channelzSessionInfo === null || channelzSessionInfo === undefined ? undefined : channelzSessionInfo.streamTracker.addCallFailed();
	                    call.sendStatus({
	                        code: constants_1.Status.INTERNAL,
	                        details: `Unknown handler type: ${handler.type}`,
	                    });
	                }
	            }
	            _streamHandler(extraInterceptors, stream, headers) {
	                // for handling idle timeout
	                this.onStreamOpened(stream);
	                if (this._verifyContentType(stream, headers) !== true) {
	                    return;
	                }
	                const path = headers[HTTP2_HEADER_PATH];
	                const handler = this._retrieveHandler(path);
	                if (!handler) {
	                    this._respondWithError(getUnimplementedStatusResponse(path), stream, null);
	                    return;
	                }
	                const call = (0, server_interceptors_1.getServerInterceptingCall)([...extraInterceptors, ...this.interceptors], stream, headers, null, handler, this.options);
	                if (!this._runHandlerForCall(call, handler)) {
	                    call.sendStatus({
	                        code: constants_1.Status.INTERNAL,
	                        details: `Unknown handler type: ${handler.type}`,
	                    });
	                }
	            }
	            _runHandlerForCall(call, handler) {
	                const { type } = handler;
	                if (type === 'unary') {
	                    handleUnary(call, handler);
	                }
	                else if (type === 'clientStream') {
	                    handleClientStreaming(call, handler);
	                }
	                else if (type === 'serverStream') {
	                    handleServerStreaming(call, handler);
	                }
	                else if (type === 'bidi') {
	                    handleBidiStreaming(call, handler);
	                }
	                else {
	                    return false;
	                }
	                return true;
	            }
	            _setupHandlers(http2Server, extraInterceptors) {
	                if (http2Server === null) {
	                    return;
	                }
	                const serverAddress = http2Server.address();
	                let serverAddressString = 'null';
	                if (serverAddress) {
	                    if (typeof serverAddress === 'string') {
	                        serverAddressString = serverAddress;
	                    }
	                    else {
	                        serverAddressString = serverAddress.address + ':' + serverAddress.port;
	                    }
	                }
	                this.serverAddressString = serverAddressString;
	                const handler = this.channelzEnabled
	                    ? this._channelzHandler
	                    : this._streamHandler;
	                const sessionHandler = this.channelzEnabled
	                    ? this._channelzSessionHandler(http2Server)
	                    : this._sessionHandler(http2Server);
	                http2Server.on('stream', handler.bind(this, extraInterceptors));
	                http2Server.on('session', sessionHandler);
	            }
	            _sessionHandler(http2Server) {
	                return (session) => {
	                    var _b, _c;
	                    (_b = this.http2Servers.get(http2Server)) === null || _b === undefined ? undefined : _b.sessions.add(session);
	                    let connectionAgeTimer = null;
	                    let connectionAgeGraceTimer = null;
	                    let keepaliveTimer = null;
	                    let sessionClosedByServer = false;
	                    const idleTimeoutObj = this.enableIdleTimeout(session);
	                    if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {
	                        // Apply a random jitter within a +/-10% range
	                        const jitterMagnitude = this.maxConnectionAgeMs / 10;
	                        const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;
	                        connectionAgeTimer = setTimeout(() => {
	                            var _b, _c;
	                            sessionClosedByServer = true;
	                            this.trace('Connection dropped by max connection age: ' +
	                                ((_b = session.socket) === null || _b === undefined ? undefined : _b.remoteAddress));
	                            try {
	                                session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 << 31), kMaxAge);
	                            }
	                            catch (e) {
	                                // The goaway can't be sent because the session is already closed
	                                session.destroy();
	                                return;
	                            }
	                            session.close();
	                            /* Allow a grace period after sending the GOAWAY before forcibly
	                             * closing the connection. */
	                            if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {
	                                connectionAgeGraceTimer = setTimeout(() => {
	                                    session.destroy();
	                                }, this.maxConnectionAgeGraceMs);
	                                (_c = connectionAgeGraceTimer.unref) === null || _c === undefined ? undefined : _c.call(connectionAgeGraceTimer);
	                            }
	                        }, this.maxConnectionAgeMs + jitter);
	                        (_c = connectionAgeTimer.unref) === null || _c === undefined ? undefined : _c.call(connectionAgeTimer);
	                    }
	                    const clearKeepaliveTimeout = () => {
	                        if (keepaliveTimer) {
	                            clearTimeout(keepaliveTimer);
	                            keepaliveTimer = null;
	                        }
	                    };
	                    const canSendPing = () => {
	                        return (!session.destroyed &&
	                            this.keepaliveTimeMs < KEEPALIVE_MAX_TIME_MS &&
	                            this.keepaliveTimeMs > 0);
	                    };
	                    /* eslint-disable-next-line prefer-const */
	                    let sendPing; // hoisted for use in maybeStartKeepalivePingTimer
	                    const maybeStartKeepalivePingTimer = () => {
	                        var _b;
	                        if (!canSendPing()) {
	                            return;
	                        }
	                        this.keepaliveTrace('Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms');
	                        keepaliveTimer = setTimeout(() => {
	                            clearKeepaliveTimeout();
	                            sendPing();
	                        }, this.keepaliveTimeMs);
	                        (_b = keepaliveTimer.unref) === null || _b === undefined ? undefined : _b.call(keepaliveTimer);
	                    };
	                    sendPing = () => {
	                        var _b;
	                        if (!canSendPing()) {
	                            return;
	                        }
	                        this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');
	                        let pingSendError = '';
	                        try {
	                            const pingSentSuccessfully = session.ping((err, duration, payload) => {
	                                clearKeepaliveTimeout();
	                                if (err) {
	                                    this.keepaliveTrace('Ping failed with error: ' + err.message);
	                                    sessionClosedByServer = true;
	                                    session.close();
	                                }
	                                else {
	                                    this.keepaliveTrace('Received ping response');
	                                    maybeStartKeepalivePingTimer();
	                                }
	                            });
	                            if (!pingSentSuccessfully) {
	                                pingSendError = 'Ping returned false';
	                            }
	                        }
	                        catch (e) {
	                            // grpc/grpc-node#2139
	                            pingSendError =
	                                (e instanceof Error ? e.message : '') || 'Unknown error';
	                        }
	                        if (pingSendError) {
	                            this.keepaliveTrace('Ping send failed: ' + pingSendError);
	                            this.trace('Connection dropped due to ping send error: ' + pingSendError);
	                            sessionClosedByServer = true;
	                            session.close();
	                            return;
	                        }
	                        keepaliveTimer = setTimeout(() => {
	                            clearKeepaliveTimeout();
	                            this.keepaliveTrace('Ping timeout passed without response');
	                            this.trace('Connection dropped by keepalive timeout');
	                            sessionClosedByServer = true;
	                            session.close();
	                        }, this.keepaliveTimeoutMs);
	                        (_b = keepaliveTimer.unref) === null || _b === undefined ? undefined : _b.call(keepaliveTimer);
	                    };
	                    maybeStartKeepalivePingTimer();
	                    session.on('close', () => {
	                        var _b, _c;
	                        if (!sessionClosedByServer) {
	                            this.trace(`Connection dropped by client ${(_b = session.socket) === null || _b === undefined ? undefined : _b.remoteAddress}`);
	                        }
	                        if (connectionAgeTimer) {
	                            clearTimeout(connectionAgeTimer);
	                        }
	                        if (connectionAgeGraceTimer) {
	                            clearTimeout(connectionAgeGraceTimer);
	                        }
	                        clearKeepaliveTimeout();
	                        if (idleTimeoutObj !== null) {
	                            clearTimeout(idleTimeoutObj.timeout);
	                            this.sessionIdleTimeouts.delete(session);
	                        }
	                        (_c = this.http2Servers.get(http2Server)) === null || _c === undefined ? undefined : _c.sessions.delete(session);
	                    });
	                };
	            }
	            _channelzSessionHandler(http2Server) {
	                return (session) => {
	                    var _b, _c, _d, _e;
	                    const channelzRef = (0, channelz_1.registerChannelzSocket)((_c = (_b = session.socket) === null || _b === undefined ? undefined : _b.remoteAddress) !== null && _c !== undefined ? _c : 'unknown', this.getChannelzSessionInfo.bind(this, session), this.channelzEnabled);
	                    const channelzSessionInfo = {
	                        ref: channelzRef,
	                        streamTracker: new channelz_1.ChannelzCallTracker(),
	                        messagesSent: 0,
	                        messagesReceived: 0,
	                        keepAlivesSent: 0,
	                        lastMessageSentTimestamp: null,
	                        lastMessageReceivedTimestamp: null,
	                    };
	                    (_d = this.http2Servers.get(http2Server)) === null || _d === undefined ? undefined : _d.sessions.add(session);
	                    this.sessions.set(session, channelzSessionInfo);
	                    const clientAddress = `${session.socket.remoteAddress}:${session.socket.remotePort}`;
	                    this.channelzTrace.addTrace('CT_INFO', 'Connection established by client ' + clientAddress);
	                    this.trace('Connection established by client ' + clientAddress);
	                    this.sessionChildrenTracker.refChild(channelzRef);
	                    let connectionAgeTimer = null;
	                    let connectionAgeGraceTimer = null;
	                    let keepaliveTimeout = null;
	                    let sessionClosedByServer = false;
	                    const idleTimeoutObj = this.enableIdleTimeout(session);
	                    if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {
	                        // Apply a random jitter within a +/-10% range
	                        const jitterMagnitude = this.maxConnectionAgeMs / 10;
	                        const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;
	                        connectionAgeTimer = setTimeout(() => {
	                            var _b;
	                            sessionClosedByServer = true;
	                            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by max connection age from ' + clientAddress);
	                            try {
	                                session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 << 31), kMaxAge);
	                            }
	                            catch (e) {
	                                // The goaway can't be sent because the session is already closed
	                                session.destroy();
	                                return;
	                            }
	                            session.close();
	                            /* Allow a grace period after sending the GOAWAY before forcibly
	                             * closing the connection. */
	                            if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {
	                                connectionAgeGraceTimer = setTimeout(() => {
	                                    session.destroy();
	                                }, this.maxConnectionAgeGraceMs);
	                                (_b = connectionAgeGraceTimer.unref) === null || _b === undefined ? undefined : _b.call(connectionAgeGraceTimer);
	                            }
	                        }, this.maxConnectionAgeMs + jitter);
	                        (_e = connectionAgeTimer.unref) === null || _e === undefined ? undefined : _e.call(connectionAgeTimer);
	                    }
	                    const clearKeepaliveTimeout = () => {
	                        if (keepaliveTimeout) {
	                            clearTimeout(keepaliveTimeout);
	                            keepaliveTimeout = null;
	                        }
	                    };
	                    const canSendPing = () => {
	                        return (!session.destroyed &&
	                            this.keepaliveTimeMs < KEEPALIVE_MAX_TIME_MS &&
	                            this.keepaliveTimeMs > 0);
	                    };
	                    /* eslint-disable-next-line prefer-const */
	                    let sendPing; // hoisted for use in maybeStartKeepalivePingTimer
	                    const maybeStartKeepalivePingTimer = () => {
	                        var _b;
	                        if (!canSendPing()) {
	                            return;
	                        }
	                        this.keepaliveTrace('Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms');
	                        keepaliveTimeout = setTimeout(() => {
	                            clearKeepaliveTimeout();
	                            sendPing();
	                        }, this.keepaliveTimeMs);
	                        (_b = keepaliveTimeout.unref) === null || _b === undefined ? undefined : _b.call(keepaliveTimeout);
	                    };
	                    sendPing = () => {
	                        var _b;
	                        if (!canSendPing()) {
	                            return;
	                        }
	                        this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');
	                        let pingSendError = '';
	                        try {
	                            const pingSentSuccessfully = session.ping((err, duration, payload) => {
	                                clearKeepaliveTimeout();
	                                if (err) {
	                                    this.keepaliveTrace('Ping failed with error: ' + err.message);
	                                    this.channelzTrace.addTrace('CT_INFO', 'Connection dropped due to error of a ping frame ' +
	                                        err.message +
	                                        ' return in ' +
	                                        duration);
	                                    sessionClosedByServer = true;
	                                    session.close();
	                                }
	                                else {
	                                    this.keepaliveTrace('Received ping response');
	                                    maybeStartKeepalivePingTimer();
	                                }
	                            });
	                            if (!pingSentSuccessfully) {
	                                pingSendError = 'Ping returned false';
	                            }
	                        }
	                        catch (e) {
	                            // grpc/grpc-node#2139
	                            pingSendError =
	                                (e instanceof Error ? e.message : '') || 'Unknown error';
	                        }
	                        if (pingSendError) {
	                            this.keepaliveTrace('Ping send failed: ' + pingSendError);
	                            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped due to ping send error: ' + pingSendError);
	                            sessionClosedByServer = true;
	                            session.close();
	                            return;
	                        }
	                        channelzSessionInfo.keepAlivesSent += 1;
	                        keepaliveTimeout = setTimeout(() => {
	                            clearKeepaliveTimeout();
	                            this.keepaliveTrace('Ping timeout passed without response');
	                            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by keepalive timeout from ' + clientAddress);
	                            sessionClosedByServer = true;
	                            session.close();
	                        }, this.keepaliveTimeoutMs);
	                        (_b = keepaliveTimeout.unref) === null || _b === undefined ? undefined : _b.call(keepaliveTimeout);
	                    };
	                    maybeStartKeepalivePingTimer();
	                    session.on('close', () => {
	                        var _b;
	                        if (!sessionClosedByServer) {
	                            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by client ' + clientAddress);
	                        }
	                        this.sessionChildrenTracker.unrefChild(channelzRef);
	                        (0, channelz_1.unregisterChannelzRef)(channelzRef);
	                        if (connectionAgeTimer) {
	                            clearTimeout(connectionAgeTimer);
	                        }
	                        if (connectionAgeGraceTimer) {
	                            clearTimeout(connectionAgeGraceTimer);
	                        }
	                        clearKeepaliveTimeout();
	                        if (idleTimeoutObj !== null) {
	                            clearTimeout(idleTimeoutObj.timeout);
	                            this.sessionIdleTimeouts.delete(session);
	                        }
	                        (_b = this.http2Servers.get(http2Server)) === null || _b === undefined ? undefined : _b.sessions.delete(session);
	                        this.sessions.delete(session);
	                    });
	                };
	            }
	            enableIdleTimeout(session) {
	                var _b, _c;
	                if (this.sessionIdleTimeout >= MAX_CONNECTION_IDLE_MS) {
	                    return null;
	                }
	                const idleTimeoutObj = {
	                    activeStreams: 0,
	                    lastIdle: Date.now(),
	                    onClose: this.onStreamClose.bind(this, session),
	                    timeout: setTimeout(this.onIdleTimeout, this.sessionIdleTimeout, this, session),
	                };
	                (_c = (_b = idleTimeoutObj.timeout).unref) === null || _c === undefined ? undefined : _c.call(_b);
	                this.sessionIdleTimeouts.set(session, idleTimeoutObj);
	                const { socket } = session;
	                this.trace('Enable idle timeout for ' +
	                    socket.remoteAddress +
	                    ':' +
	                    socket.remotePort);
	                return idleTimeoutObj;
	            }
	            onIdleTimeout(ctx, session) {
	                const { socket } = session;
	                const sessionInfo = ctx.sessionIdleTimeouts.get(session);
	                // if it is called while we have activeStreams - timer will not be rescheduled
	                // until last active stream is closed, then it will call .refresh() on the timer
	                // important part is to not clearTimeout(timer) or it becomes unusable
	                // for future refreshes
	                if (sessionInfo !== undefined &&
	                    sessionInfo.activeStreams === 0) {
	                    if (Date.now() - sessionInfo.lastIdle >= ctx.sessionIdleTimeout) {
	                        ctx.trace('Session idle timeout triggered for ' +
	                            (socket === null || socket === undefined ? undefined : socket.remoteAddress) +
	                            ':' +
	                            (socket === null || socket === undefined ? undefined : socket.remotePort) +
	                            ' last idle at ' +
	                            sessionInfo.lastIdle);
	                        ctx.closeSession(session);
	                    }
	                    else {
	                        sessionInfo.timeout.refresh();
	                    }
	                }
	            }
	            onStreamOpened(stream) {
	                const session = stream.session;
	                const idleTimeoutObj = this.sessionIdleTimeouts.get(session);
	                if (idleTimeoutObj) {
	                    idleTimeoutObj.activeStreams += 1;
	                    stream.once('close', idleTimeoutObj.onClose);
	                }
	            }
	            onStreamClose(session) {
	                var _b, _c;
	                const idleTimeoutObj = this.sessionIdleTimeouts.get(session);
	                if (idleTimeoutObj) {
	                    idleTimeoutObj.activeStreams -= 1;
	                    if (idleTimeoutObj.activeStreams === 0) {
	                        idleTimeoutObj.lastIdle = Date.now();
	                        idleTimeoutObj.timeout.refresh();
	                        this.trace('Session onStreamClose' +
	                            ((_b = session.socket) === null || _b === undefined ? undefined : _b.remoteAddress) +
	                            ':' +
	                            ((_c = session.socket) === null || _c === undefined ? undefined : _c.remotePort) +
	                            ' at ' +
	                            idleTimeoutObj.lastIdle);
	                    }
	                }
	            }
	        },
	        (() => {
	            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : undefined;
	            _start_decorators = [deprecate('Calling start() is no longer necessary. It can be safely omitted.')];
	            __esDecorate(_a, null, _start_decorators, { kind: "method", name: "start", static: false, private: false, access: { has: obj => "start" in obj, get: obj => obj.start }, metadata: _metadata }, null, _instanceExtraInitializers);
	            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
	        })(),
	        _a;
	})();
	server.Server = Server;
	async function handleUnary(call, handler) {
	    let stream;
	    function respond(err, value, trailer, flags) {
	        if (err) {
	            call.sendStatus((0, server_call_1.serverErrorToStatus)(err, trailer));
	            return;
	        }
	        call.sendMessage(value, () => {
	            call.sendStatus({
	                code: constants_1.Status.OK,
	                details: 'OK',
	                metadata: trailer !== null && trailer !== undefined ? trailer : null,
	            });
	        });
	    }
	    let requestMetadata;
	    let requestMessage = null;
	    call.start({
	        onReceiveMetadata(metadata) {
	            requestMetadata = metadata;
	            call.startRead();
	        },
	        onReceiveMessage(message) {
	            if (requestMessage) {
	                call.sendStatus({
	                    code: constants_1.Status.UNIMPLEMENTED,
	                    details: `Received a second request message for server streaming method ${handler.path}`,
	                    metadata: null,
	                });
	                return;
	            }
	            requestMessage = message;
	            call.startRead();
	        },
	        onReceiveHalfClose() {
	            if (!requestMessage) {
	                call.sendStatus({
	                    code: constants_1.Status.UNIMPLEMENTED,
	                    details: `Received no request message for server streaming method ${handler.path}`,
	                    metadata: null,
	                });
	                return;
	            }
	            stream = new server_call_1.ServerWritableStreamImpl(handler.path, call, requestMetadata, requestMessage);
	            try {
	                handler.func(stream, respond);
	            }
	            catch (err) {
	                call.sendStatus({
	                    code: constants_1.Status.UNKNOWN,
	                    details: `Server method handler threw error ${err.message}`,
	                    metadata: null,
	                });
	            }
	        },
	        onCancel() {
	            if (stream) {
	                stream.cancelled = true;
	                stream.emit('cancelled', 'cancelled');
	            }
	        },
	    });
	}
	function handleClientStreaming(call, handler) {
	    let stream;
	    function respond(err, value, trailer, flags) {
	        if (err) {
	            call.sendStatus((0, server_call_1.serverErrorToStatus)(err, trailer));
	            return;
	        }
	        call.sendMessage(value, () => {
	            call.sendStatus({
	                code: constants_1.Status.OK,
	                details: 'OK',
	                metadata: trailer !== null && trailer !== undefined ? trailer : null,
	            });
	        });
	    }
	    call.start({
	        onReceiveMetadata(metadata) {
	            stream = new server_call_1.ServerDuplexStreamImpl(handler.path, call, metadata);
	            try {
	                handler.func(stream, respond);
	            }
	            catch (err) {
	                call.sendStatus({
	                    code: constants_1.Status.UNKNOWN,
	                    details: `Server method handler threw error ${err.message}`,
	                    metadata: null,
	                });
	            }
	        },
	        onReceiveMessage(message) {
	            stream.push(message);
	        },
	        onReceiveHalfClose() {
	            stream.push(null);
	        },
	        onCancel() {
	            if (stream) {
	                stream.cancelled = true;
	                stream.emit('cancelled', 'cancelled');
	                stream.destroy();
	            }
	        },
	    });
	}
	function handleServerStreaming(call, handler) {
	    let stream;
	    let requestMetadata;
	    let requestMessage = null;
	    call.start({
	        onReceiveMetadata(metadata) {
	            requestMetadata = metadata;
	            call.startRead();
	        },
	        onReceiveMessage(message) {
	            if (requestMessage) {
	                call.sendStatus({
	                    code: constants_1.Status.UNIMPLEMENTED,
	                    details: `Received a second request message for server streaming method ${handler.path}`,
	                    metadata: null,
	                });
	                return;
	            }
	            requestMessage = message;
	            call.startRead();
	        },
	        onReceiveHalfClose() {
	            if (!requestMessage) {
	                call.sendStatus({
	                    code: constants_1.Status.UNIMPLEMENTED,
	                    details: `Received no request message for server streaming method ${handler.path}`,
	                    metadata: null,
	                });
	                return;
	            }
	            stream = new server_call_1.ServerWritableStreamImpl(handler.path, call, requestMetadata, requestMessage);
	            try {
	                handler.func(stream);
	            }
	            catch (err) {
	                call.sendStatus({
	                    code: constants_1.Status.UNKNOWN,
	                    details: `Server method handler threw error ${err.message}`,
	                    metadata: null,
	                });
	            }
	        },
	        onCancel() {
	            if (stream) {
	                stream.cancelled = true;
	                stream.emit('cancelled', 'cancelled');
	                stream.destroy();
	            }
	        },
	    });
	}
	function handleBidiStreaming(call, handler) {
	    let stream;
	    call.start({
	        onReceiveMetadata(metadata) {
	            stream = new server_call_1.ServerDuplexStreamImpl(handler.path, call, metadata);
	            try {
	                handler.func(stream);
	            }
	            catch (err) {
	                call.sendStatus({
	                    code: constants_1.Status.UNKNOWN,
	                    details: `Server method handler threw error ${err.message}`,
	                    metadata: null,
	                });
	            }
	        },
	        onReceiveMessage(message) {
	            stream.push(message);
	        },
	        onReceiveHalfClose() {
	            stream.push(null);
	        },
	        onCancel() {
	            if (stream) {
	                stream.cancelled = true;
	                stream.emit('cancelled', 'cancelled');
	                stream.destroy();
	            }
	        },
	    });
	}
	
	return server;
}

var statusBuilder = {};

var hasRequiredStatusBuilder;

function requireStatusBuilder () {
	if (hasRequiredStatusBuilder) return statusBuilder;
	hasRequiredStatusBuilder = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(statusBuilder, "__esModule", { value: true });
	statusBuilder.StatusBuilder = undefined;
	/**
	 * A builder for gRPC status objects.
	 */
	class StatusBuilder {
	    constructor() {
	        this.code = null;
	        this.details = null;
	        this.metadata = null;
	    }
	    /**
	     * Adds a status code to the builder.
	     */
	    withCode(code) {
	        this.code = code;
	        return this;
	    }
	    /**
	     * Adds details to the builder.
	     */
	    withDetails(details) {
	        this.details = details;
	        return this;
	    }
	    /**
	     * Adds metadata to the builder.
	     */
	    withMetadata(metadata) {
	        this.metadata = metadata;
	        return this;
	    }
	    /**
	     * Builds the status object.
	     */
	    build() {
	        const status = {};
	        if (this.code !== null) {
	            status.code = this.code;
	        }
	        if (this.details !== null) {
	            status.details = this.details;
	        }
	        if (this.metadata !== null) {
	            status.metadata = this.metadata;
	        }
	        return status;
	    }
	}
	statusBuilder.StatusBuilder = StatusBuilder;
	
	return statusBuilder;
}

var experimental = {};

var duration = {};

var hasRequiredDuration;

function requireDuration () {
	if (hasRequiredDuration) return duration;
	hasRequiredDuration = 1;
	/*
	 * Copyright 2022 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(duration, "__esModule", { value: true });
	duration.parseDuration = duration.isDuration = duration.durationToMs = duration.msToDuration = undefined;
	function msToDuration(millis) {
	    return {
	        seconds: (millis / 1000) | 0,
	        nanos: ((millis % 1000) * 1000000) | 0,
	    };
	}
	duration.msToDuration = msToDuration;
	function durationToMs(duration) {
	    return (duration.seconds * 1000 + duration.nanos / 1000000) | 0;
	}
	duration.durationToMs = durationToMs;
	function isDuration(value) {
	    return typeof value.seconds === 'number' && typeof value.nanos === 'number';
	}
	duration.isDuration = isDuration;
	const durationRegex = /^(\d+)(?:\.(\d+))?s$/;
	function parseDuration(value) {
	    const match = value.match(durationRegex);
	    if (!match) {
	        return null;
	    }
	    return {
	        seconds: Number.parseInt(match[1], 10),
	        nanos: match[2] ? Number.parseInt(match[2].padEnd(9, '0'), 10) : 0
	    };
	}
	duration.parseDuration = parseDuration;
	
	return duration;
}

var loadBalancerPickFirst = {};

var hasRequiredLoadBalancerPickFirst;

function requireLoadBalancerPickFirst () {
	if (hasRequiredLoadBalancerPickFirst) return loadBalancerPickFirst;
	hasRequiredLoadBalancerPickFirst = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(loadBalancerPickFirst, "__esModule", { value: true });
	loadBalancerPickFirst.setup = loadBalancerPickFirst.LeafLoadBalancer = loadBalancerPickFirst.PickFirstLoadBalancer = loadBalancerPickFirst.shuffled = loadBalancerPickFirst.PickFirstLoadBalancingConfig = undefined;
	const load_balancer_1 = requireLoadBalancer();
	const connectivity_state_1 = requireConnectivityState();
	const picker_1 = requirePicker();
	const subchannel_address_1 = requireSubchannelAddress();
	const logging = requireLogging();
	const constants_1 = requireConstants();
	const subchannel_address_2 = requireSubchannelAddress();
	const net_1 = require$$0$2;
	const TRACER_NAME = 'pick_first';
	function trace(text) {
	    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
	}
	const TYPE_NAME = 'pick_first';
	/**
	 * Delay after starting a connection on a subchannel before starting a
	 * connection on the next subchannel in the list, for Happy Eyeballs algorithm.
	 */
	const CONNECTION_DELAY_INTERVAL_MS = 250;
	class PickFirstLoadBalancingConfig {
	    constructor(shuffleAddressList) {
	        this.shuffleAddressList = shuffleAddressList;
	    }
	    getLoadBalancerName() {
	        return TYPE_NAME;
	    }
	    toJsonObject() {
	        return {
	            [TYPE_NAME]: {
	                shuffleAddressList: this.shuffleAddressList,
	            },
	        };
	    }
	    getShuffleAddressList() {
	        return this.shuffleAddressList;
	    }
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    static createFromJson(obj) {
	        if ('shuffleAddressList' in obj &&
	            !(typeof obj.shuffleAddressList === 'boolean')) {
	            throw new Error('pick_first config field shuffleAddressList must be a boolean if provided');
	        }
	        return new PickFirstLoadBalancingConfig(obj.shuffleAddressList === true);
	    }
	}
	loadBalancerPickFirst.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;
	/**
	 * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the
	 * picked subchannel.
	 */
	class PickFirstPicker {
	    constructor(subchannel) {
	        this.subchannel = subchannel;
	    }
	    pick(pickArgs) {
	        return {
	            pickResultType: picker_1.PickResultType.COMPLETE,
	            subchannel: this.subchannel,
	            status: null,
	            onCallStarted: null,
	            onCallEnded: null,
	        };
	    }
	}
	/**
	 * Return a new array with the elements of the input array in a random order
	 * @param list The input array
	 * @returns A shuffled array of the elements of list
	 */
	function shuffled(list) {
	    const result = list.slice();
	    for (let i = result.length - 1; i > 1; i--) {
	        const j = Math.floor(Math.random() * (i + 1));
	        const temp = result[i];
	        result[i] = result[j];
	        result[j] = temp;
	    }
	    return result;
	}
	loadBalancerPickFirst.shuffled = shuffled;
	/**
	 * Interleave addresses in addressList by family in accordance with RFC-8304 section 4
	 * @param addressList
	 * @returns
	 */
	function interleaveAddressFamilies(addressList) {
	    const result = [];
	    const ipv6Addresses = [];
	    const ipv4Addresses = [];
	    const ipv6First = (0, subchannel_address_2.isTcpSubchannelAddress)(addressList[0]) && (0, net_1.isIPv6)(addressList[0].host);
	    for (const address of addressList) {
	        if ((0, subchannel_address_2.isTcpSubchannelAddress)(address) && (0, net_1.isIPv6)(address.host)) {
	            ipv6Addresses.push(address);
	        }
	        else {
	            ipv4Addresses.push(address);
	        }
	    }
	    const firstList = ipv6First ? ipv6Addresses : ipv4Addresses;
	    const secondList = ipv6First ? ipv4Addresses : ipv6Addresses;
	    for (let i = 0; i < Math.max(firstList.length, secondList.length); i++) {
	        if (i < firstList.length) {
	            result.push(firstList[i]);
	        }
	        if (i < secondList.length) {
	            result.push(secondList[i]);
	        }
	    }
	    return result;
	}
	const REPORT_HEALTH_STATUS_OPTION_NAME = 'grpc-node.internal.pick-first.report_health_status';
	class PickFirstLoadBalancer {
	    /**
	     * Load balancer that attempts to connect to each backend in the address list
	     * in order, and picks the first one that connects, using it for every
	     * request.
	     * @param channelControlHelper `ChannelControlHelper` instance provided by
	     *     this load balancer's owner.
	     */
	    constructor(channelControlHelper, credentials, options) {
	        this.channelControlHelper = channelControlHelper;
	        /**
	         * The list of subchannels this load balancer is currently attempting to
	         * connect to.
	         */
	        this.children = [];
	        /**
	         * The current connectivity state of the load balancer.
	         */
	        this.currentState = connectivity_state_1.ConnectivityState.IDLE;
	        /**
	         * The index within the `subchannels` array of the subchannel with the most
	         * recently started connection attempt.
	         */
	        this.currentSubchannelIndex = 0;
	        /**
	         * The currently picked subchannel used for making calls. Populated if
	         * and only if the load balancer's current state is READY. In that case,
	         * the subchannel's current state is also READY.
	         */
	        this.currentPick = null;
	        /**
	         * Listener callback attached to each subchannel in the `subchannels` list
	         * while establishing a connection.
	         */
	        this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime, errorMessage) => {
	            this.onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage);
	        };
	        this.pickedSubchannelHealthListener = () => this.calculateAndReportNewState();
	        /**
	         * The LB policy enters sticky TRANSIENT_FAILURE mode when all
	         * subchannels have failed to connect at least once, and it stays in that
	         * mode until a connection attempt is successful. While in sticky TF mode,
	         * the LB policy continuously attempts to connect to all of its subchannels.
	         */
	        this.stickyTransientFailureMode = false;
	        /**
	         * The most recent error reported by any subchannel as it transitioned to
	         * TRANSIENT_FAILURE.
	         */
	        this.lastError = null;
	        this.latestAddressList = null;
	        this.connectionDelayTimeout = setTimeout(() => { }, 0);
	        clearTimeout(this.connectionDelayTimeout);
	        this.reportHealthStatus = options[REPORT_HEALTH_STATUS_OPTION_NAME];
	    }
	    allChildrenHaveReportedTF() {
	        return this.children.every(child => child.hasReportedTransientFailure);
	    }
	    resetChildrenReportedTF() {
	        this.children.every(child => child.hasReportedTransientFailure = false);
	    }
	    calculateAndReportNewState() {
	        if (this.currentPick) {
	            if (this.reportHealthStatus && !this.currentPick.isHealthy()) {
	                this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({
	                    details: `Picked subchannel ${this.currentPick.getAddress()} is unhealthy`,
	                }));
	            }
	            else {
	                this.updateState(connectivity_state_1.ConnectivityState.READY, new PickFirstPicker(this.currentPick));
	            }
	        }
	        else if (this.children.length === 0) {
	            this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
	        }
	        else {
	            if (this.stickyTransientFailureMode) {
	                this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({
	                    details: `No connection established. Last error: ${this.lastError}`,
	                }));
	            }
	            else {
	                this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
	            }
	        }
	    }
	    requestReresolution() {
	        this.channelControlHelper.requestReresolution();
	    }
	    maybeEnterStickyTransientFailureMode() {
	        if (!this.allChildrenHaveReportedTF()) {
	            return;
	        }
	        this.requestReresolution();
	        this.resetChildrenReportedTF();
	        if (this.stickyTransientFailureMode) {
	            this.calculateAndReportNewState();
	            return;
	        }
	        this.stickyTransientFailureMode = true;
	        for (const { subchannel } of this.children) {
	            subchannel.startConnecting();
	        }
	        this.calculateAndReportNewState();
	    }
	    removeCurrentPick() {
	        if (this.currentPick !== null) {
	            this.currentPick.removeConnectivityStateListener(this.subchannelStateListener);
	            this.channelControlHelper.removeChannelzChild(this.currentPick.getChannelzRef());
	            this.currentPick.removeHealthStateWatcher(this.pickedSubchannelHealthListener);
	            // Unref last, to avoid triggering listeners
	            this.currentPick.unref();
	            this.currentPick = null;
	        }
	    }
	    onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage) {
	        var _a;
	        if ((_a = this.currentPick) === null || _a === undefined ? undefined : _a.realSubchannelEquals(subchannel)) {
	            if (newState !== connectivity_state_1.ConnectivityState.READY) {
	                this.removeCurrentPick();
	                this.calculateAndReportNewState();
	            }
	            return;
	        }
	        for (const [index, child] of this.children.entries()) {
	            if (subchannel.realSubchannelEquals(child.subchannel)) {
	                if (newState === connectivity_state_1.ConnectivityState.READY) {
	                    this.pickSubchannel(child.subchannel);
	                }
	                if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
	                    child.hasReportedTransientFailure = true;
	                    if (errorMessage) {
	                        this.lastError = errorMessage;
	                    }
	                    this.maybeEnterStickyTransientFailureMode();
	                    if (index === this.currentSubchannelIndex) {
	                        this.startNextSubchannelConnecting(index + 1);
	                    }
	                }
	                child.subchannel.startConnecting();
	                return;
	            }
	        }
	    }
	    startNextSubchannelConnecting(startIndex) {
	        clearTimeout(this.connectionDelayTimeout);
	        for (const [index, child] of this.children.entries()) {
	            if (index >= startIndex) {
	                const subchannelState = child.subchannel.getConnectivityState();
	                if (subchannelState === connectivity_state_1.ConnectivityState.IDLE ||
	                    subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {
	                    this.startConnecting(index);
	                    return;
	                }
	            }
	        }
	        this.maybeEnterStickyTransientFailureMode();
	    }
	    /**
	     * Have a single subchannel in the `subchannels` list start connecting.
	     * @param subchannelIndex The index into the `subchannels` list.
	     */
	    startConnecting(subchannelIndex) {
	        var _a, _b;
	        clearTimeout(this.connectionDelayTimeout);
	        this.currentSubchannelIndex = subchannelIndex;
	        if (this.children[subchannelIndex].subchannel.getConnectivityState() ===
	            connectivity_state_1.ConnectivityState.IDLE) {
	            trace('Start connecting to subchannel with address ' +
	                this.children[subchannelIndex].subchannel.getAddress());
	            process.nextTick(() => {
	                var _a;
	                (_a = this.children[subchannelIndex]) === null || _a === undefined ? undefined : _a.subchannel.startConnecting();
	            });
	        }
	        this.connectionDelayTimeout = setTimeout(() => {
	            this.startNextSubchannelConnecting(subchannelIndex + 1);
	        }, CONNECTION_DELAY_INTERVAL_MS);
	        (_b = (_a = this.connectionDelayTimeout).unref) === null || _b === undefined ? undefined : _b.call(_a);
	    }
	    /**
	     * Declare that the specified subchannel should be used to make requests.
	     * This functions the same independent of whether subchannel is a member of
	     * this.children and whether it is equal to this.currentPick.
	     * Prerequisite: subchannel.getConnectivityState() === READY.
	     * @param subchannel
	     */
	    pickSubchannel(subchannel) {
	        trace('Pick subchannel with address ' + subchannel.getAddress());
	        this.stickyTransientFailureMode = false;
	        /* Ref before removeCurrentPick and resetSubchannelList to avoid the
	         * refcount dropping to 0 during this process. */
	        subchannel.ref();
	        this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());
	        this.removeCurrentPick();
	        this.resetSubchannelList();
	        subchannel.addConnectivityStateListener(this.subchannelStateListener);
	        subchannel.addHealthStateWatcher(this.pickedSubchannelHealthListener);
	        this.currentPick = subchannel;
	        clearTimeout(this.connectionDelayTimeout);
	        this.calculateAndReportNewState();
	    }
	    updateState(newState, picker) {
	        trace(connectivity_state_1.ConnectivityState[this.currentState] +
	            ' -> ' +
	            connectivity_state_1.ConnectivityState[newState]);
	        this.currentState = newState;
	        this.channelControlHelper.updateState(newState, picker);
	    }
	    resetSubchannelList() {
	        for (const child of this.children) {
	            /* Always remoev the connectivity state listener. If the subchannel is
	               getting picked, it will be re-added then. */
	            child.subchannel.removeConnectivityStateListener(this.subchannelStateListener);
	            /* Refs are counted independently for the children list and the
	             * currentPick, so we call unref whether or not the child is the
	             * currentPick. Channelz child references are also refcounted, so
	             * removeChannelzChild can be handled the same way. */
	            child.subchannel.unref();
	            this.channelControlHelper.removeChannelzChild(child.subchannel.getChannelzRef());
	        }
	        this.currentSubchannelIndex = 0;
	        this.children = [];
	    }
	    connectToAddressList(addressList) {
	        trace('connectToAddressList([' + addressList.map(address => (0, subchannel_address_1.subchannelAddressToString)(address)) + '])');
	        const newChildrenList = addressList.map(address => ({
	            subchannel: this.channelControlHelper.createSubchannel(address, {}, null),
	            hasReportedTransientFailure: false,
	        }));
	        for (const { subchannel } of newChildrenList) {
	            if (subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY) {
	                this.pickSubchannel(subchannel);
	                return;
	            }
	        }
	        /* Ref each subchannel before resetting the list, to ensure that
	         * subchannels shared between the list don't drop to 0 refs during the
	         * transition. */
	        for (const { subchannel } of newChildrenList) {
	            subchannel.ref();
	            this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());
	        }
	        this.resetSubchannelList();
	        this.children = newChildrenList;
	        for (const { subchannel } of this.children) {
	            subchannel.addConnectivityStateListener(this.subchannelStateListener);
	        }
	        for (const child of this.children) {
	            if (child.subchannel.getConnectivityState() ===
	                connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
	                child.hasReportedTransientFailure = true;
	            }
	        }
	        this.startNextSubchannelConnecting(0);
	        this.calculateAndReportNewState();
	    }
	    updateAddressList(endpointList, lbConfig) {
	        if (!(lbConfig instanceof PickFirstLoadBalancingConfig)) {
	            return;
	        }
	        /* Previously, an update would be discarded if it was identical to the
	         * previous update, to minimize churn. Now the DNS resolver is
	         * rate-limited, so that is less of a concern. */
	        if (lbConfig.getShuffleAddressList()) {
	            endpointList = shuffled(endpointList);
	        }
	        const rawAddressList = [].concat(...endpointList.map(endpoint => endpoint.addresses));
	        trace('updateAddressList([' + rawAddressList.map(address => (0, subchannel_address_1.subchannelAddressToString)(address)) + '])');
	        if (rawAddressList.length === 0) {
	            throw new Error('No addresses in endpoint list passed to pick_first');
	        }
	        const addressList = interleaveAddressFamilies(rawAddressList);
	        this.latestAddressList = addressList;
	        this.connectToAddressList(addressList);
	    }
	    exitIdle() {
	        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE &&
	            this.latestAddressList) {
	            this.connectToAddressList(this.latestAddressList);
	        }
	    }
	    resetBackoff() {
	        /* The pick first load balancer does not have a connection backoff, so this
	         * does nothing */
	    }
	    destroy() {
	        this.resetSubchannelList();
	        this.removeCurrentPick();
	    }
	    getTypeName() {
	        return TYPE_NAME;
	    }
	}
	loadBalancerPickFirst.PickFirstLoadBalancer = PickFirstLoadBalancer;
	const LEAF_CONFIG = new PickFirstLoadBalancingConfig(false);
	/**
	 * This class handles the leaf load balancing operations for a single endpoint.
	 * It is a thin wrapper around a PickFirstLoadBalancer with a different API
	 * that more closely reflects how it will be used as a leaf balancer.
	 */
	class LeafLoadBalancer {
	    constructor(endpoint, channelControlHelper, credentials, options) {
	        this.endpoint = endpoint;
	        this.latestState = connectivity_state_1.ConnectivityState.IDLE;
	        const childChannelControlHelper = (0, load_balancer_1.createChildChannelControlHelper)(channelControlHelper, {
	            updateState: (connectivityState, picker) => {
	                this.latestState = connectivityState;
	                this.latestPicker = picker;
	                channelControlHelper.updateState(connectivityState, picker);
	            },
	        });
	        this.pickFirstBalancer = new PickFirstLoadBalancer(childChannelControlHelper, credentials, Object.assign(Object.assign({}, options), { [REPORT_HEALTH_STATUS_OPTION_NAME]: true }));
	        this.latestPicker = new picker_1.QueuePicker(this.pickFirstBalancer);
	    }
	    startConnecting() {
	        this.pickFirstBalancer.updateAddressList([this.endpoint], LEAF_CONFIG);
	    }
	    /**
	     * Update the endpoint associated with this LeafLoadBalancer to a new
	     * endpoint. Does not trigger connection establishment if a connection
	     * attempt is not already in progress.
	     * @param newEndpoint
	     */
	    updateEndpoint(newEndpoint) {
	        this.endpoint = newEndpoint;
	        if (this.latestState !== connectivity_state_1.ConnectivityState.IDLE) {
	            this.startConnecting();
	        }
	    }
	    getConnectivityState() {
	        return this.latestState;
	    }
	    getPicker() {
	        return this.latestPicker;
	    }
	    getEndpoint() {
	        return this.endpoint;
	    }
	    exitIdle() {
	        this.pickFirstBalancer.exitIdle();
	    }
	    destroy() {
	        this.pickFirstBalancer.destroy();
	    }
	}
	loadBalancerPickFirst.LeafLoadBalancer = LeafLoadBalancer;
	function setup() {
	    (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);
	    (0, load_balancer_1.registerDefaultLoadBalancerType)(TYPE_NAME);
	}
	loadBalancerPickFirst.setup = setup;
	
	return loadBalancerPickFirst;
}

var certificateProvider = {};

var hasRequiredCertificateProvider;

function requireCertificateProvider () {
	if (hasRequiredCertificateProvider) return certificateProvider;
	hasRequiredCertificateProvider = 1;
	/*
	 * Copyright 2024 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(certificateProvider, "__esModule", { value: true });
	certificateProvider.FileWatcherCertificateProvider = undefined;
	const fs = require$$0;
	const logging = requireLogging();
	const constants_1 = requireConstants();
	const util_1 = require$$1$3;
	const TRACER_NAME = 'certificate_provider';
	function trace(text) {
	    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
	}
	const readFilePromise = (0, util_1.promisify)(fs.readFile);
	class FileWatcherCertificateProvider {
	    constructor(config) {
	        this.config = config;
	        this.refreshTimer = null;
	        this.fileResultPromise = null;
	        this.latestCaUpdate = null;
	        this.caListeners = new Set();
	        this.latestIdentityUpdate = null;
	        this.identityListeners = new Set();
	        this.lastUpdateTime = null;
	        if ((config.certificateFile === undefined) !== (config.privateKeyFile === undefined)) {
	            throw new Error('certificateFile and privateKeyFile must be set or unset together');
	        }
	        if (config.certificateFile === undefined && config.caCertificateFile === undefined) {
	            throw new Error('At least one of certificateFile and caCertificateFile must be set');
	        }
	        trace('File watcher constructed with config ' + JSON.stringify(config));
	    }
	    updateCertificates() {
	        if (this.fileResultPromise) {
	            return;
	        }
	        this.fileResultPromise = Promise.allSettled([
	            this.config.certificateFile ? readFilePromise(this.config.certificateFile) : Promise.reject(),
	            this.config.privateKeyFile ? readFilePromise(this.config.privateKeyFile) : Promise.reject(),
	            this.config.caCertificateFile ? readFilePromise(this.config.caCertificateFile) : Promise.reject()
	        ]);
	        this.fileResultPromise.then(([certificateResult, privateKeyResult, caCertificateResult]) => {
	            if (!this.refreshTimer) {
	                return;
	            }
	            trace('File watcher read certificates certificate' + (certificateResult ? '!=' : '==') + 'null, privateKey' + (privateKeyResult ? '!=' : '==') + 'null, CA certificate' + (caCertificateResult ? '!=' : '==') + 'null');
	            this.lastUpdateTime = new Date();
	            this.fileResultPromise = null;
	            if (certificateResult.status === 'fulfilled' && privateKeyResult.status === 'fulfilled') {
	                this.latestIdentityUpdate = {
	                    certificate: certificateResult.value,
	                    privateKey: privateKeyResult.value
	                };
	            }
	            else {
	                this.latestIdentityUpdate = null;
	            }
	            if (caCertificateResult.status === 'fulfilled') {
	                this.latestCaUpdate = {
	                    caCertificate: caCertificateResult.value
	                };
	            }
	            for (const listener of this.identityListeners) {
	                listener(this.latestIdentityUpdate);
	            }
	            for (const listener of this.caListeners) {
	                listener(this.latestCaUpdate);
	            }
	        });
	        trace('File watcher initiated certificate update');
	    }
	    maybeStartWatchingFiles() {
	        if (!this.refreshTimer) {
	            /* Perform the first read immediately, but only if there was not already
	             * a recent read, to avoid reading from the filesystem significantly more
	             * frequently than configured if the provider quickly switches between
	             * used and unused. */
	            const timeSinceLastUpdate = this.lastUpdateTime ? (new Date()).getTime() - this.lastUpdateTime.getTime() : Infinity;
	            if (timeSinceLastUpdate > this.config.refreshIntervalMs) {
	                this.updateCertificates();
	            }
	            if (timeSinceLastUpdate > this.config.refreshIntervalMs * 2) {
	                // Clear out old updates if they are definitely stale
	                this.latestCaUpdate = null;
	                this.latestIdentityUpdate = null;
	            }
	            this.refreshTimer = setInterval(() => this.updateCertificates(), this.config.refreshIntervalMs);
	            trace('File watcher started watching');
	        }
	    }
	    maybeStopWatchingFiles() {
	        if (this.caListeners.size === 0 && this.identityListeners.size === 0) {
	            this.fileResultPromise = null;
	            if (this.refreshTimer) {
	                clearInterval(this.refreshTimer);
	                this.refreshTimer = null;
	            }
	        }
	    }
	    addCaCertificateListener(listener) {
	        this.caListeners.add(listener);
	        this.maybeStartWatchingFiles();
	        process.nextTick(listener, this.latestCaUpdate);
	    }
	    removeCaCertificateListener(listener) {
	        this.caListeners.delete(listener);
	        this.maybeStopWatchingFiles();
	    }
	    addIdentityCertificateListener(listener) {
	        this.identityListeners.add(listener);
	        this.maybeStartWatchingFiles();
	        process.nextTick(listener, this.latestIdentityUpdate);
	    }
	    removeIdentityCertificateListener(listener) {
	        this.identityListeners.delete(listener);
	        this.maybeStopWatchingFiles();
	    }
	}
	certificateProvider.FileWatcherCertificateProvider = FileWatcherCertificateProvider;
	
	return certificateProvider;
}

var hasRequiredExperimental;

function requireExperimental () {
	if (hasRequiredExperimental) return experimental;
	hasRequiredExperimental = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.createCertificateProviderChannelCredentials = exports.FileWatcherCertificateProvider = exports.createCertificateProviderServerCredentials = exports.createServerCredentialsWithInterceptors = exports.BaseSubchannelWrapper = exports.registerAdminService = exports.FilterStackFactory = exports.BaseFilter = exports.PickResultType = exports.QueuePicker = exports.UnavailablePicker = exports.ChildLoadBalancerHandler = exports.EndpointMap = exports.endpointHasAddress = exports.endpointToString = exports.subchannelAddressToString = exports.LeafLoadBalancer = exports.isLoadBalancerNameRegistered = exports.parseLoadBalancingConfig = exports.selectLbConfigFromList = exports.registerLoadBalancerType = exports.createChildChannelControlHelper = exports.BackoffTimeout = exports.parseDuration = exports.durationToMs = exports.splitHostPort = exports.uriToString = exports.createResolver = exports.registerResolver = exports.log = exports.trace = undefined;
		var logging_1 = requireLogging();
		Object.defineProperty(exports, "trace", { enumerable: true, get: function () { return logging_1.trace; } });
		Object.defineProperty(exports, "log", { enumerable: true, get: function () { return logging_1.log; } });
		var resolver_1 = requireResolver();
		Object.defineProperty(exports, "registerResolver", { enumerable: true, get: function () { return resolver_1.registerResolver; } });
		Object.defineProperty(exports, "createResolver", { enumerable: true, get: function () { return resolver_1.createResolver; } });
		var uri_parser_1 = requireUriParser();
		Object.defineProperty(exports, "uriToString", { enumerable: true, get: function () { return uri_parser_1.uriToString; } });
		Object.defineProperty(exports, "splitHostPort", { enumerable: true, get: function () { return uri_parser_1.splitHostPort; } });
		var duration_1 = requireDuration();
		Object.defineProperty(exports, "durationToMs", { enumerable: true, get: function () { return duration_1.durationToMs; } });
		Object.defineProperty(exports, "parseDuration", { enumerable: true, get: function () { return duration_1.parseDuration; } });
		var backoff_timeout_1 = requireBackoffTimeout();
		Object.defineProperty(exports, "BackoffTimeout", { enumerable: true, get: function () { return backoff_timeout_1.BackoffTimeout; } });
		var load_balancer_1 = requireLoadBalancer();
		Object.defineProperty(exports, "createChildChannelControlHelper", { enumerable: true, get: function () { return load_balancer_1.createChildChannelControlHelper; } });
		Object.defineProperty(exports, "registerLoadBalancerType", { enumerable: true, get: function () { return load_balancer_1.registerLoadBalancerType; } });
		Object.defineProperty(exports, "selectLbConfigFromList", { enumerable: true, get: function () { return load_balancer_1.selectLbConfigFromList; } });
		Object.defineProperty(exports, "parseLoadBalancingConfig", { enumerable: true, get: function () { return load_balancer_1.parseLoadBalancingConfig; } });
		Object.defineProperty(exports, "isLoadBalancerNameRegistered", { enumerable: true, get: function () { return load_balancer_1.isLoadBalancerNameRegistered; } });
		var load_balancer_pick_first_1 = requireLoadBalancerPickFirst();
		Object.defineProperty(exports, "LeafLoadBalancer", { enumerable: true, get: function () { return load_balancer_pick_first_1.LeafLoadBalancer; } });
		var subchannel_address_1 = requireSubchannelAddress();
		Object.defineProperty(exports, "subchannelAddressToString", { enumerable: true, get: function () { return subchannel_address_1.subchannelAddressToString; } });
		Object.defineProperty(exports, "endpointToString", { enumerable: true, get: function () { return subchannel_address_1.endpointToString; } });
		Object.defineProperty(exports, "endpointHasAddress", { enumerable: true, get: function () { return subchannel_address_1.endpointHasAddress; } });
		Object.defineProperty(exports, "EndpointMap", { enumerable: true, get: function () { return subchannel_address_1.EndpointMap; } });
		var load_balancer_child_handler_1 = requireLoadBalancerChildHandler();
		Object.defineProperty(exports, "ChildLoadBalancerHandler", { enumerable: true, get: function () { return load_balancer_child_handler_1.ChildLoadBalancerHandler; } });
		var picker_1 = requirePicker();
		Object.defineProperty(exports, "UnavailablePicker", { enumerable: true, get: function () { return picker_1.UnavailablePicker; } });
		Object.defineProperty(exports, "QueuePicker", { enumerable: true, get: function () { return picker_1.QueuePicker; } });
		Object.defineProperty(exports, "PickResultType", { enumerable: true, get: function () { return picker_1.PickResultType; } });
		var filter_1 = requireFilter();
		Object.defineProperty(exports, "BaseFilter", { enumerable: true, get: function () { return filter_1.BaseFilter; } });
		var filter_stack_1 = requireFilterStack();
		Object.defineProperty(exports, "FilterStackFactory", { enumerable: true, get: function () { return filter_stack_1.FilterStackFactory; } });
		var admin_1 = requireAdmin();
		Object.defineProperty(exports, "registerAdminService", { enumerable: true, get: function () { return admin_1.registerAdminService; } });
		var subchannel_interface_1 = requireSubchannelInterface();
		Object.defineProperty(exports, "BaseSubchannelWrapper", { enumerable: true, get: function () { return subchannel_interface_1.BaseSubchannelWrapper; } });
		var server_credentials_1 = requireServerCredentials();
		Object.defineProperty(exports, "createServerCredentialsWithInterceptors", { enumerable: true, get: function () { return server_credentials_1.createServerCredentialsWithInterceptors; } });
		Object.defineProperty(exports, "createCertificateProviderServerCredentials", { enumerable: true, get: function () { return server_credentials_1.createCertificateProviderServerCredentials; } });
		var certificate_provider_1 = requireCertificateProvider();
		Object.defineProperty(exports, "FileWatcherCertificateProvider", { enumerable: true, get: function () { return certificate_provider_1.FileWatcherCertificateProvider; } });
		var channel_credentials_1 = requireChannelCredentials();
		Object.defineProperty(exports, "createCertificateProviderChannelCredentials", { enumerable: true, get: function () { return channel_credentials_1.createCertificateProviderChannelCredentials; } });
		
	} (experimental));
	return experimental;
}

var resolverUds = {};

var hasRequiredResolverUds;

function requireResolverUds () {
	if (hasRequiredResolverUds) return resolverUds;
	hasRequiredResolverUds = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(resolverUds, "__esModule", { value: true });
	resolverUds.setup = undefined;
	const resolver_1 = requireResolver();
	class UdsResolver {
	    constructor(target, listener, channelOptions) {
	        this.listener = listener;
	        this.hasReturnedResult = false;
	        this.endpoints = [];
	        let path;
	        if (target.authority === '') {
	            path = '/' + target.path;
	        }
	        else {
	            path = target.path;
	        }
	        this.endpoints = [{ addresses: [{ path }] }];
	    }
	    updateResolution() {
	        if (!this.hasReturnedResult) {
	            this.hasReturnedResult = true;
	            process.nextTick(this.listener.onSuccessfulResolution, this.endpoints, null, null, null, {});
	        }
	    }
	    destroy() {
	        this.hasReturnedResult = false;
	    }
	    static getDefaultAuthority(target) {
	        return 'localhost';
	    }
	}
	function setup() {
	    (0, resolver_1.registerResolver)('unix', UdsResolver);
	}
	resolverUds.setup = setup;
	
	return resolverUds;
}

var resolverIp = {};

var hasRequiredResolverIp;

function requireResolverIp () {
	if (hasRequiredResolverIp) return resolverIp;
	hasRequiredResolverIp = 1;
	/*
	 * Copyright 2021 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(resolverIp, "__esModule", { value: true });
	resolverIp.setup = undefined;
	const net_1 = require$$0$2;
	const constants_1 = requireConstants();
	const metadata_1 = requireMetadata();
	const resolver_1 = requireResolver();
	const uri_parser_1 = requireUriParser();
	const logging = requireLogging();
	const TRACER_NAME = 'ip_resolver';
	function trace(text) {
	    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
	}
	const IPV4_SCHEME = 'ipv4';
	const IPV6_SCHEME = 'ipv6';
	/**
	 * The default TCP port to connect to if not explicitly specified in the target.
	 */
	const DEFAULT_PORT = 443;
	class IpResolver {
	    constructor(target, listener, channelOptions) {
	        var _a;
	        this.listener = listener;
	        this.endpoints = [];
	        this.error = null;
	        this.hasReturnedResult = false;
	        trace('Resolver constructed for target ' + (0, uri_parser_1.uriToString)(target));
	        const addresses = [];
	        if (!(target.scheme === IPV4_SCHEME || target.scheme === IPV6_SCHEME)) {
	            this.error = {
	                code: constants_1.Status.UNAVAILABLE,
	                details: `Unrecognized scheme ${target.scheme} in IP resolver`,
	                metadata: new metadata_1.Metadata(),
	            };
	            return;
	        }
	        const pathList = target.path.split(',');
	        for (const path of pathList) {
	            const hostPort = (0, uri_parser_1.splitHostPort)(path);
	            if (hostPort === null) {
	                this.error = {
	                    code: constants_1.Status.UNAVAILABLE,
	                    details: `Failed to parse ${target.scheme} address ${path}`,
	                    metadata: new metadata_1.Metadata(),
	                };
	                return;
	            }
	            if ((target.scheme === IPV4_SCHEME && !(0, net_1.isIPv4)(hostPort.host)) ||
	                (target.scheme === IPV6_SCHEME && !(0, net_1.isIPv6)(hostPort.host))) {
	                this.error = {
	                    code: constants_1.Status.UNAVAILABLE,
	                    details: `Failed to parse ${target.scheme} address ${path}`,
	                    metadata: new metadata_1.Metadata(),
	                };
	                return;
	            }
	            addresses.push({
	                host: hostPort.host,
	                port: (_a = hostPort.port) !== null && _a !== undefined ? _a : DEFAULT_PORT,
	            });
	        }
	        this.endpoints = addresses.map(address => ({ addresses: [address] }));
	        trace('Parsed ' + target.scheme + ' address list ' + addresses);
	    }
	    updateResolution() {
	        if (!this.hasReturnedResult) {
	            this.hasReturnedResult = true;
	            process.nextTick(() => {
	                if (this.error) {
	                    this.listener.onError(this.error);
	                }
	                else {
	                    this.listener.onSuccessfulResolution(this.endpoints, null, null, null, {});
	                }
	            });
	        }
	    }
	    destroy() {
	        this.hasReturnedResult = false;
	    }
	    static getDefaultAuthority(target) {
	        return target.path.split(',')[0];
	    }
	}
	function setup() {
	    (0, resolver_1.registerResolver)(IPV4_SCHEME, IpResolver);
	    (0, resolver_1.registerResolver)(IPV6_SCHEME, IpResolver);
	}
	resolverIp.setup = setup;
	
	return resolverIp;
}

var loadBalancerRoundRobin = {};

var hasRequiredLoadBalancerRoundRobin;

function requireLoadBalancerRoundRobin () {
	if (hasRequiredLoadBalancerRoundRobin) return loadBalancerRoundRobin;
	hasRequiredLoadBalancerRoundRobin = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(loadBalancerRoundRobin, "__esModule", { value: true });
	loadBalancerRoundRobin.setup = loadBalancerRoundRobin.RoundRobinLoadBalancer = undefined;
	const load_balancer_1 = requireLoadBalancer();
	const connectivity_state_1 = requireConnectivityState();
	const picker_1 = requirePicker();
	const logging = requireLogging();
	const constants_1 = requireConstants();
	const subchannel_address_1 = requireSubchannelAddress();
	const load_balancer_pick_first_1 = requireLoadBalancerPickFirst();
	const TRACER_NAME = 'round_robin';
	function trace(text) {
	    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
	}
	const TYPE_NAME = 'round_robin';
	class RoundRobinLoadBalancingConfig {
	    getLoadBalancerName() {
	        return TYPE_NAME;
	    }
	    constructor() { }
	    toJsonObject() {
	        return {
	            [TYPE_NAME]: {},
	        };
	    }
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    static createFromJson(obj) {
	        return new RoundRobinLoadBalancingConfig();
	    }
	}
	class RoundRobinPicker {
	    constructor(children, nextIndex = 0) {
	        this.children = children;
	        this.nextIndex = nextIndex;
	    }
	    pick(pickArgs) {
	        const childPicker = this.children[this.nextIndex].picker;
	        this.nextIndex = (this.nextIndex + 1) % this.children.length;
	        return childPicker.pick(pickArgs);
	    }
	    /**
	     * Check what the next subchannel returned would be. Used by the load
	     * balancer implementation to preserve this part of the picker state if
	     * possible when a subchannel connects or disconnects.
	     */
	    peekNextEndpoint() {
	        return this.children[this.nextIndex].endpoint;
	    }
	}
	class RoundRobinLoadBalancer {
	    constructor(channelControlHelper, credentials, options) {
	        this.channelControlHelper = channelControlHelper;
	        this.credentials = credentials;
	        this.options = options;
	        this.children = [];
	        this.currentState = connectivity_state_1.ConnectivityState.IDLE;
	        this.currentReadyPicker = null;
	        this.updatesPaused = false;
	        this.lastError = null;
	        this.childChannelControlHelper = (0, load_balancer_1.createChildChannelControlHelper)(channelControlHelper, {
	            updateState: (connectivityState, picker) => {
	                /* Ensure that name resolution is requested again after active
	                 * connections are dropped. This is more aggressive than necessary to
	                 * accomplish that, so we are counting on resolvers to have
	                 * reasonable rate limits. */
	                if (this.currentState === connectivity_state_1.ConnectivityState.READY && connectivityState !== connectivity_state_1.ConnectivityState.READY) {
	                    this.channelControlHelper.requestReresolution();
	                }
	                this.calculateAndUpdateState();
	            },
	        });
	    }
	    countChildrenWithState(state) {
	        return this.children.filter(child => child.getConnectivityState() === state)
	            .length;
	    }
	    calculateAndUpdateState() {
	        if (this.updatesPaused) {
	            return;
	        }
	        if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.READY) > 0) {
	            const readyChildren = this.children.filter(child => child.getConnectivityState() === connectivity_state_1.ConnectivityState.READY);
	            let index = 0;
	            if (this.currentReadyPicker !== null) {
	                const nextPickedEndpoint = this.currentReadyPicker.peekNextEndpoint();
	                index = readyChildren.findIndex(child => (0, subchannel_address_1.endpointEqual)(child.getEndpoint(), nextPickedEndpoint));
	                if (index < 0) {
	                    index = 0;
	                }
	            }
	            this.updateState(connectivity_state_1.ConnectivityState.READY, new RoundRobinPicker(readyChildren.map(child => ({
	                endpoint: child.getEndpoint(),
	                picker: child.getPicker(),
	            })), index));
	        }
	        else if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.CONNECTING) > 0) {
	            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
	        }
	        else if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) > 0) {
	            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({
	                details: `No connection established. Last error: ${this.lastError}`,
	            }));
	        }
	        else {
	            this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
	        }
	        /* round_robin should keep all children connected, this is how we do that.
	         * We can't do this more efficiently in the individual child's updateState
	         * callback because that doesn't have a reference to which child the state
	         * change is associated with. */
	        for (const child of this.children) {
	            if (child.getConnectivityState() === connectivity_state_1.ConnectivityState.IDLE) {
	                child.exitIdle();
	            }
	        }
	    }
	    updateState(newState, picker) {
	        trace(connectivity_state_1.ConnectivityState[this.currentState] +
	            ' -> ' +
	            connectivity_state_1.ConnectivityState[newState]);
	        if (newState === connectivity_state_1.ConnectivityState.READY) {
	            this.currentReadyPicker = picker;
	        }
	        else {
	            this.currentReadyPicker = null;
	        }
	        this.currentState = newState;
	        this.channelControlHelper.updateState(newState, picker);
	    }
	    resetSubchannelList() {
	        for (const child of this.children) {
	            child.destroy();
	        }
	    }
	    updateAddressList(endpointList, lbConfig) {
	        this.resetSubchannelList();
	        trace('Connect to endpoint list ' + endpointList.map(subchannel_address_1.endpointToString));
	        this.updatesPaused = true;
	        this.children = endpointList.map(endpoint => new load_balancer_pick_first_1.LeafLoadBalancer(endpoint, this.childChannelControlHelper, this.credentials, this.options));
	        for (const child of this.children) {
	            child.startConnecting();
	        }
	        this.updatesPaused = false;
	        this.calculateAndUpdateState();
	    }
	    exitIdle() {
	        /* The round_robin LB policy is only in the IDLE state if it has no
	         * addresses to try to connect to and it has no picked subchannel.
	         * In that case, there is no meaningful action that can be taken here. */
	    }
	    resetBackoff() {
	        // This LB policy has no backoff to reset
	    }
	    destroy() {
	        this.resetSubchannelList();
	    }
	    getTypeName() {
	        return TYPE_NAME;
	    }
	}
	loadBalancerRoundRobin.RoundRobinLoadBalancer = RoundRobinLoadBalancer;
	function setup() {
	    (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, RoundRobinLoadBalancer, RoundRobinLoadBalancingConfig);
	}
	loadBalancerRoundRobin.setup = setup;
	
	return loadBalancerRoundRobin;
}

var loadBalancerOutlierDetection = {};

var hasRequiredLoadBalancerOutlierDetection;

function requireLoadBalancerOutlierDetection () {
	if (hasRequiredLoadBalancerOutlierDetection) return loadBalancerOutlierDetection;
	hasRequiredLoadBalancerOutlierDetection = 1;
	/*
	 * Copyright 2022 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	var _a;
	Object.defineProperty(loadBalancerOutlierDetection, "__esModule", { value: true });
	loadBalancerOutlierDetection.setup = loadBalancerOutlierDetection.OutlierDetectionLoadBalancer = loadBalancerOutlierDetection.OutlierDetectionLoadBalancingConfig = undefined;
	const connectivity_state_1 = requireConnectivityState();
	const constants_1 = requireConstants();
	const duration_1 = requireDuration();
	const experimental_1 = requireExperimental();
	const load_balancer_1 = requireLoadBalancer();
	const load_balancer_child_handler_1 = requireLoadBalancerChildHandler();
	const picker_1 = requirePicker();
	const subchannel_address_1 = requireSubchannelAddress();
	const subchannel_interface_1 = requireSubchannelInterface();
	const logging = requireLogging();
	const TRACER_NAME = 'outlier_detection';
	function trace(text) {
	    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
	}
	const TYPE_NAME = 'outlier_detection';
	const OUTLIER_DETECTION_ENABLED = ((_a = process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION) !== null && _a !== undefined ? _a : 'true') === 'true';
	const defaultSuccessRateEjectionConfig = {
	    stdev_factor: 1900,
	    enforcement_percentage: 100,
	    minimum_hosts: 5,
	    request_volume: 100,
	};
	const defaultFailurePercentageEjectionConfig = {
	    threshold: 85,
	    enforcement_percentage: 100,
	    minimum_hosts: 5,
	    request_volume: 50,
	};
	function validateFieldType(obj, fieldName, expectedType, objectName) {
	    if (fieldName in obj &&
	        obj[fieldName] !== undefined &&
	        typeof obj[fieldName] !== expectedType) {
	        const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;
	        throw new Error(`outlier detection config ${fullFieldName} parse error: expected ${expectedType}, got ${typeof obj[fieldName]}`);
	    }
	}
	function validatePositiveDuration(obj, fieldName, objectName) {
	    const fullFieldName = fieldName;
	    if (fieldName in obj && obj[fieldName] !== undefined) {
	        if (!(0, duration_1.isDuration)(obj[fieldName])) {
	            throw new Error(`outlier detection config ${fullFieldName} parse error: expected Duration, got ${typeof obj[fieldName]}`);
	        }
	        if (!(obj[fieldName].seconds >= 0 &&
	            obj[fieldName].seconds <= 315576000000 &&
	            obj[fieldName].nanos >= 0 &&
	            obj[fieldName].nanos <= 999999999)) {
	            throw new Error(`outlier detection config ${fullFieldName} parse error: values out of range for non-negative Duaration`);
	        }
	    }
	}
	function validatePercentage(obj, fieldName, objectName) {
	    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;
	    validateFieldType(obj, fieldName, 'number', objectName);
	    if (fieldName in obj &&
	        obj[fieldName] !== undefined &&
	        !(obj[fieldName] >= 0 && obj[fieldName] <= 100)) {
	        throw new Error(`outlier detection config ${fullFieldName} parse error: value out of range for percentage (0-100)`);
	    }
	}
	class OutlierDetectionLoadBalancingConfig {
	    constructor(intervalMs, baseEjectionTimeMs, maxEjectionTimeMs, maxEjectionPercent, successRateEjection, failurePercentageEjection, childPolicy) {
	        this.childPolicy = childPolicy;
	        if (childPolicy.getLoadBalancerName() === 'pick_first') {
	            throw new Error('outlier_detection LB policy cannot have a pick_first child policy');
	        }
	        this.intervalMs = intervalMs !== null && intervalMs !== undefined ? intervalMs : 10000;
	        this.baseEjectionTimeMs = baseEjectionTimeMs !== null && baseEjectionTimeMs !== undefined ? baseEjectionTimeMs : 30000;
	        this.maxEjectionTimeMs = maxEjectionTimeMs !== null && maxEjectionTimeMs !== undefined ? maxEjectionTimeMs : 300000;
	        this.maxEjectionPercent = maxEjectionPercent !== null && maxEjectionPercent !== undefined ? maxEjectionPercent : 10;
	        this.successRateEjection = successRateEjection
	            ? Object.assign(Object.assign({}, defaultSuccessRateEjectionConfig), successRateEjection) : null;
	        this.failurePercentageEjection = failurePercentageEjection
	            ? Object.assign(Object.assign({}, defaultFailurePercentageEjectionConfig), failurePercentageEjection) : null;
	    }
	    getLoadBalancerName() {
	        return TYPE_NAME;
	    }
	    toJsonObject() {
	        var _a, _b;
	        return {
	            outlier_detection: {
	                interval: (0, duration_1.msToDuration)(this.intervalMs),
	                base_ejection_time: (0, duration_1.msToDuration)(this.baseEjectionTimeMs),
	                max_ejection_time: (0, duration_1.msToDuration)(this.maxEjectionTimeMs),
	                max_ejection_percent: this.maxEjectionPercent,
	                success_rate_ejection: (_a = this.successRateEjection) !== null && _a !== undefined ? _a : undefined,
	                failure_percentage_ejection: (_b = this.failurePercentageEjection) !== null && _b !== undefined ? _b : undefined,
	                child_policy: [this.childPolicy.toJsonObject()],
	            },
	        };
	    }
	    getIntervalMs() {
	        return this.intervalMs;
	    }
	    getBaseEjectionTimeMs() {
	        return this.baseEjectionTimeMs;
	    }
	    getMaxEjectionTimeMs() {
	        return this.maxEjectionTimeMs;
	    }
	    getMaxEjectionPercent() {
	        return this.maxEjectionPercent;
	    }
	    getSuccessRateEjectionConfig() {
	        return this.successRateEjection;
	    }
	    getFailurePercentageEjectionConfig() {
	        return this.failurePercentageEjection;
	    }
	    getChildPolicy() {
	        return this.childPolicy;
	    }
	    static createFromJson(obj) {
	        var _a;
	        validatePositiveDuration(obj, 'interval');
	        validatePositiveDuration(obj, 'base_ejection_time');
	        validatePositiveDuration(obj, 'max_ejection_time');
	        validatePercentage(obj, 'max_ejection_percent');
	        if ('success_rate_ejection' in obj &&
	            obj.success_rate_ejection !== undefined) {
	            if (typeof obj.success_rate_ejection !== 'object') {
	                throw new Error('outlier detection config success_rate_ejection must be an object');
	            }
	            validateFieldType(obj.success_rate_ejection, 'stdev_factor', 'number', 'success_rate_ejection');
	            validatePercentage(obj.success_rate_ejection, 'enforcement_percentage', 'success_rate_ejection');
	            validateFieldType(obj.success_rate_ejection, 'minimum_hosts', 'number', 'success_rate_ejection');
	            validateFieldType(obj.success_rate_ejection, 'request_volume', 'number', 'success_rate_ejection');
	        }
	        if ('failure_percentage_ejection' in obj &&
	            obj.failure_percentage_ejection !== undefined) {
	            if (typeof obj.failure_percentage_ejection !== 'object') {
	                throw new Error('outlier detection config failure_percentage_ejection must be an object');
	            }
	            validatePercentage(obj.failure_percentage_ejection, 'threshold', 'failure_percentage_ejection');
	            validatePercentage(obj.failure_percentage_ejection, 'enforcement_percentage', 'failure_percentage_ejection');
	            validateFieldType(obj.failure_percentage_ejection, 'minimum_hosts', 'number', 'failure_percentage_ejection');
	            validateFieldType(obj.failure_percentage_ejection, 'request_volume', 'number', 'failure_percentage_ejection');
	        }
	        if (!('child_policy' in obj) || !Array.isArray(obj.child_policy)) {
	            throw new Error('outlier detection config child_policy must be an array');
	        }
	        const childPolicy = (0, load_balancer_1.selectLbConfigFromList)(obj.child_policy);
	        if (!childPolicy) {
	            throw new Error('outlier detection config child_policy: no valid recognized policy found');
	        }
	        return new OutlierDetectionLoadBalancingConfig(obj.interval ? (0, duration_1.durationToMs)(obj.interval) : null, obj.base_ejection_time ? (0, duration_1.durationToMs)(obj.base_ejection_time) : null, obj.max_ejection_time ? (0, duration_1.durationToMs)(obj.max_ejection_time) : null, (_a = obj.max_ejection_percent) !== null && _a !== undefined ? _a : null, obj.success_rate_ejection, obj.failure_percentage_ejection, childPolicy);
	    }
	}
	loadBalancerOutlierDetection.OutlierDetectionLoadBalancingConfig = OutlierDetectionLoadBalancingConfig;
	class OutlierDetectionSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {
	    constructor(childSubchannel, mapEntry) {
	        super(childSubchannel);
	        this.mapEntry = mapEntry;
	        this.refCount = 0;
	    }
	    ref() {
	        this.child.ref();
	        this.refCount += 1;
	    }
	    unref() {
	        this.child.unref();
	        this.refCount -= 1;
	        if (this.refCount <= 0) {
	            if (this.mapEntry) {
	                const index = this.mapEntry.subchannelWrappers.indexOf(this);
	                if (index >= 0) {
	                    this.mapEntry.subchannelWrappers.splice(index, 1);
	                }
	            }
	        }
	    }
	    eject() {
	        this.setHealthy(false);
	    }
	    uneject() {
	        this.setHealthy(true);
	    }
	    getMapEntry() {
	        return this.mapEntry;
	    }
	    getWrappedSubchannel() {
	        return this.child;
	    }
	}
	function createEmptyBucket() {
	    return {
	        success: 0,
	        failure: 0,
	    };
	}
	class CallCounter {
	    constructor() {
	        this.activeBucket = createEmptyBucket();
	        this.inactiveBucket = createEmptyBucket();
	    }
	    addSuccess() {
	        this.activeBucket.success += 1;
	    }
	    addFailure() {
	        this.activeBucket.failure += 1;
	    }
	    switchBuckets() {
	        this.inactiveBucket = this.activeBucket;
	        this.activeBucket = createEmptyBucket();
	    }
	    getLastSuccesses() {
	        return this.inactiveBucket.success;
	    }
	    getLastFailures() {
	        return this.inactiveBucket.failure;
	    }
	}
	class OutlierDetectionPicker {
	    constructor(wrappedPicker, countCalls) {
	        this.wrappedPicker = wrappedPicker;
	        this.countCalls = countCalls;
	    }
	    pick(pickArgs) {
	        const wrappedPick = this.wrappedPicker.pick(pickArgs);
	        if (wrappedPick.pickResultType === picker_1.PickResultType.COMPLETE) {
	            const subchannelWrapper = wrappedPick.subchannel;
	            const mapEntry = subchannelWrapper.getMapEntry();
	            if (mapEntry) {
	                let onCallEnded = wrappedPick.onCallEnded;
	                if (this.countCalls) {
	                    onCallEnded = statusCode => {
	                        var _a;
	                        if (statusCode === constants_1.Status.OK) {
	                            mapEntry.counter.addSuccess();
	                        }
	                        else {
	                            mapEntry.counter.addFailure();
	                        }
	                        (_a = wrappedPick.onCallEnded) === null || _a === undefined ? undefined : _a.call(wrappedPick, statusCode);
	                    };
	                }
	                return Object.assign(Object.assign({}, wrappedPick), { subchannel: subchannelWrapper.getWrappedSubchannel(), onCallEnded: onCallEnded });
	            }
	            else {
	                return Object.assign(Object.assign({}, wrappedPick), { subchannel: subchannelWrapper.getWrappedSubchannel() });
	            }
	        }
	        else {
	            return wrappedPick;
	        }
	    }
	}
	class OutlierDetectionLoadBalancer {
	    constructor(channelControlHelper, credentials, options) {
	        this.entryMap = new subchannel_address_1.EndpointMap();
	        this.latestConfig = null;
	        this.timerStartTime = null;
	        this.childBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler((0, experimental_1.createChildChannelControlHelper)(channelControlHelper, {
	            createSubchannel: (subchannelAddress, subchannelArgs, credentialsOverride) => {
	                const originalSubchannel = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs, credentialsOverride);
	                const mapEntry = this.entryMap.getForSubchannelAddress(subchannelAddress);
	                const subchannelWrapper = new OutlierDetectionSubchannelWrapper(originalSubchannel, mapEntry);
	                if ((mapEntry === null || mapEntry === undefined ? undefined : mapEntry.currentEjectionTimestamp) !== null) {
	                    // If the address is ejected, propagate that to the new subchannel wrapper
	                    subchannelWrapper.eject();
	                }
	                mapEntry === null || mapEntry === undefined ? undefined : mapEntry.subchannelWrappers.push(subchannelWrapper);
	                return subchannelWrapper;
	            },
	            updateState: (connectivityState, picker) => {
	                if (connectivityState === connectivity_state_1.ConnectivityState.READY) {
	                    channelControlHelper.updateState(connectivityState, new OutlierDetectionPicker(picker, this.isCountingEnabled()));
	                }
	                else {
	                    channelControlHelper.updateState(connectivityState, picker);
	                }
	            },
	        }), credentials, options);
	        this.ejectionTimer = setInterval(() => { }, 0);
	        clearInterval(this.ejectionTimer);
	    }
	    isCountingEnabled() {
	        return (this.latestConfig !== null &&
	            (this.latestConfig.getSuccessRateEjectionConfig() !== null ||
	                this.latestConfig.getFailurePercentageEjectionConfig() !== null));
	    }
	    getCurrentEjectionPercent() {
	        let ejectionCount = 0;
	        for (const mapEntry of this.entryMap.values()) {
	            if (mapEntry.currentEjectionTimestamp !== null) {
	                ejectionCount += 1;
	            }
	        }
	        return (ejectionCount * 100) / this.entryMap.size;
	    }
	    runSuccessRateCheck(ejectionTimestamp) {
	        if (!this.latestConfig) {
	            return;
	        }
	        const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();
	        if (!successRateConfig) {
	            return;
	        }
	        trace('Running success rate check');
	        // Step 1
	        const targetRequestVolume = successRateConfig.request_volume;
	        let addresesWithTargetVolume = 0;
	        const successRates = [];
	        for (const [endpoint, mapEntry] of this.entryMap.entries()) {
	            const successes = mapEntry.counter.getLastSuccesses();
	            const failures = mapEntry.counter.getLastFailures();
	            trace('Stats for ' +
	                (0, subchannel_address_1.endpointToString)(endpoint) +
	                ': successes=' +
	                successes +
	                ' failures=' +
	                failures +
	                ' targetRequestVolume=' +
	                targetRequestVolume);
	            if (successes + failures >= targetRequestVolume) {
	                addresesWithTargetVolume += 1;
	                successRates.push(successes / (successes + failures));
	            }
	        }
	        trace('Found ' +
	            addresesWithTargetVolume +
	            ' success rate candidates; currentEjectionPercent=' +
	            this.getCurrentEjectionPercent() +
	            ' successRates=[' +
	            successRates +
	            ']');
	        if (addresesWithTargetVolume < successRateConfig.minimum_hosts) {
	            return;
	        }
	        // Step 2
	        const successRateMean = successRates.reduce((a, b) => a + b) / successRates.length;
	        let successRateDeviationSum = 0;
	        for (const rate of successRates) {
	            const deviation = rate - successRateMean;
	            successRateDeviationSum += deviation * deviation;
	        }
	        const successRateVariance = successRateDeviationSum / successRates.length;
	        const successRateStdev = Math.sqrt(successRateVariance);
	        const ejectionThreshold = successRateMean -
	            successRateStdev * (successRateConfig.stdev_factor / 1000);
	        trace('stdev=' + successRateStdev + ' ejectionThreshold=' + ejectionThreshold);
	        // Step 3
	        for (const [address, mapEntry] of this.entryMap.entries()) {
	            // Step 3.i
	            if (this.getCurrentEjectionPercent() >=
	                this.latestConfig.getMaxEjectionPercent()) {
	                break;
	            }
	            // Step 3.ii
	            const successes = mapEntry.counter.getLastSuccesses();
	            const failures = mapEntry.counter.getLastFailures();
	            if (successes + failures < targetRequestVolume) {
	                continue;
	            }
	            // Step 3.iii
	            const successRate = successes / (successes + failures);
	            trace('Checking candidate ' + address + ' successRate=' + successRate);
	            if (successRate < ejectionThreshold) {
	                const randomNumber = Math.random() * 100;
	                trace('Candidate ' +
	                    address +
	                    ' randomNumber=' +
	                    randomNumber +
	                    ' enforcement_percentage=' +
	                    successRateConfig.enforcement_percentage);
	                if (randomNumber < successRateConfig.enforcement_percentage) {
	                    trace('Ejecting candidate ' + address);
	                    this.eject(mapEntry, ejectionTimestamp);
	                }
	            }
	        }
	    }
	    runFailurePercentageCheck(ejectionTimestamp) {
	        if (!this.latestConfig) {
	            return;
	        }
	        const failurePercentageConfig = this.latestConfig.getFailurePercentageEjectionConfig();
	        if (!failurePercentageConfig) {
	            return;
	        }
	        trace('Running failure percentage check. threshold=' +
	            failurePercentageConfig.threshold +
	            ' request volume threshold=' +
	            failurePercentageConfig.request_volume);
	        // Step 1
	        let addressesWithTargetVolume = 0;
	        for (const mapEntry of this.entryMap.values()) {
	            const successes = mapEntry.counter.getLastSuccesses();
	            const failures = mapEntry.counter.getLastFailures();
	            if (successes + failures >= failurePercentageConfig.request_volume) {
	                addressesWithTargetVolume += 1;
	            }
	        }
	        if (addressesWithTargetVolume < failurePercentageConfig.minimum_hosts) {
	            return;
	        }
	        // Step 2
	        for (const [address, mapEntry] of this.entryMap.entries()) {
	            // Step 2.i
	            if (this.getCurrentEjectionPercent() >=
	                this.latestConfig.getMaxEjectionPercent()) {
	                break;
	            }
	            // Step 2.ii
	            const successes = mapEntry.counter.getLastSuccesses();
	            const failures = mapEntry.counter.getLastFailures();
	            trace('Candidate successes=' + successes + ' failures=' + failures);
	            if (successes + failures < failurePercentageConfig.request_volume) {
	                continue;
	            }
	            // Step 2.iii
	            const failurePercentage = (failures * 100) / (failures + successes);
	            if (failurePercentage > failurePercentageConfig.threshold) {
	                const randomNumber = Math.random() * 100;
	                trace('Candidate ' +
	                    address +
	                    ' randomNumber=' +
	                    randomNumber +
	                    ' enforcement_percentage=' +
	                    failurePercentageConfig.enforcement_percentage);
	                if (randomNumber < failurePercentageConfig.enforcement_percentage) {
	                    trace('Ejecting candidate ' + address);
	                    this.eject(mapEntry, ejectionTimestamp);
	                }
	            }
	        }
	    }
	    eject(mapEntry, ejectionTimestamp) {
	        mapEntry.currentEjectionTimestamp = new Date();
	        mapEntry.ejectionTimeMultiplier += 1;
	        for (const subchannelWrapper of mapEntry.subchannelWrappers) {
	            subchannelWrapper.eject();
	        }
	    }
	    uneject(mapEntry) {
	        mapEntry.currentEjectionTimestamp = null;
	        for (const subchannelWrapper of mapEntry.subchannelWrappers) {
	            subchannelWrapper.uneject();
	        }
	    }
	    switchAllBuckets() {
	        for (const mapEntry of this.entryMap.values()) {
	            mapEntry.counter.switchBuckets();
	        }
	    }
	    startTimer(delayMs) {
	        var _a, _b;
	        this.ejectionTimer = setTimeout(() => this.runChecks(), delayMs);
	        (_b = (_a = this.ejectionTimer).unref) === null || _b === undefined ? undefined : _b.call(_a);
	    }
	    runChecks() {
	        const ejectionTimestamp = new Date();
	        trace('Ejection timer running');
	        this.switchAllBuckets();
	        if (!this.latestConfig) {
	            return;
	        }
	        this.timerStartTime = ejectionTimestamp;
	        this.startTimer(this.latestConfig.getIntervalMs());
	        this.runSuccessRateCheck(ejectionTimestamp);
	        this.runFailurePercentageCheck(ejectionTimestamp);
	        for (const [address, mapEntry] of this.entryMap.entries()) {
	            if (mapEntry.currentEjectionTimestamp === null) {
	                if (mapEntry.ejectionTimeMultiplier > 0) {
	                    mapEntry.ejectionTimeMultiplier -= 1;
	                }
	            }
	            else {
	                const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();
	                const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();
	                const returnTime = new Date(mapEntry.currentEjectionTimestamp.getTime());
	                returnTime.setMilliseconds(returnTime.getMilliseconds() +
	                    Math.min(baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier, Math.max(baseEjectionTimeMs, maxEjectionTimeMs)));
	                if (returnTime < new Date()) {
	                    trace('Unejecting ' + address);
	                    this.uneject(mapEntry);
	                }
	            }
	        }
	    }
	    updateAddressList(endpointList, lbConfig, attributes) {
	        if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) {
	            return;
	        }
	        for (const endpoint of endpointList) {
	            if (!this.entryMap.has(endpoint)) {
	                trace('Adding map entry for ' + (0, subchannel_address_1.endpointToString)(endpoint));
	                this.entryMap.set(endpoint, {
	                    counter: new CallCounter(),
	                    currentEjectionTimestamp: null,
	                    ejectionTimeMultiplier: 0,
	                    subchannelWrappers: [],
	                });
	            }
	        }
	        this.entryMap.deleteMissing(endpointList);
	        const childPolicy = lbConfig.getChildPolicy();
	        this.childBalancer.updateAddressList(endpointList, childPolicy, attributes);
	        if (lbConfig.getSuccessRateEjectionConfig() ||
	            lbConfig.getFailurePercentageEjectionConfig()) {
	            if (this.timerStartTime) {
	                trace('Previous timer existed. Replacing timer');
	                clearTimeout(this.ejectionTimer);
	                const remainingDelay = lbConfig.getIntervalMs() -
	                    (new Date().getTime() - this.timerStartTime.getTime());
	                this.startTimer(remainingDelay);
	            }
	            else {
	                trace('Starting new timer');
	                this.timerStartTime = new Date();
	                this.startTimer(lbConfig.getIntervalMs());
	                this.switchAllBuckets();
	            }
	        }
	        else {
	            trace('Counting disabled. Cancelling timer.');
	            this.timerStartTime = null;
	            clearTimeout(this.ejectionTimer);
	            for (const mapEntry of this.entryMap.values()) {
	                this.uneject(mapEntry);
	                mapEntry.ejectionTimeMultiplier = 0;
	            }
	        }
	        this.latestConfig = lbConfig;
	    }
	    exitIdle() {
	        this.childBalancer.exitIdle();
	    }
	    resetBackoff() {
	        this.childBalancer.resetBackoff();
	    }
	    destroy() {
	        clearTimeout(this.ejectionTimer);
	        this.childBalancer.destroy();
	    }
	    getTypeName() {
	        return TYPE_NAME;
	    }
	}
	loadBalancerOutlierDetection.OutlierDetectionLoadBalancer = OutlierDetectionLoadBalancer;
	function setup() {
	    if (OUTLIER_DETECTION_ENABLED) {
	        (0, experimental_1.registerLoadBalancerType)(TYPE_NAME, OutlierDetectionLoadBalancer, OutlierDetectionLoadBalancingConfig);
	    }
	}
	loadBalancerOutlierDetection.setup = setup;
	
	return loadBalancerOutlierDetection;
}

var hasRequiredSrc;

function requireSrc () {
	if (hasRequiredSrc) return src$2;
	hasRequiredSrc = 1;
	(function (exports) {
		/*
		 * Copyright 2019 gRPC authors.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *     http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 *
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.experimental = exports.ServerInterceptingCall = exports.ResponderBuilder = exports.ServerListenerBuilder = exports.addAdminServicesToServer = exports.getChannelzHandlers = exports.getChannelzServiceDefinition = exports.InterceptorConfigurationError = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.StatusBuilder = exports.getClientChannel = exports.ServerCredentials = exports.Server = exports.setLogVerbosity = exports.setLogger = exports.load = exports.loadObject = exports.CallCredentials = exports.ChannelCredentials = exports.waitForClientReady = exports.closeClient = exports.Channel = exports.makeGenericClientConstructor = exports.makeClientConstructor = exports.loadPackageDefinition = exports.Client = exports.compressionAlgorithms = exports.propagate = exports.connectivityState = exports.status = exports.logVerbosity = exports.Metadata = exports.credentials = undefined;
		const call_credentials_1 = requireCallCredentials();
		Object.defineProperty(exports, "CallCredentials", { enumerable: true, get: function () { return call_credentials_1.CallCredentials; } });
		const channel_1 = requireChannel$1();
		Object.defineProperty(exports, "Channel", { enumerable: true, get: function () { return channel_1.ChannelImplementation; } });
		const compression_algorithms_1 = requireCompressionAlgorithms();
		Object.defineProperty(exports, "compressionAlgorithms", { enumerable: true, get: function () { return compression_algorithms_1.CompressionAlgorithms; } });
		const connectivity_state_1 = requireConnectivityState();
		Object.defineProperty(exports, "connectivityState", { enumerable: true, get: function () { return connectivity_state_1.ConnectivityState; } });
		const channel_credentials_1 = requireChannelCredentials();
		Object.defineProperty(exports, "ChannelCredentials", { enumerable: true, get: function () { return channel_credentials_1.ChannelCredentials; } });
		const client_1 = requireClient$1();
		Object.defineProperty(exports, "Client", { enumerable: true, get: function () { return client_1.Client; } });
		const constants_1 = requireConstants();
		Object.defineProperty(exports, "logVerbosity", { enumerable: true, get: function () { return constants_1.LogVerbosity; } });
		Object.defineProperty(exports, "status", { enumerable: true, get: function () { return constants_1.Status; } });
		Object.defineProperty(exports, "propagate", { enumerable: true, get: function () { return constants_1.Propagate; } });
		const logging = requireLogging();
		const make_client_1 = requireMakeClient();
		Object.defineProperty(exports, "loadPackageDefinition", { enumerable: true, get: function () { return make_client_1.loadPackageDefinition; } });
		Object.defineProperty(exports, "makeClientConstructor", { enumerable: true, get: function () { return make_client_1.makeClientConstructor; } });
		Object.defineProperty(exports, "makeGenericClientConstructor", { enumerable: true, get: function () { return make_client_1.makeClientConstructor; } });
		const metadata_1 = requireMetadata();
		Object.defineProperty(exports, "Metadata", { enumerable: true, get: function () { return metadata_1.Metadata; } });
		const server_1 = requireServer$1();
		Object.defineProperty(exports, "Server", { enumerable: true, get: function () { return server_1.Server; } });
		const server_credentials_1 = requireServerCredentials();
		Object.defineProperty(exports, "ServerCredentials", { enumerable: true, get: function () { return server_credentials_1.ServerCredentials; } });
		const status_builder_1 = requireStatusBuilder();
		Object.defineProperty(exports, "StatusBuilder", { enumerable: true, get: function () { return status_builder_1.StatusBuilder; } });
		/**** Client Credentials ****/
		// Using assign only copies enumerable properties, which is what we want
		exports.credentials = {
		    /**
		     * Combine a ChannelCredentials with any number of CallCredentials into a
		     * single ChannelCredentials object.
		     * @param channelCredentials The ChannelCredentials object.
		     * @param callCredentials Any number of CallCredentials objects.
		     * @return The resulting ChannelCredentials object.
		     */
		    combineChannelCredentials: (channelCredentials, ...callCredentials) => {
		        return callCredentials.reduce((acc, other) => acc.compose(other), channelCredentials);
		    },
		    /**
		     * Combine any number of CallCredentials into a single CallCredentials
		     * object.
		     * @param first The first CallCredentials object.
		     * @param additional Any number of additional CallCredentials objects.
		     * @return The resulting CallCredentials object.
		     */
		    combineCallCredentials: (first, ...additional) => {
		        return additional.reduce((acc, other) => acc.compose(other), first);
		    },
		    // from channel-credentials.ts
		    createInsecure: channel_credentials_1.ChannelCredentials.createInsecure,
		    createSsl: channel_credentials_1.ChannelCredentials.createSsl,
		    createFromSecureContext: channel_credentials_1.ChannelCredentials.createFromSecureContext,
		    // from call-credentials.ts
		    createFromMetadataGenerator: call_credentials_1.CallCredentials.createFromMetadataGenerator,
		    createFromGoogleCredential: call_credentials_1.CallCredentials.createFromGoogleCredential,
		    createEmpty: call_credentials_1.CallCredentials.createEmpty,
		};
		/**
		 * Close a Client object.
		 * @param client The client to close.
		 */
		const closeClient = (client) => client.close();
		exports.closeClient = closeClient;
		const waitForClientReady = (client, deadline, callback) => client.waitForReady(deadline, callback);
		exports.waitForClientReady = waitForClientReady;
		/* eslint-enable @typescript-eslint/no-explicit-any */
		/**** Unimplemented function stubs ****/
		/* eslint-disable @typescript-eslint/no-explicit-any */
		const loadObject = (value, options) => {
		    throw new Error('Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead');
		};
		exports.loadObject = loadObject;
		const load = (filename, format, options) => {
		    throw new Error('Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead');
		};
		exports.load = load;
		const setLogger = (logger) => {
		    logging.setLogger(logger);
		};
		exports.setLogger = setLogger;
		const setLogVerbosity = (verbosity) => {
		    logging.setLoggerVerbosity(verbosity);
		};
		exports.setLogVerbosity = setLogVerbosity;
		const getClientChannel = (client) => {
		    return client_1.Client.prototype.getChannel.call(client);
		};
		exports.getClientChannel = getClientChannel;
		var client_interceptors_1 = requireClientInterceptors();
		Object.defineProperty(exports, "ListenerBuilder", { enumerable: true, get: function () { return client_interceptors_1.ListenerBuilder; } });
		Object.defineProperty(exports, "RequesterBuilder", { enumerable: true, get: function () { return client_interceptors_1.RequesterBuilder; } });
		Object.defineProperty(exports, "InterceptingCall", { enumerable: true, get: function () { return client_interceptors_1.InterceptingCall; } });
		Object.defineProperty(exports, "InterceptorConfigurationError", { enumerable: true, get: function () { return client_interceptors_1.InterceptorConfigurationError; } });
		var channelz_1 = requireChannelz();
		Object.defineProperty(exports, "getChannelzServiceDefinition", { enumerable: true, get: function () { return channelz_1.getChannelzServiceDefinition; } });
		Object.defineProperty(exports, "getChannelzHandlers", { enumerable: true, get: function () { return channelz_1.getChannelzHandlers; } });
		var admin_1 = requireAdmin();
		Object.defineProperty(exports, "addAdminServicesToServer", { enumerable: true, get: function () { return admin_1.addAdminServicesToServer; } });
		var server_interceptors_1 = requireServerInterceptors();
		Object.defineProperty(exports, "ServerListenerBuilder", { enumerable: true, get: function () { return server_interceptors_1.ServerListenerBuilder; } });
		Object.defineProperty(exports, "ResponderBuilder", { enumerable: true, get: function () { return server_interceptors_1.ResponderBuilder; } });
		Object.defineProperty(exports, "ServerInterceptingCall", { enumerable: true, get: function () { return server_interceptors_1.ServerInterceptingCall; } });
		const experimental = requireExperimental();
		exports.experimental = experimental;
		const resolver_dns = requireResolverDns();
		const resolver_uds = requireResolverUds();
		const resolver_ip = requireResolverIp();
		const load_balancer_pick_first = requireLoadBalancerPickFirst();
		const load_balancer_round_robin = requireLoadBalancerRoundRobin();
		const load_balancer_outlier_detection = requireLoadBalancerOutlierDetection();
		const channelz = requireChannelz();
		(() => {
		    resolver_dns.setup();
		    resolver_uds.setup();
		    resolver_ip.setup();
		    load_balancer_pick_first.setup();
		    load_balancer_round_robin.setup();
		    load_balancer_outlier_detection.setup();
		    channelz.setup();
		})();
		
	} (src$2));
	return src$2;
}

var serviceDefinitions = {};

var grpcJs = {};

var hasRequiredGrpcJs;

function requireGrpcJs () {
	if (hasRequiredGrpcJs) return grpcJs;
	hasRequiredGrpcJs = 1;
	Object.defineProperty(grpcJs, "__esModule", { value: true });
	grpcJs.fromGrpcJsServiceDefinition = fromGrpcJsServiceDefinition;
	grpcJs.isGrpcJsServiceDefinition = isGrpcJsServiceDefinition;
	function fromGrpcJsServiceDefinition(definition) {
	    const result = {};
	    for (const [key, method] of Object.entries(definition)) {
	        result[key] = {
	            path: method.path,
	            requestStream: method.requestStream,
	            responseStream: method.responseStream,
	            requestDeserialize: bytes => method.requestDeserialize(Buffer.from(bytes)),
	            requestSerialize: method.requestSerialize,
	            responseDeserialize: bytes => method.responseDeserialize(Buffer.from(bytes)),
	            responseSerialize: method.responseSerialize,
	            options: {},
	        };
	    }
	    return result;
	}
	function isGrpcJsServiceDefinition(definition) {
	    return Object.values(definition).every(value => typeof value === 'object' &&
	        value != null &&
	        typeof value.path === 'string');
	}
	
	return grpcJs;
}

var tsProto = {};

var hasRequiredTsProto;

function requireTsProto () {
	if (hasRequiredTsProto) return tsProto;
	hasRequiredTsProto = 1;
	Object.defineProperty(tsProto, "__esModule", { value: true });
	tsProto.fromTsProtoServiceDefinition = fromTsProtoServiceDefinition;
	tsProto.isTsProtoServiceDefinition = isTsProtoServiceDefinition;
	function fromTsProtoServiceDefinition(definition) {
	    const result = {};
	    for (const [key, method] of Object.entries(definition.methods)) {
	        const requestEncode = method.requestType.encode;
	        const requestFromPartial = method.requestType.fromPartial;
	        const responseEncode = method.responseType.encode;
	        const responseFromPartial = method.responseType.fromPartial;
	        result[key] = {
	            path: `/${definition.fullName}/${method.name}`,
	            requestStream: method.requestStream,
	            responseStream: method.responseStream,
	            requestDeserialize: method.requestType.decode,
	            requestSerialize: requestFromPartial != null
	                ? value => requestEncode(requestFromPartial(value)).finish()
	                : value => requestEncode(value).finish(),
	            responseDeserialize: method.responseType.decode,
	            responseSerialize: responseFromPartial != null
	                ? value => responseEncode(responseFromPartial(value)).finish()
	                : value => responseEncode(value).finish(),
	            options: method.options,
	        };
	    }
	    return result;
	}
	function isTsProtoServiceDefinition(definition) {
	    return ('name' in definition && 'fullName' in definition && 'methods' in definition);
	}
	
	return tsProto;
}

var hasRequiredServiceDefinitions;

function requireServiceDefinitions () {
	if (hasRequiredServiceDefinitions) return serviceDefinitions;
	hasRequiredServiceDefinitions = 1;
	Object.defineProperty(serviceDefinitions, "__esModule", { value: true });
	serviceDefinitions.normalizeServiceDefinition = normalizeServiceDefinition;
	serviceDefinitions.toGrpcJsServiceDefinition = toGrpcJsServiceDefinition;
	serviceDefinitions.toGrpcJsMethodDefinition = toGrpcJsMethodDefinition;
	const grpc_js_1 = requireGrpcJs();
	const ts_proto_1 = requireTsProto();
	/** @internal */
	function normalizeServiceDefinition(definition) {
	    if ((0, grpc_js_1.isGrpcJsServiceDefinition)(definition)) {
	        return (0, grpc_js_1.fromGrpcJsServiceDefinition)(definition);
	    }
	    else if ((0, ts_proto_1.isTsProtoServiceDefinition)(definition)) {
	        return (0, ts_proto_1.fromTsProtoServiceDefinition)(definition);
	    }
	    else {
	        return definition;
	    }
	}
	/** @internal */
	function toGrpcJsServiceDefinition(definition) {
	    const result = {};
	    for (const [key, method] of Object.entries(definition)) {
	        result[key] = toGrpcJsMethodDefinition(method);
	    }
	    return result;
	}
	/** @internal */
	function toGrpcJsMethodDefinition(definition) {
	    return {
	        path: definition.path,
	        requestStream: definition.requestStream,
	        responseStream: definition.responseStream,
	        requestDeserialize: definition.requestDeserialize,
	        requestSerialize: value => Buffer.from(definition.requestSerialize(value)),
	        responseDeserialize: definition.responseDeserialize,
	        responseSerialize: value => Buffer.from(definition.responseSerialize(value)),
	    };
	}
	
	return serviceDefinitions;
}

var handleBidiStreamingCall = {};

var lib = {};

var abortable = {};

var execute = {};

var AbortError = {};

var hasRequiredAbortError;

function requireAbortError () {
	if (hasRequiredAbortError) return AbortError;
	hasRequiredAbortError = 1;
	Object.defineProperty(AbortError, "__esModule", { value: true });
	AbortError.catchAbortError = AbortError.rethrowAbortError = AbortError.throwIfAborted = AbortError.isAbortError = AbortError.AbortError = undefined;
	/**
	 * Thrown when an abortable function was aborted.
	 *
	 * **Warning**: do not use `instanceof` with this class. Instead, use
	 * `isAbortError` function.
	 */
	let AbortError$1 = class AbortError extends Error {
	    constructor() {
	        super('The operation has been aborted');
	        this.message = 'The operation has been aborted';
	        this.name = 'AbortError';
	        if (typeof Error.captureStackTrace === 'function') {
	            Error.captureStackTrace(this, this.constructor);
	        }
	    }
	};
	AbortError.AbortError = AbortError$1;
	/**
	 * Checks whether given `error` is an `AbortError`.
	 */
	function isAbortError(error) {
	    return (typeof error === 'object' &&
	        error !== null &&
	        error.name === 'AbortError');
	}
	AbortError.isAbortError = isAbortError;
	/**
	 * If `signal` is aborted, throws `AbortError`. Otherwise does nothing.
	 */
	function throwIfAborted(signal) {
	    if (signal.aborted) {
	        throw new AbortError$1();
	    }
	}
	AbortError.throwIfAborted = throwIfAborted;
	/**
	 * If `error` is `AbortError`, throws it. Otherwise does nothing.
	 *
	 * Useful for `try/catch` blocks around abortable code:
	 *
	 *    try {
	 *      await somethingAbortable(signal);
	 *    } catch (err) {
	 *      rethrowAbortError(err);
	 *
	 *      // do normal error handling
	 *    }
	 */
	function rethrowAbortError(error) {
	    if (isAbortError(error)) {
	        throw error;
	    }
	    return;
	}
	AbortError.rethrowAbortError = rethrowAbortError;
	/**
	 * If `error` is `AbortError`, does nothing. Otherwise throws it.
	 *
	 * Useful for invoking top-level abortable functions:
	 *
	 *    somethingAbortable(signal).catch(catchAbortError)
	 *
	 * Without `catchAbortError`, aborting would result in unhandled promise
	 * rejection.
	 */
	function catchAbortError(error) {
	    if (isAbortError(error)) {
	        return;
	    }
	    throw error;
	}
	AbortError.catchAbortError = catchAbortError;
	
	return AbortError;
}

var hasRequiredExecute;

function requireExecute () {
	if (hasRequiredExecute) return execute;
	hasRequiredExecute = 1;
	Object.defineProperty(execute, "__esModule", { value: true });
	execute.execute = undefined;
	const AbortError_1 = requireAbortError();
	/**
	 * Similar to `new Promise(executor)`, but allows executor to return abort
	 * callback that is called once `signal` is aborted.
	 *
	 * Returned promise rejects with `AbortError` once `signal` is aborted.
	 *
	 * Callback can return a promise, e.g. for doing any async cleanup. In this
	 * case, the promise returned from `execute` rejects with `AbortError` after
	 * that promise fulfills.
	 */
	function execute$1(signal, executor) {
	    return new Promise((resolve, reject) => {
	        if (signal.aborted) {
	            reject(new AbortError_1.AbortError());
	            return;
	        }
	        let removeAbortListener;
	        let finished = false;
	        function finish() {
	            if (!finished) {
	                finished = true;
	                if (removeAbortListener != null) {
	                    removeAbortListener();
	                }
	            }
	        }
	        const callback = executor(value => {
	            resolve(value);
	            finish();
	        }, reason => {
	            reject(reason);
	            finish();
	        });
	        if (!finished) {
	            const listener = () => {
	                const callbackResult = callback();
	                if (callbackResult == null) {
	                    reject(new AbortError_1.AbortError());
	                }
	                else {
	                    callbackResult.then(() => {
	                        reject(new AbortError_1.AbortError());
	                    }, reason => {
	                        reject(reason);
	                    });
	                }
	                finish();
	            };
	            signal.addEventListener('abort', listener);
	            removeAbortListener = () => {
	                signal.removeEventListener('abort', listener);
	            };
	        }
	    });
	}
	execute.execute = execute$1;
	
	return execute;
}

var hasRequiredAbortable;

function requireAbortable () {
	if (hasRequiredAbortable) return abortable;
	hasRequiredAbortable = 1;
	Object.defineProperty(abortable, "__esModule", { value: true });
	abortable.abortable = undefined;
	const execute_1 = requireExecute();
	/**
	 * Wrap a promise to reject with `AbortError` once `signal` is aborted.
	 *
	 * Useful to wrap non-abortable promises.
	 * Note that underlying process will NOT be aborted.
	 */
	function abortable$1(signal, promise) {
	    if (signal.aborted) {
	        // prevent unhandled rejection
	        const noop = () => { };
	        promise.then(noop, noop);
	    }
	    return (0, execute_1.execute)(signal, (resolve, reject) => {
	        promise.then(resolve, reject);
	        return () => { };
	    });
	}
	abortable.abortable = abortable$1;
	
	return abortable;
}

var delay = {};

var hasRequiredDelay;

function requireDelay () {
	if (hasRequiredDelay) return delay;
	hasRequiredDelay = 1;
	Object.defineProperty(delay, "__esModule", { value: true });
	delay.delay = undefined;
	const execute_1 = requireExecute();
	/**
	 * Returns a promise that fulfills after delay and rejects with
	 * `AbortError` once `signal` is aborted.
	 *
	 * The delay time is specified as a `Date` object or as an integer denoting
	 * milliseconds to wait.
	 *
	 * Example:
	 *
	 *     // Make requests repeatedly with a delay between consecutive requests
	 *     while (true) {
	 *       await makeRequest(signal, params);
	 *       await delay(signal, 1000);
	 *     }
	 *
	 * Example:
	 *
	 *     // Make requests repeatedly with a fixed interval
	 *     import {addMilliseconds} from 'date-fns';
	 *
	 *     let date = new Date();
	 *
	 *     while (true) {
	 *       await makeRequest(signal, params);
	 *
	 *       date = addMilliseconds(date, 1000);
	 *       await delay(signal, date);
	 *     }
	 */
	function delay$1(signal, dueTime) {
	    return (0, execute_1.execute)(signal, resolve => {
	        const ms = typeof dueTime === 'number' ? dueTime : dueTime.getTime() - Date.now();
	        const timer = setTimeout(resolve, ms);
	        return () => {
	            clearTimeout(timer);
	        };
	    });
	}
	delay.delay = delay$1;
	
	return delay;
}

var forever = {};

var hasRequiredForever;

function requireForever () {
	if (hasRequiredForever) return forever;
	hasRequiredForever = 1;
	Object.defineProperty(forever, "__esModule", { value: true });
	forever.forever = undefined;
	const execute_1 = requireExecute();
	/**
	 * Return a promise that never fulfills and only rejects with `AbortError` once
	 * `signal` is aborted.
	 */
	function forever$1(signal) {
	    return (0, execute_1.execute)(signal, () => () => { });
	}
	forever.forever = forever$1;
	
	return forever;
}

var waitForEvent = {};

var hasRequiredWaitForEvent;

function requireWaitForEvent () {
	if (hasRequiredWaitForEvent) return waitForEvent;
	hasRequiredWaitForEvent = 1;
	Object.defineProperty(waitForEvent, "__esModule", { value: true });
	waitForEvent.waitForEvent = undefined;
	const execute_1 = requireExecute();
	/**
	 * Returns a promise that fulfills when an event of specific type is emitted
	 * from given event target and rejects with `AbortError` once `signal` is
	 * aborted.
	 *
	 * Example:
	 *
	 *     // Create a WebSocket and wait for connection
	 *     const webSocket = new WebSocket(url);
	 *
	 *     const openEvent = await race(signal, signal => [
	 *       waitForEvent<WebSocketEventMap['open']>(signal, webSocket, 'open'),
	 *       waitForEvent<WebSocketEventMap['close']>(signal, webSocket, 'close').then(
	 *         event => {
	 *           throw new Error(`Failed to connect to ${url}: ${event.reason}`);
	 *         },
	 *       ),
	 *     ]);
	 */
	function waitForEvent$1(signal, target, eventName, options) {
	    return (0, execute_1.execute)(signal, resolve => {
	        let unlisten;
	        let finished = false;
	        const handler = (...args) => {
	            resolve(args.length > 1 ? args : args[0]);
	            finished = true;
	            if (unlisten != null) {
	                unlisten();
	            }
	        };
	        unlisten = listen(target, eventName, handler, options);
	        if (finished) {
	            unlisten();
	        }
	        return () => {
	            finished = true;
	            if (unlisten != null) {
	                unlisten();
	            }
	        };
	    });
	}
	waitForEvent.waitForEvent = waitForEvent$1;
	function listen(target, eventName, handler, options) {
	    if (isEventTarget(target)) {
	        target.addEventListener(eventName, handler, options);
	        return () => target.removeEventListener(eventName, handler, options);
	    }
	    if (isJQueryStyleEventEmitter(target)) {
	        target.on(eventName, handler);
	        return () => target.off(eventName, handler);
	    }
	    if (isNodeStyleEventEmitter(target)) {
	        target.addListener(eventName, handler);
	        return () => target.removeListener(eventName, handler);
	    }
	    throw new Error('Invalid event target');
	}
	function isNodeStyleEventEmitter(sourceObj) {
	    return (isFunction(sourceObj.addListener) && isFunction(sourceObj.removeListener));
	}
	function isJQueryStyleEventEmitter(sourceObj) {
	    return isFunction(sourceObj.on) && isFunction(sourceObj.off);
	}
	function isEventTarget(sourceObj) {
	    return (isFunction(sourceObj.addEventListener) &&
	        isFunction(sourceObj.removeEventListener));
	}
	const isFunction = (obj) => typeof obj === 'function';
	
	return waitForEvent;
}

var all = {};

var hasRequiredAll;

function requireAll () {
	if (hasRequiredAll) return all;
	hasRequiredAll = 1;
	Object.defineProperty(all, "__esModule", { value: true });
	all.all = undefined;
	const AbortError_1 = requireAbortError();
	function all$1(signal, executor) {
	    return new Promise((resolve, reject) => {
	        if (signal.aborted) {
	            reject(new AbortError_1.AbortError());
	            return;
	        }
	        const innerAbortController = new AbortController();
	        const promises = executor(innerAbortController.signal);
	        if (promises.length === 0) {
	            resolve([]);
	            return;
	        }
	        const abortListener = () => {
	            innerAbortController.abort();
	        };
	        signal.addEventListener('abort', abortListener);
	        let rejection;
	        const results = new Array(promises.length);
	        let settledCount = 0;
	        function settled() {
	            settledCount += 1;
	            if (settledCount === promises.length) {
	                signal.removeEventListener('abort', abortListener);
	                if (rejection != null) {
	                    reject(rejection.reason);
	                }
	                else {
	                    resolve(results);
	                }
	            }
	        }
	        for (const [i, promise] of promises.entries()) {
	            promise.then(value => {
	                results[i] = value;
	                settled();
	            }, reason => {
	                innerAbortController.abort();
	                if (rejection == null ||
	                    (!(0, AbortError_1.isAbortError)(reason) && (0, AbortError_1.isAbortError)(rejection.reason))) {
	                    rejection = { reason };
	                }
	                settled();
	            });
	        }
	    });
	}
	all.all = all$1;
	
	return all;
}

var race = {};

var hasRequiredRace;

function requireRace () {
	if (hasRequiredRace) return race;
	hasRequiredRace = 1;
	Object.defineProperty(race, "__esModule", { value: true });
	race.race = undefined;
	const AbortError_1 = requireAbortError();
	/**
	 * Abortable version of `Promise.race`.
	 *
	 * Creates new inner `AbortSignal` and passes it to `executor`. That signal is
	 * aborted when `signal` is aborted or any of the promises returned from
	 * `executor` are fulfilled or rejected.
	 *
	 * Returns a promise that fulfills or rejects when any of the promises returned
	 * from `executor` are fulfilled or rejected, and rejects with `AbortError` when
	 * `signal` is aborted.
	 *
	 * The promises returned from `executor` must be abortable, i.e. once
	 * `innerSignal` is aborted, they must reject with `AbortError` either
	 * immediately, or after doing any async cleanup.
	 *
	 * Example:
	 *
	 *     const result = await race(signal, signal => [
	 *       delay(signal, 1000).then(() => ({status: 'timeout'})),
	 *       makeRequest(signal, params).then(value => ({status: 'success', value})),
	 *     ]);
	 *
	 *     if (result.status === 'timeout') {
	 *       // request timed out
	 *     } else {
	 *       const response = result.value;
	 *     }
	 */
	function race$1(signal, executor) {
	    return new Promise((resolve, reject) => {
	        if (signal.aborted) {
	            reject(new AbortError_1.AbortError());
	            return;
	        }
	        const innerAbortController = new AbortController();
	        const promises = executor(innerAbortController.signal);
	        const abortListener = () => {
	            innerAbortController.abort();
	        };
	        signal.addEventListener('abort', abortListener);
	        let settledCount = 0;
	        function settled(result) {
	            innerAbortController.abort();
	            settledCount += 1;
	            if (settledCount === promises.length) {
	                signal.removeEventListener('abort', abortListener);
	                if (result.status === 'fulfilled') {
	                    resolve(result.value);
	                }
	                else {
	                    reject(result.reason);
	                }
	            }
	        }
	        let result;
	        for (const promise of promises) {
	            promise.then(value => {
	                if (result == null) {
	                    result = { status: 'fulfilled', value };
	                }
	                settled(result);
	            }, reason => {
	                if (result == null ||
	                    (!(0, AbortError_1.isAbortError)(reason) &&
	                        (result.status === 'fulfilled' || (0, AbortError_1.isAbortError)(result.reason)))) {
	                    result = { status: 'rejected', reason };
	                }
	                settled(result);
	            });
	        }
	    });
	}
	race.race = race$1;
	
	return race;
}

var retry = {};

var hasRequiredRetry;

function requireRetry () {
	if (hasRequiredRetry) return retry;
	hasRequiredRetry = 1;
	Object.defineProperty(retry, "__esModule", { value: true });
	retry.retry = undefined;
	const delay_1 = requireDelay();
	const AbortError_1 = requireAbortError();
	/**
	 * Retry function with exponential backoff.
	 *
	 * The function receives AbortSignal, attempt number starting with 0, and reset
	 * function that sets attempt number to -1 so that the next attempt will be
	 * made without delay.
	 */
	async function retry$1(signal, fn, options = {}) {
	    const { baseMs = 1000, maxDelayMs = 30000, onError, maxAttempts = Infinity, } = options;
	    let attempt = 0;
	    const reset = () => {
	        attempt = -1;
	    };
	    while (true) {
	        try {
	            return await fn(signal, attempt, reset);
	        }
	        catch (error) {
	            (0, AbortError_1.rethrowAbortError)(error);
	            if (attempt >= maxAttempts) {
	                throw error;
	            }
	            let delayMs;
	            if (attempt === -1) {
	                delayMs = 0;
	            }
	            else {
	                // https://aws.amazon.com/ru/blogs/architecture/exponential-backoff-and-jitter/
	                const backoff = Math.min(maxDelayMs, Math.pow(2, attempt) * baseMs);
	                delayMs = Math.round((backoff * (1 + Math.random())) / 2);
	            }
	            if (onError) {
	                onError(error, attempt, delayMs);
	            }
	            if (delayMs !== 0) {
	                await (0, delay_1.delay)(signal, delayMs);
	            }
	            attempt += 1;
	        }
	    }
	}
	retry.retry = retry$1;
	
	return retry;
}

var spawn = {};

var hasRequiredSpawn;

function requireSpawn () {
	if (hasRequiredSpawn) return spawn;
	hasRequiredSpawn = 1;
	Object.defineProperty(spawn, "__esModule", { value: true });
	spawn.spawn = undefined;
	const AbortError_1 = requireAbortError();
	/**
	 * Run an abortable function with `fork` and `defer` effects attached to it.
	 *
	 * `spawn` allows to write Go-style coroutines.
	 *
	 * Example:
	 *
	 *     // Connect to a database, then start a server, then block until abort.
	 *     // On abort, gracefully shutdown the server, and once done, disconnect
	 *     // from the database.
	 *     spawn(signal, async (signal, {defer}) => {
	 *       const db = await connectToDb();
	 *
	 *       defer(async () => {
	 *         await db.close();
	 *       });
	 *
	 *       const server = await startServer(db);
	 *
	 *       defer(async () => {
	 *         await server.close();
	 *       });
	 *
	 *       await forever(signal);
	 *     });
	 *
	 * Example:
	 *
	 *     // Connect to a database, then start an infinite polling loop.
	 *     // On abort, disconnect from the database.
	 *     spawn(signal, async (signal, {defer}) => {
	 *       const db = await connectToDb();
	 *
	 *       defer(async () => {
	 *         await db.close();
	 *       });
	 *
	 *       while (true) {
	 *         await poll(signal, db);
	 *         await delay(signal, 5000);
	 *       }
	 *     });
	 *
	 * Example:
	 *
	 *     // Acquire a lock and execute a function.
	 *     // Extend the lock while the function is running.
	 *     // Once the function finishes or the signal is aborted, stop extending
	 *     // the lock and release it.
	 *     import Redlock = require('redlock');
	 *
	 *     const lockTtl = 30_000;
	 *
	 *     function withLock<T>(
	 *       signal: AbortSignal,
	 *       redlock: Redlock,
	 *       key: string,
	 *       fn: (signal: AbortSignal) => Promise<T>,
	 *     ): Promise<T> {
	 *       return spawn(signal, async (signal, {fork, defer}) => {
	 *         const lock = await redlock.lock(key, lockTtl);
	 *
	 *         defer(() => lock.unlock());
	 *     ​
	 *         fork(async signal => {
	 *           while (true) {
	 *             await delay(signal, lockTtl / 10);
	 *             await lock.extend(lockTtl);
	 *           }
	 *         });
	 *
	 *         return await fn(signal);
	 *       });
	 *     }
	 *
	 *     const redlock = new Redlock([redis], {
	 *       retryCount: -1,
	 *     });
	 *
	 *     await withLock(signal, redlock, 'the-lock-key', async signal => {
	 *       // ...
	 *     });
	 */
	function spawn$1(signal, fn) {
	    if (signal.aborted) {
	        return Promise.reject(new AbortError_1.AbortError());
	    }
	    const deferredFunctions = [];
	    /**
	     * Aborted when spawned function finishes
	     * or one of forked functions throws
	     * or parent signal aborted.
	     */
	    const spawnAbortController = new AbortController();
	    const spawnSignal = spawnAbortController.signal;
	    const abortSpawn = () => {
	        spawnAbortController.abort();
	    };
	    signal.addEventListener('abort', abortSpawn);
	    const removeAbortListener = () => {
	        signal.removeEventListener('abort', abortSpawn);
	    };
	    const tasks = new Set();
	    const abortTasks = () => {
	        for (const task of tasks) {
	            task.abort();
	        }
	    };
	    spawnSignal.addEventListener('abort', abortTasks);
	    const removeSpawnAbortListener = () => {
	        spawnSignal.removeEventListener('abort', abortTasks);
	    };
	    let promise = new Promise((resolve, reject) => {
	        let result;
	        let failure;
	        fork(signal => fn(signal, {
	            defer(fn) {
	                deferredFunctions.push(fn);
	            },
	            fork,
	        }))
	            .join()
	            .then(value => {
	            spawnAbortController.abort();
	            result = { value };
	        }, error => {
	            spawnAbortController.abort();
	            if (!(0, AbortError_1.isAbortError)(error) || failure == null) {
	                failure = { error };
	            }
	        });
	        function fork(forkFn) {
	            if (spawnSignal.aborted) {
	                // return already aborted task
	                return {
	                    abort() { },
	                    async join() {
	                        throw new AbortError_1.AbortError();
	                    },
	                };
	            }
	            const taskAbortController = new AbortController();
	            const taskSignal = taskAbortController.signal;
	            const taskPromise = forkFn(taskSignal);
	            const task = {
	                abort() {
	                    taskAbortController.abort();
	                },
	                join: () => taskPromise,
	            };
	            tasks.add(task);
	            taskPromise
	                .catch(AbortError_1.catchAbortError)
	                .catch(error => {
	                failure = { error };
	                // error in forked function
	                spawnAbortController.abort();
	            })
	                .finally(() => {
	                tasks.delete(task);
	                if (tasks.size === 0) {
	                    if (failure != null) {
	                        reject(failure.error);
	                    }
	                    else {
	                        resolve(result.value);
	                    }
	                }
	            });
	            return task;
	        }
	    });
	    promise = promise.finally(() => {
	        removeAbortListener();
	        removeSpawnAbortListener();
	        let deferPromise = Promise.resolve();
	        for (let i = deferredFunctions.length - 1; i >= 0; i--) {
	            deferPromise = deferPromise.finally(deferredFunctions[i]);
	        }
	        return deferPromise;
	    });
	    return promise;
	}
	spawn.spawn = spawn$1;
	
	return spawn;
}

var run$1 = {};

var hasRequiredRun;

function requireRun () {
	if (hasRequiredRun) return run$1;
	hasRequiredRun = 1;
	Object.defineProperty(run$1, "__esModule", { value: true });
	run$1.run = undefined;
	const AbortError_1 = requireAbortError();
	/**
	 * Invokes an abortable function with implicitly created `AbortSignal`.
	 *
	 * Returns a function that aborts that signal and waits until passed function
	 * finishes.
	 *
	 * Any error other than `AbortError` thrown from passed function will result in
	 * unhandled promise rejection.
	 *
	 * Example:
	 *
	 *    const stop = run(async signal => {
	 *      try {
	 *        while (true) {
	 *          await delay(signal, 1000);
	 *          console.log('tick');
	 *        }
	 *      } finally {
	 *        await doCleanup();
	 *      }
	 *    });
	 *
	 *    // abort and wait until cleanup is done
	 *    await stop();
	 */
	function run(fn) {
	    const abortController = new AbortController();
	    const promise = fn(abortController.signal).catch(AbortError_1.catchAbortError);
	    return () => {
	        abortController.abort();
	        return promise;
	    };
	}
	run$1.run = run;
	
	return run$1;
}

var proactiveRetry = {};

var hasRequiredProactiveRetry;

function requireProactiveRetry () {
	if (hasRequiredProactiveRetry) return proactiveRetry;
	hasRequiredProactiveRetry = 1;
	Object.defineProperty(proactiveRetry, "__esModule", { value: true });
	proactiveRetry.proactiveRetry = undefined;
	const AbortError_1 = requireAbortError();
	const delay_1 = requireDelay();
	const execute_1 = requireExecute();
	/**
	 * Proactively retry a function with exponential backoff.
	 *
	 * Also known as hedging.
	 *
	 * The function will be called multiple times in parallel until it succeeds, in
	 * which case all the other calls will be aborted.
	 */
	function proactiveRetry$1(signal, fn, options = {}) {
	    const { baseMs = 1000, onError, maxAttempts = Infinity } = options;
	    return (0, execute_1.execute)(signal, (resolve, reject) => {
	        const innerAbortController = new AbortController();
	        let attemptsExhausted = false;
	        const promises = new Map();
	        function handleFulfilled(value) {
	            innerAbortController.abort();
	            promises.clear();
	            resolve(value);
	        }
	        function handleRejected(err, attempt) {
	            promises.delete(attempt);
	            if (attemptsExhausted && promises.size === 0) {
	                reject(err);
	                return;
	            }
	            if ((0, AbortError_1.isAbortError)(err)) {
	                return;
	            }
	            if (onError) {
	                try {
	                    onError(err, attempt);
	                }
	                catch (err) {
	                    innerAbortController.abort();
	                    promises.clear();
	                    reject(err);
	                }
	            }
	        }
	        async function makeAttempts(signal) {
	            for (let attempt = 0;; attempt++) {
	                const promise = fn(signal, attempt);
	                promises.set(attempt, promise);
	                promise.then(handleFulfilled, err => handleRejected(err, attempt));
	                if (attempt + 1 >= maxAttempts) {
	                    break;
	                }
	                // https://aws.amazon.com/ru/blogs/architecture/exponential-backoff-and-jitter/
	                const backoff = Math.pow(2, attempt) * baseMs;
	                const delayMs = Math.round((backoff * (1 + Math.random())) / 2);
	                await (0, delay_1.delay)(signal, delayMs);
	            }
	            attemptsExhausted = true;
	        }
	        makeAttempts(innerAbortController.signal).catch(AbortError_1.catchAbortError);
	        return () => {
	            innerAbortController.abort();
	        };
	    });
	}
	proactiveRetry.proactiveRetry = proactiveRetry$1;
	
	return proactiveRetry;
}

var hasRequiredLib$1;

function requireLib$1 () {
	if (hasRequiredLib$1) return lib;
	hasRequiredLib$1 = 1;
	(function (exports) {
		var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		__exportStar(requireAbortable(), exports);
		__exportStar(requireAbortError(), exports);
		__exportStar(requireDelay(), exports);
		__exportStar(requireExecute(), exports);
		__exportStar(requireForever(), exports);
		__exportStar(requireWaitForEvent(), exports);
		__exportStar(requireAll(), exports);
		__exportStar(requireRace(), exports);
		__exportStar(requireRetry(), exports);
		__exportStar(requireSpawn(), exports);
		__exportStar(requireRun(), exports);
		__exportStar(requireProactiveRetry(), exports);
		
	} (lib));
	return lib;
}

var convertMetadata = {};

var hasRequiredConvertMetadata;

function requireConvertMetadata () {
	if (hasRequiredConvertMetadata) return convertMetadata;
	hasRequiredConvertMetadata = 1;
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(convertMetadata, "__esModule", { value: true });
	convertMetadata.convertMetadataToGrpcJs = convertMetadataToGrpcJs;
	convertMetadata.convertMetadataFromGrpcJs = convertMetadataFromGrpcJs;
	const grpc = __importStar(requireSrc());
	const nice_grpc_common_1 = requireLib$2();
	/** @internal */
	function convertMetadataToGrpcJs(metadata) {
	    const grpcMetadata = new grpc.Metadata();
	    for (const [key, values] of metadata) {
	        for (const value of values) {
	            grpcMetadata.add(key, typeof value === 'string' ? value : Buffer.from(value));
	        }
	    }
	    return grpcMetadata;
	}
	/** @internal */
	function convertMetadataFromGrpcJs(grpcMetadata) {
	    const metadata = (0, nice_grpc_common_1.Metadata)();
	    for (const key of Object.keys(grpcMetadata.getMap())) {
	        const value = grpcMetadata.get(key);
	        metadata.set(key, value);
	    }
	    return metadata;
	}
	
	return convertMetadata;
}

var isAsyncIterable = {};

var hasRequiredIsAsyncIterable;

function requireIsAsyncIterable () {
	if (hasRequiredIsAsyncIterable) return isAsyncIterable;
	hasRequiredIsAsyncIterable = 1;
	Object.defineProperty(isAsyncIterable, "__esModule", { value: true });
	isAsyncIterable.isAsyncIterable = isAsyncIterable$1;
	/** @internal */
	function isAsyncIterable$1(value) {
	    return value != null && Symbol.asyncIterator in value;
	}
	
	return isAsyncIterable;
}

var readableToAsyncIterable = {};

var hasRequiredReadableToAsyncIterable;

function requireReadableToAsyncIterable () {
	if (hasRequiredReadableToAsyncIterable) return readableToAsyncIterable;
	hasRequiredReadableToAsyncIterable = 1;
	Object.defineProperty(readableToAsyncIterable, "__esModule", { value: true });
	readableToAsyncIterable.readableToAsyncIterable = readableToAsyncIterable$1;
	let nodejsInternalsCompatibilityCheckedOnce = false;
	/**
	 * Exactly once check that an object has Node.js readable stream internal object looks roughly like we expect.
	 */
	function nodejsInternalsAccessible(obj) {
	    if (nodejsInternalsCompatibilityCheckedOnce) {
	        return true;
	    }
	    const safe = obj &&
	        typeof obj === 'object' &&
	        'errored' in obj &&
	        'errorEmitted' in obj &&
	        'endEmitted' in obj &&
	        'closeEmitted' in obj &&
	        typeof obj.errorEmitted === 'boolean' &&
	        typeof obj.endEmitted === 'boolean' &&
	        typeof obj.closeEmitted === 'boolean';
	    nodejsInternalsCompatibilityCheckedOnce = safe;
	    return safe;
	}
	/**
	 * This is a copy of NodeJS createAsyncIterator(stream), with removed stream
	 * destruction.
	 *
	 * https://github.com/nodejs/node/blob/v15.8.0/lib/internal/streams/readable.js#L1079
	 *
	 * @internal
	 */
	async function* readableToAsyncIterable$1(stream) {
	    let callback = nop;
	    function next(resolve) {
	        if (this === stream) {
	            callback();
	            callback = nop;
	        }
	        else {
	            callback = resolve;
	        }
	    }
	    const state = stream._readableState;
	    if (!nodejsInternalsAccessible(state)) {
	        throw new Error('nice-grpc: _readableState members incompatible');
	    }
	    let error = state.errored;
	    let errorEmitted = state.errorEmitted;
	    let endEmitted = state.endEmitted;
	    let closeEmitted = state.closeEmitted;
	    stream
	        .on('readable', next)
	        .on('error', function (err) {
	        error = err;
	        errorEmitted = true;
	        next.call(this);
	    })
	        .on('end', function () {
	        endEmitted = true;
	        next.call(this);
	    })
	        .on('close', function () {
	        closeEmitted = true;
	        next.call(this);
	    });
	    while (true) {
	        const chunk = stream.destroyed ? null : stream.read();
	        if (chunk !== null) {
	            yield chunk;
	        }
	        else if (errorEmitted) {
	            throw error;
	        }
	        else if (endEmitted) {
	            break;
	        }
	        else if (closeEmitted) {
	            break;
	        }
	        else {
	            await new Promise(next);
	        }
	    }
	}
	const nop = () => { };
	
	return readableToAsyncIterable;
}

var createCallContext = {};

var hasRequiredCreateCallContext;

function requireCreateCallContext () {
	if (hasRequiredCreateCallContext) return createCallContext;
	hasRequiredCreateCallContext = 1;
	Object.defineProperty(createCallContext, "__esModule", { value: true });
	createCallContext.createCallContext = createCallContext$1;
	const nice_grpc_common_1 = requireLib$2();
	const convertMetadata_1 = requireConvertMetadata();
	/** @internal */
	function createCallContext$1(call) {
	    const ac = new AbortController();
	    const maybeCancel = {
	        signal: ac.signal,
	        cancel() {
	            ac.abort();
	        },
	    };
	    const header = (0, nice_grpc_common_1.Metadata)();
	    const trailer = (0, nice_grpc_common_1.Metadata)();
	    if (call.cancelled) {
	        maybeCancel.cancel?.();
	        maybeCancel.cancel = undefined;
	    }
	    else {
	        call.on('close', () => {
	            maybeCancel.cancel = undefined;
	        });
	        call.on('finish', () => {
	            maybeCancel.cancel = undefined;
	        });
	        call.on('cancelled', () => {
	            maybeCancel.cancel?.();
	            maybeCancel.cancel = undefined;
	        });
	    }
	    let headerSent = false;
	    const context = {
	        metadata: (0, convertMetadata_1.convertMetadataFromGrpcJs)(call.metadata),
	        peer: call.getPeer(),
	        header,
	        sendHeader() {
	            if (headerSent) {
	                return;
	            }
	            call.sendMetadata((0, convertMetadata_1.convertMetadataToGrpcJs)(header));
	            headerSent = true;
	        },
	        trailer,
	        signal: maybeCancel.signal,
	    };
	    return { context, maybeCancel };
	}
	
	return createCallContext;
}

var createErrorStatusObject = {};

var hasRequiredCreateErrorStatusObject;

function requireCreateErrorStatusObject () {
	if (hasRequiredCreateErrorStatusObject) return createErrorStatusObject;
	hasRequiredCreateErrorStatusObject = 1;
	Object.defineProperty(createErrorStatusObject, "__esModule", { value: true });
	createErrorStatusObject.createErrorStatusObject = createErrorStatusObject$1;
	const grpc_js_1 = requireSrc();
	const abort_controller_x_1 = requireLib$1();
	const nice_grpc_common_1 = requireLib$2();
	/** @internal */
	function createErrorStatusObject$1(path, error, trailer) {
	    if (error instanceof nice_grpc_common_1.ServerError) {
	        return {
	            code: error.code,
	            details: error.details,
	            metadata: trailer,
	        };
	    }
	    else if ((0, abort_controller_x_1.isAbortError)(error)) {
	        return {
	            code: grpc_js_1.status.CANCELLED,
	            details: 'The operation was cancelled',
	            metadata: trailer,
	        };
	    }
	    else {
	        process.emitWarning(`${path}: Uncaught error in server implementation method. Server methods should only throw ServerError or AbortError. ${error instanceof Error ? error.stack : error}`);
	        return {
	            code: grpc_js_1.status.UNKNOWN,
	            details: 'Unknown server error occurred',
	            metadata: trailer,
	        };
	    }
	}
	
	return createErrorStatusObject;
}

var hasRequiredHandleBidiStreamingCall;

function requireHandleBidiStreamingCall () {
	if (hasRequiredHandleBidiStreamingCall) return handleBidiStreamingCall;
	hasRequiredHandleBidiStreamingCall = 1;
	Object.defineProperty(handleBidiStreamingCall, "__esModule", { value: true });
	handleBidiStreamingCall.createBidiStreamingMethodHandler = createBidiStreamingMethodHandler;
	const abort_controller_x_1 = requireLib$1();
	const convertMetadata_1 = requireConvertMetadata();
	const isAsyncIterable_1 = requireIsAsyncIterable();
	const readableToAsyncIterable_1 = requireReadableToAsyncIterable();
	const createCallContext_1 = requireCreateCallContext();
	const createErrorStatusObject_1 = requireCreateErrorStatusObject();
	/** @internal */
	function createBidiStreamingMethodHandler(definition, implementation, middleware) {
	    const methodDescriptor = {
	        path: definition.path,
	        requestStream: definition.requestStream,
	        responseStream: definition.responseStream,
	        options: definition.options,
	    };
	    async function* bidiStreamingMethodHandler(request, context) {
	        if (!(0, isAsyncIterable_1.isAsyncIterable)(request)) {
	            throw new Error('A middleware passed invalid request to next(): expected a single message for bidirectional streaming method');
	        }
	        yield* implementation(request, context);
	    }
	    const handler = middleware == null
	        ? bidiStreamingMethodHandler
	        : (request, context) => middleware({
	            method: methodDescriptor,
	            requestStream: true,
	            request,
	            responseStream: true,
	            next: bidiStreamingMethodHandler,
	        }, context);
	    return call => {
	        const { context, maybeCancel } = (0, createCallContext_1.createCallContext)(call);
	        Promise.resolve()
	            .then(async () => {
	            const iterable = handler((0, readableToAsyncIterable_1.readableToAsyncIterable)(call), context);
	            const iterator = iterable[Symbol.asyncIterator]();
	            try {
	                let result = await iterator.next();
	                while (true) {
	                    if (!result.done) {
	                        try {
	                            context.sendHeader();
	                            const shouldContinue = call.write(result.value);
	                            if (!shouldContinue) {
	                                await (0, abort_controller_x_1.waitForEvent)(context.signal, call, 'drain');
	                            }
	                        }
	                        catch (err) {
	                            result = (0, abort_controller_x_1.isAbortError)(err)
	                                ? await iterator.return()
	                                : await iterator.throw(err);
	                            continue;
	                        }
	                        result = await iterator.next();
	                        continue;
	                    }
	                    if (result.value != null) {
	                        result = await iterator.throw(new Error('A middleware returned a message, but expected to return void for bidirectional streaming method'));
	                        continue;
	                    }
	                    break;
	                }
	            }
	            finally {
	                maybeCancel.cancel = undefined;
	                context.sendHeader();
	            }
	        })
	            .then(() => {
	            call.end((0, convertMetadata_1.convertMetadataToGrpcJs)(context.trailer));
	        }, err => {
	            call.emit('error', (0, createErrorStatusObject_1.createErrorStatusObject)(definition.path, err, (0, convertMetadata_1.convertMetadataToGrpcJs)(context.trailer)));
	        });
	    };
	}
	
	return handleBidiStreamingCall;
}

var handleClientStreamingCall = {};

var hasRequiredHandleClientStreamingCall;

function requireHandleClientStreamingCall () {
	if (hasRequiredHandleClientStreamingCall) return handleClientStreamingCall;
	hasRequiredHandleClientStreamingCall = 1;
	Object.defineProperty(handleClientStreamingCall, "__esModule", { value: true });
	handleClientStreamingCall.createClientStreamingMethodHandler = createClientStreamingMethodHandler;
	const convertMetadata_1 = requireConvertMetadata();
	const isAsyncIterable_1 = requireIsAsyncIterable();
	const readableToAsyncIterable_1 = requireReadableToAsyncIterable();
	const createCallContext_1 = requireCreateCallContext();
	const createErrorStatusObject_1 = requireCreateErrorStatusObject();
	/** @internal */
	function createClientStreamingMethodHandler(definition, implementation, middleware) {
	    const methodDescriptor = {
	        path: definition.path,
	        requestStream: definition.requestStream,
	        responseStream: definition.responseStream,
	        options: definition.options,
	    };
	    async function* clientStreamingMethodHandler(request, context) {
	        if (!(0, isAsyncIterable_1.isAsyncIterable)(request)) {
	            throw new Error('A middleware passed invalid request to next(): expected a single message for client streaming method');
	        }
	        return await implementation(request, context);
	    }
	    const handler = middleware == null
	        ? clientStreamingMethodHandler
	        : (request, context) => middleware({
	            method: methodDescriptor,
	            requestStream: true,
	            request,
	            responseStream: false,
	            next: clientStreamingMethodHandler,
	        }, context);
	    return (call, callback) => {
	        const { context, maybeCancel } = (0, createCallContext_1.createCallContext)(call);
	        Promise.resolve()
	            .then(async () => {
	            const iterable = handler((0, readableToAsyncIterable_1.readableToAsyncIterable)(call), context);
	            const iterator = iterable[Symbol.asyncIterator]();
	            try {
	                let result = await iterator.next();
	                while (true) {
	                    if (!result.done) {
	                        result = await iterator.throw(new Error('A middleware yielded a message, but expected to only return a message for client streaming method'));
	                        continue;
	                    }
	                    if (result.value == null) {
	                        result = await iterator.throw(new Error('A middleware returned void, but expected to return a message for client streaming method'));
	                        continue;
	                    }
	                    return result.value;
	                }
	            }
	            finally {
	                maybeCancel.cancel = undefined;
	                context.sendHeader();
	            }
	        })
	            .then(res => {
	            callback(null, res, (0, convertMetadata_1.convertMetadataToGrpcJs)(context.trailer));
	        }, err => {
	            callback((0, createErrorStatusObject_1.createErrorStatusObject)(definition.path, err, (0, convertMetadata_1.convertMetadataToGrpcJs)(context.trailer)));
	        });
	    };
	}
	
	return handleClientStreamingCall;
}

var handleServerStreamingCall = {};

var hasRequiredHandleServerStreamingCall;

function requireHandleServerStreamingCall () {
	if (hasRequiredHandleServerStreamingCall) return handleServerStreamingCall;
	hasRequiredHandleServerStreamingCall = 1;
	Object.defineProperty(handleServerStreamingCall, "__esModule", { value: true });
	handleServerStreamingCall.createServerStreamingMethodHandler = createServerStreamingMethodHandler;
	const abort_controller_x_1 = requireLib$1();
	const convertMetadata_1 = requireConvertMetadata();
	const isAsyncIterable_1 = requireIsAsyncIterable();
	const createCallContext_1 = requireCreateCallContext();
	const createErrorStatusObject_1 = requireCreateErrorStatusObject();
	/** @internal */
	function createServerStreamingMethodHandler(definition, implementation, middleware) {
	    const methodDescriptor = {
	        path: definition.path,
	        requestStream: definition.requestStream,
	        responseStream: definition.responseStream,
	        options: definition.options,
	    };
	    async function* serverStreamingMethodHandler(request, context) {
	        if ((0, isAsyncIterable_1.isAsyncIterable)(request)) {
	            throw new Error('A middleware passed invalid request to next(): expected a single message for server streaming method');
	        }
	        yield* implementation(request, context);
	    }
	    const handler = middleware == null
	        ? serverStreamingMethodHandler
	        : (request, context) => middleware({
	            method: methodDescriptor,
	            requestStream: false,
	            request,
	            responseStream: true,
	            next: serverStreamingMethodHandler,
	        }, context);
	    return call => {
	        const { context, maybeCancel } = (0, createCallContext_1.createCallContext)(call);
	        Promise.resolve()
	            .then(async () => {
	            const iterable = handler(call.request, context);
	            const iterator = iterable[Symbol.asyncIterator]();
	            try {
	                let result = await iterator.next();
	                while (true) {
	                    if (!result.done) {
	                        try {
	                            context.sendHeader();
	                            const shouldContinue = call.write(result.value);
	                            if (!shouldContinue) {
	                                await (0, abort_controller_x_1.waitForEvent)(context.signal, call, 'drain');
	                            }
	                        }
	                        catch (err) {
	                            result = (0, abort_controller_x_1.isAbortError)(err)
	                                ? await iterator.return()
	                                : await iterator.throw(err);
	                            continue;
	                        }
	                        result = await iterator.next();
	                        continue;
	                    }
	                    if (result.value != null) {
	                        result = await iterator.throw(new Error('A middleware returned a message, but expected to return void for server streaming method'));
	                        continue;
	                    }
	                    break;
	                }
	            }
	            finally {
	                maybeCancel.cancel = undefined;
	                context.sendHeader();
	            }
	        })
	            .then(() => {
	            call.end((0, convertMetadata_1.convertMetadataToGrpcJs)(context.trailer));
	        }, err => {
	            call.emit('error', (0, createErrorStatusObject_1.createErrorStatusObject)(definition.path, err, (0, convertMetadata_1.convertMetadataToGrpcJs)(context.trailer)));
	        });
	    };
	}
	
	return handleServerStreamingCall;
}

var handleUnaryCall = {};

var hasRequiredHandleUnaryCall;

function requireHandleUnaryCall () {
	if (hasRequiredHandleUnaryCall) return handleUnaryCall;
	hasRequiredHandleUnaryCall = 1;
	Object.defineProperty(handleUnaryCall, "__esModule", { value: true });
	handleUnaryCall.createUnaryMethodHandler = createUnaryMethodHandler;
	const convertMetadata_1 = requireConvertMetadata();
	const isAsyncIterable_1 = requireIsAsyncIterable();
	const createCallContext_1 = requireCreateCallContext();
	const createErrorStatusObject_1 = requireCreateErrorStatusObject();
	/** @internal */
	function createUnaryMethodHandler(definition, implementation, middleware) {
	    const methodDescriptor = {
	        path: definition.path,
	        requestStream: definition.requestStream,
	        responseStream: definition.responseStream,
	        options: definition.options,
	    };
	    async function* unaryMethodHandler(request, context) {
	        if ((0, isAsyncIterable_1.isAsyncIterable)(request)) {
	            throw new Error('A middleware passed invalid request to next(): expected a single message for unary method');
	        }
	        return await implementation(request, context);
	    }
	    const handler = middleware == null
	        ? unaryMethodHandler
	        : (request, context) => middleware({
	            method: methodDescriptor,
	            requestStream: false,
	            request,
	            responseStream: false,
	            next: unaryMethodHandler,
	        }, context);
	    return (call, callback) => {
	        const { context, maybeCancel } = (0, createCallContext_1.createCallContext)(call);
	        Promise.resolve()
	            .then(async () => {
	            const iterable = handler(call.request, context);
	            const iterator = iterable[Symbol.asyncIterator]();
	            try {
	                let result = await iterator.next();
	                while (true) {
	                    if (!result.done) {
	                        result = await iterator.throw(new Error('A middleware yielded a message, but expected to only return a message for unary method'));
	                        continue;
	                    }
	                    if (result.value == null) {
	                        result = await iterator.throw(new Error('A middleware returned void, but expected to return a message for unary method'));
	                        continue;
	                    }
	                    return result.value;
	                }
	            }
	            finally {
	                maybeCancel.cancel = undefined;
	                context.sendHeader();
	            }
	        })
	            .then(res => {
	            callback(null, res, (0, convertMetadata_1.convertMetadataToGrpcJs)(context.trailer));
	        }, err => {
	            callback((0, createErrorStatusObject_1.createErrorStatusObject)(definition.path, err, (0, convertMetadata_1.convertMetadataToGrpcJs)(context.trailer)));
	        });
	    };
	}
	
	return handleUnaryCall;
}

var hasRequiredServer;

function requireServer () {
	if (hasRequiredServer) return Server;
	hasRequiredServer = 1;
	Object.defineProperty(Server, "__esModule", { value: true });
	Server.createServer = createServer;
	const grpc_js_1 = requireSrc();
	const nice_grpc_common_1 = requireLib$2();
	const service_definitions_1 = requireServiceDefinitions();
	const handleBidiStreamingCall_1 = requireHandleBidiStreamingCall();
	const handleClientStreamingCall_1 = requireHandleClientStreamingCall();
	const handleServerStreamingCall_1 = requireHandleServerStreamingCall();
	const handleUnaryCall_1 = requireHandleUnaryCall();
	/**
	 * Create a new server.
	 *
	 * @param options Optional channel options.
	 * @returns The new server.
	 */
	function createServer(options = {}) {
	    return createServerWithMiddleware(options);
	}
	function createServerWithMiddleware(options, middleware) {
	    const services = [];
	    let server;
	    function createAddBuilder(middleware) {
	        return {
	            with(newMiddleware) {
	                return createAddBuilder(middleware == null
	                    ? newMiddleware
	                    : (0, nice_grpc_common_1.composeServerMiddleware)(middleware, newMiddleware));
	            },
	            add(definition, implementation) {
	                if (server != null) {
	                    throw new Error('server.add() must be used before listen()');
	                }
	                services.push({
	                    definition: (0, service_definitions_1.normalizeServiceDefinition)(definition),
	                    middleware,
	                    implementation,
	                });
	            },
	        };
	    }
	    return {
	        use(newMiddleware) {
	            if (server != null) {
	                throw new Error('server.use() must be used before listen()');
	            }
	            if (services.length > 0) {
	                throw new Error('server.use() must be used before adding any services');
	            }
	            return createServerWithMiddleware(options, middleware == null
	                ? newMiddleware
	                : (0, nice_grpc_common_1.composeServerMiddleware)(middleware, newMiddleware));
	        },
	        ...createAddBuilder(middleware),
	        async listen(address, credentials) {
	            if (server != null) {
	                throw new Error('server.listen() has already been called');
	            }
	            server = new grpc_js_1.Server(options);
	            for (const { definition, middleware, implementation } of services) {
	                const grpcImplementation = {};
	                for (const [methodName, methodDefinition] of Object.entries(definition)) {
	                    const methodImplementation = implementation[methodName].bind(implementation);
	                    if (!methodDefinition.requestStream) {
	                        if (!methodDefinition.responseStream) {
	                            grpcImplementation[methodName] = (0, handleUnaryCall_1.createUnaryMethodHandler)(methodDefinition, methodImplementation, middleware);
	                        }
	                        else {
	                            grpcImplementation[methodName] =
	                                (0, handleServerStreamingCall_1.createServerStreamingMethodHandler)(methodDefinition, methodImplementation, middleware);
	                        }
	                    }
	                    else {
	                        if (!methodDefinition.responseStream) {
	                            grpcImplementation[methodName] =
	                                (0, handleClientStreamingCall_1.createClientStreamingMethodHandler)(methodDefinition, methodImplementation, middleware);
	                        }
	                        else {
	                            grpcImplementation[methodName] = (0, handleBidiStreamingCall_1.createBidiStreamingMethodHandler)(methodDefinition, methodImplementation, middleware);
	                        }
	                    }
	                }
	                server.addService((0, service_definitions_1.toGrpcJsServiceDefinition)(definition), grpcImplementation);
	            }
	            const port = await new Promise((resolve, reject) => {
	                server.bindAsync(address, credentials ?? grpc_js_1.ServerCredentials.createInsecure(), (err, port) => {
	                    if (err != null) {
	                        server = undefined;
	                        reject(err);
	                    }
	                    else {
	                        resolve(port);
	                    }
	                });
	            });
	            return port;
	        },
	        async shutdown() {
	            if (server == null) {
	                return;
	            }
	            await new Promise((resolve, reject) => {
	                server.tryShutdown(err => {
	                    if (err != null) {
	                        reject(err);
	                    }
	                    else {
	                        resolve();
	                    }
	                });
	            });
	            server = undefined;
	        },
	        forceShutdown() {
	            if (server == null) {
	                return;
	            }
	            server.forceShutdown();
	            server = undefined;
	        },
	    };
	}
	
	return Server;
}

var ServiceImplementation = {};

var hasRequiredServiceImplementation;

function requireServiceImplementation () {
	if (hasRequiredServiceImplementation) return ServiceImplementation;
	hasRequiredServiceImplementation = 1;
	Object.defineProperty(ServiceImplementation, "__esModule", { value: true });
	
	return ServiceImplementation;
}

var channel = {};

var hasRequiredChannel;

function requireChannel () {
	if (hasRequiredChannel) return channel;
	hasRequiredChannel = 1;
	Object.defineProperty(channel, "__esModule", { value: true });
	channel.createChannel = createChannel;
	channel.waitForChannelReady = waitForChannelReady;
	const grpc_js_1 = requireSrc();
	const knownProtocols = new Set(['http', 'https']);
	/**
	 * Creates a new channel. The channel represents a remote endpoint that can be
	 * connected to.
	 *
	 * @param address The address of the server, in the form `protocol://host:port`,
	 *     where `protocol` is one of `http` or `https`.
	 *     If the protocol is not specified, it will be inferred from the
	 *     credentials.
	 *     If the port is not specified, it will be inferred from the protocol.
	 * @param credentials Optional credentials object that is usually created by
	 *     calling `ChannelCredentials.createSsl()` or
	 *     `ChannelCredentials.createInsecure()`. If not specified, the credentials
	 *     will be inferred from the protocol. If the protocol is not specified,
	 *     `ChannelCredentials.createInsecure()` will be used.
	 * @param options Optional channel options object.
	 * @returns The new channel.
	 */
	function createChannel(address, credentials, options = {}) {
	    const match = /^(?:([^:]+):\/\/)?(.*?)(?::(\d+))?$/.exec(address);
	    if (match == null)
	        throw new Error(`Invalid address: '${address}'`);
	    let [, protocol, host, port] = match;
	    const knownProtocol = !protocol || knownProtocols.has(protocol);
	    const isSecure = credentials?._isSecure() || protocol?.includes('https');
	    credentials ?? (credentials = isSecure
	        ? grpc_js_1.ChannelCredentials.createSsl()
	        : grpc_js_1.ChannelCredentials.createInsecure());
	    port ?? (port = isSecure ? '443' : '80');
	    let target = knownProtocol ? `${host}:${port}` : address;
	    return new grpc_js_1.Channel(target, credentials, options);
	}
	/**
	 * Waits for the channel to be connected.
	 *
	 * It is not necessary to call this function before making a call on a client.
	 */
	async function waitForChannelReady(channel, deadline) {
	    while (true) {
	        const state = channel.getConnectivityState(true);
	        if (state === grpc_js_1.connectivityState.READY) {
	            return;
	        }
	        await new Promise((resolve, reject) => {
	            channel.watchConnectivityState(state, deadline, err => {
	                if (err != null) {
	                    reject(err);
	                }
	                else {
	                    resolve();
	                }
	            });
	        });
	    }
	}
	
	return channel;
}

var ClientFactory = {};

var createBidiStreamingMethod = {};

var wrapClientError = {};

var hasRequiredWrapClientError;

function requireWrapClientError () {
	if (hasRequiredWrapClientError) return wrapClientError;
	hasRequiredWrapClientError = 1;
	Object.defineProperty(wrapClientError, "__esModule", { value: true });
	wrapClientError.wrapClientError = wrapClientError$1;
	const nice_grpc_common_1 = requireLib$2();
	const grpc_js_1 = requireSrc();
	/** @internal */
	function wrapClientError$1(error, path) {
	    if (isStatusObject(error)) {
	        return new nice_grpc_common_1.ClientError(path, error.code, error.details);
	    }
	    return error;
	}
	function isStatusObject(obj) {
	    return (typeof obj === 'object' &&
	        obj !== null &&
	        typeof obj.code === 'number' &&
	        typeof obj.details === 'string' &&
	        obj.metadata instanceof grpc_js_1.Metadata);
	}
	
	return wrapClientError;
}

var hasRequiredCreateBidiStreamingMethod;

function requireCreateBidiStreamingMethod () {
	if (hasRequiredCreateBidiStreamingMethod) return createBidiStreamingMethod;
	hasRequiredCreateBidiStreamingMethod = 1;
	Object.defineProperty(createBidiStreamingMethod, "__esModule", { value: true });
	createBidiStreamingMethod.createBidiStreamingMethod = createBidiStreamingMethod$1;
	const abort_controller_x_1 = requireLib$1();
	const nice_grpc_common_1 = requireLib$2();
	const service_definitions_1 = requireServiceDefinitions();
	const convertMetadata_1 = requireConvertMetadata();
	const isAsyncIterable_1 = requireIsAsyncIterable();
	const readableToAsyncIterable_1 = requireReadableToAsyncIterable();
	const wrapClientError_1 = requireWrapClientError();
	/** @internal */
	function createBidiStreamingMethod$1(definition, client, middleware, defaultOptions) {
	    const grpcMethodDefinition = (0, service_definitions_1.toGrpcJsMethodDefinition)(definition);
	    const methodDescriptor = {
	        path: definition.path,
	        requestStream: definition.requestStream,
	        responseStream: definition.responseStream,
	        options: definition.options,
	    };
	    async function* bidiStreamingMethod(request, options) {
	        if (!(0, isAsyncIterable_1.isAsyncIterable)(request)) {
	            throw new Error('A middleware passed invalid request to next(): expected a single message for bidirectional streaming method');
	        }
	        const { metadata = (0, nice_grpc_common_1.Metadata)(), onHeader, onTrailer } = options;
	        const signal = options.signal ?? new AbortController().signal;
	        const pipeAbortController = new AbortController();
	        const call = client.makeBidiStreamRequest(grpcMethodDefinition.path, grpcMethodDefinition.requestSerialize, grpcMethodDefinition.responseDeserialize, (0, convertMetadata_1.convertMetadataToGrpcJs)(metadata));
	        call.on('metadata', metadata => {
	            onHeader?.((0, convertMetadata_1.convertMetadataFromGrpcJs)(metadata));
	        });
	        call.on('status', status => {
	            onTrailer?.((0, convertMetadata_1.convertMetadataFromGrpcJs)(status.metadata));
	        });
	        let pipeError;
	        pipeRequest(pipeAbortController.signal, request, call).then(() => {
	            call.end();
	        }, err => {
	            if (!(0, abort_controller_x_1.isAbortError)(err)) {
	                pipeError = err;
	                call.cancel();
	            }
	        });
	        const abortListener = () => {
	            pipeAbortController.abort();
	            call.cancel();
	        };
	        signal.addEventListener('abort', abortListener);
	        try {
	            yield* (0, readableToAsyncIterable_1.readableToAsyncIterable)(call);
	        }
	        catch (err) {
	            throw (0, wrapClientError_1.wrapClientError)(err, definition.path);
	        }
	        finally {
	            pipeAbortController.abort();
	            signal.removeEventListener('abort', abortListener);
	            (0, abort_controller_x_1.throwIfAborted)(signal);
	            call.cancel();
	            if (pipeError) {
	                throw pipeError;
	            }
	        }
	    }
	    const method = middleware == null
	        ? bidiStreamingMethod
	        : (request, options) => middleware({
	            method: methodDescriptor,
	            requestStream: true,
	            request,
	            responseStream: true,
	            next: bidiStreamingMethod,
	        }, options);
	    return (request, options) => {
	        const iterable = method(request, {
	            ...defaultOptions,
	            ...options,
	        });
	        const iterator = iterable[Symbol.asyncIterator]();
	        return {
	            [Symbol.asyncIterator]() {
	                return {
	                    async next() {
	                        const result = await iterator.next();
	                        if (result.done && result.value != null) {
	                            return await iterator.throw(new Error('A middleware returned a message, but expected to return void for bidirectional streaming method'));
	                        }
	                        return result;
	                    },
	                    return() {
	                        return iterator.return();
	                    },
	                    throw(err) {
	                        return iterator.throw(err);
	                    },
	                };
	            },
	        };
	    };
	}
	async function pipeRequest(signal, request, call) {
	    for await (const item of request) {
	        (0, abort_controller_x_1.throwIfAborted)(signal);
	        const shouldContinue = call.write(item);
	        if (!shouldContinue) {
	            await (0, abort_controller_x_1.waitForEvent)(signal, call, 'drain');
	        }
	    }
	}
	
	return createBidiStreamingMethod;
}

var createClientStreamingMethod = {};

var hasRequiredCreateClientStreamingMethod;

function requireCreateClientStreamingMethod () {
	if (hasRequiredCreateClientStreamingMethod) return createClientStreamingMethod;
	hasRequiredCreateClientStreamingMethod = 1;
	Object.defineProperty(createClientStreamingMethod, "__esModule", { value: true });
	createClientStreamingMethod.createClientStreamingMethod = createClientStreamingMethod$1;
	const abort_controller_x_1 = requireLib$1();
	const nice_grpc_common_1 = requireLib$2();
	const service_definitions_1 = requireServiceDefinitions();
	const convertMetadata_1 = requireConvertMetadata();
	const isAsyncIterable_1 = requireIsAsyncIterable();
	const wrapClientError_1 = requireWrapClientError();
	/** @internal */
	function createClientStreamingMethod$1(definition, client, middleware, defaultOptions) {
	    const grpcMethodDefinition = (0, service_definitions_1.toGrpcJsMethodDefinition)(definition);
	    const methodDescriptor = {
	        path: definition.path,
	        requestStream: definition.requestStream,
	        responseStream: definition.responseStream,
	        options: definition.options,
	    };
	    async function* clientStreamingMethod(request, options) {
	        if (!(0, isAsyncIterable_1.isAsyncIterable)(request)) {
	            throw new Error('A middleware passed invalid request to next(): expected a single message for client streaming method');
	        }
	        const { metadata = (0, nice_grpc_common_1.Metadata)(), signal = new AbortController().signal, onHeader, onTrailer, } = options;
	        return await (0, abort_controller_x_1.execute)(signal, (resolve, reject) => {
	            const pipeAbortController = new AbortController();
	            const call = client.makeClientStreamRequest(grpcMethodDefinition.path, grpcMethodDefinition.requestSerialize, grpcMethodDefinition.responseDeserialize, (0, convertMetadata_1.convertMetadataToGrpcJs)(metadata), (err, response) => {
	                pipeAbortController.abort();
	                if (err != null) {
	                    reject((0, wrapClientError_1.wrapClientError)(err, definition.path));
	                }
	                else {
	                    resolve(response);
	                }
	            });
	            call.on('metadata', metadata => {
	                onHeader?.((0, convertMetadata_1.convertMetadataFromGrpcJs)(metadata));
	            });
	            call.on('status', status => {
	                onTrailer?.((0, convertMetadata_1.convertMetadataFromGrpcJs)(status.metadata));
	            });
	            pipeRequest(pipeAbortController.signal, request, call).then(() => {
	                call.end();
	            }, err => {
	                if (!(0, abort_controller_x_1.isAbortError)(err)) {
	                    reject(err);
	                    call.cancel();
	                }
	            });
	            return () => {
	                pipeAbortController.abort();
	                call.cancel();
	            };
	        });
	    }
	    const method = middleware == null
	        ? clientStreamingMethod
	        : (request, options) => middleware({
	            method: methodDescriptor,
	            requestStream: true,
	            request,
	            responseStream: false,
	            next: clientStreamingMethod,
	        }, options);
	    return async (request, options) => {
	        const iterable = method(request, {
	            ...defaultOptions,
	            ...options,
	        });
	        const iterator = iterable[Symbol.asyncIterator]();
	        let result = await iterator.next();
	        while (true) {
	            if (!result.done) {
	                result = await iterator.throw(new Error('A middleware yielded a message, but expected to only return a message for client streaming method'));
	                continue;
	            }
	            if (result.value == null) {
	                result = await iterator.throw(new Error('A middleware returned void, but expected to return a message for client streaming method'));
	                continue;
	            }
	            return result.value;
	        }
	    };
	}
	async function pipeRequest(signal, request, call) {
	    for await (const item of request) {
	        (0, abort_controller_x_1.throwIfAborted)(signal);
	        const shouldContinue = call.write(item);
	        if (!shouldContinue) {
	            await (0, abort_controller_x_1.waitForEvent)(signal, call, 'drain');
	        }
	    }
	}
	
	return createClientStreamingMethod;
}

var createServerStreamingMethod = {};

var hasRequiredCreateServerStreamingMethod;

function requireCreateServerStreamingMethod () {
	if (hasRequiredCreateServerStreamingMethod) return createServerStreamingMethod;
	hasRequiredCreateServerStreamingMethod = 1;
	Object.defineProperty(createServerStreamingMethod, "__esModule", { value: true });
	createServerStreamingMethod.createServerStreamingMethod = createServerStreamingMethod$1;
	const abort_controller_x_1 = requireLib$1();
	const nice_grpc_common_1 = requireLib$2();
	const service_definitions_1 = requireServiceDefinitions();
	const convertMetadata_1 = requireConvertMetadata();
	const isAsyncIterable_1 = requireIsAsyncIterable();
	const readableToAsyncIterable_1 = requireReadableToAsyncIterable();
	const wrapClientError_1 = requireWrapClientError();
	/** @internal */
	function createServerStreamingMethod$1(definition, client, middleware, defaultOptions) {
	    const grpcMethodDefinition = (0, service_definitions_1.toGrpcJsMethodDefinition)(definition);
	    const methodDescriptor = {
	        path: definition.path,
	        requestStream: definition.requestStream,
	        responseStream: definition.responseStream,
	        options: definition.options,
	    };
	    async function* serverStreamingMethod(request, options) {
	        if ((0, isAsyncIterable_1.isAsyncIterable)(request)) {
	            throw new Error('A middleware passed invalid request to next(): expected a single message for server streaming method');
	        }
	        const { metadata = (0, nice_grpc_common_1.Metadata)(), onHeader, onTrailer } = options;
	        const signal = options.signal ?? new AbortController().signal;
	        const call = client.makeServerStreamRequest(grpcMethodDefinition.path, grpcMethodDefinition.requestSerialize, grpcMethodDefinition.responseDeserialize, request, (0, convertMetadata_1.convertMetadataToGrpcJs)(metadata));
	        call.on('metadata', metadata => {
	            onHeader?.((0, convertMetadata_1.convertMetadataFromGrpcJs)(metadata));
	        });
	        call.on('status', status => {
	            onTrailer?.((0, convertMetadata_1.convertMetadataFromGrpcJs)(status.metadata));
	        });
	        const abortListener = () => {
	            call.cancel();
	        };
	        signal.addEventListener('abort', abortListener);
	        try {
	            yield* (0, readableToAsyncIterable_1.readableToAsyncIterable)(call);
	        }
	        catch (err) {
	            throw (0, wrapClientError_1.wrapClientError)(err, definition.path);
	        }
	        finally {
	            signal.removeEventListener('abort', abortListener);
	            (0, abort_controller_x_1.throwIfAborted)(signal);
	            call.cancel();
	        }
	    }
	    const method = middleware == null
	        ? serverStreamingMethod
	        : (request, options) => middleware({
	            method: methodDescriptor,
	            requestStream: false,
	            request,
	            responseStream: true,
	            next: serverStreamingMethod,
	        }, options);
	    return (request, options) => {
	        const iterable = method(request, {
	            ...defaultOptions,
	            ...options,
	        });
	        const iterator = iterable[Symbol.asyncIterator]();
	        return {
	            [Symbol.asyncIterator]() {
	                return {
	                    async next() {
	                        const result = await iterator.next();
	                        if (result.done && result.value != null) {
	                            return await iterator.throw(new Error('A middleware returned a message, but expected to return void for server streaming method'));
	                        }
	                        return result;
	                    },
	                    return() {
	                        return iterator.return();
	                    },
	                    throw(err) {
	                        return iterator.throw(err);
	                    },
	                };
	            },
	        };
	    };
	}
	
	return createServerStreamingMethod;
}

var createUnaryMethod = {};

var hasRequiredCreateUnaryMethod;

function requireCreateUnaryMethod () {
	if (hasRequiredCreateUnaryMethod) return createUnaryMethod;
	hasRequiredCreateUnaryMethod = 1;
	Object.defineProperty(createUnaryMethod, "__esModule", { value: true });
	createUnaryMethod.createUnaryMethod = createUnaryMethod$1;
	const abort_controller_x_1 = requireLib$1();
	const nice_grpc_common_1 = requireLib$2();
	const service_definitions_1 = requireServiceDefinitions();
	const convertMetadata_1 = requireConvertMetadata();
	const isAsyncIterable_1 = requireIsAsyncIterable();
	const wrapClientError_1 = requireWrapClientError();
	/** @internal */
	function createUnaryMethod$1(definition, client, middleware, defaultOptions) {
	    const grpcMethodDefinition = (0, service_definitions_1.toGrpcJsMethodDefinition)(definition);
	    const methodDescriptor = {
	        path: definition.path,
	        requestStream: definition.requestStream,
	        responseStream: definition.responseStream,
	        options: definition.options,
	    };
	    async function* unaryMethod(request, options) {
	        if ((0, isAsyncIterable_1.isAsyncIterable)(request)) {
	            throw new Error('A middleware passed invalid request to next(): expected a single message for unary method');
	        }
	        const { metadata = (0, nice_grpc_common_1.Metadata)(), signal = new AbortController().signal, onHeader, onTrailer, } = options;
	        return await (0, abort_controller_x_1.execute)(signal, (resolve, reject) => {
	            const call = client.makeUnaryRequest(grpcMethodDefinition.path, grpcMethodDefinition.requestSerialize, grpcMethodDefinition.responseDeserialize, request, (0, convertMetadata_1.convertMetadataToGrpcJs)(metadata), (err, response) => {
	                if (err != null) {
	                    reject((0, wrapClientError_1.wrapClientError)(err, definition.path));
	                }
	                else {
	                    resolve(response);
	                }
	            });
	            call.on('metadata', metadata => {
	                onHeader?.((0, convertMetadata_1.convertMetadataFromGrpcJs)(metadata));
	            });
	            call.on('status', status => {
	                onTrailer?.((0, convertMetadata_1.convertMetadataFromGrpcJs)(status.metadata));
	            });
	            return () => {
	                call.cancel();
	            };
	        });
	    }
	    const method = middleware == null
	        ? unaryMethod
	        : (request, options) => middleware({
	            method: methodDescriptor,
	            requestStream: false,
	            request,
	            responseStream: false,
	            next: unaryMethod,
	        }, options);
	    return async (request, options) => {
	        const iterable = method(request, {
	            ...defaultOptions,
	            ...options,
	        });
	        const iterator = iterable[Symbol.asyncIterator]();
	        let result = await iterator.next();
	        while (true) {
	            if (!result.done) {
	                result = await iterator.throw(new Error('A middleware yielded a message, but expected to only return a message for unary method'));
	                continue;
	            }
	            if (result.value == null) {
	                result = await iterator.throw(new Error('A middleware returned void, but expected to return a message for unary method'));
	                continue;
	            }
	            return result.value;
	        }
	    };
	}
	
	return createUnaryMethod;
}

var hasRequiredClientFactory;

function requireClientFactory () {
	if (hasRequiredClientFactory) return ClientFactory;
	hasRequiredClientFactory = 1;
	Object.defineProperty(ClientFactory, "__esModule", { value: true });
	ClientFactory.createClientFactory = createClientFactory;
	ClientFactory.createClient = createClient;
	const grpc_js_1 = requireSrc();
	const nice_grpc_common_1 = requireLib$2();
	const service_definitions_1 = requireServiceDefinitions();
	const createBidiStreamingMethod_1 = requireCreateBidiStreamingMethod();
	const createClientStreamingMethod_1 = requireCreateClientStreamingMethod();
	const createServerStreamingMethod_1 = requireCreateServerStreamingMethod();
	const createUnaryMethod_1 = requireCreateUnaryMethod();
	/**
	 * Create a client factory that can be used to create clients with middleware.
	 */
	function createClientFactory() {
	    return createClientFactoryWithMiddleware();
	}
	/**
	 * Create a client with no middleware.
	 *
	 * This is the same as calling `createClientFactory().create()`.
	 */
	function createClient(definition, channel, defaultCallOptions) {
	    return createClientFactory().create(definition, channel, defaultCallOptions);
	}
	function createClientFactoryWithMiddleware(middleware) {
	    return {
	        use(newMiddleware) {
	            return createClientFactoryWithMiddleware(middleware == null
	                ? newMiddleware
	                : (0, nice_grpc_common_1.composeClientMiddleware)(middleware, newMiddleware));
	        },
	        create(definition, channel, defaultCallOptions = {}) {
	            const constructor = (0, grpc_js_1.makeClientConstructor)({}, '');
	            const grpcClient = new constructor('', null, {
	                channelOverride: channel,
	            });
	            const client = {};
	            const methodEntries = Object.entries((0, service_definitions_1.normalizeServiceDefinition)(definition));
	            for (const [methodName, methodDefinition] of methodEntries) {
	                const defaultOptions = {
	                    ...defaultCallOptions['*'],
	                    ...defaultCallOptions[methodName],
	                };
	                if (!methodDefinition.requestStream) {
	                    if (!methodDefinition.responseStream) {
	                        client[methodName] = (0, createUnaryMethod_1.createUnaryMethod)(methodDefinition, grpcClient, middleware, defaultOptions);
	                    }
	                    else {
	                        client[methodName] = (0, createServerStreamingMethod_1.createServerStreamingMethod)(methodDefinition, grpcClient, middleware, defaultOptions);
	                    }
	                }
	                else {
	                    if (!methodDefinition.responseStream) {
	                        client[methodName] = (0, createClientStreamingMethod_1.createClientStreamingMethod)(methodDefinition, grpcClient, middleware, defaultOptions);
	                    }
	                    else {
	                        client[methodName] = (0, createBidiStreamingMethod_1.createBidiStreamingMethod)(methodDefinition, grpcClient, middleware, defaultOptions);
	                    }
	                }
	            }
	            return client;
	        },
	    };
	}
	
	return ClientFactory;
}

var Client = {};

var hasRequiredClient;

function requireClient () {
	if (hasRequiredClient) return Client;
	hasRequiredClient = 1;
	Object.defineProperty(Client, "__esModule", { value: true });
	
	return Client;
}

var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib$2;
	hasRequiredLib = 1;
	(function (exports) {
		var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.ChannelCredentials = exports.Channel = exports.waitForChannelReady = exports.createChannel = undefined;
		__exportStar(requireLib$2(), exports);
		__exportStar(requireServer(), exports);
		__exportStar(requireServiceImplementation(), exports);
		var channel_1 = requireChannel();
		Object.defineProperty(exports, "createChannel", { enumerable: true, get: function () { return channel_1.createChannel; } });
		Object.defineProperty(exports, "waitForChannelReady", { enumerable: true, get: function () { return channel_1.waitForChannelReady; } });
		var grpc_js_1 = requireSrc();
		Object.defineProperty(exports, "Channel", { enumerable: true, get: function () { return grpc_js_1.Channel; } });
		Object.defineProperty(exports, "ChannelCredentials", { enumerable: true, get: function () { return grpc_js_1.ChannelCredentials; } });
		__exportStar(requireClientFactory(), exports);
		__exportStar(requireClient(), exports);
		
	} (lib$2));
	return lib$2;
}

var libExports = requireLib();

const StatusRequest = Struct({});
const statusRequestToProto = encodeSync(StatusRequest);
decodeSync(StatusRequest);
const StatusResponse = Struct({
  currentHead: optional(Cursor),
  lastIngested: optional(Cursor),
  finalized: optional(Cursor),
  starting: optional(Cursor)
});
encodeSync(StatusResponse);
const statusResponseFromProto = decodeSync(StatusResponse);

var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, key + "" , value);
  return value;
};
function createClient(config, streamUrl, options = {}) {
  const channel = libExports.createChannel(
    streamUrl,
    options?.credentials,
    options?.channelOptions
  );
  const client = libExports.createClient(
    DnaStreamDefinition,
    channel,
    options?.defaultCallOptions
  );
  return new GrpcClient(config, client);
}
class GrpcClient {
  constructor(config, client) {
    this.config = config;
    this.client = client;
    __publicField$1(this, "encodeRequest");
    this.encodeRequest = encodeSync(config.Request);
  }
  async status(request, options) {
    const response = await this.client.status(
      statusRequestToProto(request ?? {}),
      options
    );
    return statusResponseFromProto(response);
  }
  streamData(request, options) {
    const it = this.client.streamData(this.encodeRequest(request), options);
    return new StreamDataIterable(it, this.config.Block, options);
  }
}
class StreamDataIterable {
  constructor(it, schema, options) {
    this.it = it;
    this.schema = schema;
    this.options = options;
  }
  [Symbol.asyncIterator]() {
    const inner = this.it[Symbol.asyncIterator]();
    const schema = StreamDataResponse(this.schema);
    const decoder = decodeSync(schema);
    const { endingCursor } = this.options ?? {};
    let shouldStop = false;
    return {
      async next() {
        if (shouldStop) {
          return { done: true, value: undefined };
        }
        const { done, value } = await inner.next();
        if (done || value.message === undefined) {
          return { done: true, value: undefined };
        }
        const decodedMessage = decoder(value.message);
        if (endingCursor) {
          assert(value.message.$case === "data");
          assert(decodedMessage._tag === "data");
          const { orderKey, uniqueKey } = endingCursor;
          const endCursor = decodedMessage.data.endCursor;
          if (orderKey === endCursor?.orderKey) {
            if (!uniqueKey || uniqueKey === endCursor.uniqueKey) {
              shouldStop = true;
              return { done: false, value: decodedMessage };
            }
          }
        }
        return {
          done: false,
          value: decodedMessage
        };
      }
    };
  }
}

const LogLevels = {
  silent: Number.NEGATIVE_INFINITY,
  fatal: 0,
  error: 0,
  warn: 1,
  log: 2,
  info: 3,
  success: 3,
  fail: 3,
  ready: 3,
  start: 3,
  box: 3,
  debug: 4,
  trace: 5,
  verbose: Number.POSITIVE_INFINITY
};
const LogTypes = {
  // Silent
  silent: {
    level: -1
  },
  // Level 0
  fatal: {
    level: LogLevels.fatal
  },
  error: {
    level: LogLevels.error
  },
  // Level 1
  warn: {
    level: LogLevels.warn
  },
  // Level 2
  log: {
    level: LogLevels.log
  },
  // Level 3
  info: {
    level: LogLevels.info
  },
  success: {
    level: LogLevels.success
  },
  fail: {
    level: LogLevels.fail
  },
  ready: {
    level: LogLevels.info
  },
  start: {
    level: LogLevels.info
  },
  box: {
    level: LogLevels.info
  },
  // Level 4
  debug: {
    level: LogLevels.debug
  },
  // Level 5
  trace: {
    level: LogLevels.trace
  },
  // Verbose
  verbose: {
    level: LogLevels.verbose
  }
};

function isPlainObject$1(value) {
  if (value === null || typeof value !== "object") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {
    return false;
  }
  if (Symbol.iterator in value) {
    return false;
  }
  if (Symbol.toStringTag in value) {
    return Object.prototype.toString.call(value) === "[object Module]";
  }
  return true;
}

function _defu(baseObject, defaults, namespace = ".", merger) {
  if (!isPlainObject$1(defaults)) {
    return _defu(baseObject, {}, namespace);
  }
  const object = Object.assign({}, defaults);
  for (const key in baseObject) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = baseObject[key];
    if (value === null || value === undefined) {
      continue;
    }
    if (Array.isArray(value) && Array.isArray(object[key])) {
      object[key] = [...value, ...object[key]];
    } else if (isPlainObject$1(value) && isPlainObject$1(object[key])) {
      object[key] = _defu(
        value,
        object[key],
        (namespace ? `${namespace}.` : "") + key.toString());
    } else {
      object[key] = value;
    }
  }
  return object;
}
function createDefu(merger) {
  return (...arguments_) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    arguments_.reduce((p, c) => _defu(p, c, ""), {})
  );
}
const defu = createDefu();

function isPlainObject(obj) {
  return Object.prototype.toString.call(obj) === "[object Object]";
}
function isLogObj(arg) {
  if (!isPlainObject(arg)) {
    return false;
  }
  if (!arg.message && !arg.args) {
    return false;
  }
  if (arg.stack) {
    return false;
  }
  return true;
}

let paused = false;
const queue = [];
class Consola {
  options;
  _lastLog;
  _mockFn;
  /**
   * Creates an instance of Consola with specified options or defaults.
   *
   * @param {Partial<ConsolaOptions>} [options={}] - Configuration options for the Consola instance.
   */
  constructor(options = {}) {
    const types = options.types || LogTypes;
    this.options = defu(
      {
        ...options,
        defaults: { ...options.defaults },
        level: _normalizeLogLevel(options.level, types),
        reporters: [...options.reporters || []]
      },
      {
        types: LogTypes,
        throttle: 1e3,
        throttleMin: 5,
        formatOptions: {
          date: true,
          colors: false,
          compact: true
        }
      }
    );
    for (const type in types) {
      const defaults = {
        type,
        ...this.options.defaults,
        ...types[type]
      };
      this[type] = this._wrapLogFn(defaults);
      this[type].raw = this._wrapLogFn(
        defaults,
        true
      );
    }
    if (this.options.mockFn) {
      this.mockTypes();
    }
    this._lastLog = {};
  }
  /**
   * Gets the current log level of the Consola instance.
   *
   * @returns {number} The current log level.
   */
  get level() {
    return this.options.level;
  }
  /**
   * Sets the minimum log level that will be output by the instance.
   *
   * @param {number} level - The new log level to set.
   */
  set level(level) {
    this.options.level = _normalizeLogLevel(
      level,
      this.options.types,
      this.options.level
    );
  }
  /**
   * Displays a prompt to the user and returns the response.
   * Throw an error if `prompt` is not supported by the current configuration.
   *
   * @template T
   * @param {string} message - The message to display in the prompt.
   * @param {T} [opts] - Optional options for the prompt. See {@link PromptOptions}.
   * @returns {promise<T>} A promise that infer with the prompt options. See {@link PromptOptions}.
   */
  prompt(message, opts) {
    if (!this.options.prompt) {
      throw new Error("prompt is not supported!");
    }
    return this.options.prompt(message, opts);
  }
  /**
   * Creates a new instance of Consola, inheriting options from the current instance, with possible overrides.
   *
   * @param {Partial<ConsolaOptions>} options - Optional overrides for the new instance. See {@link ConsolaOptions}.
   * @returns {ConsolaInstance} A new Consola instance. See {@link ConsolaInstance}.
   */
  create(options) {
    const instance = new Consola({
      ...this.options,
      ...options
    });
    if (this._mockFn) {
      instance.mockTypes(this._mockFn);
    }
    return instance;
  }
  /**
   * Creates a new Consola instance with the specified default log object properties.
   *
   * @param {InputLogObject} defaults - Default properties to include in any log from the new instance. See {@link InputLogObject}.
   * @returns {ConsolaInstance} A new Consola instance. See {@link ConsolaInstance}.
   */
  withDefaults(defaults) {
    return this.create({
      ...this.options,
      defaults: {
        ...this.options.defaults,
        ...defaults
      }
    });
  }
  /**
   * Creates a new Consola instance with a specified tag, which will be included in every log.
   *
   * @param {string} tag - The tag to include in each log of the new instance.
   * @returns {ConsolaInstance} A new Consola instance. See {@link ConsolaInstance}.
   */
  withTag(tag) {
    return this.withDefaults({
      tag: this.options.defaults.tag ? this.options.defaults.tag + ":" + tag : tag
    });
  }
  /**
   * Adds a custom reporter to the Consola instance.
   * Reporters will be called for each log message, depending on their implementation and log level.
   *
   * @param {ConsolaReporter} reporter - The reporter to add. See {@link ConsolaReporter}.
   * @returns {Consola} The current Consola instance.
   */
  addReporter(reporter) {
    this.options.reporters.push(reporter);
    return this;
  }
  /**
   * Removes a custom reporter from the Consola instance.
   * If no reporter is specified, all reporters will be removed.
   *
   * @param {ConsolaReporter} reporter - The reporter to remove. See {@link ConsolaReporter}.
   * @returns {Consola} The current Consola instance.
   */
  removeReporter(reporter) {
    if (reporter) {
      const i = this.options.reporters.indexOf(reporter);
      if (i !== -1) {
        return this.options.reporters.splice(i, 1);
      }
    } else {
      this.options.reporters.splice(0);
    }
    return this;
  }
  /**
   * Replaces all reporters of the Consola instance with the specified array of reporters.
   *
   * @param {ConsolaReporter[]} reporters - The new reporters to set. See {@link ConsolaReporter}.
   * @returns {Consola} The current Consola instance.
   */
  setReporters(reporters) {
    this.options.reporters = Array.isArray(reporters) ? reporters : [reporters];
    return this;
  }
  wrapAll() {
    this.wrapConsole();
    this.wrapStd();
  }
  restoreAll() {
    this.restoreConsole();
    this.restoreStd();
  }
  /**
   * Overrides console methods with Consola logging methods for consistent logging.
   */
  wrapConsole() {
    for (const type in this.options.types) {
      if (!console["__" + type]) {
        console["__" + type] = console[type];
      }
      console[type] = this[type].raw;
    }
  }
  /**
   * Restores the original console methods, removing Consola overrides.
   */
  restoreConsole() {
    for (const type in this.options.types) {
      if (console["__" + type]) {
        console[type] = console["__" + type];
        delete console["__" + type];
      }
    }
  }
  /**
   * Overrides standard output and error streams to redirect them through Consola.
   */
  wrapStd() {
    this._wrapStream(this.options.stdout, "log");
    this._wrapStream(this.options.stderr, "log");
  }
  _wrapStream(stream, type) {
    if (!stream) {
      return;
    }
    if (!stream.__write) {
      stream.__write = stream.write;
    }
    stream.write = (data) => {
      this[type].raw(String(data).trim());
    };
  }
  /**
   * Restores the original standard output and error streams, removing the Consola redirection.
   */
  restoreStd() {
    this._restoreStream(this.options.stdout);
    this._restoreStream(this.options.stderr);
  }
  _restoreStream(stream) {
    if (!stream) {
      return;
    }
    if (stream.__write) {
      stream.write = stream.__write;
      delete stream.__write;
    }
  }
  /**
   * Pauses logging, queues incoming logs until resumed.
   */
  pauseLogs() {
    paused = true;
  }
  /**
   * Resumes logging, processing any queued logs.
   */
  resumeLogs() {
    paused = false;
    const _queue = queue.splice(0);
    for (const item of _queue) {
      item[0]._logFn(item[1], item[2]);
    }
  }
  /**
   * Replaces logging methods with mocks if a mock function is provided.
   *
   * @param {ConsolaOptions["mockFn"]} mockFn - The function to use for mocking logging methods. See {@link ConsolaOptions["mockFn"]}.
   */
  mockTypes(mockFn) {
    const _mockFn = mockFn || this.options.mockFn;
    this._mockFn = _mockFn;
    if (typeof _mockFn !== "function") {
      return;
    }
    for (const type in this.options.types) {
      this[type] = _mockFn(type, this.options.types[type]) || this[type];
      this[type].raw = this[type];
    }
  }
  _wrapLogFn(defaults, isRaw) {
    return (...args) => {
      if (paused) {
        queue.push([this, defaults, args, isRaw]);
        return;
      }
      return this._logFn(defaults, args, isRaw);
    };
  }
  _logFn(defaults, args, isRaw) {
    if ((defaults.level || 0) > this.level) {
      return false;
    }
    const logObj = {
      date: /* @__PURE__ */ new Date(),
      args: [],
      ...defaults,
      level: _normalizeLogLevel(defaults.level, this.options.types)
    };
    if (!isRaw && args.length === 1 && isLogObj(args[0])) {
      Object.assign(logObj, args[0]);
    } else {
      logObj.args = [...args];
    }
    if (logObj.message) {
      logObj.args.unshift(logObj.message);
      delete logObj.message;
    }
    if (logObj.additional) {
      if (!Array.isArray(logObj.additional)) {
        logObj.additional = logObj.additional.split("\n");
      }
      logObj.args.push("\n" + logObj.additional.join("\n"));
      delete logObj.additional;
    }
    logObj.type = typeof logObj.type === "string" ? logObj.type.toLowerCase() : "log";
    logObj.tag = typeof logObj.tag === "string" ? logObj.tag : "";
    const resolveLog = (newLog = false) => {
      const repeated = (this._lastLog.count || 0) - this.options.throttleMin;
      if (this._lastLog.object && repeated > 0) {
        const args2 = [...this._lastLog.object.args];
        if (repeated > 1) {
          args2.push(`(repeated ${repeated} times)`);
        }
        this._log({ ...this._lastLog.object, args: args2 });
        this._lastLog.count = 1;
      }
      if (newLog) {
        this._lastLog.object = logObj;
        this._log(logObj);
      }
    };
    clearTimeout(this._lastLog.timeout);
    const diffTime = this._lastLog.time && logObj.date ? logObj.date.getTime() - this._lastLog.time.getTime() : 0;
    this._lastLog.time = logObj.date;
    if (diffTime < this.options.throttle) {
      try {
        const serializedLog = JSON.stringify([
          logObj.type,
          logObj.tag,
          logObj.args
        ]);
        const isSameLog = this._lastLog.serialized === serializedLog;
        this._lastLog.serialized = serializedLog;
        if (isSameLog) {
          this._lastLog.count = (this._lastLog.count || 0) + 1;
          if (this._lastLog.count > this.options.throttleMin) {
            this._lastLog.timeout = setTimeout(
              resolveLog,
              this.options.throttle
            );
            return;
          }
        }
      } catch {
      }
    }
    resolveLog(true);
  }
  _log(logObj) {
    for (const reporter of this.options.reporters) {
      reporter.log(logObj, {
        options: this.options
      });
    }
  }
}
function _normalizeLogLevel(input, types = {}, defaultLevel = 3) {
  if (input === undefined) {
    return defaultLevel;
  }
  if (typeof input === "number") {
    return input;
  }
  if (types[input] && types[input].level !== undefined) {
    return types[input].level;
  }
  return defaultLevel;
}
Consola.prototype.add = Consola.prototype.addReporter;
Consola.prototype.remove = Consola.prototype.removeReporter;
Consola.prototype.clear = Consola.prototype.removeReporter;
Consola.prototype.withScope = Consola.prototype.withTag;
Consola.prototype.mock = Consola.prototype.mockTypes;
Consola.prototype.pause = Consola.prototype.pauseLogs;
Consola.prototype.resume = Consola.prototype.resumeLogs;
function createConsola$1(options = {}) {
  return new Consola(options);
}

class BrowserReporter {
  options;
  defaultColor;
  levelColorMap;
  typeColorMap;
  constructor(options) {
    this.options = { ...options };
    this.defaultColor = "#7f8c8d";
    this.levelColorMap = {
      0: "#c0392b",
      // Red
      1: "#f39c12",
      // Yellow
      3: "#00BCD4"
      // Cyan
    };
    this.typeColorMap = {
      success: "#2ecc71"
      // Green
    };
  }
  _getLogFn(level) {
    if (level < 1) {
      return console.__error || console.error;
    }
    if (level === 1) {
      return console.__warn || console.warn;
    }
    return console.__log || console.log;
  }
  log(logObj) {
    const consoleLogFn = this._getLogFn(logObj.level);
    const type = logObj.type === "log" ? "" : logObj.type;
    const tag = logObj.tag || "";
    const color = this.typeColorMap[logObj.type] || this.levelColorMap[logObj.level] || this.defaultColor;
    const style = `
      background: ${color};
      border-radius: 0.5em;
      color: white;
      font-weight: bold;
      padding: 2px 0.5em;
    `;
    const badge = `%c${[tag, type].filter(Boolean).join(":")}`;
    if (typeof logObj.args[0] === "string") {
      consoleLogFn(
        `${badge}%c ${logObj.args[0]}`,
        style,
        // Empty string as style resets to default console style
        "",
        ...logObj.args.slice(1)
      );
    } else {
      consoleLogFn(badge, style, ...logObj.args);
    }
  }
}

function createConsola(options = {}) {
  const consola2 = createConsola$1({
    reporters: options.reporters || [new BrowserReporter({})],
    prompt(message, options2 = {}) {
      if (options2.type === "confirm") {
        return Promise.resolve(confirm(message));
      }
      return Promise.resolve(prompt(message));
    },
    ...options
  });
  return consola2;
}
const consola = createConsola();

function flatHooks(configHooks, hooks = {}, parentName) {
  for (const key in configHooks) {
    const subHook = configHooks[key];
    const name = parentName ? `${parentName}:${key}` : key;
    if (typeof subHook === "object" && subHook !== null) {
      flatHooks(subHook, hooks, name);
    } else if (typeof subHook === "function") {
      hooks[name] = subHook;
    }
  }
  return hooks;
}
const defaultTask = { run: (function_) => function_() };
const _createTask = () => defaultTask;
const createTask = typeof console.createTask !== "undefined" ? console.createTask : _createTask;
function serialTaskCaller(hooks, args) {
  const name = args.shift();
  const task = createTask(name);
  return hooks.reduce(
    (promise, hookFunction) => promise.then(() => task.run(() => hookFunction(...args))),
    Promise.resolve()
  );
}
function parallelTaskCaller(hooks, args) {
  const name = args.shift();
  const task = createTask(name);
  return Promise.all(hooks.map((hook) => task.run(() => hook(...args))));
}
function callEachWith(callbacks, arg0) {
  for (const callback of [...callbacks]) {
    callback(arg0);
  }
}

class Hookable {
  constructor() {
    this._hooks = {};
    this._before = undefined;
    this._after = undefined;
    this._deprecatedMessages = undefined;
    this._deprecatedHooks = {};
    this.hook = this.hook.bind(this);
    this.callHook = this.callHook.bind(this);
    this.callHookWith = this.callHookWith.bind(this);
  }
  hook(name, function_, options = {}) {
    if (!name || typeof function_ !== "function") {
      return () => {
      };
    }
    const originalName = name;
    let dep;
    while (this._deprecatedHooks[name]) {
      dep = this._deprecatedHooks[name];
      name = dep.to;
    }
    if (dep && !options.allowDeprecated) {
      let message = dep.message;
      if (!message) {
        message = `${originalName} hook has been deprecated` + (dep.to ? `, please use ${dep.to}` : "");
      }
      if (!this._deprecatedMessages) {
        this._deprecatedMessages = /* @__PURE__ */ new Set();
      }
      if (!this._deprecatedMessages.has(message)) {
        console.warn(message);
        this._deprecatedMessages.add(message);
      }
    }
    if (!function_.name) {
      try {
        Object.defineProperty(function_, "name", {
          get: () => "_" + name.replace(/\W+/g, "_") + "_hook_cb",
          configurable: true
        });
      } catch {
      }
    }
    this._hooks[name] = this._hooks[name] || [];
    this._hooks[name].push(function_);
    return () => {
      if (function_) {
        this.removeHook(name, function_);
        function_ = undefined;
      }
    };
  }
  hookOnce(name, function_) {
    let _unreg;
    let _function = (...arguments_) => {
      if (typeof _unreg === "function") {
        _unreg();
      }
      _unreg = undefined;
      _function = undefined;
      return function_(...arguments_);
    };
    _unreg = this.hook(name, _function);
    return _unreg;
  }
  removeHook(name, function_) {
    if (this._hooks[name]) {
      const index = this._hooks[name].indexOf(function_);
      if (index !== -1) {
        this._hooks[name].splice(index, 1);
      }
      if (this._hooks[name].length === 0) {
        delete this._hooks[name];
      }
    }
  }
  deprecateHook(name, deprecated) {
    this._deprecatedHooks[name] = typeof deprecated === "string" ? { to: deprecated } : deprecated;
    const _hooks = this._hooks[name] || [];
    delete this._hooks[name];
    for (const hook of _hooks) {
      this.hook(name, hook);
    }
  }
  deprecateHooks(deprecatedHooks) {
    Object.assign(this._deprecatedHooks, deprecatedHooks);
    for (const name in deprecatedHooks) {
      this.deprecateHook(name, deprecatedHooks[name]);
    }
  }
  addHooks(configHooks) {
    const hooks = flatHooks(configHooks);
    const removeFns = Object.keys(hooks).map(
      (key) => this.hook(key, hooks[key])
    );
    return () => {
      for (const unreg of removeFns.splice(0, removeFns.length)) {
        unreg();
      }
    };
  }
  removeHooks(configHooks) {
    const hooks = flatHooks(configHooks);
    for (const key in hooks) {
      this.removeHook(key, hooks[key]);
    }
  }
  removeAllHooks() {
    for (const key in this._hooks) {
      delete this._hooks[key];
    }
  }
  callHook(name, ...arguments_) {
    arguments_.unshift(name);
    return this.callHookWith(serialTaskCaller, name, ...arguments_);
  }
  callHookParallel(name, ...arguments_) {
    arguments_.unshift(name);
    return this.callHookWith(parallelTaskCaller, name, ...arguments_);
  }
  callHookWith(caller, name, ...arguments_) {
    const event = this._before || this._after ? { name, args: arguments_, context: {} } : undefined;
    if (this._before) {
      callEachWith(this._before, event);
    }
    const result = caller(
      name in this._hooks ? [...this._hooks[name]] : [],
      arguments_
    );
    if (result instanceof Promise) {
      return result.finally(() => {
        if (this._after && event) {
          callEachWith(this._after, event);
        }
      });
    }
    if (this._after && event) {
      callEachWith(this._after, event);
    }
    return result;
  }
  beforeEach(function_) {
    this._before = this._before || [];
    this._before.push(function_);
    return () => {
      if (this._before !== undefined) {
        const index = this._before.indexOf(function_);
        if (index !== -1) {
          this._before.splice(index, 1);
        }
      }
    };
  }
  afterEach(function_) {
    this._after = this._after || [];
    this._after.push(function_);
    return () => {
      if (this._after !== undefined) {
        const index = this._after.indexOf(function_);
        if (index !== -1) {
          this._after.splice(index, 1);
        }
      }
    };
  }
}
function createHooks() {
  return new Hookable();
}

const isBrowser = typeof window !== "undefined";
function createDebugger(hooks, _options = {}) {
  const options = {
    inspect: isBrowser,
    group: isBrowser,
    filter: () => true,
    ..._options
  };
  const _filter = options.filter;
  const filter = typeof _filter === "string" ? (name) => name.startsWith(_filter) : _filter;
  const _tag = options.tag ? `[${options.tag}] ` : "";
  const logPrefix = (event) => _tag + event.name + "".padEnd(event._id, "\0");
  const _idCtr = {};
  const unsubscribeBefore = hooks.beforeEach((event) => {
    if (filter !== undefined && !filter(event.name)) {
      return;
    }
    _idCtr[event.name] = _idCtr[event.name] || 0;
    event._id = _idCtr[event.name]++;
    console.time(logPrefix(event));
  });
  const unsubscribeAfter = hooks.afterEach((event) => {
    if (filter !== undefined && !filter(event.name)) {
      return;
    }
    if (options.group) {
      console.groupCollapsed(event.name);
    }
    if (options.inspect) {
      console.timeLog(logPrefix(event), event.args);
    } else {
      console.timeEnd(logPrefix(event));
    }
    if (options.group) {
      console.groupEnd();
    }
    _idCtr[event.name]--;
  });
  return {
    /** Stop debugging and remove listeners */
    close: () => {
      unsubscribeBefore();
      unsubscribeAfter();
    }
  };
}

function createContext(opts = {}) {
  let currentInstance;
  let isSingleton = false;
  const checkConflict = (instance) => {
    if (currentInstance && currentInstance !== instance) {
      throw new Error("Context conflict");
    }
  };
  let als;
  if (opts.asyncContext) {
    const _AsyncLocalStorage = opts.AsyncLocalStorage || globalThis.AsyncLocalStorage;
    if (_AsyncLocalStorage) {
      als = new _AsyncLocalStorage();
    } else {
      console.warn("[unctx] `AsyncLocalStorage` is not provided.");
    }
  }
  const _getCurrentInstance = () => {
    if (als) {
      const instance = als.getStore();
      if (instance !== undefined) {
        return instance;
      }
    }
    return currentInstance;
  };
  return {
    use: () => {
      const _instance = _getCurrentInstance();
      if (_instance === undefined) {
        throw new Error("Context is not available");
      }
      return _instance;
    },
    tryUse: () => {
      return _getCurrentInstance();
    },
    set: (instance, replace) => {
      if (!replace) {
        checkConflict(instance);
      }
      currentInstance = instance;
      isSingleton = true;
    },
    unset: () => {
      currentInstance = undefined;
      isSingleton = false;
    },
    call: (instance, callback) => {
      checkConflict(instance);
      currentInstance = instance;
      try {
        return als ? als.run(instance, callback) : callback();
      } finally {
        if (!isSingleton) {
          currentInstance = undefined;
        }
      }
    },
    async callAsync(instance, callback) {
      currentInstance = instance;
      const onRestore = () => {
        currentInstance = instance;
      };
      const onLeave = () => currentInstance === instance ? onRestore : undefined;
      asyncHandlers.add(onLeave);
      try {
        const r = als ? als.run(instance, callback) : callback();
        if (!isSingleton) {
          currentInstance = void 0;
        }
        return await r;
      } finally {
        asyncHandlers.delete(onLeave);
      }
    }
  };
}
function createNamespace(defaultOpts = {}) {
  const contexts = {};
  return {
    get(key, opts = {}) {
      if (!contexts[key]) {
        contexts[key] = createContext({ ...defaultOpts, ...opts });
      }
      return contexts[key];
    }
  };
}
const _globalThis$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : {};
const globalKey = "__unctx__";
const defaultNamespace = _globalThis$1[globalKey] || (_globalThis$1[globalKey] = createNamespace());
const getContext = (key, opts = {}) => defaultNamespace.get(key, opts);
const asyncHandlersKey = "__unctx_async_handlers__";
const asyncHandlers = _globalThis$1[asyncHandlersKey] || (_globalThis$1[asyncHandlersKey] = /* @__PURE__ */ new Set());

const indexerAsyncContext = getContext("indexer", {
  asyncContext: true,
  AsyncLocalStorage
});
function useIndexerContext() {
  return indexerAsyncContext.use();
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** only globals that common to node and browsers are allowed */
// eslint-disable-next-line node/no-unsupported-features/es-builtins
var _globalThis = typeof globalThis === 'object' ? globalThis : global;

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// this is autogenerated file, see scripts/version-update.js
var VERSION = '1.9.0';

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
/**
 * Create a function to test an API version to see if it is compatible with the provided ownVersion.
 *
 * The returned function has the following semantics:
 * - Exact match is always compatible
 * - Major versions must match exactly
 *    - 1.x package cannot use global 2.x package
 *    - 2.x package cannot use global 1.x package
 * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API
 *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects
 *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3
 * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor
 * - Patch and build tag differences are not considered at this time
 *
 * @param ownVersion version which should be checked against
 */
function _makeCompatibilityCheck(ownVersion) {
    var acceptedVersions = new Set([ownVersion]);
    var rejectedVersions = new Set();
    var myVersionMatch = ownVersion.match(re);
    if (!myVersionMatch) {
        // we cannot guarantee compatibility so we always return noop
        return function () { return false; };
    }
    var ownVersionParsed = {
        major: +myVersionMatch[1],
        minor: +myVersionMatch[2],
        patch: +myVersionMatch[3],
        prerelease: myVersionMatch[4],
    };
    // if ownVersion has a prerelease tag, versions must match exactly
    if (ownVersionParsed.prerelease != null) {
        return function isExactmatch(globalVersion) {
            return globalVersion === ownVersion;
        };
    }
    function _reject(v) {
        rejectedVersions.add(v);
        return false;
    }
    function _accept(v) {
        acceptedVersions.add(v);
        return true;
    }
    return function isCompatible(globalVersion) {
        if (acceptedVersions.has(globalVersion)) {
            return true;
        }
        if (rejectedVersions.has(globalVersion)) {
            return false;
        }
        var globalVersionMatch = globalVersion.match(re);
        if (!globalVersionMatch) {
            // cannot parse other version
            // we cannot guarantee compatibility so we always noop
            return _reject(globalVersion);
        }
        var globalVersionParsed = {
            major: +globalVersionMatch[1],
            minor: +globalVersionMatch[2],
            patch: +globalVersionMatch[3],
            prerelease: globalVersionMatch[4],
        };
        // if globalVersion has a prerelease tag, versions must match exactly
        if (globalVersionParsed.prerelease != null) {
            return _reject(globalVersion);
        }
        // major versions must match
        if (ownVersionParsed.major !== globalVersionParsed.major) {
            return _reject(globalVersion);
        }
        if (ownVersionParsed.major === 0) {
            if (ownVersionParsed.minor === globalVersionParsed.minor &&
                ownVersionParsed.patch <= globalVersionParsed.patch) {
                return _accept(globalVersion);
            }
            return _reject(globalVersion);
        }
        if (ownVersionParsed.minor <= globalVersionParsed.minor) {
            return _accept(globalVersion);
        }
        return _reject(globalVersion);
    };
}
/**
 * Test an API version to see if it is compatible with this API.
 *
 * - Exact match is always compatible
 * - Major versions must match exactly
 *    - 1.x package cannot use global 2.x package
 *    - 2.x package cannot use global 1.x package
 * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API
 *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects
 *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3
 * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor
 * - Patch and build tag differences are not considered at this time
 *
 * @param version version of the API requesting an instance of the global API
 */
var isCompatible = _makeCompatibilityCheck(VERSION);

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var major = VERSION.split('.')[0];
var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
var _global = _globalThis;
function registerGlobal(type, instance, diag, allowOverride) {
    var _a;
    if (allowOverride === undefined) { allowOverride = false; }
    var api = (_global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== undefined ? _a : {
        version: VERSION,
    });
    if (!allowOverride && api[type]) {
        // already registered an API of this type
        var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
        diag.error(err.stack || err.message);
        return false;
    }
    if (api.version !== VERSION) {
        // All registered APIs must be of the same version exactly
        var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION);
        diag.error(err.stack || err.message);
        return false;
    }
    api[type] = instance;
    diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION + ".");
    return true;
}
function getGlobal(type) {
    var _a, _b;
    var globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === undefined ? undefined : _a.version;
    if (!globalVersion || !isCompatible(globalVersion)) {
        return;
    }
    return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === undefined ? undefined : _b[type];
}
function unregisterGlobal(type, diag) {
    diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION + ".");
    var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
    if (api) {
        delete api[type];
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __read$4 = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray$3 = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/**
 * Component Logger which is meant to be used as part of any component which
 * will add automatically additional namespace in front of the log message.
 * It will then forward all message to global diag logger
 * @example
 * const cLogger = diag.createComponentLogger({ namespace: '@opentelemetry/instrumentation-http' });
 * cLogger.debug('test');
 * // @opentelemetry/instrumentation-http test
 */
var DiagComponentLogger = /** @class */ (function () {
    function DiagComponentLogger(props) {
        this._namespace = props.namespace || 'DiagComponentLogger';
    }
    DiagComponentLogger.prototype.debug = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return logProxy('debug', this._namespace, args);
    };
    DiagComponentLogger.prototype.error = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return logProxy('error', this._namespace, args);
    };
    DiagComponentLogger.prototype.info = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return logProxy('info', this._namespace, args);
    };
    DiagComponentLogger.prototype.warn = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return logProxy('warn', this._namespace, args);
    };
    DiagComponentLogger.prototype.verbose = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return logProxy('verbose', this._namespace, args);
    };
    return DiagComponentLogger;
}());
function logProxy(funcName, namespace, args) {
    var logger = getGlobal('diag');
    // shortcut if logger not set
    if (!logger) {
        return;
    }
    args.unshift(namespace);
    return logger[funcName].apply(logger, __spreadArray$3([], __read$4(args), false));
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Defines the available internal logging levels for the diagnostic logger, the numeric values
 * of the levels are defined to match the original values from the initial LogLevel to avoid
 * compatibility/migration issues for any implementation that assume the numeric ordering.
 */
var DiagLogLevel;
(function (DiagLogLevel) {
    /** Diagnostic Logging level setting to disable all logging (except and forced logs) */
    DiagLogLevel[DiagLogLevel["NONE"] = 0] = "NONE";
    /** Identifies an error scenario */
    DiagLogLevel[DiagLogLevel["ERROR"] = 30] = "ERROR";
    /** Identifies a warning scenario */
    DiagLogLevel[DiagLogLevel["WARN"] = 50] = "WARN";
    /** General informational log message */
    DiagLogLevel[DiagLogLevel["INFO"] = 60] = "INFO";
    /** General debug log message */
    DiagLogLevel[DiagLogLevel["DEBUG"] = 70] = "DEBUG";
    /**
     * Detailed trace level logging should only be used for development, should only be set
     * in a development environment.
     */
    DiagLogLevel[DiagLogLevel["VERBOSE"] = 80] = "VERBOSE";
    /** Used to set the logging level to include all logging */
    DiagLogLevel[DiagLogLevel["ALL"] = 9999] = "ALL";
})(DiagLogLevel || (DiagLogLevel = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function createLogLevelDiagLogger(maxLevel, logger) {
    if (maxLevel < DiagLogLevel.NONE) {
        maxLevel = DiagLogLevel.NONE;
    }
    else if (maxLevel > DiagLogLevel.ALL) {
        maxLevel = DiagLogLevel.ALL;
    }
    // In case the logger is null or undefined
    logger = logger || {};
    function _filterFunc(funcName, theLevel) {
        var theFunc = logger[funcName];
        if (typeof theFunc === 'function' && maxLevel >= theLevel) {
            return theFunc.bind(logger);
        }
        return function () { };
    }
    return {
        error: _filterFunc('error', DiagLogLevel.ERROR),
        warn: _filterFunc('warn', DiagLogLevel.WARN),
        info: _filterFunc('info', DiagLogLevel.INFO),
        debug: _filterFunc('debug', DiagLogLevel.DEBUG),
        verbose: _filterFunc('verbose', DiagLogLevel.VERBOSE),
    };
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __read$3 = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray$2 = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME$4 = 'diag';
/**
 * Singleton object which represents the entry point to the OpenTelemetry internal
 * diagnostic API
 */
var DiagAPI = /** @class */ (function () {
    /**
     * Private internal constructor
     * @private
     */
    function DiagAPI() {
        function _logProxy(funcName) {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var logger = getGlobal('diag');
                // shortcut if logger not set
                if (!logger)
                    return;
                return logger[funcName].apply(logger, __spreadArray$2([], __read$3(args), false));
            };
        }
        // Using self local variable for minification purposes as 'this' cannot be minified
        var self = this;
        // DiagAPI specific functions
        var setLogger = function (logger, optionsOrLogLevel) {
            var _a, _b, _c;
            if (optionsOrLogLevel === undefined) { optionsOrLogLevel = { logLevel: DiagLogLevel.INFO }; }
            if (logger === self) {
                // There isn't much we can do here.
                // Logging to the console might break the user application.
                // Try to log to self. If a logger was previously registered it will receive the log.
                var err = new Error('Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation');
                self.error((_a = err.stack) !== null && _a !== undefined ? _a : err.message);
                return false;
            }
            if (typeof optionsOrLogLevel === 'number') {
                optionsOrLogLevel = {
                    logLevel: optionsOrLogLevel,
                };
            }
            var oldLogger = getGlobal('diag');
            var newLogger = createLogLevelDiagLogger((_b = optionsOrLogLevel.logLevel) !== null && _b !== undefined ? _b : DiagLogLevel.INFO, logger);
            // There already is an logger registered. We'll let it know before overwriting it.
            if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
                var stack = (_c = new Error().stack) !== null && _c !== undefined ? _c : '<failed to generate stacktrace>';
                oldLogger.warn("Current logger will be overwritten from " + stack);
                newLogger.warn("Current logger will overwrite one already registered from " + stack);
            }
            return registerGlobal('diag', newLogger, self, true);
        };
        self.setLogger = setLogger;
        self.disable = function () {
            unregisterGlobal(API_NAME$4, self);
        };
        self.createComponentLogger = function (options) {
            return new DiagComponentLogger(options);
        };
        self.verbose = _logProxy('verbose');
        self.debug = _logProxy('debug');
        self.info = _logProxy('info');
        self.warn = _logProxy('warn');
        self.error = _logProxy('error');
    }
    /** Get the singleton instance of the DiagAPI API */
    DiagAPI.instance = function () {
        if (!this._instance) {
            this._instance = new DiagAPI();
        }
        return this._instance;
    };
    return DiagAPI;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __read$2 = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = undefined;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var BaggageImpl = /** @class */ (function () {
    function BaggageImpl(entries) {
        this._entries = entries ? new Map(entries) : new Map();
    }
    BaggageImpl.prototype.getEntry = function (key) {
        var entry = this._entries.get(key);
        if (!entry) {
            return undefined;
        }
        return Object.assign({}, entry);
    };
    BaggageImpl.prototype.getAllEntries = function () {
        return Array.from(this._entries.entries()).map(function (_a) {
            var _b = __read$2(_a, 2), k = _b[0], v = _b[1];
            return [k, v];
        });
    };
    BaggageImpl.prototype.setEntry = function (key, entry) {
        var newBaggage = new BaggageImpl(this._entries);
        newBaggage._entries.set(key, entry);
        return newBaggage;
    };
    BaggageImpl.prototype.removeEntry = function (key) {
        var newBaggage = new BaggageImpl(this._entries);
        newBaggage._entries.delete(key);
        return newBaggage;
    };
    BaggageImpl.prototype.removeEntries = function () {
        var e_1, _a;
        var keys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            keys[_i] = arguments[_i];
        }
        var newBaggage = new BaggageImpl(this._entries);
        try {
            for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
                var key = keys_1_1.value;
                newBaggage._entries.delete(key);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return newBaggage;
    };
    BaggageImpl.prototype.clear = function () {
        return new BaggageImpl();
    };
    return BaggageImpl;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
DiagAPI.instance();
/**
 * Create a new Baggage with optional entries
 *
 * @param entries An array of baggage entries the new baggage should contain
 */
function createBaggage(entries) {
    if (entries === undefined) { entries = {}; }
    return new BaggageImpl(new Map(Object.entries(entries)));
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Get a key to uniquely identify a context value */
function createContextKey(description) {
    // The specification states that for the same input, multiple calls should
    // return different keys. Due to the nature of the JS dependency management
    // system, this creates problems where multiple versions of some package
    // could hold different keys for the same property.
    //
    // Therefore, we use Symbol.for which returns the same key for the same input.
    return Symbol.for(description);
}
var BaseContext = /** @class */ (function () {
    /**
     * Construct a new context which inherits values from an optional parent context.
     *
     * @param parentContext a context from which to inherit values
     */
    function BaseContext(parentContext) {
        // for minification
        var self = this;
        self._currentContext = parentContext ? new Map(parentContext) : new Map();
        self.getValue = function (key) { return self._currentContext.get(key); };
        self.setValue = function (key, value) {
            var context = new BaseContext(self._currentContext);
            context._currentContext.set(key, value);
            return context;
        };
        self.deleteValue = function (key) {
            var context = new BaseContext(self._currentContext);
            context._currentContext.delete(key);
            return context;
        };
    }
    return BaseContext;
}());
/** The root context is used as the default parent context when there is no active context */
var ROOT_CONTEXT = new BaseContext();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * NoopMeter is a noop implementation of the {@link Meter} interface. It reuses
 * constant NoopMetrics for all of its methods.
 */
var NoopMeter = /** @class */ (function () {
    function NoopMeter() {
    }
    /**
     * @see {@link Meter.createGauge}
     */
    NoopMeter.prototype.createGauge = function (_name, _options) {
        return NOOP_GAUGE_METRIC;
    };
    /**
     * @see {@link Meter.createHistogram}
     */
    NoopMeter.prototype.createHistogram = function (_name, _options) {
        return NOOP_HISTOGRAM_METRIC;
    };
    /**
     * @see {@link Meter.createCounter}
     */
    NoopMeter.prototype.createCounter = function (_name, _options) {
        return NOOP_COUNTER_METRIC;
    };
    /**
     * @see {@link Meter.createUpDownCounter}
     */
    NoopMeter.prototype.createUpDownCounter = function (_name, _options) {
        return NOOP_UP_DOWN_COUNTER_METRIC;
    };
    /**
     * @see {@link Meter.createObservableGauge}
     */
    NoopMeter.prototype.createObservableGauge = function (_name, _options) {
        return NOOP_OBSERVABLE_GAUGE_METRIC;
    };
    /**
     * @see {@link Meter.createObservableCounter}
     */
    NoopMeter.prototype.createObservableCounter = function (_name, _options) {
        return NOOP_OBSERVABLE_COUNTER_METRIC;
    };
    /**
     * @see {@link Meter.createObservableUpDownCounter}
     */
    NoopMeter.prototype.createObservableUpDownCounter = function (_name, _options) {
        return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
    };
    /**
     * @see {@link Meter.addBatchObservableCallback}
     */
    NoopMeter.prototype.addBatchObservableCallback = function (_callback, _observables) { };
    /**
     * @see {@link Meter.removeBatchObservableCallback}
     */
    NoopMeter.prototype.removeBatchObservableCallback = function (_callback) { };
    return NoopMeter;
}());
var NoopMetric = /** @class */ (function () {
    function NoopMetric() {
    }
    return NoopMetric;
}());
var NoopCounterMetric = /** @class */ (function (_super) {
    __extends(NoopCounterMetric, _super);
    function NoopCounterMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopCounterMetric.prototype.add = function (_value, _attributes) { };
    return NoopCounterMetric;
}(NoopMetric));
var NoopUpDownCounterMetric = /** @class */ (function (_super) {
    __extends(NoopUpDownCounterMetric, _super);
    function NoopUpDownCounterMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopUpDownCounterMetric.prototype.add = function (_value, _attributes) { };
    return NoopUpDownCounterMetric;
}(NoopMetric));
var NoopGaugeMetric = /** @class */ (function (_super) {
    __extends(NoopGaugeMetric, _super);
    function NoopGaugeMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopGaugeMetric.prototype.record = function (_value, _attributes) { };
    return NoopGaugeMetric;
}(NoopMetric));
var NoopHistogramMetric = /** @class */ (function (_super) {
    __extends(NoopHistogramMetric, _super);
    function NoopHistogramMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopHistogramMetric.prototype.record = function (_value, _attributes) { };
    return NoopHistogramMetric;
}(NoopMetric));
var NoopObservableMetric = /** @class */ (function () {
    function NoopObservableMetric() {
    }
    NoopObservableMetric.prototype.addCallback = function (_callback) { };
    NoopObservableMetric.prototype.removeCallback = function (_callback) { };
    return NoopObservableMetric;
}());
var NoopObservableCounterMetric = /** @class */ (function (_super) {
    __extends(NoopObservableCounterMetric, _super);
    function NoopObservableCounterMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return NoopObservableCounterMetric;
}(NoopObservableMetric));
var NoopObservableGaugeMetric = /** @class */ (function (_super) {
    __extends(NoopObservableGaugeMetric, _super);
    function NoopObservableGaugeMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return NoopObservableGaugeMetric;
}(NoopObservableMetric));
var NoopObservableUpDownCounterMetric = /** @class */ (function (_super) {
    __extends(NoopObservableUpDownCounterMetric, _super);
    function NoopObservableUpDownCounterMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return NoopObservableUpDownCounterMetric;
}(NoopObservableMetric));
var NOOP_METER = new NoopMeter();
// Synchronous instruments
var NOOP_COUNTER_METRIC = new NoopCounterMetric();
var NOOP_GAUGE_METRIC = new NoopGaugeMetric();
var NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
var NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
// Asynchronous instruments
var NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
var NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
var NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** The Type of value. It describes how the data is reported. */
var ValueType;
(function (ValueType) {
    ValueType[ValueType["INT"] = 0] = "INT";
    ValueType[ValueType["DOUBLE"] = 1] = "DOUBLE";
})(ValueType || (ValueType = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var defaultTextMapGetter = {
    get: function (carrier, key) {
        if (carrier == null) {
            return undefined;
        }
        return carrier[key];
    },
    keys: function (carrier) {
        if (carrier == null) {
            return [];
        }
        return Object.keys(carrier);
    },
};
var defaultTextMapSetter = {
    set: function (carrier, key, value) {
        if (carrier == null) {
            return;
        }
        carrier[key] = value;
    },
};

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __read$1 = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray$1 = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var NoopContextManager = /** @class */ (function () {
    function NoopContextManager() {
    }
    NoopContextManager.prototype.active = function () {
        return ROOT_CONTEXT;
    };
    NoopContextManager.prototype.with = function (_context, fn, thisArg) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            args[_i - 3] = arguments[_i];
        }
        return fn.call.apply(fn, __spreadArray$1([thisArg], __read$1(args), false));
    };
    NoopContextManager.prototype.bind = function (_context, target) {
        return target;
    };
    NoopContextManager.prototype.enable = function () {
        return this;
    };
    NoopContextManager.prototype.disable = function () {
        return this;
    };
    return NoopContextManager;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME$3 = 'context';
var NOOP_CONTEXT_MANAGER = new NoopContextManager();
/**
 * Singleton object which represents the entry point to the OpenTelemetry Context API
 */
var ContextAPI = /** @class */ (function () {
    /** Empty private constructor prevents end users from constructing a new instance of the API */
    function ContextAPI() {
    }
    /** Get the singleton instance of the Context API */
    ContextAPI.getInstance = function () {
        if (!this._instance) {
            this._instance = new ContextAPI();
        }
        return this._instance;
    };
    /**
     * Set the current context manager.
     *
     * @returns true if the context manager was successfully registered, else false
     */
    ContextAPI.prototype.setGlobalContextManager = function (contextManager) {
        return registerGlobal(API_NAME$3, contextManager, DiagAPI.instance());
    };
    /**
     * Get the currently active context
     */
    ContextAPI.prototype.active = function () {
        return this._getContextManager().active();
    };
    /**
     * Execute a function with an active context
     *
     * @param context context to be active during function execution
     * @param fn function to execute in a context
     * @param thisArg optional receiver to be used for calling fn
     * @param args optional arguments forwarded to fn
     */
    ContextAPI.prototype.with = function (context, fn, thisArg) {
        var _a;
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            args[_i - 3] = arguments[_i];
        }
        return (_a = this._getContextManager()).with.apply(_a, __spreadArray([context, fn, thisArg], __read(args), false));
    };
    /**
     * Bind a context to a target function or event emitter
     *
     * @param context context to bind to the event emitter or function. Defaults to the currently active context
     * @param target function or event emitter to bind
     */
    ContextAPI.prototype.bind = function (context, target) {
        return this._getContextManager().bind(context, target);
    };
    ContextAPI.prototype._getContextManager = function () {
        return getGlobal(API_NAME$3) || NOOP_CONTEXT_MANAGER;
    };
    /** Disable and remove the global context manager */
    ContextAPI.prototype.disable = function () {
        this._getContextManager().disable();
        unregisterGlobal(API_NAME$3, DiagAPI.instance());
    };
    return ContextAPI;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var TraceFlags;
(function (TraceFlags) {
    /** Represents no flag set. */
    TraceFlags[TraceFlags["NONE"] = 0] = "NONE";
    /** Bit to represent whether trace is sampled in trace flags. */
    TraceFlags[TraceFlags["SAMPLED"] = 1] = "SAMPLED";
})(TraceFlags || (TraceFlags = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var INVALID_SPANID = '0000000000000000';
var INVALID_TRACEID = '00000000000000000000000000000000';
var INVALID_SPAN_CONTEXT = {
    traceId: INVALID_TRACEID,
    spanId: INVALID_SPANID,
    traceFlags: TraceFlags.NONE,
};

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The NonRecordingSpan is the default {@link Span} that is used when no Span
 * implementation is available. All operations are no-op including context
 * propagation.
 */
var NonRecordingSpan = /** @class */ (function () {
    function NonRecordingSpan(_spanContext) {
        if (_spanContext === undefined) { _spanContext = INVALID_SPAN_CONTEXT; }
        this._spanContext = _spanContext;
    }
    // Returns a SpanContext.
    NonRecordingSpan.prototype.spanContext = function () {
        return this._spanContext;
    };
    // By default does nothing
    NonRecordingSpan.prototype.setAttribute = function (_key, _value) {
        return this;
    };
    // By default does nothing
    NonRecordingSpan.prototype.setAttributes = function (_attributes) {
        return this;
    };
    // By default does nothing
    NonRecordingSpan.prototype.addEvent = function (_name, _attributes) {
        return this;
    };
    NonRecordingSpan.prototype.addLink = function (_link) {
        return this;
    };
    NonRecordingSpan.prototype.addLinks = function (_links) {
        return this;
    };
    // By default does nothing
    NonRecordingSpan.prototype.setStatus = function (_status) {
        return this;
    };
    // By default does nothing
    NonRecordingSpan.prototype.updateName = function (_name) {
        return this;
    };
    // By default does nothing
    NonRecordingSpan.prototype.end = function (_endTime) { };
    // isRecording always returns false for NonRecordingSpan.
    NonRecordingSpan.prototype.isRecording = function () {
        return false;
    };
    // By default does nothing
    NonRecordingSpan.prototype.recordException = function (_exception, _time) { };
    return NonRecordingSpan;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * span key
 */
var SPAN_KEY = createContextKey('OpenTelemetry Context Key SPAN');
/**
 * Return the span if one exists
 *
 * @param context context to get span from
 */
function getSpan(context) {
    return context.getValue(SPAN_KEY) || undefined;
}
/**
 * Gets the span from the current context, if one exists.
 */
function getActiveSpan() {
    return getSpan(ContextAPI.getInstance().active());
}
/**
 * Set the span on a context
 *
 * @param context context to use as parent
 * @param span span to set active
 */
function setSpan(context, span) {
    return context.setValue(SPAN_KEY, span);
}
/**
 * Remove current span stored in the context
 *
 * @param context context to delete span from
 */
function deleteSpan(context) {
    return context.deleteValue(SPAN_KEY);
}
/**
 * Wrap span context in a NoopSpan and set as span in a new
 * context
 *
 * @param context context to set active span on
 * @param spanContext span context to be wrapped
 */
function setSpanContext(context, spanContext) {
    return setSpan(context, new NonRecordingSpan(spanContext));
}
/**
 * Get the span context of the span if it exists.
 *
 * @param context context to get values from
 */
function getSpanContext(context) {
    var _a;
    return (_a = getSpan(context)) === null || _a === undefined ? undefined : _a.spanContext();
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
function isValidTraceId(traceId) {
    return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
}
function isValidSpanId(spanId) {
    return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
}
/**
 * Returns true if this {@link SpanContext} is valid.
 * @return true if this {@link SpanContext} is valid.
 */
function isSpanContextValid(spanContext) {
    return (isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId));
}
/**
 * Wrap the given {@link SpanContext} in a new non-recording {@link Span}
 *
 * @param spanContext span context to be wrapped
 * @returns a new non-recording {@link Span} with the provided context
 */
function wrapSpanContext(spanContext) {
    return new NonRecordingSpan(spanContext);
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var contextApi = ContextAPI.getInstance();
/**
 * No-op implementations of {@link Tracer}.
 */
var NoopTracer = /** @class */ (function () {
    function NoopTracer() {
    }
    // startSpan starts a noop span.
    NoopTracer.prototype.startSpan = function (name, options, context) {
        if (context === undefined) { context = contextApi.active(); }
        var root = Boolean(options === null || options === undefined ? undefined : options.root);
        if (root) {
            return new NonRecordingSpan();
        }
        var parentFromContext = context && getSpanContext(context);
        if (isSpanContext(parentFromContext) &&
            isSpanContextValid(parentFromContext)) {
            return new NonRecordingSpan(parentFromContext);
        }
        else {
            return new NonRecordingSpan();
        }
    };
    NoopTracer.prototype.startActiveSpan = function (name, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
            return;
        }
        else if (arguments.length === 2) {
            fn = arg2;
        }
        else if (arguments.length === 3) {
            opts = arg2;
            fn = arg3;
        }
        else {
            opts = arg2;
            ctx = arg3;
            fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== undefined ? ctx : contextApi.active();
        var span = this.startSpan(name, opts, parentContext);
        var contextWithSpanSet = setSpan(parentContext, span);
        return contextApi.with(contextWithSpanSet, fn, undefined, span);
    };
    return NoopTracer;
}());
function isSpanContext(spanContext) {
    return (typeof spanContext === 'object' &&
        typeof spanContext['spanId'] === 'string' &&
        typeof spanContext['traceId'] === 'string' &&
        typeof spanContext['traceFlags'] === 'number');
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var NOOP_TRACER = new NoopTracer();
/**
 * Proxy tracer provided by the proxy tracer provider
 */
var ProxyTracer = /** @class */ (function () {
    function ProxyTracer(_provider, name, version, options) {
        this._provider = _provider;
        this.name = name;
        this.version = version;
        this.options = options;
    }
    ProxyTracer.prototype.startSpan = function (name, options, context) {
        return this._getTracer().startSpan(name, options, context);
    };
    ProxyTracer.prototype.startActiveSpan = function (_name, _options, _context, _fn) {
        var tracer = this._getTracer();
        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    };
    /**
     * Try to get a tracer from the proxy tracer provider.
     * If the proxy tracer provider has no delegate, return a noop tracer.
     */
    ProxyTracer.prototype._getTracer = function () {
        if (this._delegate) {
            return this._delegate;
        }
        var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer) {
            return NOOP_TRACER;
        }
        this._delegate = tracer;
        return this._delegate;
    };
    return ProxyTracer;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An implementation of the {@link TracerProvider} which returns an impotent
 * Tracer for all calls to `getTracer`.
 *
 * All operations are no-op.
 */
var NoopTracerProvider = /** @class */ (function () {
    function NoopTracerProvider() {
    }
    NoopTracerProvider.prototype.getTracer = function (_name, _version, _options) {
        return new NoopTracer();
    };
    return NoopTracerProvider;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var NOOP_TRACER_PROVIDER = new NoopTracerProvider();
/**
 * Tracer provider which provides {@link ProxyTracer}s.
 *
 * Before a delegate is set, tracers provided are NoOp.
 *   When a delegate is set, traces are provided from the delegate.
 *   When a delegate is set after tracers have already been provided,
 *   all tracers already provided will use the provided delegate implementation.
 */
var ProxyTracerProvider = /** @class */ (function () {
    function ProxyTracerProvider() {
    }
    /**
     * Get a {@link ProxyTracer}
     */
    ProxyTracerProvider.prototype.getTracer = function (name, version, options) {
        var _a;
        return ((_a = this.getDelegateTracer(name, version, options)) !== null && _a !== undefined ? _a : new ProxyTracer(this, name, version, options));
    };
    ProxyTracerProvider.prototype.getDelegate = function () {
        var _a;
        return (_a = this._delegate) !== null && _a !== undefined ? _a : NOOP_TRACER_PROVIDER;
    };
    /**
     * Set the delegate tracer provider
     */
    ProxyTracerProvider.prototype.setDelegate = function (delegate) {
        this._delegate = delegate;
    };
    ProxyTracerProvider.prototype.getDelegateTracer = function (name, version, options) {
        var _a;
        return (_a = this._delegate) === null || _a === undefined ? undefined : _a.getTracer(name, version, options);
    };
    return ProxyTracerProvider;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @deprecated use the one declared in @opentelemetry/sdk-trace-base instead.
 * A sampling decision that determines how a {@link Span} will be recorded
 * and collected.
 */
var SamplingDecision;
(function (SamplingDecision) {
    /**
     * `Span.isRecording() === false`, span will not be recorded and all events
     * and attributes will be dropped.
     */
    SamplingDecision[SamplingDecision["NOT_RECORD"] = 0] = "NOT_RECORD";
    /**
     * `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}
     * MUST NOT be set.
     */
    SamplingDecision[SamplingDecision["RECORD"] = 1] = "RECORD";
    /**
     * `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}
     * MUST be set.
     */
    SamplingDecision[SamplingDecision["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
})(SamplingDecision || (SamplingDecision = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var SpanKind;
(function (SpanKind) {
    /** Default value. Indicates that the span is used internally. */
    SpanKind[SpanKind["INTERNAL"] = 0] = "INTERNAL";
    /**
     * Indicates that the span covers server-side handling of an RPC or other
     * remote request.
     */
    SpanKind[SpanKind["SERVER"] = 1] = "SERVER";
    /**
     * Indicates that the span covers the client-side wrapper around an RPC or
     * other remote request.
     */
    SpanKind[SpanKind["CLIENT"] = 2] = "CLIENT";
    /**
     * Indicates that the span describes producer sending a message to a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */
    SpanKind[SpanKind["PRODUCER"] = 3] = "PRODUCER";
    /**
     * Indicates that the span describes consumer receiving a message from a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */
    SpanKind[SpanKind["CONSUMER"] = 4] = "CONSUMER";
})(SpanKind || (SpanKind = {}));

/**
 * An enumeration of status codes.
 */
var SpanStatusCode;
(function (SpanStatusCode) {
    /**
     * The default status.
     */
    SpanStatusCode[SpanStatusCode["UNSET"] = 0] = "UNSET";
    /**
     * The operation has been validated by an Application developer or
     * Operator to have completed successfully.
     */
    SpanStatusCode[SpanStatusCode["OK"] = 1] = "OK";
    /**
     * The operation contains an error.
     */
    SpanStatusCode[SpanStatusCode["ERROR"] = 2] = "ERROR";
})(SpanStatusCode || (SpanStatusCode = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Split module-level variable definition into separate files to allow
// tree-shaking on each api instance.
/** Entrypoint for context API */
ContextAPI.getInstance();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Split module-level variable definition into separate files to allow
// tree-shaking on each api instance.
/**
 * Entrypoint for Diag API.
 * Defines Diagnostic handler used for internal diagnostic logging operations.
 * The default provides a Noop DiagLogger implementation which may be changed via the
 * diag.setLogger(logger: DiagLogger) function.
 */
DiagAPI.instance();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An implementation of the {@link MeterProvider} which returns an impotent Meter
 * for all calls to `getMeter`
 */
var NoopMeterProvider = /** @class */ (function () {
    function NoopMeterProvider() {
    }
    NoopMeterProvider.prototype.getMeter = function (_name, _version, _options) {
        return NOOP_METER;
    };
    return NoopMeterProvider;
}());
var NOOP_METER_PROVIDER = new NoopMeterProvider();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var API_NAME$2 = 'metrics';
/**
 * Singleton object which represents the entry point to the OpenTelemetry Metrics API
 */
var MetricsAPI = /** @class */ (function () {
    /** Empty private constructor prevents end users from constructing a new instance of the API */
    function MetricsAPI() {
    }
    /** Get the singleton instance of the Metrics API */
    MetricsAPI.getInstance = function () {
        if (!this._instance) {
            this._instance = new MetricsAPI();
        }
        return this._instance;
    };
    /**
     * Set the current global meter provider.
     * Returns true if the meter provider was successfully registered, else false.
     */
    MetricsAPI.prototype.setGlobalMeterProvider = function (provider) {
        return registerGlobal(API_NAME$2, provider, DiagAPI.instance());
    };
    /**
     * Returns the global meter provider.
     */
    MetricsAPI.prototype.getMeterProvider = function () {
        return getGlobal(API_NAME$2) || NOOP_METER_PROVIDER;
    };
    /**
     * Returns a meter from the global meter provider.
     */
    MetricsAPI.prototype.getMeter = function (name, version, options) {
        return this.getMeterProvider().getMeter(name, version, options);
    };
    /** Remove the global meter provider */
    MetricsAPI.prototype.disable = function () {
        unregisterGlobal(API_NAME$2, DiagAPI.instance());
    };
    return MetricsAPI;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Split module-level variable definition into separate files to allow
// tree-shaking on each api instance.
/** Entrypoint for metrics API */
MetricsAPI.getInstance();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * No-op implementations of {@link TextMapPropagator}.
 */
var NoopTextMapPropagator = /** @class */ (function () {
    function NoopTextMapPropagator() {
    }
    /** Noop inject function does nothing */
    NoopTextMapPropagator.prototype.inject = function (_context, _carrier) { };
    /** Noop extract function does nothing and returns the input context */
    NoopTextMapPropagator.prototype.extract = function (context, _carrier) {
        return context;
    };
    NoopTextMapPropagator.prototype.fields = function () {
        return [];
    };
    return NoopTextMapPropagator;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Baggage key
 */
var BAGGAGE_KEY = createContextKey('OpenTelemetry Baggage Key');
/**
 * Retrieve the current baggage from the given context
 *
 * @param {Context} Context that manage all context values
 * @returns {Baggage} Extracted baggage from the context
 */
function getBaggage(context) {
    return context.getValue(BAGGAGE_KEY) || undefined;
}
/**
 * Retrieve the current baggage from the active/current context
 *
 * @returns {Baggage} Extracted baggage from the context
 */
function getActiveBaggage() {
    return getBaggage(ContextAPI.getInstance().active());
}
/**
 * Store a baggage in the given context
 *
 * @param {Context} Context that manage all context values
 * @param {Baggage} baggage that will be set in the actual context
 */
function setBaggage(context, baggage) {
    return context.setValue(BAGGAGE_KEY, baggage);
}
/**
 * Delete the baggage stored in the given context
 *
 * @param {Context} Context that manage all context values
 */
function deleteBaggage(context) {
    return context.deleteValue(BAGGAGE_KEY);
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var API_NAME$1 = 'propagation';
var NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();
/**
 * Singleton object which represents the entry point to the OpenTelemetry Propagation API
 */
var PropagationAPI = /** @class */ (function () {
    /** Empty private constructor prevents end users from constructing a new instance of the API */
    function PropagationAPI() {
        this.createBaggage = createBaggage;
        this.getBaggage = getBaggage;
        this.getActiveBaggage = getActiveBaggage;
        this.setBaggage = setBaggage;
        this.deleteBaggage = deleteBaggage;
    }
    /** Get the singleton instance of the Propagator API */
    PropagationAPI.getInstance = function () {
        if (!this._instance) {
            this._instance = new PropagationAPI();
        }
        return this._instance;
    };
    /**
     * Set the current propagator.
     *
     * @returns true if the propagator was successfully registered, else false
     */
    PropagationAPI.prototype.setGlobalPropagator = function (propagator) {
        return registerGlobal(API_NAME$1, propagator, DiagAPI.instance());
    };
    /**
     * Inject context into a carrier to be propagated inter-process
     *
     * @param context Context carrying tracing data to inject
     * @param carrier carrier to inject context into
     * @param setter Function used to set values on the carrier
     */
    PropagationAPI.prototype.inject = function (context, carrier, setter) {
        if (setter === undefined) { setter = defaultTextMapSetter; }
        return this._getGlobalPropagator().inject(context, carrier, setter);
    };
    /**
     * Extract context from a carrier
     *
     * @param context Context which the newly created context will inherit from
     * @param carrier Carrier to extract context from
     * @param getter Function used to extract keys from a carrier
     */
    PropagationAPI.prototype.extract = function (context, carrier, getter) {
        if (getter === undefined) { getter = defaultTextMapGetter; }
        return this._getGlobalPropagator().extract(context, carrier, getter);
    };
    /**
     * Return a list of all fields which may be used by the propagator.
     */
    PropagationAPI.prototype.fields = function () {
        return this._getGlobalPropagator().fields();
    };
    /** Remove the global propagator */
    PropagationAPI.prototype.disable = function () {
        unregisterGlobal(API_NAME$1, DiagAPI.instance());
    };
    PropagationAPI.prototype._getGlobalPropagator = function () {
        return getGlobal(API_NAME$1) || NOOP_TEXT_MAP_PROPAGATOR;
    };
    return PropagationAPI;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Split module-level variable definition into separate files to allow
// tree-shaking on each api instance.
/** Entrypoint for propagation API */
PropagationAPI.getInstance();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var API_NAME = 'trace';
/**
 * Singleton object which represents the entry point to the OpenTelemetry Tracing API
 */
var TraceAPI = /** @class */ (function () {
    /** Empty private constructor prevents end users from constructing a new instance of the API */
    function TraceAPI() {
        this._proxyTracerProvider = new ProxyTracerProvider();
        this.wrapSpanContext = wrapSpanContext;
        this.isSpanContextValid = isSpanContextValid;
        this.deleteSpan = deleteSpan;
        this.getSpan = getSpan;
        this.getActiveSpan = getActiveSpan;
        this.getSpanContext = getSpanContext;
        this.setSpan = setSpan;
        this.setSpanContext = setSpanContext;
    }
    /** Get the singleton instance of the Trace API */
    TraceAPI.getInstance = function () {
        if (!this._instance) {
            this._instance = new TraceAPI();
        }
        return this._instance;
    };
    /**
     * Set the current global tracer.
     *
     * @returns true if the tracer provider was successfully registered, else false
     */
    TraceAPI.prototype.setGlobalTracerProvider = function (provider) {
        var success = registerGlobal(API_NAME, this._proxyTracerProvider, DiagAPI.instance());
        if (success) {
            this._proxyTracerProvider.setDelegate(provider);
        }
        return success;
    };
    /**
     * Returns the global tracer provider.
     */
    TraceAPI.prototype.getTracerProvider = function () {
        return getGlobal(API_NAME) || this._proxyTracerProvider;
    };
    /**
     * Returns a tracer from the global tracer provider.
     */
    TraceAPI.prototype.getTracer = function (name, version) {
        return this.getTracerProvider().getTracer(name, version);
    };
    /** Remove the global tracer provider */
    TraceAPI.prototype.disable = function () {
        unregisterGlobal(API_NAME, DiagAPI.instance());
        this._proxyTracerProvider = new ProxyTracerProvider();
    };
    return TraceAPI;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Split module-level variable definition into separate files to allow
// tree-shaking on each api instance.
/** Entrypoint for trace API */
var trace = TraceAPI.getInstance();

function compose(middleware) {
  return (context, next) => {
    let index = -1;
    return dispatch(0);
    async function dispatch(i) {
      if (i <= index) {
        throw new Error("next() called multiple times");
      }
      index = i;
      let handler;
      if (i >= middleware.length) {
        if (next) {
          await next();
        }
        return;
      }
      if (middleware[i]) {
        handler = middleware[i];
      } else {
        handler = i === middleware.length ? next : undefined;
      }
      if (!handler) {
        throw new Error("Handler not found");
      }
      await handler(context, () => dispatch(i + 1));
    }
  };
}

const tracer = trace.getTracer("@apibara/indexer");

function defineIndexer(streamConfig) {
  return (config) => ({
    streamConfig,
    ...config
  });
}
function createIndexer$1({
  streamConfig,
  ...options
}) {
  const indexer = {
    options,
    streamConfig,
    hooks: createHooks()
  };
  if (indexer.options.debug) {
    createDebugger(indexer.hooks, { tag: "indexer" });
  }
  indexer.hooks.addHooks(indexer.options.hooks ?? {});
  for (const plugin of indexer.options.plugins ?? []) {
    plugin(indexer);
  }
  return indexer;
}
async function runWithReconnect(client, indexer, options = {}) {
  let retryCount = 0;
  const maxRetries = options.maxRetries ?? 10;
  const retryDelay = options.retryDelay ?? 1e3;
  const maxWait = options.maxWait ?? 3e4;
  const runOptions = {
    onConnect() {
      retryCount = 0;
    }
  };
  while (true) {
    try {
      await run(client, indexer, runOptions);
      return;
    } catch (error) {
      retryCount++;
      if (error instanceof libExports.ClientError) {
        if (error.code === libExports.Status.INTERNAL) {
          if (retryCount < maxRetries) {
            consola.error(
              "Internal server error, reconnecting...",
              error.message
            );
            const delay = Math.random() * (retryDelay * 0.2) + retryDelay;
            await new Promise(
              (resolve) => setTimeout(resolve, Math.min(retryCount * delay, maxWait))
            );
            continue;
          }
        }
      }
      throw error;
    }
  }
}
async function run(client, indexer, runOptions = {}) {
  await indexerAsyncContext.callAsync({}, async () => {
    const context = useIndexerContext();
    const middleware = await registerMiddleware(indexer);
    await indexer.hooks.callHook("run:before");
    const isFactoryMode = indexer.options.factory !== undefined;
    const request = indexer.streamConfig.Request.make({
      filter: isFactoryMode ? [indexer.options.filter, {}] : [indexer.options.filter],
      finality: indexer.options.finality,
      startingCursor: indexer.options.startingCursor
    });
    const options = {};
    await indexer.hooks.callHook("connect:before", { request, options });
    let mainFilter;
    if (isFactoryMode) {
      mainFilter = request.filter[1];
    }
    let stream = client.streamData(request, options)[Symbol.asyncIterator]();
    await indexer.hooks.callHook("connect:after", { request });
    let onConnectCalled = false;
    while (true) {
      const { value: message, done } = await stream.next();
      if (done) {
        break;
      }
      if (!onConnectCalled) {
        onConnectCalled = true;
        if (runOptions.onConnect) {
          await runOptions.onConnect();
        }
      }
      await indexer.hooks.callHook("message", { message });
      switch (message._tag) {
        case "data": {
          await tracer.startActiveSpan("message data", async (span) => {
            const blocks = message.data.data;
            const { cursor, endCursor, finality } = message.data;
            context.cursor = cursor;
            context.endCursor = endCursor;
            context.finality = finality;
            await middleware(context, async () => {
              let block;
              if (isFactoryMode) {
                assert(indexer.options.factory !== undefined);
                const [factoryBlock, mainBlock] = blocks;
                block = mainBlock;
                if (factoryBlock !== null) {
                  const { filter } = await indexer.options.factory({
                    block: factoryBlock,
                    context
                  });
                  if (filter) {
                    mainFilter = indexer.streamConfig.mergeFilter(
                      mainFilter,
                      filter
                    );
                    const request2 = indexer.streamConfig.Request.make({
                      filter: [indexer.options.filter, mainFilter],
                      finality: indexer.options.finality,
                      startingCursor: cursor
                    });
                    await indexer.hooks.callHook("connect:factory", {
                      request: request2,
                      endCursor
                    });
                    stream = client.streamData(request2, options)[Symbol.asyncIterator]();
                    const { value: message2 } = await stream.next();
                    assert(message2._tag === "data");
                    const [_factoryBlock, _block] = message2.data.data;
                    block = _block;
                  }
                }
              } else {
                block = blocks[0];
              }
              if (block) {
                await tracer.startActiveSpan("handler", async (span2) => {
                  await indexer.options.transform({
                    block,
                    cursor,
                    endCursor,
                    finality,
                    context
                  });
                  span2.end();
                });
              }
            });
            span.end();
          });
          context.cursor = undefined;
          context.endCursor = undefined;
          context.finality = undefined;
          break;
        }
        case "invalidate": {
          await tracer.startActiveSpan("message invalidate", async (span) => {
            await indexer.hooks.callHook("message:invalidate", { message });
            span.end();
          });
          break;
        }
        case "finalize": {
          await tracer.startActiveSpan("message finalize", async (span) => {
            await indexer.hooks.callHook("message:finalize", { message });
            span.end();
          });
          break;
        }
        case "heartbeat": {
          await tracer.startActiveSpan("message heartbeat", async (span) => {
            await indexer.hooks.callHook("message:heartbeat", { message });
            span.end();
          });
          break;
        }
        case "systemMessage": {
          await tracer.startActiveSpan(
            "message systemMessage",
            async (span) => {
              switch (message.systemMessage.output?._tag) {
                case "stderr": {
                  consola.warn(message.systemMessage.output.stderr);
                  break;
                }
                case "stdout": {
                  consola.info(message.systemMessage.output.stdout);
                  break;
                }
              }
              await indexer.hooks.callHook("message:systemMessage", {
                message
              });
              span.end();
            }
          );
          break;
        }
        default: {
          consola.warn("unexpected message", message);
          throw new Error("not implemented");
        }
      }
      await indexer.hooks.callHook("run:after");
    }
  });
}
async function registerMiddleware(indexer) {
  const middleware = [];
  const use = (fn) => {
    middleware.push(fn);
  };
  await indexer.hooks.callHook("handler:middleware", { use });
  const composed = compose(middleware);
  return async function _composedIndexerMiddleware(context, next) {
    await composed(context, next);
  };
}

const {
  env = {},
  argv = [],
  platform = ""
} = typeof process === "undefined" ? {} : process;
const isDisabled = "NO_COLOR" in env || argv.includes("--no-color");
const isForced = "FORCE_COLOR" in env || argv.includes("--color");
const isWindows = platform === "win32";
const isDumbTerminal = env.TERM === "dumb";
const isCompatibleTerminal = tty && tty.isatty && tty.isatty(1) && env.TERM && !isDumbTerminal;
const isCI = "CI" in env && ("GITHUB_ACTIONS" in env || "GITLAB_CI" in env || "CIRCLECI" in env);
const isColorSupported = !isDisabled && (isForced || isWindows && !isDumbTerminal || isCompatibleTerminal || isCI);
function replaceClose(index, string, close, replace, head = string.slice(0, Math.max(0, index)) + replace, tail = string.slice(Math.max(0, index + close.length)), next = tail.indexOf(close)) {
  return head + (next < 0 ? tail : replaceClose(next, tail, close, replace));
}
function clearBleed(index, string, open, close, replace) {
  return index < 0 ? open + string + close : open + replaceClose(index, string, close, replace) + close;
}
function filterEmpty(open, close, replace = open, at = open.length + 1) {
  return (string) => string || !(string === "" || string === undefined) ? clearBleed(
    ("" + string).indexOf(close, at),
    string,
    open,
    close,
    replace
  ) : "";
}
function init(open, close, replace) {
  return filterEmpty(`\x1B[${open}m`, `\x1B[${close}m`, replace);
}
const colorDefs = {
  reset: init(0, 0),
  bold: init(1, 22, "\x1B[22m\x1B[1m"),
  dim: init(2, 22, "\x1B[22m\x1B[2m"),
  italic: init(3, 23),
  underline: init(4, 24),
  inverse: init(7, 27),
  hidden: init(8, 28),
  strikethrough: init(9, 29),
  black: init(30, 39),
  red: init(31, 39),
  green: init(32, 39),
  yellow: init(33, 39),
  blue: init(34, 39),
  magenta: init(35, 39),
  cyan: init(36, 39),
  white: init(37, 39),
  gray: init(90, 39),
  bgBlack: init(40, 49),
  bgRed: init(41, 49),
  bgGreen: init(42, 49),
  bgYellow: init(43, 49),
  bgBlue: init(44, 49),
  bgMagenta: init(45, 49),
  bgCyan: init(46, 49),
  bgWhite: init(47, 49),
  blackBright: init(90, 39),
  redBright: init(91, 39),
  greenBright: init(92, 39),
  yellowBright: init(93, 39),
  blueBright: init(94, 39),
  magentaBright: init(95, 39),
  cyanBright: init(96, 39),
  whiteBright: init(97, 39),
  bgBlackBright: init(100, 49),
  bgRedBright: init(101, 49),
  bgGreenBright: init(102, 49),
  bgYellowBright: init(103, 49),
  bgBlueBright: init(104, 49),
  bgMagentaBright: init(105, 49),
  bgCyanBright: init(106, 49),
  bgWhiteBright: init(107, 49)
};
function createColors(useColor = isColorSupported) {
  return useColor ? colorDefs : Object.fromEntries(Object.keys(colorDefs).map((key) => [key, String]));
}
const colors = createColors();
function getColor(color, fallback = "reset") {
  return colors[color] || colors[fallback];
}

function toArray(val) {
  if (Array.isArray(val)) {
    return val;
  }
  return val === undefined ? [] : [val];
}
function formatLineColumns(lines, linePrefix = "") {
  const maxLengh = [];
  for (const line of lines) {
    for (const [i, element] of line.entries()) {
      maxLengh[i] = Math.max(maxLengh[i] || 0, element.length);
    }
  }
  return lines.map(
    (l) => l.map(
      (c, i) => linePrefix + c[i === 0 ? "padStart" : "padEnd"](maxLengh[i])
    ).join("  ")
  ).join("\n");
}
function resolveValue(input) {
  return typeof input === "function" ? input() : input;
}
class CLIError extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
    this.name = "CLIError";
  }
}

const NUMBER_CHAR_RE = /\d/;
const STR_SPLITTERS = ["-", "_", "/", "."];
function isUppercase(char = "") {
  if (NUMBER_CHAR_RE.test(char)) {
    return undefined;
  }
  return char !== char.toLowerCase();
}
function splitByCase(str, separators) {
  const splitters = STR_SPLITTERS;
  const parts = [];
  if (!str || typeof str !== "string") {
    return parts;
  }
  let buff = "";
  let previousUpper;
  let previousSplitter;
  for (const char of str) {
    const isSplitter = splitters.includes(char);
    if (isSplitter === true) {
      parts.push(buff);
      buff = "";
      previousUpper = undefined;
      continue;
    }
    const isUpper = isUppercase(char);
    if (previousSplitter === false) {
      if (previousUpper === false && isUpper === true) {
        parts.push(buff);
        buff = char;
        previousUpper = isUpper;
        continue;
      }
      if (previousUpper === true && isUpper === false && buff.length > 1) {
        const lastChar = buff.at(-1);
        parts.push(buff.slice(0, Math.max(0, buff.length - 1)));
        buff = lastChar + char;
        previousUpper = isUpper;
        continue;
      }
    }
    buff += char;
    previousUpper = isUpper;
    previousSplitter = isSplitter;
  }
  parts.push(buff);
  return parts;
}
function upperFirst(str) {
  return str ? str[0].toUpperCase() + str.slice(1) : "";
}
function lowerFirst(str) {
  return str ? str[0].toLowerCase() + str.slice(1) : "";
}
function pascalCase(str, opts) {
  return str ? (Array.isArray(str) ? str : splitByCase(str)).map((p) => upperFirst(p)).join("") : "";
}
function camelCase(str, opts) {
  return lowerFirst(pascalCase(str || ""));
}
function kebabCase(str, joiner) {
  return str ? (Array.isArray(str) ? str : splitByCase(str)).map((p) => p.toLowerCase()).join("-") : "";
}

function toArr(any) {
  return any == undefined ? [] : Array.isArray(any) ? any : [any];
}
function toVal(out, key, val, opts) {
  let x;
  const old = out[key];
  const nxt = ~opts.string.indexOf(key) ? val == undefined || val === true ? "" : String(val) : typeof val === "boolean" ? val : ~opts.boolean.indexOf(key) ? val === "false" ? false : val === "true" || (out._.push((x = +val, x * 0 === 0) ? x : val), !!val) : (x = +val, x * 0 === 0) ? x : val;
  out[key] = old == undefined ? nxt : Array.isArray(old) ? old.concat(nxt) : [old, nxt];
}
function parseRawArgs(args = [], opts = {}) {
  let k;
  let arr;
  let arg;
  let name;
  let val;
  const out = { _: [] };
  let i = 0;
  let j = 0;
  let idx = 0;
  const len = args.length;
  const alibi = opts.alias !== undefined;
  const strict = opts.unknown !== undefined;
  const defaults = opts.default !== undefined;
  opts.alias = opts.alias || {};
  opts.string = toArr(opts.string);
  opts.boolean = toArr(opts.boolean);
  if (alibi) {
    for (k in opts.alias) {
      arr = opts.alias[k] = toArr(opts.alias[k]);
      for (i = 0; i < arr.length; i++) {
        (opts.alias[arr[i]] = arr.concat(k)).splice(i, 1);
      }
    }
  }
  for (i = opts.boolean.length; i-- > 0; ) {
    arr = opts.alias[opts.boolean[i]] || [];
    for (j = arr.length; j-- > 0; ) {
      opts.boolean.push(arr[j]);
    }
  }
  for (i = opts.string.length; i-- > 0; ) {
    arr = opts.alias[opts.string[i]] || [];
    for (j = arr.length; j-- > 0; ) {
      opts.string.push(arr[j]);
    }
  }
  if (defaults) {
    for (k in opts.default) {
      name = typeof opts.default[k];
      arr = opts.alias[k] = opts.alias[k] || [];
      if (opts[name] !== undefined) {
        opts[name].push(k);
        for (i = 0; i < arr.length; i++) {
          opts[name].push(arr[i]);
        }
      }
    }
  }
  const keys = strict ? Object.keys(opts.alias) : [];
  for (i = 0; i < len; i++) {
    arg = args[i];
    if (arg === "--") {
      out._ = out._.concat(args.slice(++i));
      break;
    }
    for (j = 0; j < arg.length; j++) {
      if (arg.charCodeAt(j) !== 45) {
        break;
      }
    }
    if (j === 0) {
      out._.push(arg);
    } else if (arg.substring(j, j + 3) === "no-") {
      name = arg.slice(Math.max(0, j + 3));
      if (strict && !~keys.indexOf(name)) {
        return opts.unknown(arg);
      }
      out[name] = false;
    } else {
      for (idx = j + 1; idx < arg.length; idx++) {
        if (arg.charCodeAt(idx) === 61) {
          break;
        }
      }
      name = arg.substring(j, idx);
      val = arg.slice(Math.max(0, ++idx)) || i + 1 === len || ("" + args[i + 1]).charCodeAt(0) === 45 || args[++i];
      arr = j === 2 ? [name] : name;
      for (idx = 0; idx < arr.length; idx++) {
        name = arr[idx];
        if (strict && !~keys.indexOf(name)) {
          return opts.unknown("-".repeat(j) + name);
        }
        toVal(out, name, idx + 1 < arr.length || val, opts);
      }
    }
  }
  if (defaults) {
    for (k in opts.default) {
      if (out[k] === undefined) {
        out[k] = opts.default[k];
      }
    }
  }
  if (alibi) {
    for (k in out) {
      arr = opts.alias[k] || [];
      while (arr.length > 0) {
        out[arr.shift()] = out[k];
      }
    }
  }
  return out;
}

function parseArgs(rawArgs, argsDef) {
  const parseOptions = {
    boolean: [],
    string: [],
    mixed: [],
    alias: {},
    default: {}
  };
  const args = resolveArgs(argsDef);
  for (const arg of args) {
    if (arg.type === "positional") {
      continue;
    }
    if (arg.type === "string") {
      parseOptions.string.push(arg.name);
    } else if (arg.type === "boolean") {
      parseOptions.boolean.push(arg.name);
    }
    if (arg.default !== undefined) {
      parseOptions.default[arg.name] = arg.default;
    }
    if (arg.alias) {
      parseOptions.alias[arg.name] = arg.alias;
    }
  }
  const parsed = parseRawArgs(rawArgs, parseOptions);
  const [...positionalArguments] = parsed._;
  const parsedArgsProxy = new Proxy(parsed, {
    get(target, prop) {
      return target[prop] ?? target[camelCase(prop)] ?? target[kebabCase(prop)];
    }
  });
  for (const [, arg] of args.entries()) {
    if (arg.type === "positional") {
      const nextPositionalArgument = positionalArguments.shift();
      if (nextPositionalArgument !== undefined) {
        parsedArgsProxy[arg.name] = nextPositionalArgument;
      } else if (arg.default === undefined && arg.required !== false) {
        throw new CLIError(
          `Missing required positional argument: ${arg.name.toUpperCase()}`,
          "EARG"
        );
      } else {
        parsedArgsProxy[arg.name] = arg.default;
      }
    } else if (arg.required && parsedArgsProxy[arg.name] === undefined) {
      throw new CLIError(`Missing required argument: --${arg.name}`, "EARG");
    }
  }
  return parsedArgsProxy;
}
function resolveArgs(argsDef) {
  const args = [];
  for (const [name, argDef] of Object.entries(argsDef || {})) {
    args.push({
      ...argDef,
      name,
      alias: toArray(argDef.alias)
    });
  }
  return args;
}

function defineCommand(def) {
  return def;
}
async function runCommand(cmd, opts) {
  const cmdArgs = await resolveValue(cmd.args || {});
  const parsedArgs = parseArgs(opts.rawArgs, cmdArgs);
  const context = {
    rawArgs: opts.rawArgs,
    args: parsedArgs,
    data: opts.data,
    cmd
  };
  if (typeof cmd.setup === "function") {
    await cmd.setup(context);
  }
  let result;
  try {
    const subCommands = await resolveValue(cmd.subCommands);
    if (subCommands && Object.keys(subCommands).length > 0) {
      const subCommandArgIndex = opts.rawArgs.findIndex(
        (arg) => !arg.startsWith("-")
      );
      const subCommandName = opts.rawArgs[subCommandArgIndex];
      if (subCommandName) {
        if (!subCommands[subCommandName]) {
          throw new CLIError(
            `Unknown command \`${subCommandName}\``,
            "E_UNKNOWN_COMMAND"
          );
        }
        const subCommand = await resolveValue(subCommands[subCommandName]);
        if (subCommand) {
          await runCommand(subCommand, {
            rawArgs: opts.rawArgs.slice(subCommandArgIndex + 1)
          });
        }
      } else if (!cmd.run) {
        throw new CLIError(`No command specified.`, "E_NO_COMMAND");
      }
    }
    if (typeof cmd.run === "function") {
      result = await cmd.run(context);
    }
  } finally {
    if (typeof cmd.cleanup === "function") {
      await cmd.cleanup(context);
    }
  }
  return { result };
}
async function resolveSubCommand(cmd, rawArgs, parent) {
  const subCommands = await resolveValue(cmd.subCommands);
  if (subCommands && Object.keys(subCommands).length > 0) {
    const subCommandArgIndex = rawArgs.findIndex((arg) => !arg.startsWith("-"));
    const subCommandName = rawArgs[subCommandArgIndex];
    const subCommand = await resolveValue(subCommands[subCommandName]);
    if (subCommand) {
      return resolveSubCommand(
        subCommand,
        rawArgs.slice(subCommandArgIndex + 1),
        cmd
      );
    }
  }
  return [cmd, parent];
}

async function showUsage(cmd, parent) {
  try {
    consola.log(await renderUsage(cmd, parent) + "\n");
  } catch (error) {
    consola.error(error);
  }
}
async function renderUsage(cmd, parent) {
  const cmdMeta = await resolveValue(cmd.meta || {});
  const cmdArgs = resolveArgs(await resolveValue(cmd.args || {}));
  const parentMeta = await resolveValue(parent?.meta || {});
  const commandName = `${parentMeta.name ? `${parentMeta.name} ` : ""}` + (cmdMeta.name || process.argv[1]);
  const argLines = [];
  const posLines = [];
  const commandsLines = [];
  const usageLine = [];
  for (const arg of cmdArgs) {
    if (arg.type === "positional") {
      const name = arg.name.toUpperCase();
      const isRequired = arg.required !== false && arg.default === undefined;
      const defaultHint = arg.default ? `="${arg.default}"` : "";
      posLines.push([
        "`" + name + defaultHint + "`",
        arg.description || "",
        arg.valueHint ? `<${arg.valueHint}>` : ""
      ]);
      usageLine.push(isRequired ? `<${name}>` : `[${name}]`);
    } else {
      const isRequired = arg.required === true && arg.default === undefined;
      const argStr = (arg.type === "boolean" && arg.default === true ? [
        ...(arg.alias || []).map((a) => `--no-${a}`),
        `--no-${arg.name}`
      ].join(", ") : [...(arg.alias || []).map((a) => `-${a}`), `--${arg.name}`].join(
        ", "
      )) + (arg.type === "string" && (arg.valueHint || arg.default) ? `=${arg.valueHint ? `<${arg.valueHint}>` : `"${arg.default || ""}"`}` : "");
      argLines.push([
        "`" + argStr + (isRequired ? " (required)" : "") + "`",
        arg.description || ""
      ]);
      if (isRequired) {
        usageLine.push(argStr);
      }
    }
  }
  if (cmd.subCommands) {
    const commandNames = [];
    const subCommands = await resolveValue(cmd.subCommands);
    for (const [name, sub] of Object.entries(subCommands)) {
      const subCmd = await resolveValue(sub);
      const meta = await resolveValue(subCmd?.meta);
      commandsLines.push([`\`${name}\``, meta?.description || ""]);
      commandNames.push(name);
    }
    usageLine.push(commandNames.join("|"));
  }
  const usageLines = [];
  const version = cmdMeta.version || parentMeta.version;
  usageLines.push(
    colors.gray(
      `${cmdMeta.description} (${commandName + (version ? ` v${version}` : "")})`
    ),
    ""
  );
  const hasOptions = argLines.length > 0 || posLines.length > 0;
  usageLines.push(
    `${colors.underline(colors.bold("USAGE"))} \`${commandName}${hasOptions ? " [OPTIONS]" : ""} ${usageLine.join(" ")}\``,
    ""
  );
  if (posLines.length > 0) {
    usageLines.push(colors.underline(colors.bold("ARGUMENTS")), "");
    usageLines.push(formatLineColumns(posLines, "  "));
    usageLines.push("");
  }
  if (argLines.length > 0) {
    usageLines.push(colors.underline(colors.bold("OPTIONS")), "");
    usageLines.push(formatLineColumns(argLines, "  "));
    usageLines.push("");
  }
  if (commandsLines.length > 0) {
    usageLines.push(colors.underline(colors.bold("COMMANDS")), "");
    usageLines.push(formatLineColumns(commandsLines, "  "));
    usageLines.push(
      "",
      `Use \`${commandName} <command> --help\` for more information about a command.`
    );
  }
  return usageLines.filter((l) => typeof l === "string").join("\n");
}

async function runMain(cmd, opts = {}) {
  const rawArgs = opts.rawArgs || process.argv.slice(2);
  const showUsage$1 = opts.showUsage || showUsage;
  try {
    if (rawArgs.includes("--help") || rawArgs.includes("-h")) {
      await showUsage$1(...await resolveSubCommand(cmd, rawArgs));
      process.exit(0);
    } else if (rawArgs.length === 1 && rawArgs[0] === "--version") {
      const meta = typeof cmd.meta === "function" ? await cmd.meta() : await cmd.meta;
      if (!meta?.version) {
        throw new CLIError("No version specified", "E_NO_VERSION");
      }
      consola.log(meta.version);
    } else {
      await runCommand(cmd, { rawArgs });
    }
  } catch (error) {
    const isCLIError = error instanceof CLIError;
    if (!isCLIError) {
      consola.error(error, "\n");
    }
    if (isCLIError) {
      await showUsage$1(...await resolveSubCommand(cmd, rawArgs));
    }
    consola.error(error.message);
    process.exit(1);
  }
}

function defineIndexerPlugin(def) {
  return def;
}

function logger({
  logger: logger2
} = {}) {
  return defineIndexerPlugin((indexer) => {
    indexer.hooks.hook("run:before", () => {
      const ctx = useIndexerContext();
      if (logger2) {
        ctx.logger = consola.create({ reporters: [logger2] });
      } else {
        ctx.logger = consola.create({});
      }
    });
  });
}

function inMemoryPersistence() {
  return defineIndexerPlugin((indexer) => {
    let lastCursor;
    let lastFilter;
    indexer.hooks.hook("connect:before", ({ request }) => {
      if (lastCursor) {
        request.startingCursor = lastCursor;
      }
      if (lastFilter) {
        request.filter[1] = lastFilter;
      }
    });
    indexer.hooks.hook("connect:factory", ({ request, endCursor }) => {
      if (request.filter[1]) {
        lastCursor = endCursor;
        lastFilter = request.filter[1];
      }
    });
    indexer.hooks.hook("handler:middleware", ({ use }) => {
      use(async (context, next) => {
        await next();
        if (context.endCursor && isCursor(context.endCursor)) {
          lastCursor = context.endCursor;
        }
      });
    });
  });
}

function defineConfig(config) {
  return config;
}

const apibara_config = defineConfig({});

const config = apibara_config;

const _FieldElement = TemplateLiteral(
  Literal("0x"),
  String$
);
const FieldElementProto = Struct({
  x0: BigIntFromSelf,
  x1: BigIntFromSelf,
  x2: BigIntFromSelf,
  x3: BigIntFromSelf
});
const FieldElement$1 = transform(FieldElementProto, _FieldElement, {
  decode(value) {
    const x0 = value.x0.toString(16).padStart(16, "0");
    const x1 = value.x1.toString(16).padStart(16, "0");
    const x2 = value.x2.toString(16).padStart(16, "0");
    const x3 = value.x3.toString(16).padStart(16, "0");
    return `0x${x0}${x1}${x2}${x3}`;
  },
  encode(value) {
    const bn = BigInt(value);
    const hex = bn.toString(16).padStart(64, "0");
    const s = hex.length;
    const x3 = BigInt(`0x${hex.slice(s - 16, s)}`);
    const x2 = BigInt(`0x${hex.slice(s - 32, s - 16)}`);
    const x1 = BigInt(`0x${hex.slice(s - 48, s - 32)}`);
    const x0 = BigInt(`0x${hex.slice(s - 64, s - 48)}`);
    return { x0, x1, x2, x3 };
  }
});
encodeSync(FieldElement$1);
decodeSync(FieldElement$1);

function tag(tag2) {
  return Literal(tag2).pipe(
    propertySignature,
    fromKey("$case")
  );
}
function createBaseFieldElement() {
  return { x0: BigInt("0"), x1: BigInt("0"), x2: BigInt("0"), x3: BigInt("0") };
}
const FieldElement = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.x0 !== undefined && message.x0 !== BigInt("0")) {
      if (BigInt.asUintN(64, message.x0) !== message.x0) {
        throw new globalThis.Error("value provided for field message.x0 of type fixed64 too large");
      }
      writer.uint32(9).fixed64(message.x0.toString());
    }
    if (message.x1 !== undefined && message.x1 !== BigInt("0")) {
      if (BigInt.asUintN(64, message.x1) !== message.x1) {
        throw new globalThis.Error("value provided for field message.x1 of type fixed64 too large");
      }
      writer.uint32(17).fixed64(message.x1.toString());
    }
    if (message.x2 !== undefined && message.x2 !== BigInt("0")) {
      if (BigInt.asUintN(64, message.x2) !== message.x2) {
        throw new globalThis.Error("value provided for field message.x2 of type fixed64 too large");
      }
      writer.uint32(25).fixed64(message.x2.toString());
    }
    if (message.x3 !== undefined && message.x3 !== BigInt("0")) {
      if (BigInt.asUintN(64, message.x3) !== message.x3) {
        throw new globalThis.Error("value provided for field message.x3 of type fixed64 too large");
      }
      writer.uint32(33).fixed64(message.x3.toString());
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFieldElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }
          message.x0 = longToBigint$2(reader.fixed64());
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }
          message.x1 = longToBigint$2(reader.fixed64());
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }
          message.x2 = longToBigint$2(reader.fixed64());
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }
          message.x3 = longToBigint$2(reader.fixed64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      x0: isSet$3(object.x0) ? BigInt(object.x0) : BigInt("0"),
      x1: isSet$3(object.x1) ? BigInt(object.x1) : BigInt("0"),
      x2: isSet$3(object.x2) ? BigInt(object.x2) : BigInt("0"),
      x3: isSet$3(object.x3) ? BigInt(object.x3) : BigInt("0")
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.x0 !== undefined && message.x0 !== BigInt("0")) {
      obj.x0 = message.x0.toString();
    }
    if (message.x1 !== undefined && message.x1 !== BigInt("0")) {
      obj.x1 = message.x1.toString();
    }
    if (message.x2 !== undefined && message.x2 !== BigInt("0")) {
      obj.x2 = message.x2.toString();
    }
    if (message.x3 !== undefined && message.x3 !== BigInt("0")) {
      obj.x3 = message.x3.toString();
    }
    return obj;
  },
  create(base) {
    return FieldElement.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFieldElement();
    message.x0 = object.x0 ?? BigInt("0");
    message.x1 = object.x1 ?? BigInt("0");
    message.x2 = object.x2 ?? BigInt("0");
    message.x3 = object.x3 ?? BigInt("0");
    return message;
  }
};
function longToBigint$2(long) {
  return BigInt(long.toString());
}
if (_m0.util.Long !== Long) {
  _m0.util.Long = Long;
  _m0.configure();
}
function isSet$3(value) {
  return value !== null && value !== undefined;
}

function createBaseTimestamp() {
  return { seconds: BigInt("0"), nanos: 0 };
}
const Timestamp = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.seconds !== undefined && message.seconds !== BigInt("0")) {
      if (BigInt.asIntN(64, message.seconds) !== message.seconds) {
        throw new globalThis.Error("value provided for field message.seconds of type int64 too large");
      }
      writer.uint32(8).int64(message.seconds.toString());
    }
    if (message.nanos !== undefined && message.nanos !== 0) {
      writer.uint32(16).int32(message.nanos);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimestamp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.seconds = longToBigint$1(reader.int64());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.nanos = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      seconds: isSet$2(object.seconds) ? BigInt(object.seconds) : BigInt("0"),
      nanos: isSet$2(object.nanos) ? globalThis.Number(object.nanos) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.seconds !== undefined && message.seconds !== BigInt("0")) {
      obj.seconds = message.seconds.toString();
    }
    if (message.nanos !== undefined && message.nanos !== 0) {
      obj.nanos = Math.round(message.nanos);
    }
    return obj;
  },
  create(base) {
    return Timestamp.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTimestamp();
    message.seconds = object.seconds ?? BigInt("0");
    message.nanos = object.nanos ?? 0;
    return message;
  }
};
function longToBigint$1(long) {
  return BigInt(long.toString());
}
if (_m0.util.Long !== Long) {
  _m0.util.Long = Long;
  _m0.configure();
}
function isSet$2(value) {
  return value !== null && value !== undefined;
}
var TransactionStatus$1 = /* @__PURE__ */ ((TransactionStatus2) => {
  TransactionStatus2[TransactionStatus2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  TransactionStatus2[TransactionStatus2["SUCCEEDED"] = 1] = "SUCCEEDED";
  TransactionStatus2[TransactionStatus2["REVERTED"] = 2] = "REVERTED";
  TransactionStatus2[TransactionStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  return TransactionStatus2;
})(TransactionStatus$1 || {});
function transactionStatusFromJSON(object) {
  switch (object) {
    case 0:
    case "TRANSACTION_STATUS_UNSPECIFIED":
      return 0 /* UNSPECIFIED */;
    case 1:
    case "TRANSACTION_STATUS_SUCCEEDED":
      return 1 /* SUCCEEDED */;
    case 2:
    case "TRANSACTION_STATUS_REVERTED":
      return 2 /* REVERTED */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function transactionStatusToJSON(object) {
  switch (object) {
    case 0 /* UNSPECIFIED */:
      return "TRANSACTION_STATUS_UNSPECIFIED";
    case 1 /* SUCCEEDED */:
      return "TRANSACTION_STATUS_SUCCEEDED";
    case 2 /* REVERTED */:
      return "TRANSACTION_STATUS_REVERTED";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
var L1DataAvailabilityMode$1 = /* @__PURE__ */ ((L1DataAvailabilityMode2) => {
  L1DataAvailabilityMode2[L1DataAvailabilityMode2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  L1DataAvailabilityMode2[L1DataAvailabilityMode2["BLOB"] = 1] = "BLOB";
  L1DataAvailabilityMode2[L1DataAvailabilityMode2["CALLDATA"] = 2] = "CALLDATA";
  L1DataAvailabilityMode2[L1DataAvailabilityMode2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  return L1DataAvailabilityMode2;
})(L1DataAvailabilityMode$1 || {});
function l1DataAvailabilityModeFromJSON(object) {
  switch (object) {
    case 0:
    case "L1_DATA_AVAILABILITY_MODE_UNSPECIFIED":
      return 0 /* UNSPECIFIED */;
    case 1:
    case "L1_DATA_AVAILABILITY_MODE_BLOB":
      return 1 /* BLOB */;
    case 2:
    case "L1_DATA_AVAILABILITY_MODE_CALLDATA":
      return 2 /* CALLDATA */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function l1DataAvailabilityModeToJSON(object) {
  switch (object) {
    case 0 /* UNSPECIFIED */:
      return "L1_DATA_AVAILABILITY_MODE_UNSPECIFIED";
    case 1 /* BLOB */:
      return "L1_DATA_AVAILABILITY_MODE_BLOB";
    case 2 /* CALLDATA */:
      return "L1_DATA_AVAILABILITY_MODE_CALLDATA";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
var PriceUnit$1 = /* @__PURE__ */ ((PriceUnit2) => {
  PriceUnit2[PriceUnit2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  PriceUnit2[PriceUnit2["WEI"] = 1] = "WEI";
  PriceUnit2[PriceUnit2["FRI"] = 2] = "FRI";
  PriceUnit2[PriceUnit2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  return PriceUnit2;
})(PriceUnit$1 || {});
function priceUnitFromJSON(object) {
  switch (object) {
    case 0:
    case "PRICE_UNIT_UNSPECIFIED":
      return 0 /* UNSPECIFIED */;
    case 1:
    case "PRICE_UNIT_WEI":
      return 1 /* WEI */;
    case 2:
    case "PRICE_UNIT_FRI":
      return 2 /* FRI */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function priceUnitToJSON(object) {
  switch (object) {
    case 0 /* UNSPECIFIED */:
      return "PRICE_UNIT_UNSPECIFIED";
    case 1 /* WEI */:
      return "PRICE_UNIT_WEI";
    case 2 /* FRI */:
      return "PRICE_UNIT_FRI";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
var DataAvailabilityMode$1 = /* @__PURE__ */ ((DataAvailabilityMode2) => {
  DataAvailabilityMode2[DataAvailabilityMode2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  DataAvailabilityMode2[DataAvailabilityMode2["L1"] = 1] = "L1";
  DataAvailabilityMode2[DataAvailabilityMode2["L2"] = 2] = "L2";
  DataAvailabilityMode2[DataAvailabilityMode2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  return DataAvailabilityMode2;
})(DataAvailabilityMode$1 || {});
function dataAvailabilityModeFromJSON(object) {
  switch (object) {
    case 0:
    case "DATA_AVAILABILITY_MODE_UNSPECIFIED":
      return 0 /* UNSPECIFIED */;
    case 1:
    case "DATA_AVAILABILITY_MODE_L1":
      return 1 /* L1 */;
    case 2:
    case "DATA_AVAILABILITY_MODE_L2":
      return 2 /* L2 */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function dataAvailabilityModeToJSON(object) {
  switch (object) {
    case 0 /* UNSPECIFIED */:
      return "DATA_AVAILABILITY_MODE_UNSPECIFIED";
    case 1 /* L1 */:
      return "DATA_AVAILABILITY_MODE_L1";
    case 2 /* L2 */:
      return "DATA_AVAILABILITY_MODE_L2";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function createBaseBlock() {
  return {
    header: undefined,
    transactions: [],
    receipts: [],
    events: [],
    messages: [],
    storageDiffs: [],
    contractChanges: [],
    nonceUpdates: []
  };
}
const Block$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.header !== undefined) {
      BlockHeader$1.encode(message.header, writer.uint32(10).fork()).ldelim();
    }
    if (message.transactions !== undefined && message.transactions.length !== 0) {
      for (const v of message.transactions) {
        Transaction$1.encode(v, writer.uint32(18).fork()).ldelim();
      }
    }
    if (message.receipts !== undefined && message.receipts.length !== 0) {
      for (const v of message.receipts) {
        TransactionReceipt$1.encode(v, writer.uint32(26).fork()).ldelim();
      }
    }
    if (message.events !== undefined && message.events.length !== 0) {
      for (const v of message.events) {
        Event$1.encode(v, writer.uint32(34).fork()).ldelim();
      }
    }
    if (message.messages !== undefined && message.messages.length !== 0) {
      for (const v of message.messages) {
        MessageToL1$1.encode(v, writer.uint32(42).fork()).ldelim();
      }
    }
    if (message.storageDiffs !== undefined && message.storageDiffs.length !== 0) {
      for (const v of message.storageDiffs) {
        StorageDiff$1.encode(v, writer.uint32(50).fork()).ldelim();
      }
    }
    if (message.contractChanges !== undefined && message.contractChanges.length !== 0) {
      for (const v of message.contractChanges) {
        ContractChange$1.encode(v, writer.uint32(58).fork()).ldelim();
      }
    }
    if (message.nonceUpdates !== undefined && message.nonceUpdates.length !== 0) {
      for (const v of message.nonceUpdates) {
        NonceUpdate$1.encode(v, writer.uint32(66).fork()).ldelim();
      }
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.header = BlockHeader$1.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.transactions.push(Transaction$1.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.receipts.push(TransactionReceipt$1.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.events.push(Event$1.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.messages.push(MessageToL1$1.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.storageDiffs.push(StorageDiff$1.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.contractChanges.push(ContractChange$1.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.nonceUpdates.push(NonceUpdate$1.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      header: isSet$1(object.header) ? BlockHeader$1.fromJSON(object.header) : undefined,
      transactions: globalThis.Array.isArray(object?.transactions) ? object.transactions.map((e) => Transaction$1.fromJSON(e)) : [],
      receipts: globalThis.Array.isArray(object?.receipts) ? object.receipts.map((e) => TransactionReceipt$1.fromJSON(e)) : [],
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e) => Event$1.fromJSON(e)) : [],
      messages: globalThis.Array.isArray(object?.messages) ? object.messages.map((e) => MessageToL1$1.fromJSON(e)) : [],
      storageDiffs: globalThis.Array.isArray(object?.storageDiffs) ? object.storageDiffs.map((e) => StorageDiff$1.fromJSON(e)) : [],
      contractChanges: globalThis.Array.isArray(object?.contractChanges) ? object.contractChanges.map((e) => ContractChange$1.fromJSON(e)) : [],
      nonceUpdates: globalThis.Array.isArray(object?.nonceUpdates) ? object.nonceUpdates.map((e) => NonceUpdate$1.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.header !== undefined) {
      obj.header = BlockHeader$1.toJSON(message.header);
    }
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => Transaction$1.toJSON(e));
    }
    if (message.receipts?.length) {
      obj.receipts = message.receipts.map((e) => TransactionReceipt$1.toJSON(e));
    }
    if (message.events?.length) {
      obj.events = message.events.map((e) => Event$1.toJSON(e));
    }
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => MessageToL1$1.toJSON(e));
    }
    if (message.storageDiffs?.length) {
      obj.storageDiffs = message.storageDiffs.map((e) => StorageDiff$1.toJSON(e));
    }
    if (message.contractChanges?.length) {
      obj.contractChanges = message.contractChanges.map((e) => ContractChange$1.toJSON(e));
    }
    if (message.nonceUpdates?.length) {
      obj.nonceUpdates = message.nonceUpdates.map((e) => NonceUpdate$1.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return Block$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBlock();
    message.header = object.header !== undefined && object.header !== null ? BlockHeader$1.fromPartial(object.header) : undefined;
    message.transactions = object.transactions?.map((e) => Transaction$1.fromPartial(e)) || [];
    message.receipts = object.receipts?.map((e) => TransactionReceipt$1.fromPartial(e)) || [];
    message.events = object.events?.map((e) => Event$1.fromPartial(e)) || [];
    message.messages = object.messages?.map((e) => MessageToL1$1.fromPartial(e)) || [];
    message.storageDiffs = object.storageDiffs?.map((e) => StorageDiff$1.fromPartial(e)) || [];
    message.contractChanges = object.contractChanges?.map((e) => ContractChange$1.fromPartial(e)) || [];
    message.nonceUpdates = object.nonceUpdates?.map((e) => NonceUpdate$1.fromPartial(e)) || [];
    return message;
  }
};
function createBaseBlockHeader() {
  return {
    blockHash: undefined,
    parentBlockHash: undefined,
    blockNumber: BigInt("0"),
    sequencerAddress: undefined,
    newRoot: undefined,
    timestamp: undefined,
    starknetVersion: "",
    l1GasPrice: undefined,
    l1DataGasPrice: undefined,
    l1DataAvailabilityMode: 0
  };
}
const BlockHeader$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.blockHash !== undefined) {
      FieldElement.encode(message.blockHash, writer.uint32(10).fork()).ldelim();
    }
    if (message.parentBlockHash !== undefined) {
      FieldElement.encode(message.parentBlockHash, writer.uint32(18).fork()).ldelim();
    }
    if (message.blockNumber !== undefined && message.blockNumber !== BigInt("0")) {
      if (BigInt.asUintN(64, message.blockNumber) !== message.blockNumber) {
        throw new globalThis.Error("value provided for field message.blockNumber of type uint64 too large");
      }
      writer.uint32(24).uint64(message.blockNumber.toString());
    }
    if (message.sequencerAddress !== undefined) {
      FieldElement.encode(message.sequencerAddress, writer.uint32(34).fork()).ldelim();
    }
    if (message.newRoot !== undefined) {
      FieldElement.encode(message.newRoot, writer.uint32(42).fork()).ldelim();
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(50).fork()).ldelim();
    }
    if (message.starknetVersion !== undefined && message.starknetVersion !== "") {
      writer.uint32(58).string(message.starknetVersion);
    }
    if (message.l1GasPrice !== undefined) {
      ResourcePrice$1.encode(message.l1GasPrice, writer.uint32(66).fork()).ldelim();
    }
    if (message.l1DataGasPrice !== undefined) {
      ResourcePrice$1.encode(message.l1DataGasPrice, writer.uint32(74).fork()).ldelim();
    }
    if (message.l1DataAvailabilityMode !== undefined && message.l1DataAvailabilityMode !== 0) {
      writer.uint32(80).int32(message.l1DataAvailabilityMode);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.blockHash = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.parentBlockHash = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.blockNumber = longToBigint(reader.uint64());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.sequencerAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.newRoot = FieldElement.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.starknetVersion = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.l1GasPrice = ResourcePrice$1.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.l1DataGasPrice = ResourcePrice$1.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }
          message.l1DataAvailabilityMode = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      blockHash: isSet$1(object.blockHash) ? FieldElement.fromJSON(object.blockHash) : undefined,
      parentBlockHash: isSet$1(object.parentBlockHash) ? FieldElement.fromJSON(object.parentBlockHash) : undefined,
      blockNumber: isSet$1(object.blockNumber) ? BigInt(object.blockNumber) : BigInt("0"),
      sequencerAddress: isSet$1(object.sequencerAddress) ? FieldElement.fromJSON(object.sequencerAddress) : undefined,
      newRoot: isSet$1(object.newRoot) ? FieldElement.fromJSON(object.newRoot) : undefined,
      timestamp: isSet$1(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      starknetVersion: isSet$1(object.starknetVersion) ? globalThis.String(object.starknetVersion) : "",
      l1GasPrice: isSet$1(object.l1GasPrice) ? ResourcePrice$1.fromJSON(object.l1GasPrice) : undefined,
      l1DataGasPrice: isSet$1(object.l1DataGasPrice) ? ResourcePrice$1.fromJSON(object.l1DataGasPrice) : undefined,
      l1DataAvailabilityMode: isSet$1(object.l1DataAvailabilityMode) ? l1DataAvailabilityModeFromJSON(object.l1DataAvailabilityMode) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.blockHash !== undefined) {
      obj.blockHash = FieldElement.toJSON(message.blockHash);
    }
    if (message.parentBlockHash !== undefined) {
      obj.parentBlockHash = FieldElement.toJSON(message.parentBlockHash);
    }
    if (message.blockNumber !== undefined && message.blockNumber !== BigInt("0")) {
      obj.blockNumber = message.blockNumber.toString();
    }
    if (message.sequencerAddress !== undefined) {
      obj.sequencerAddress = FieldElement.toJSON(message.sequencerAddress);
    }
    if (message.newRoot !== undefined) {
      obj.newRoot = FieldElement.toJSON(message.newRoot);
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.starknetVersion !== undefined && message.starknetVersion !== "") {
      obj.starknetVersion = message.starknetVersion;
    }
    if (message.l1GasPrice !== undefined) {
      obj.l1GasPrice = ResourcePrice$1.toJSON(message.l1GasPrice);
    }
    if (message.l1DataGasPrice !== undefined) {
      obj.l1DataGasPrice = ResourcePrice$1.toJSON(message.l1DataGasPrice);
    }
    if (message.l1DataAvailabilityMode !== undefined && message.l1DataAvailabilityMode !== 0) {
      obj.l1DataAvailabilityMode = l1DataAvailabilityModeToJSON(message.l1DataAvailabilityMode);
    }
    return obj;
  },
  create(base) {
    return BlockHeader$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBlockHeader();
    message.blockHash = object.blockHash !== undefined && object.blockHash !== null ? FieldElement.fromPartial(object.blockHash) : undefined;
    message.parentBlockHash = object.parentBlockHash !== undefined && object.parentBlockHash !== null ? FieldElement.fromPartial(object.parentBlockHash) : undefined;
    message.blockNumber = object.blockNumber ?? BigInt("0");
    message.sequencerAddress = object.sequencerAddress !== undefined && object.sequencerAddress !== null ? FieldElement.fromPartial(object.sequencerAddress) : undefined;
    message.newRoot = object.newRoot !== undefined && object.newRoot !== null ? FieldElement.fromPartial(object.newRoot) : undefined;
    message.timestamp = object.timestamp ?? undefined;
    message.starknetVersion = object.starknetVersion ?? "";
    message.l1GasPrice = object.l1GasPrice !== undefined && object.l1GasPrice !== null ? ResourcePrice$1.fromPartial(object.l1GasPrice) : undefined;
    message.l1DataGasPrice = object.l1DataGasPrice !== undefined && object.l1DataGasPrice !== null ? ResourcePrice$1.fromPartial(object.l1DataGasPrice) : undefined;
    message.l1DataAvailabilityMode = object.l1DataAvailabilityMode ?? 0;
    return message;
  }
};
function createBaseTransaction() {
  return { filterIds: [], meta: undefined, transaction: undefined };
}
const Transaction$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.filterIds !== undefined && message.filterIds.length !== 0) {
      writer.uint32(10).fork();
      for (const v of message.filterIds) {
        writer.uint32(v);
      }
      writer.ldelim();
    }
    if (message.meta !== undefined) {
      TransactionMeta$1.encode(message.meta, writer.uint32(18).fork()).ldelim();
    }
    switch (message.transaction?.$case) {
      case "invokeV0":
        InvokeTransactionV0$1.encode(message.transaction.invokeV0, writer.uint32(26).fork()).ldelim();
        break;
      case "invokeV1":
        InvokeTransactionV1$1.encode(message.transaction.invokeV1, writer.uint32(34).fork()).ldelim();
        break;
      case "invokeV3":
        InvokeTransactionV3$1.encode(message.transaction.invokeV3, writer.uint32(42).fork()).ldelim();
        break;
      case "l1Handler":
        L1HandlerTransaction$1.encode(message.transaction.l1Handler, writer.uint32(50).fork()).ldelim();
        break;
      case "deploy":
        DeployTransaction$1.encode(message.transaction.deploy, writer.uint32(58).fork()).ldelim();
        break;
      case "declareV0":
        DeclareTransactionV0$1.encode(message.transaction.declareV0, writer.uint32(66).fork()).ldelim();
        break;
      case "declareV1":
        DeclareTransactionV1$1.encode(message.transaction.declareV1, writer.uint32(74).fork()).ldelim();
        break;
      case "declareV2":
        DeclareTransactionV2$1.encode(message.transaction.declareV2, writer.uint32(82).fork()).ldelim();
        break;
      case "declareV3":
        DeclareTransactionV3$1.encode(message.transaction.declareV3, writer.uint32(90).fork()).ldelim();
        break;
      case "deployAccountV1":
        DeployAccountTransactionV1$1.encode(message.transaction.deployAccountV1, writer.uint32(98).fork()).ldelim();
        break;
      case "deployAccountV3":
        DeployAccountTransactionV3$1.encode(message.transaction.deployAccountV3, writer.uint32(106).fork()).ldelim();
        break;
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.filterIds.push(reader.uint32());
            continue;
          }
          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.filterIds.push(reader.uint32());
            }
            continue;
          }
          break;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.meta = TransactionMeta$1.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.transaction = { $case: "invokeV0", invokeV0: InvokeTransactionV0$1.decode(reader, reader.uint32()) };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.transaction = { $case: "invokeV1", invokeV1: InvokeTransactionV1$1.decode(reader, reader.uint32()) };
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.transaction = { $case: "invokeV3", invokeV3: InvokeTransactionV3$1.decode(reader, reader.uint32()) };
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.transaction = { $case: "l1Handler", l1Handler: L1HandlerTransaction$1.decode(reader, reader.uint32()) };
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.transaction = { $case: "deploy", deploy: DeployTransaction$1.decode(reader, reader.uint32()) };
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.transaction = { $case: "declareV0", declareV0: DeclareTransactionV0$1.decode(reader, reader.uint32()) };
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.transaction = { $case: "declareV1", declareV1: DeclareTransactionV1$1.decode(reader, reader.uint32()) };
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.transaction = { $case: "declareV2", declareV2: DeclareTransactionV2$1.decode(reader, reader.uint32()) };
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.transaction = { $case: "declareV3", declareV3: DeclareTransactionV3$1.decode(reader, reader.uint32()) };
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.transaction = {
            $case: "deployAccountV1",
            deployAccountV1: DeployAccountTransactionV1$1.decode(reader, reader.uint32())
          };
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }
          message.transaction = {
            $case: "deployAccountV3",
            deployAccountV3: DeployAccountTransactionV3$1.decode(reader, reader.uint32())
          };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      filterIds: globalThis.Array.isArray(object?.filterIds) ? object.filterIds.map((e) => globalThis.Number(e)) : [],
      meta: isSet$1(object.meta) ? TransactionMeta$1.fromJSON(object.meta) : undefined,
      transaction: isSet$1(object.invokeV0) ? { $case: "invokeV0", invokeV0: InvokeTransactionV0$1.fromJSON(object.invokeV0) } : isSet$1(object.invokeV1) ? { $case: "invokeV1", invokeV1: InvokeTransactionV1$1.fromJSON(object.invokeV1) } : isSet$1(object.invokeV3) ? { $case: "invokeV3", invokeV3: InvokeTransactionV3$1.fromJSON(object.invokeV3) } : isSet$1(object.l1Handler) ? { $case: "l1Handler", l1Handler: L1HandlerTransaction$1.fromJSON(object.l1Handler) } : isSet$1(object.deploy) ? { $case: "deploy", deploy: DeployTransaction$1.fromJSON(object.deploy) } : isSet$1(object.declareV0) ? { $case: "declareV0", declareV0: DeclareTransactionV0$1.fromJSON(object.declareV0) } : isSet$1(object.declareV1) ? { $case: "declareV1", declareV1: DeclareTransactionV1$1.fromJSON(object.declareV1) } : isSet$1(object.declareV2) ? { $case: "declareV2", declareV2: DeclareTransactionV2$1.fromJSON(object.declareV2) } : isSet$1(object.declareV3) ? { $case: "declareV3", declareV3: DeclareTransactionV3$1.fromJSON(object.declareV3) } : isSet$1(object.deployAccountV1) ? { $case: "deployAccountV1", deployAccountV1: DeployAccountTransactionV1$1.fromJSON(object.deployAccountV1) } : isSet$1(object.deployAccountV3) ? { $case: "deployAccountV3", deployAccountV3: DeployAccountTransactionV3$1.fromJSON(object.deployAccountV3) } : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.filterIds?.length) {
      obj.filterIds = message.filterIds.map((e) => Math.round(e));
    }
    if (message.meta !== undefined) {
      obj.meta = TransactionMeta$1.toJSON(message.meta);
    }
    if (message.transaction?.$case === "invokeV0") {
      obj.invokeV0 = InvokeTransactionV0$1.toJSON(message.transaction.invokeV0);
    }
    if (message.transaction?.$case === "invokeV1") {
      obj.invokeV1 = InvokeTransactionV1$1.toJSON(message.transaction.invokeV1);
    }
    if (message.transaction?.$case === "invokeV3") {
      obj.invokeV3 = InvokeTransactionV3$1.toJSON(message.transaction.invokeV3);
    }
    if (message.transaction?.$case === "l1Handler") {
      obj.l1Handler = L1HandlerTransaction$1.toJSON(message.transaction.l1Handler);
    }
    if (message.transaction?.$case === "deploy") {
      obj.deploy = DeployTransaction$1.toJSON(message.transaction.deploy);
    }
    if (message.transaction?.$case === "declareV0") {
      obj.declareV0 = DeclareTransactionV0$1.toJSON(message.transaction.declareV0);
    }
    if (message.transaction?.$case === "declareV1") {
      obj.declareV1 = DeclareTransactionV1$1.toJSON(message.transaction.declareV1);
    }
    if (message.transaction?.$case === "declareV2") {
      obj.declareV2 = DeclareTransactionV2$1.toJSON(message.transaction.declareV2);
    }
    if (message.transaction?.$case === "declareV3") {
      obj.declareV3 = DeclareTransactionV3$1.toJSON(message.transaction.declareV3);
    }
    if (message.transaction?.$case === "deployAccountV1") {
      obj.deployAccountV1 = DeployAccountTransactionV1$1.toJSON(message.transaction.deployAccountV1);
    }
    if (message.transaction?.$case === "deployAccountV3") {
      obj.deployAccountV3 = DeployAccountTransactionV3$1.toJSON(message.transaction.deployAccountV3);
    }
    return obj;
  },
  create(base) {
    return Transaction$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTransaction();
    message.filterIds = object.filterIds?.map((e) => e) || [];
    message.meta = object.meta !== undefined && object.meta !== null ? TransactionMeta$1.fromPartial(object.meta) : undefined;
    if (object.transaction?.$case === "invokeV0" && object.transaction?.invokeV0 !== undefined && object.transaction?.invokeV0 !== null) {
      message.transaction = {
        $case: "invokeV0",
        invokeV0: InvokeTransactionV0$1.fromPartial(object.transaction.invokeV0)
      };
    }
    if (object.transaction?.$case === "invokeV1" && object.transaction?.invokeV1 !== undefined && object.transaction?.invokeV1 !== null) {
      message.transaction = {
        $case: "invokeV1",
        invokeV1: InvokeTransactionV1$1.fromPartial(object.transaction.invokeV1)
      };
    }
    if (object.transaction?.$case === "invokeV3" && object.transaction?.invokeV3 !== undefined && object.transaction?.invokeV3 !== null) {
      message.transaction = {
        $case: "invokeV3",
        invokeV3: InvokeTransactionV3$1.fromPartial(object.transaction.invokeV3)
      };
    }
    if (object.transaction?.$case === "l1Handler" && object.transaction?.l1Handler !== undefined && object.transaction?.l1Handler !== null) {
      message.transaction = {
        $case: "l1Handler",
        l1Handler: L1HandlerTransaction$1.fromPartial(object.transaction.l1Handler)
      };
    }
    if (object.transaction?.$case === "deploy" && object.transaction?.deploy !== undefined && object.transaction?.deploy !== null) {
      message.transaction = { $case: "deploy", deploy: DeployTransaction$1.fromPartial(object.transaction.deploy) };
    }
    if (object.transaction?.$case === "declareV0" && object.transaction?.declareV0 !== undefined && object.transaction?.declareV0 !== null) {
      message.transaction = {
        $case: "declareV0",
        declareV0: DeclareTransactionV0$1.fromPartial(object.transaction.declareV0)
      };
    }
    if (object.transaction?.$case === "declareV1" && object.transaction?.declareV1 !== undefined && object.transaction?.declareV1 !== null) {
      message.transaction = {
        $case: "declareV1",
        declareV1: DeclareTransactionV1$1.fromPartial(object.transaction.declareV1)
      };
    }
    if (object.transaction?.$case === "declareV2" && object.transaction?.declareV2 !== undefined && object.transaction?.declareV2 !== null) {
      message.transaction = {
        $case: "declareV2",
        declareV2: DeclareTransactionV2$1.fromPartial(object.transaction.declareV2)
      };
    }
    if (object.transaction?.$case === "declareV3" && object.transaction?.declareV3 !== undefined && object.transaction?.declareV3 !== null) {
      message.transaction = {
        $case: "declareV3",
        declareV3: DeclareTransactionV3$1.fromPartial(object.transaction.declareV3)
      };
    }
    if (object.transaction?.$case === "deployAccountV1" && object.transaction?.deployAccountV1 !== undefined && object.transaction?.deployAccountV1 !== null) {
      message.transaction = {
        $case: "deployAccountV1",
        deployAccountV1: DeployAccountTransactionV1$1.fromPartial(object.transaction.deployAccountV1)
      };
    }
    if (object.transaction?.$case === "deployAccountV3" && object.transaction?.deployAccountV3 !== undefined && object.transaction?.deployAccountV3 !== null) {
      message.transaction = {
        $case: "deployAccountV3",
        deployAccountV3: DeployAccountTransactionV3$1.fromPartial(object.transaction.deployAccountV3)
      };
    }
    return message;
  }
};
function createBaseTransactionMeta() {
  return { transactionIndex: 0, transactionHash: undefined, transactionStatus: 0 };
}
const TransactionMeta$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.transactionIndex !== undefined && message.transactionIndex !== 0) {
      writer.uint32(8).uint32(message.transactionIndex);
    }
    if (message.transactionHash !== undefined) {
      FieldElement.encode(message.transactionHash, writer.uint32(18).fork()).ldelim();
    }
    if (message.transactionStatus !== undefined && message.transactionStatus !== 0) {
      writer.uint32(24).int32(message.transactionStatus);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionMeta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.transactionIndex = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.transactionHash = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.transactionStatus = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      transactionIndex: isSet$1(object.transactionIndex) ? globalThis.Number(object.transactionIndex) : 0,
      transactionHash: isSet$1(object.transactionHash) ? FieldElement.fromJSON(object.transactionHash) : undefined,
      transactionStatus: isSet$1(object.transactionStatus) ? transactionStatusFromJSON(object.transactionStatus) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.transactionIndex !== undefined && message.transactionIndex !== 0) {
      obj.transactionIndex = Math.round(message.transactionIndex);
    }
    if (message.transactionHash !== undefined) {
      obj.transactionHash = FieldElement.toJSON(message.transactionHash);
    }
    if (message.transactionStatus !== undefined && message.transactionStatus !== 0) {
      obj.transactionStatus = transactionStatusToJSON(message.transactionStatus);
    }
    return obj;
  },
  create(base) {
    return TransactionMeta$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTransactionMeta();
    message.transactionIndex = object.transactionIndex ?? 0;
    message.transactionHash = object.transactionHash !== undefined && object.transactionHash !== null ? FieldElement.fromPartial(object.transactionHash) : undefined;
    message.transactionStatus = object.transactionStatus ?? 0;
    return message;
  }
};
function createBaseInvokeTransactionV0() {
  return { maxFee: undefined, signature: [], contractAddress: undefined, entryPointSelector: undefined, calldata: [] };
}
const InvokeTransactionV0$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.maxFee !== undefined) {
      FieldElement.encode(message.maxFee, writer.uint32(10).fork()).ldelim();
    }
    if (message.signature !== undefined && message.signature.length !== 0) {
      for (const v of message.signature) {
        FieldElement.encode(v, writer.uint32(18).fork()).ldelim();
      }
    }
    if (message.contractAddress !== undefined) {
      FieldElement.encode(message.contractAddress, writer.uint32(26).fork()).ldelim();
    }
    if (message.entryPointSelector !== undefined) {
      FieldElement.encode(message.entryPointSelector, writer.uint32(34).fork()).ldelim();
    }
    if (message.calldata !== undefined && message.calldata.length !== 0) {
      for (const v of message.calldata) {
        FieldElement.encode(v, writer.uint32(50).fork()).ldelim();
      }
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeTransactionV0();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.maxFee = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.signature.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.contractAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.entryPointSelector = FieldElement.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.calldata.push(FieldElement.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      maxFee: isSet$1(object.maxFee) ? FieldElement.fromJSON(object.maxFee) : undefined,
      signature: globalThis.Array.isArray(object?.signature) ? object.signature.map((e) => FieldElement.fromJSON(e)) : [],
      contractAddress: isSet$1(object.contractAddress) ? FieldElement.fromJSON(object.contractAddress) : undefined,
      entryPointSelector: isSet$1(object.entryPointSelector) ? FieldElement.fromJSON(object.entryPointSelector) : undefined,
      calldata: globalThis.Array.isArray(object?.calldata) ? object.calldata.map((e) => FieldElement.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.maxFee !== undefined) {
      obj.maxFee = FieldElement.toJSON(message.maxFee);
    }
    if (message.signature?.length) {
      obj.signature = message.signature.map((e) => FieldElement.toJSON(e));
    }
    if (message.contractAddress !== undefined) {
      obj.contractAddress = FieldElement.toJSON(message.contractAddress);
    }
    if (message.entryPointSelector !== undefined) {
      obj.entryPointSelector = FieldElement.toJSON(message.entryPointSelector);
    }
    if (message.calldata?.length) {
      obj.calldata = message.calldata.map((e) => FieldElement.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return InvokeTransactionV0$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseInvokeTransactionV0();
    message.maxFee = object.maxFee !== undefined && object.maxFee !== null ? FieldElement.fromPartial(object.maxFee) : undefined;
    message.signature = object.signature?.map((e) => FieldElement.fromPartial(e)) || [];
    message.contractAddress = object.contractAddress !== undefined && object.contractAddress !== null ? FieldElement.fromPartial(object.contractAddress) : undefined;
    message.entryPointSelector = object.entryPointSelector !== undefined && object.entryPointSelector !== null ? FieldElement.fromPartial(object.entryPointSelector) : undefined;
    message.calldata = object.calldata?.map((e) => FieldElement.fromPartial(e)) || [];
    return message;
  }
};
function createBaseInvokeTransactionV1() {
  return { senderAddress: undefined, calldata: [], maxFee: undefined, signature: [], nonce: undefined };
}
const InvokeTransactionV1$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.senderAddress !== undefined) {
      FieldElement.encode(message.senderAddress, writer.uint32(10).fork()).ldelim();
    }
    if (message.calldata !== undefined && message.calldata.length !== 0) {
      for (const v of message.calldata) {
        FieldElement.encode(v, writer.uint32(18).fork()).ldelim();
      }
    }
    if (message.maxFee !== undefined) {
      FieldElement.encode(message.maxFee, writer.uint32(26).fork()).ldelim();
    }
    if (message.signature !== undefined && message.signature.length !== 0) {
      for (const v of message.signature) {
        FieldElement.encode(v, writer.uint32(34).fork()).ldelim();
      }
    }
    if (message.nonce !== undefined) {
      FieldElement.encode(message.nonce, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeTransactionV1();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.senderAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.calldata.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.maxFee = FieldElement.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.signature.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.nonce = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      senderAddress: isSet$1(object.senderAddress) ? FieldElement.fromJSON(object.senderAddress) : undefined,
      calldata: globalThis.Array.isArray(object?.calldata) ? object.calldata.map((e) => FieldElement.fromJSON(e)) : [],
      maxFee: isSet$1(object.maxFee) ? FieldElement.fromJSON(object.maxFee) : undefined,
      signature: globalThis.Array.isArray(object?.signature) ? object.signature.map((e) => FieldElement.fromJSON(e)) : [],
      nonce: isSet$1(object.nonce) ? FieldElement.fromJSON(object.nonce) : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.senderAddress !== undefined) {
      obj.senderAddress = FieldElement.toJSON(message.senderAddress);
    }
    if (message.calldata?.length) {
      obj.calldata = message.calldata.map((e) => FieldElement.toJSON(e));
    }
    if (message.maxFee !== undefined) {
      obj.maxFee = FieldElement.toJSON(message.maxFee);
    }
    if (message.signature?.length) {
      obj.signature = message.signature.map((e) => FieldElement.toJSON(e));
    }
    if (message.nonce !== undefined) {
      obj.nonce = FieldElement.toJSON(message.nonce);
    }
    return obj;
  },
  create(base) {
    return InvokeTransactionV1$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseInvokeTransactionV1();
    message.senderAddress = object.senderAddress !== undefined && object.senderAddress !== null ? FieldElement.fromPartial(object.senderAddress) : undefined;
    message.calldata = object.calldata?.map((e) => FieldElement.fromPartial(e)) || [];
    message.maxFee = object.maxFee !== undefined && object.maxFee !== null ? FieldElement.fromPartial(object.maxFee) : undefined;
    message.signature = object.signature?.map((e) => FieldElement.fromPartial(e)) || [];
    message.nonce = object.nonce !== undefined && object.nonce !== null ? FieldElement.fromPartial(object.nonce) : undefined;
    return message;
  }
};
function createBaseInvokeTransactionV3() {
  return {
    senderAddress: undefined,
    calldata: [],
    signature: [],
    nonce: undefined,
    resourceBounds: undefined,
    tip: BigInt("0"),
    paymasterData: [],
    accountDeploymentData: [],
    nonceDataAvailabilityMode: 0,
    feeDataAvailabilityMode: 0
  };
}
const InvokeTransactionV3$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.senderAddress !== undefined) {
      FieldElement.encode(message.senderAddress, writer.uint32(10).fork()).ldelim();
    }
    if (message.calldata !== undefined && message.calldata.length !== 0) {
      for (const v of message.calldata) {
        FieldElement.encode(v, writer.uint32(18).fork()).ldelim();
      }
    }
    if (message.signature !== undefined && message.signature.length !== 0) {
      for (const v of message.signature) {
        FieldElement.encode(v, writer.uint32(26).fork()).ldelim();
      }
    }
    if (message.nonce !== undefined) {
      FieldElement.encode(message.nonce, writer.uint32(34).fork()).ldelim();
    }
    if (message.resourceBounds !== undefined) {
      ResourceBoundsMapping$1.encode(message.resourceBounds, writer.uint32(42).fork()).ldelim();
    }
    if (message.tip !== undefined && message.tip !== BigInt("0")) {
      if (BigInt.asUintN(64, message.tip) !== message.tip) {
        throw new globalThis.Error("value provided for field message.tip of type uint64 too large");
      }
      writer.uint32(48).uint64(message.tip.toString());
    }
    if (message.paymasterData !== undefined && message.paymasterData.length !== 0) {
      for (const v of message.paymasterData) {
        FieldElement.encode(v, writer.uint32(58).fork()).ldelim();
      }
    }
    if (message.accountDeploymentData !== undefined && message.accountDeploymentData.length !== 0) {
      for (const v of message.accountDeploymentData) {
        FieldElement.encode(v, writer.uint32(66).fork()).ldelim();
      }
    }
    if (message.nonceDataAvailabilityMode !== undefined && message.nonceDataAvailabilityMode !== 0) {
      writer.uint32(72).int32(message.nonceDataAvailabilityMode);
    }
    if (message.feeDataAvailabilityMode !== undefined && message.feeDataAvailabilityMode !== 0) {
      writer.uint32(80).int32(message.feeDataAvailabilityMode);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeTransactionV3();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.senderAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.calldata.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.signature.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.nonce = FieldElement.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.resourceBounds = ResourceBoundsMapping$1.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.tip = longToBigint(reader.uint64());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.paymasterData.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.accountDeploymentData.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }
          message.nonceDataAvailabilityMode = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }
          message.feeDataAvailabilityMode = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      senderAddress: isSet$1(object.senderAddress) ? FieldElement.fromJSON(object.senderAddress) : undefined,
      calldata: globalThis.Array.isArray(object?.calldata) ? object.calldata.map((e) => FieldElement.fromJSON(e)) : [],
      signature: globalThis.Array.isArray(object?.signature) ? object.signature.map((e) => FieldElement.fromJSON(e)) : [],
      nonce: isSet$1(object.nonce) ? FieldElement.fromJSON(object.nonce) : undefined,
      resourceBounds: isSet$1(object.resourceBounds) ? ResourceBoundsMapping$1.fromJSON(object.resourceBounds) : undefined,
      tip: isSet$1(object.tip) ? BigInt(object.tip) : BigInt("0"),
      paymasterData: globalThis.Array.isArray(object?.paymasterData) ? object.paymasterData.map((e) => FieldElement.fromJSON(e)) : [],
      accountDeploymentData: globalThis.Array.isArray(object?.accountDeploymentData) ? object.accountDeploymentData.map((e) => FieldElement.fromJSON(e)) : [],
      nonceDataAvailabilityMode: isSet$1(object.nonceDataAvailabilityMode) ? dataAvailabilityModeFromJSON(object.nonceDataAvailabilityMode) : 0,
      feeDataAvailabilityMode: isSet$1(object.feeDataAvailabilityMode) ? dataAvailabilityModeFromJSON(object.feeDataAvailabilityMode) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.senderAddress !== undefined) {
      obj.senderAddress = FieldElement.toJSON(message.senderAddress);
    }
    if (message.calldata?.length) {
      obj.calldata = message.calldata.map((e) => FieldElement.toJSON(e));
    }
    if (message.signature?.length) {
      obj.signature = message.signature.map((e) => FieldElement.toJSON(e));
    }
    if (message.nonce !== undefined) {
      obj.nonce = FieldElement.toJSON(message.nonce);
    }
    if (message.resourceBounds !== undefined) {
      obj.resourceBounds = ResourceBoundsMapping$1.toJSON(message.resourceBounds);
    }
    if (message.tip !== undefined && message.tip !== BigInt("0")) {
      obj.tip = message.tip.toString();
    }
    if (message.paymasterData?.length) {
      obj.paymasterData = message.paymasterData.map((e) => FieldElement.toJSON(e));
    }
    if (message.accountDeploymentData?.length) {
      obj.accountDeploymentData = message.accountDeploymentData.map((e) => FieldElement.toJSON(e));
    }
    if (message.nonceDataAvailabilityMode !== undefined && message.nonceDataAvailabilityMode !== 0) {
      obj.nonceDataAvailabilityMode = dataAvailabilityModeToJSON(message.nonceDataAvailabilityMode);
    }
    if (message.feeDataAvailabilityMode !== undefined && message.feeDataAvailabilityMode !== 0) {
      obj.feeDataAvailabilityMode = dataAvailabilityModeToJSON(message.feeDataAvailabilityMode);
    }
    return obj;
  },
  create(base) {
    return InvokeTransactionV3$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseInvokeTransactionV3();
    message.senderAddress = object.senderAddress !== undefined && object.senderAddress !== null ? FieldElement.fromPartial(object.senderAddress) : undefined;
    message.calldata = object.calldata?.map((e) => FieldElement.fromPartial(e)) || [];
    message.signature = object.signature?.map((e) => FieldElement.fromPartial(e)) || [];
    message.nonce = object.nonce !== undefined && object.nonce !== null ? FieldElement.fromPartial(object.nonce) : undefined;
    message.resourceBounds = object.resourceBounds !== undefined && object.resourceBounds !== null ? ResourceBoundsMapping$1.fromPartial(object.resourceBounds) : undefined;
    message.tip = object.tip ?? BigInt("0");
    message.paymasterData = object.paymasterData?.map((e) => FieldElement.fromPartial(e)) || [];
    message.accountDeploymentData = object.accountDeploymentData?.map((e) => FieldElement.fromPartial(e)) || [];
    message.nonceDataAvailabilityMode = object.nonceDataAvailabilityMode ?? 0;
    message.feeDataAvailabilityMode = object.feeDataAvailabilityMode ?? 0;
    return message;
  }
};
function createBaseL1HandlerTransaction() {
  return { nonce: BigInt("0"), contractAddress: undefined, entryPointSelector: undefined, calldata: [] };
}
const L1HandlerTransaction$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.nonce !== undefined && message.nonce !== BigInt("0")) {
      if (BigInt.asUintN(64, message.nonce) !== message.nonce) {
        throw new globalThis.Error("value provided for field message.nonce of type uint64 too large");
      }
      writer.uint32(8).uint64(message.nonce.toString());
    }
    if (message.contractAddress !== undefined) {
      FieldElement.encode(message.contractAddress, writer.uint32(18).fork()).ldelim();
    }
    if (message.entryPointSelector !== undefined) {
      FieldElement.encode(message.entryPointSelector, writer.uint32(26).fork()).ldelim();
    }
    if (message.calldata !== undefined && message.calldata.length !== 0) {
      for (const v of message.calldata) {
        FieldElement.encode(v, writer.uint32(34).fork()).ldelim();
      }
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseL1HandlerTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.nonce = longToBigint(reader.uint64());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.contractAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.entryPointSelector = FieldElement.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.calldata.push(FieldElement.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      nonce: isSet$1(object.nonce) ? BigInt(object.nonce) : BigInt("0"),
      contractAddress: isSet$1(object.contractAddress) ? FieldElement.fromJSON(object.contractAddress) : undefined,
      entryPointSelector: isSet$1(object.entryPointSelector) ? FieldElement.fromJSON(object.entryPointSelector) : undefined,
      calldata: globalThis.Array.isArray(object?.calldata) ? object.calldata.map((e) => FieldElement.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.nonce !== undefined && message.nonce !== BigInt("0")) {
      obj.nonce = message.nonce.toString();
    }
    if (message.contractAddress !== undefined) {
      obj.contractAddress = FieldElement.toJSON(message.contractAddress);
    }
    if (message.entryPointSelector !== undefined) {
      obj.entryPointSelector = FieldElement.toJSON(message.entryPointSelector);
    }
    if (message.calldata?.length) {
      obj.calldata = message.calldata.map((e) => FieldElement.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return L1HandlerTransaction$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseL1HandlerTransaction();
    message.nonce = object.nonce ?? BigInt("0");
    message.contractAddress = object.contractAddress !== undefined && object.contractAddress !== null ? FieldElement.fromPartial(object.contractAddress) : undefined;
    message.entryPointSelector = object.entryPointSelector !== undefined && object.entryPointSelector !== null ? FieldElement.fromPartial(object.entryPointSelector) : undefined;
    message.calldata = object.calldata?.map((e) => FieldElement.fromPartial(e)) || [];
    return message;
  }
};
function createBaseDeployTransaction() {
  return { contractAddressSalt: undefined, constructorCalldata: [], classHash: undefined };
}
const DeployTransaction$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.contractAddressSalt !== undefined) {
      FieldElement.encode(message.contractAddressSalt, writer.uint32(10).fork()).ldelim();
    }
    if (message.constructorCalldata !== undefined && message.constructorCalldata.length !== 0) {
      for (const v of message.constructorCalldata) {
        FieldElement.encode(v, writer.uint32(18).fork()).ldelim();
      }
    }
    if (message.classHash !== undefined) {
      FieldElement.encode(message.classHash, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.contractAddressSalt = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.constructorCalldata.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.classHash = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      contractAddressSalt: isSet$1(object.contractAddressSalt) ? FieldElement.fromJSON(object.contractAddressSalt) : undefined,
      constructorCalldata: globalThis.Array.isArray(object?.constructorCalldata) ? object.constructorCalldata.map((e) => FieldElement.fromJSON(e)) : [],
      classHash: isSet$1(object.classHash) ? FieldElement.fromJSON(object.classHash) : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.contractAddressSalt !== undefined) {
      obj.contractAddressSalt = FieldElement.toJSON(message.contractAddressSalt);
    }
    if (message.constructorCalldata?.length) {
      obj.constructorCalldata = message.constructorCalldata.map((e) => FieldElement.toJSON(e));
    }
    if (message.classHash !== undefined) {
      obj.classHash = FieldElement.toJSON(message.classHash);
    }
    return obj;
  },
  create(base) {
    return DeployTransaction$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDeployTransaction();
    message.contractAddressSalt = object.contractAddressSalt !== undefined && object.contractAddressSalt !== null ? FieldElement.fromPartial(object.contractAddressSalt) : undefined;
    message.constructorCalldata = object.constructorCalldata?.map((e) => FieldElement.fromPartial(e)) || [];
    message.classHash = object.classHash !== undefined && object.classHash !== null ? FieldElement.fromPartial(object.classHash) : undefined;
    return message;
  }
};
function createBaseDeclareTransactionV0() {
  return { senderAddress: undefined, maxFee: undefined, signature: [], classHash: undefined };
}
const DeclareTransactionV0$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.senderAddress !== undefined) {
      FieldElement.encode(message.senderAddress, writer.uint32(10).fork()).ldelim();
    }
    if (message.maxFee !== undefined) {
      FieldElement.encode(message.maxFee, writer.uint32(18).fork()).ldelim();
    }
    if (message.signature !== undefined && message.signature.length !== 0) {
      for (const v of message.signature) {
        FieldElement.encode(v, writer.uint32(26).fork()).ldelim();
      }
    }
    if (message.classHash !== undefined) {
      FieldElement.encode(message.classHash, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclareTransactionV0();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.senderAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.maxFee = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.signature.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.classHash = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      senderAddress: isSet$1(object.senderAddress) ? FieldElement.fromJSON(object.senderAddress) : undefined,
      maxFee: isSet$1(object.maxFee) ? FieldElement.fromJSON(object.maxFee) : undefined,
      signature: globalThis.Array.isArray(object?.signature) ? object.signature.map((e) => FieldElement.fromJSON(e)) : [],
      classHash: isSet$1(object.classHash) ? FieldElement.fromJSON(object.classHash) : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.senderAddress !== undefined) {
      obj.senderAddress = FieldElement.toJSON(message.senderAddress);
    }
    if (message.maxFee !== undefined) {
      obj.maxFee = FieldElement.toJSON(message.maxFee);
    }
    if (message.signature?.length) {
      obj.signature = message.signature.map((e) => FieldElement.toJSON(e));
    }
    if (message.classHash !== undefined) {
      obj.classHash = FieldElement.toJSON(message.classHash);
    }
    return obj;
  },
  create(base) {
    return DeclareTransactionV0$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDeclareTransactionV0();
    message.senderAddress = object.senderAddress !== undefined && object.senderAddress !== null ? FieldElement.fromPartial(object.senderAddress) : undefined;
    message.maxFee = object.maxFee !== undefined && object.maxFee !== null ? FieldElement.fromPartial(object.maxFee) : undefined;
    message.signature = object.signature?.map((e) => FieldElement.fromPartial(e)) || [];
    message.classHash = object.classHash !== undefined && object.classHash !== null ? FieldElement.fromPartial(object.classHash) : undefined;
    return message;
  }
};
function createBaseDeclareTransactionV1() {
  return { senderAddress: undefined, maxFee: undefined, signature: [], nonce: undefined, classHash: undefined };
}
const DeclareTransactionV1$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.senderAddress !== undefined) {
      FieldElement.encode(message.senderAddress, writer.uint32(10).fork()).ldelim();
    }
    if (message.maxFee !== undefined) {
      FieldElement.encode(message.maxFee, writer.uint32(18).fork()).ldelim();
    }
    if (message.signature !== undefined && message.signature.length !== 0) {
      for (const v of message.signature) {
        FieldElement.encode(v, writer.uint32(26).fork()).ldelim();
      }
    }
    if (message.nonce !== undefined) {
      FieldElement.encode(message.nonce, writer.uint32(34).fork()).ldelim();
    }
    if (message.classHash !== undefined) {
      FieldElement.encode(message.classHash, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclareTransactionV1();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.senderAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.maxFee = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.signature.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.nonce = FieldElement.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.classHash = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      senderAddress: isSet$1(object.senderAddress) ? FieldElement.fromJSON(object.senderAddress) : undefined,
      maxFee: isSet$1(object.maxFee) ? FieldElement.fromJSON(object.maxFee) : undefined,
      signature: globalThis.Array.isArray(object?.signature) ? object.signature.map((e) => FieldElement.fromJSON(e)) : [],
      nonce: isSet$1(object.nonce) ? FieldElement.fromJSON(object.nonce) : undefined,
      classHash: isSet$1(object.classHash) ? FieldElement.fromJSON(object.classHash) : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.senderAddress !== undefined) {
      obj.senderAddress = FieldElement.toJSON(message.senderAddress);
    }
    if (message.maxFee !== undefined) {
      obj.maxFee = FieldElement.toJSON(message.maxFee);
    }
    if (message.signature?.length) {
      obj.signature = message.signature.map((e) => FieldElement.toJSON(e));
    }
    if (message.nonce !== undefined) {
      obj.nonce = FieldElement.toJSON(message.nonce);
    }
    if (message.classHash !== undefined) {
      obj.classHash = FieldElement.toJSON(message.classHash);
    }
    return obj;
  },
  create(base) {
    return DeclareTransactionV1$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDeclareTransactionV1();
    message.senderAddress = object.senderAddress !== undefined && object.senderAddress !== null ? FieldElement.fromPartial(object.senderAddress) : undefined;
    message.maxFee = object.maxFee !== undefined && object.maxFee !== null ? FieldElement.fromPartial(object.maxFee) : undefined;
    message.signature = object.signature?.map((e) => FieldElement.fromPartial(e)) || [];
    message.nonce = object.nonce !== undefined && object.nonce !== null ? FieldElement.fromPartial(object.nonce) : undefined;
    message.classHash = object.classHash !== undefined && object.classHash !== null ? FieldElement.fromPartial(object.classHash) : undefined;
    return message;
  }
};
function createBaseDeclareTransactionV2() {
  return {
    senderAddress: undefined,
    compiledClassHash: undefined,
    maxFee: undefined,
    signature: [],
    nonce: undefined,
    classHash: undefined
  };
}
const DeclareTransactionV2$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.senderAddress !== undefined) {
      FieldElement.encode(message.senderAddress, writer.uint32(10).fork()).ldelim();
    }
    if (message.compiledClassHash !== undefined) {
      FieldElement.encode(message.compiledClassHash, writer.uint32(18).fork()).ldelim();
    }
    if (message.maxFee !== undefined) {
      FieldElement.encode(message.maxFee, writer.uint32(26).fork()).ldelim();
    }
    if (message.signature !== undefined && message.signature.length !== 0) {
      for (const v of message.signature) {
        FieldElement.encode(v, writer.uint32(34).fork()).ldelim();
      }
    }
    if (message.nonce !== undefined) {
      FieldElement.encode(message.nonce, writer.uint32(42).fork()).ldelim();
    }
    if (message.classHash !== undefined) {
      FieldElement.encode(message.classHash, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclareTransactionV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.senderAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.compiledClassHash = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.maxFee = FieldElement.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.signature.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.nonce = FieldElement.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.classHash = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      senderAddress: isSet$1(object.senderAddress) ? FieldElement.fromJSON(object.senderAddress) : undefined,
      compiledClassHash: isSet$1(object.compiledClassHash) ? FieldElement.fromJSON(object.compiledClassHash) : undefined,
      maxFee: isSet$1(object.maxFee) ? FieldElement.fromJSON(object.maxFee) : undefined,
      signature: globalThis.Array.isArray(object?.signature) ? object.signature.map((e) => FieldElement.fromJSON(e)) : [],
      nonce: isSet$1(object.nonce) ? FieldElement.fromJSON(object.nonce) : undefined,
      classHash: isSet$1(object.classHash) ? FieldElement.fromJSON(object.classHash) : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.senderAddress !== undefined) {
      obj.senderAddress = FieldElement.toJSON(message.senderAddress);
    }
    if (message.compiledClassHash !== undefined) {
      obj.compiledClassHash = FieldElement.toJSON(message.compiledClassHash);
    }
    if (message.maxFee !== undefined) {
      obj.maxFee = FieldElement.toJSON(message.maxFee);
    }
    if (message.signature?.length) {
      obj.signature = message.signature.map((e) => FieldElement.toJSON(e));
    }
    if (message.nonce !== undefined) {
      obj.nonce = FieldElement.toJSON(message.nonce);
    }
    if (message.classHash !== undefined) {
      obj.classHash = FieldElement.toJSON(message.classHash);
    }
    return obj;
  },
  create(base) {
    return DeclareTransactionV2$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDeclareTransactionV2();
    message.senderAddress = object.senderAddress !== undefined && object.senderAddress !== null ? FieldElement.fromPartial(object.senderAddress) : undefined;
    message.compiledClassHash = object.compiledClassHash !== undefined && object.compiledClassHash !== null ? FieldElement.fromPartial(object.compiledClassHash) : undefined;
    message.maxFee = object.maxFee !== undefined && object.maxFee !== null ? FieldElement.fromPartial(object.maxFee) : undefined;
    message.signature = object.signature?.map((e) => FieldElement.fromPartial(e)) || [];
    message.nonce = object.nonce !== undefined && object.nonce !== null ? FieldElement.fromPartial(object.nonce) : undefined;
    message.classHash = object.classHash !== undefined && object.classHash !== null ? FieldElement.fromPartial(object.classHash) : undefined;
    return message;
  }
};
function createBaseDeclareTransactionV3() {
  return {
    senderAddress: undefined,
    compiledClassHash: undefined,
    signature: [],
    nonce: undefined,
    classHash: undefined,
    resourceBounds: undefined,
    tip: BigInt("0"),
    paymasterData: [],
    accountDeploymentData: [],
    nonceDataAvailabilityMode: 0,
    feeDataAvailabilityMode: 0
  };
}
const DeclareTransactionV3$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.senderAddress !== undefined) {
      FieldElement.encode(message.senderAddress, writer.uint32(10).fork()).ldelim();
    }
    if (message.compiledClassHash !== undefined) {
      FieldElement.encode(message.compiledClassHash, writer.uint32(18).fork()).ldelim();
    }
    if (message.signature !== undefined && message.signature.length !== 0) {
      for (const v of message.signature) {
        FieldElement.encode(v, writer.uint32(26).fork()).ldelim();
      }
    }
    if (message.nonce !== undefined) {
      FieldElement.encode(message.nonce, writer.uint32(34).fork()).ldelim();
    }
    if (message.classHash !== undefined) {
      FieldElement.encode(message.classHash, writer.uint32(42).fork()).ldelim();
    }
    if (message.resourceBounds !== undefined) {
      ResourceBoundsMapping$1.encode(message.resourceBounds, writer.uint32(50).fork()).ldelim();
    }
    if (message.tip !== undefined && message.tip !== BigInt("0")) {
      if (BigInt.asUintN(64, message.tip) !== message.tip) {
        throw new globalThis.Error("value provided for field message.tip of type uint64 too large");
      }
      writer.uint32(56).uint64(message.tip.toString());
    }
    if (message.paymasterData !== undefined && message.paymasterData.length !== 0) {
      for (const v of message.paymasterData) {
        FieldElement.encode(v, writer.uint32(66).fork()).ldelim();
      }
    }
    if (message.accountDeploymentData !== undefined && message.accountDeploymentData.length !== 0) {
      for (const v of message.accountDeploymentData) {
        FieldElement.encode(v, writer.uint32(74).fork()).ldelim();
      }
    }
    if (message.nonceDataAvailabilityMode !== undefined && message.nonceDataAvailabilityMode !== 0) {
      writer.uint32(80).int32(message.nonceDataAvailabilityMode);
    }
    if (message.feeDataAvailabilityMode !== undefined && message.feeDataAvailabilityMode !== 0) {
      writer.uint32(88).int32(message.feeDataAvailabilityMode);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclareTransactionV3();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.senderAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.compiledClassHash = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.signature.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.nonce = FieldElement.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.classHash = FieldElement.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.resourceBounds = ResourceBoundsMapping$1.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }
          message.tip = longToBigint(reader.uint64());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.paymasterData.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.accountDeploymentData.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }
          message.nonceDataAvailabilityMode = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }
          message.feeDataAvailabilityMode = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      senderAddress: isSet$1(object.senderAddress) ? FieldElement.fromJSON(object.senderAddress) : undefined,
      compiledClassHash: isSet$1(object.compiledClassHash) ? FieldElement.fromJSON(object.compiledClassHash) : undefined,
      signature: globalThis.Array.isArray(object?.signature) ? object.signature.map((e) => FieldElement.fromJSON(e)) : [],
      nonce: isSet$1(object.nonce) ? FieldElement.fromJSON(object.nonce) : undefined,
      classHash: isSet$1(object.classHash) ? FieldElement.fromJSON(object.classHash) : undefined,
      resourceBounds: isSet$1(object.resourceBounds) ? ResourceBoundsMapping$1.fromJSON(object.resourceBounds) : undefined,
      tip: isSet$1(object.tip) ? BigInt(object.tip) : BigInt("0"),
      paymasterData: globalThis.Array.isArray(object?.paymasterData) ? object.paymasterData.map((e) => FieldElement.fromJSON(e)) : [],
      accountDeploymentData: globalThis.Array.isArray(object?.accountDeploymentData) ? object.accountDeploymentData.map((e) => FieldElement.fromJSON(e)) : [],
      nonceDataAvailabilityMode: isSet$1(object.nonceDataAvailabilityMode) ? dataAvailabilityModeFromJSON(object.nonceDataAvailabilityMode) : 0,
      feeDataAvailabilityMode: isSet$1(object.feeDataAvailabilityMode) ? dataAvailabilityModeFromJSON(object.feeDataAvailabilityMode) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.senderAddress !== undefined) {
      obj.senderAddress = FieldElement.toJSON(message.senderAddress);
    }
    if (message.compiledClassHash !== undefined) {
      obj.compiledClassHash = FieldElement.toJSON(message.compiledClassHash);
    }
    if (message.signature?.length) {
      obj.signature = message.signature.map((e) => FieldElement.toJSON(e));
    }
    if (message.nonce !== undefined) {
      obj.nonce = FieldElement.toJSON(message.nonce);
    }
    if (message.classHash !== undefined) {
      obj.classHash = FieldElement.toJSON(message.classHash);
    }
    if (message.resourceBounds !== undefined) {
      obj.resourceBounds = ResourceBoundsMapping$1.toJSON(message.resourceBounds);
    }
    if (message.tip !== undefined && message.tip !== BigInt("0")) {
      obj.tip = message.tip.toString();
    }
    if (message.paymasterData?.length) {
      obj.paymasterData = message.paymasterData.map((e) => FieldElement.toJSON(e));
    }
    if (message.accountDeploymentData?.length) {
      obj.accountDeploymentData = message.accountDeploymentData.map((e) => FieldElement.toJSON(e));
    }
    if (message.nonceDataAvailabilityMode !== undefined && message.nonceDataAvailabilityMode !== 0) {
      obj.nonceDataAvailabilityMode = dataAvailabilityModeToJSON(message.nonceDataAvailabilityMode);
    }
    if (message.feeDataAvailabilityMode !== undefined && message.feeDataAvailabilityMode !== 0) {
      obj.feeDataAvailabilityMode = dataAvailabilityModeToJSON(message.feeDataAvailabilityMode);
    }
    return obj;
  },
  create(base) {
    return DeclareTransactionV3$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDeclareTransactionV3();
    message.senderAddress = object.senderAddress !== undefined && object.senderAddress !== null ? FieldElement.fromPartial(object.senderAddress) : undefined;
    message.compiledClassHash = object.compiledClassHash !== undefined && object.compiledClassHash !== null ? FieldElement.fromPartial(object.compiledClassHash) : undefined;
    message.signature = object.signature?.map((e) => FieldElement.fromPartial(e)) || [];
    message.nonce = object.nonce !== undefined && object.nonce !== null ? FieldElement.fromPartial(object.nonce) : undefined;
    message.classHash = object.classHash !== undefined && object.classHash !== null ? FieldElement.fromPartial(object.classHash) : undefined;
    message.resourceBounds = object.resourceBounds !== undefined && object.resourceBounds !== null ? ResourceBoundsMapping$1.fromPartial(object.resourceBounds) : undefined;
    message.tip = object.tip ?? BigInt("0");
    message.paymasterData = object.paymasterData?.map((e) => FieldElement.fromPartial(e)) || [];
    message.accountDeploymentData = object.accountDeploymentData?.map((e) => FieldElement.fromPartial(e)) || [];
    message.nonceDataAvailabilityMode = object.nonceDataAvailabilityMode ?? 0;
    message.feeDataAvailabilityMode = object.feeDataAvailabilityMode ?? 0;
    return message;
  }
};
function createBaseDeployAccountTransactionV1() {
  return {
    maxFee: undefined,
    signature: [],
    nonce: undefined,
    contractAddressSalt: undefined,
    constructorCalldata: [],
    classHash: undefined
  };
}
const DeployAccountTransactionV1$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.maxFee !== undefined) {
      FieldElement.encode(message.maxFee, writer.uint32(10).fork()).ldelim();
    }
    if (message.signature !== undefined && message.signature.length !== 0) {
      for (const v of message.signature) {
        FieldElement.encode(v, writer.uint32(18).fork()).ldelim();
      }
    }
    if (message.nonce !== undefined) {
      FieldElement.encode(message.nonce, writer.uint32(26).fork()).ldelim();
    }
    if (message.contractAddressSalt !== undefined) {
      FieldElement.encode(message.contractAddressSalt, writer.uint32(34).fork()).ldelim();
    }
    if (message.constructorCalldata !== undefined && message.constructorCalldata.length !== 0) {
      for (const v of message.constructorCalldata) {
        FieldElement.encode(v, writer.uint32(42).fork()).ldelim();
      }
    }
    if (message.classHash !== undefined) {
      FieldElement.encode(message.classHash, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployAccountTransactionV1();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.maxFee = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.signature.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.nonce = FieldElement.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.contractAddressSalt = FieldElement.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.constructorCalldata.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.classHash = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      maxFee: isSet$1(object.maxFee) ? FieldElement.fromJSON(object.maxFee) : undefined,
      signature: globalThis.Array.isArray(object?.signature) ? object.signature.map((e) => FieldElement.fromJSON(e)) : [],
      nonce: isSet$1(object.nonce) ? FieldElement.fromJSON(object.nonce) : undefined,
      contractAddressSalt: isSet$1(object.contractAddressSalt) ? FieldElement.fromJSON(object.contractAddressSalt) : undefined,
      constructorCalldata: globalThis.Array.isArray(object?.constructorCalldata) ? object.constructorCalldata.map((e) => FieldElement.fromJSON(e)) : [],
      classHash: isSet$1(object.classHash) ? FieldElement.fromJSON(object.classHash) : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.maxFee !== undefined) {
      obj.maxFee = FieldElement.toJSON(message.maxFee);
    }
    if (message.signature?.length) {
      obj.signature = message.signature.map((e) => FieldElement.toJSON(e));
    }
    if (message.nonce !== undefined) {
      obj.nonce = FieldElement.toJSON(message.nonce);
    }
    if (message.contractAddressSalt !== undefined) {
      obj.contractAddressSalt = FieldElement.toJSON(message.contractAddressSalt);
    }
    if (message.constructorCalldata?.length) {
      obj.constructorCalldata = message.constructorCalldata.map((e) => FieldElement.toJSON(e));
    }
    if (message.classHash !== undefined) {
      obj.classHash = FieldElement.toJSON(message.classHash);
    }
    return obj;
  },
  create(base) {
    return DeployAccountTransactionV1$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDeployAccountTransactionV1();
    message.maxFee = object.maxFee !== undefined && object.maxFee !== null ? FieldElement.fromPartial(object.maxFee) : undefined;
    message.signature = object.signature?.map((e) => FieldElement.fromPartial(e)) || [];
    message.nonce = object.nonce !== undefined && object.nonce !== null ? FieldElement.fromPartial(object.nonce) : undefined;
    message.contractAddressSalt = object.contractAddressSalt !== undefined && object.contractAddressSalt !== null ? FieldElement.fromPartial(object.contractAddressSalt) : undefined;
    message.constructorCalldata = object.constructorCalldata?.map((e) => FieldElement.fromPartial(e)) || [];
    message.classHash = object.classHash !== undefined && object.classHash !== null ? FieldElement.fromPartial(object.classHash) : undefined;
    return message;
  }
};
function createBaseDeployAccountTransactionV3() {
  return {
    signature: [],
    nonce: undefined,
    contractAddressSalt: undefined,
    constructorCalldata: [],
    classHash: undefined,
    resourceBounds: undefined,
    tip: BigInt("0"),
    paymasterData: [],
    nonceDataAvailabilityMode: 0,
    feeDataAvailabilityMode: 0
  };
}
const DeployAccountTransactionV3$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.signature !== undefined && message.signature.length !== 0) {
      for (const v of message.signature) {
        FieldElement.encode(v, writer.uint32(10).fork()).ldelim();
      }
    }
    if (message.nonce !== undefined) {
      FieldElement.encode(message.nonce, writer.uint32(18).fork()).ldelim();
    }
    if (message.contractAddressSalt !== undefined) {
      FieldElement.encode(message.contractAddressSalt, writer.uint32(26).fork()).ldelim();
    }
    if (message.constructorCalldata !== undefined && message.constructorCalldata.length !== 0) {
      for (const v of message.constructorCalldata) {
        FieldElement.encode(v, writer.uint32(34).fork()).ldelim();
      }
    }
    if (message.classHash !== undefined) {
      FieldElement.encode(message.classHash, writer.uint32(42).fork()).ldelim();
    }
    if (message.resourceBounds !== undefined) {
      ResourceBoundsMapping$1.encode(message.resourceBounds, writer.uint32(50).fork()).ldelim();
    }
    if (message.tip !== undefined && message.tip !== BigInt("0")) {
      if (BigInt.asUintN(64, message.tip) !== message.tip) {
        throw new globalThis.Error("value provided for field message.tip of type uint64 too large");
      }
      writer.uint32(56).uint64(message.tip.toString());
    }
    if (message.paymasterData !== undefined && message.paymasterData.length !== 0) {
      for (const v of message.paymasterData) {
        FieldElement.encode(v, writer.uint32(66).fork()).ldelim();
      }
    }
    if (message.nonceDataAvailabilityMode !== undefined && message.nonceDataAvailabilityMode !== 0) {
      writer.uint32(72).int32(message.nonceDataAvailabilityMode);
    }
    if (message.feeDataAvailabilityMode !== undefined && message.feeDataAvailabilityMode !== 0) {
      writer.uint32(80).int32(message.feeDataAvailabilityMode);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployAccountTransactionV3();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.signature.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.nonce = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.contractAddressSalt = FieldElement.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.constructorCalldata.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.classHash = FieldElement.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.resourceBounds = ResourceBoundsMapping$1.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }
          message.tip = longToBigint(reader.uint64());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.paymasterData.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }
          message.nonceDataAvailabilityMode = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }
          message.feeDataAvailabilityMode = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      signature: globalThis.Array.isArray(object?.signature) ? object.signature.map((e) => FieldElement.fromJSON(e)) : [],
      nonce: isSet$1(object.nonce) ? FieldElement.fromJSON(object.nonce) : undefined,
      contractAddressSalt: isSet$1(object.contractAddressSalt) ? FieldElement.fromJSON(object.contractAddressSalt) : undefined,
      constructorCalldata: globalThis.Array.isArray(object?.constructorCalldata) ? object.constructorCalldata.map((e) => FieldElement.fromJSON(e)) : [],
      classHash: isSet$1(object.classHash) ? FieldElement.fromJSON(object.classHash) : undefined,
      resourceBounds: isSet$1(object.resourceBounds) ? ResourceBoundsMapping$1.fromJSON(object.resourceBounds) : undefined,
      tip: isSet$1(object.tip) ? BigInt(object.tip) : BigInt("0"),
      paymasterData: globalThis.Array.isArray(object?.paymasterData) ? object.paymasterData.map((e) => FieldElement.fromJSON(e)) : [],
      nonceDataAvailabilityMode: isSet$1(object.nonceDataAvailabilityMode) ? dataAvailabilityModeFromJSON(object.nonceDataAvailabilityMode) : 0,
      feeDataAvailabilityMode: isSet$1(object.feeDataAvailabilityMode) ? dataAvailabilityModeFromJSON(object.feeDataAvailabilityMode) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.signature?.length) {
      obj.signature = message.signature.map((e) => FieldElement.toJSON(e));
    }
    if (message.nonce !== undefined) {
      obj.nonce = FieldElement.toJSON(message.nonce);
    }
    if (message.contractAddressSalt !== undefined) {
      obj.contractAddressSalt = FieldElement.toJSON(message.contractAddressSalt);
    }
    if (message.constructorCalldata?.length) {
      obj.constructorCalldata = message.constructorCalldata.map((e) => FieldElement.toJSON(e));
    }
    if (message.classHash !== undefined) {
      obj.classHash = FieldElement.toJSON(message.classHash);
    }
    if (message.resourceBounds !== undefined) {
      obj.resourceBounds = ResourceBoundsMapping$1.toJSON(message.resourceBounds);
    }
    if (message.tip !== undefined && message.tip !== BigInt("0")) {
      obj.tip = message.tip.toString();
    }
    if (message.paymasterData?.length) {
      obj.paymasterData = message.paymasterData.map((e) => FieldElement.toJSON(e));
    }
    if (message.nonceDataAvailabilityMode !== undefined && message.nonceDataAvailabilityMode !== 0) {
      obj.nonceDataAvailabilityMode = dataAvailabilityModeToJSON(message.nonceDataAvailabilityMode);
    }
    if (message.feeDataAvailabilityMode !== undefined && message.feeDataAvailabilityMode !== 0) {
      obj.feeDataAvailabilityMode = dataAvailabilityModeToJSON(message.feeDataAvailabilityMode);
    }
    return obj;
  },
  create(base) {
    return DeployAccountTransactionV3$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDeployAccountTransactionV3();
    message.signature = object.signature?.map((e) => FieldElement.fromPartial(e)) || [];
    message.nonce = object.nonce !== undefined && object.nonce !== null ? FieldElement.fromPartial(object.nonce) : undefined;
    message.contractAddressSalt = object.contractAddressSalt !== undefined && object.contractAddressSalt !== null ? FieldElement.fromPartial(object.contractAddressSalt) : undefined;
    message.constructorCalldata = object.constructorCalldata?.map((e) => FieldElement.fromPartial(e)) || [];
    message.classHash = object.classHash !== undefined && object.classHash !== null ? FieldElement.fromPartial(object.classHash) : undefined;
    message.resourceBounds = object.resourceBounds !== undefined && object.resourceBounds !== null ? ResourceBoundsMapping$1.fromPartial(object.resourceBounds) : undefined;
    message.tip = object.tip ?? BigInt("0");
    message.paymasterData = object.paymasterData?.map((e) => FieldElement.fromPartial(e)) || [];
    message.nonceDataAvailabilityMode = object.nonceDataAvailabilityMode ?? 0;
    message.feeDataAvailabilityMode = object.feeDataAvailabilityMode ?? 0;
    return message;
  }
};
function createBaseTransactionReceipt() {
  return { filterIds: [], meta: undefined, receipt: undefined };
}
const TransactionReceipt$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.filterIds !== undefined && message.filterIds.length !== 0) {
      writer.uint32(10).fork();
      for (const v of message.filterIds) {
        writer.uint32(v);
      }
      writer.ldelim();
    }
    if (message.meta !== undefined) {
      TransactionReceiptMeta$1.encode(message.meta, writer.uint32(18).fork()).ldelim();
    }
    switch (message.receipt?.$case) {
      case "invoke":
        InvokeTransactionReceipt$1.encode(message.receipt.invoke, writer.uint32(26).fork()).ldelim();
        break;
      case "l1Handler":
        L1HandlerTransactionReceipt$1.encode(message.receipt.l1Handler, writer.uint32(34).fork()).ldelim();
        break;
      case "declare":
        DeclareTransactionReceipt$1.encode(message.receipt.declare, writer.uint32(42).fork()).ldelim();
        break;
      case "deploy":
        DeployTransactionReceipt$1.encode(message.receipt.deploy, writer.uint32(50).fork()).ldelim();
        break;
      case "deployAccount":
        DeployAccountTransactionReceipt$1.encode(message.receipt.deployAccount, writer.uint32(58).fork()).ldelim();
        break;
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionReceipt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.filterIds.push(reader.uint32());
            continue;
          }
          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.filterIds.push(reader.uint32());
            }
            continue;
          }
          break;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.meta = TransactionReceiptMeta$1.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.receipt = { $case: "invoke", invoke: InvokeTransactionReceipt$1.decode(reader, reader.uint32()) };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.receipt = {
            $case: "l1Handler",
            l1Handler: L1HandlerTransactionReceipt$1.decode(reader, reader.uint32())
          };
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.receipt = { $case: "declare", declare: DeclareTransactionReceipt$1.decode(reader, reader.uint32()) };
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.receipt = { $case: "deploy", deploy: DeployTransactionReceipt$1.decode(reader, reader.uint32()) };
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.receipt = {
            $case: "deployAccount",
            deployAccount: DeployAccountTransactionReceipt$1.decode(reader, reader.uint32())
          };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      filterIds: globalThis.Array.isArray(object?.filterIds) ? object.filterIds.map((e) => globalThis.Number(e)) : [],
      meta: isSet$1(object.meta) ? TransactionReceiptMeta$1.fromJSON(object.meta) : undefined,
      receipt: isSet$1(object.invoke) ? { $case: "invoke", invoke: InvokeTransactionReceipt$1.fromJSON(object.invoke) } : isSet$1(object.l1Handler) ? { $case: "l1Handler", l1Handler: L1HandlerTransactionReceipt$1.fromJSON(object.l1Handler) } : isSet$1(object.declare) ? { $case: "declare", declare: DeclareTransactionReceipt$1.fromJSON(object.declare) } : isSet$1(object.deploy) ? { $case: "deploy", deploy: DeployTransactionReceipt$1.fromJSON(object.deploy) } : isSet$1(object.deployAccount) ? { $case: "deployAccount", deployAccount: DeployAccountTransactionReceipt$1.fromJSON(object.deployAccount) } : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.filterIds?.length) {
      obj.filterIds = message.filterIds.map((e) => Math.round(e));
    }
    if (message.meta !== undefined) {
      obj.meta = TransactionReceiptMeta$1.toJSON(message.meta);
    }
    if (message.receipt?.$case === "invoke") {
      obj.invoke = InvokeTransactionReceipt$1.toJSON(message.receipt.invoke);
    }
    if (message.receipt?.$case === "l1Handler") {
      obj.l1Handler = L1HandlerTransactionReceipt$1.toJSON(message.receipt.l1Handler);
    }
    if (message.receipt?.$case === "declare") {
      obj.declare = DeclareTransactionReceipt$1.toJSON(message.receipt.declare);
    }
    if (message.receipt?.$case === "deploy") {
      obj.deploy = DeployTransactionReceipt$1.toJSON(message.receipt.deploy);
    }
    if (message.receipt?.$case === "deployAccount") {
      obj.deployAccount = DeployAccountTransactionReceipt$1.toJSON(message.receipt.deployAccount);
    }
    return obj;
  },
  create(base) {
    return TransactionReceipt$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTransactionReceipt();
    message.filterIds = object.filterIds?.map((e) => e) || [];
    message.meta = object.meta !== undefined && object.meta !== null ? TransactionReceiptMeta$1.fromPartial(object.meta) : undefined;
    if (object.receipt?.$case === "invoke" && object.receipt?.invoke !== undefined && object.receipt?.invoke !== null) {
      message.receipt = { $case: "invoke", invoke: InvokeTransactionReceipt$1.fromPartial(object.receipt.invoke) };
    }
    if (object.receipt?.$case === "l1Handler" && object.receipt?.l1Handler !== undefined && object.receipt?.l1Handler !== null) {
      message.receipt = {
        $case: "l1Handler",
        l1Handler: L1HandlerTransactionReceipt$1.fromPartial(object.receipt.l1Handler)
      };
    }
    if (object.receipt?.$case === "declare" && object.receipt?.declare !== undefined && object.receipt?.declare !== null) {
      message.receipt = { $case: "declare", declare: DeclareTransactionReceipt$1.fromPartial(object.receipt.declare) };
    }
    if (object.receipt?.$case === "deploy" && object.receipt?.deploy !== undefined && object.receipt?.deploy !== null) {
      message.receipt = { $case: "deploy", deploy: DeployTransactionReceipt$1.fromPartial(object.receipt.deploy) };
    }
    if (object.receipt?.$case === "deployAccount" && object.receipt?.deployAccount !== undefined && object.receipt?.deployAccount !== null) {
      message.receipt = {
        $case: "deployAccount",
        deployAccount: DeployAccountTransactionReceipt$1.fromPartial(object.receipt.deployAccount)
      };
    }
    return message;
  }
};
function createBaseTransactionReceiptMeta() {
  return {
    transactionIndex: 0,
    transactionHash: undefined,
    actualFee: undefined,
    executionResources: undefined,
    executionResult: undefined
  };
}
const TransactionReceiptMeta$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.transactionIndex !== undefined && message.transactionIndex !== 0) {
      writer.uint32(8).uint32(message.transactionIndex);
    }
    if (message.transactionHash !== undefined) {
      FieldElement.encode(message.transactionHash, writer.uint32(18).fork()).ldelim();
    }
    if (message.actualFee !== undefined) {
      FeePayment$1.encode(message.actualFee, writer.uint32(26).fork()).ldelim();
    }
    if (message.executionResources !== undefined) {
      ExecutionResources$1.encode(message.executionResources, writer.uint32(34).fork()).ldelim();
    }
    switch (message.executionResult?.$case) {
      case "succeeded":
        ExecutionSucceeded$1.encode(message.executionResult.succeeded, writer.uint32(42).fork()).ldelim();
        break;
      case "reverted":
        ExecutionReverted$1.encode(message.executionResult.reverted, writer.uint32(50).fork()).ldelim();
        break;
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionReceiptMeta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.transactionIndex = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.transactionHash = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.actualFee = FeePayment$1.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.executionResources = ExecutionResources$1.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.executionResult = {
            $case: "succeeded",
            succeeded: ExecutionSucceeded$1.decode(reader, reader.uint32())
          };
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.executionResult = { $case: "reverted", reverted: ExecutionReverted$1.decode(reader, reader.uint32()) };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      transactionIndex: isSet$1(object.transactionIndex) ? globalThis.Number(object.transactionIndex) : 0,
      transactionHash: isSet$1(object.transactionHash) ? FieldElement.fromJSON(object.transactionHash) : undefined,
      actualFee: isSet$1(object.actualFee) ? FeePayment$1.fromJSON(object.actualFee) : undefined,
      executionResources: isSet$1(object.executionResources) ? ExecutionResources$1.fromJSON(object.executionResources) : undefined,
      executionResult: isSet$1(object.succeeded) ? { $case: "succeeded", succeeded: ExecutionSucceeded$1.fromJSON(object.succeeded) } : isSet$1(object.reverted) ? { $case: "reverted", reverted: ExecutionReverted$1.fromJSON(object.reverted) } : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.transactionIndex !== undefined && message.transactionIndex !== 0) {
      obj.transactionIndex = Math.round(message.transactionIndex);
    }
    if (message.transactionHash !== undefined) {
      obj.transactionHash = FieldElement.toJSON(message.transactionHash);
    }
    if (message.actualFee !== undefined) {
      obj.actualFee = FeePayment$1.toJSON(message.actualFee);
    }
    if (message.executionResources !== undefined) {
      obj.executionResources = ExecutionResources$1.toJSON(message.executionResources);
    }
    if (message.executionResult?.$case === "succeeded") {
      obj.succeeded = ExecutionSucceeded$1.toJSON(message.executionResult.succeeded);
    }
    if (message.executionResult?.$case === "reverted") {
      obj.reverted = ExecutionReverted$1.toJSON(message.executionResult.reverted);
    }
    return obj;
  },
  create(base) {
    return TransactionReceiptMeta$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTransactionReceiptMeta();
    message.transactionIndex = object.transactionIndex ?? 0;
    message.transactionHash = object.transactionHash !== undefined && object.transactionHash !== null ? FieldElement.fromPartial(object.transactionHash) : undefined;
    message.actualFee = object.actualFee !== undefined && object.actualFee !== null ? FeePayment$1.fromPartial(object.actualFee) : undefined;
    message.executionResources = object.executionResources !== undefined && object.executionResources !== null ? ExecutionResources$1.fromPartial(object.executionResources) : undefined;
    if (object.executionResult?.$case === "succeeded" && object.executionResult?.succeeded !== undefined && object.executionResult?.succeeded !== null) {
      message.executionResult = {
        $case: "succeeded",
        succeeded: ExecutionSucceeded$1.fromPartial(object.executionResult.succeeded)
      };
    }
    if (object.executionResult?.$case === "reverted" && object.executionResult?.reverted !== undefined && object.executionResult?.reverted !== null) {
      message.executionResult = {
        $case: "reverted",
        reverted: ExecutionReverted$1.fromPartial(object.executionResult.reverted)
      };
    }
    return message;
  }
};
function createBaseExecutionSucceeded() {
  return {};
}
const ExecutionSucceeded$1 = {
  encode(_, writer = _m0.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionSucceeded();
    while (reader.pos < end) {
      const tag = reader.uint32();
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return ExecutionSucceeded$1.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseExecutionSucceeded();
    return message;
  }
};
function createBaseExecutionReverted() {
  return { reason: "" };
}
const ExecutionReverted$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.reason !== undefined && message.reason !== "") {
      writer.uint32(10).string(message.reason);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionReverted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.reason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { reason: isSet$1(object.reason) ? globalThis.String(object.reason) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.reason !== undefined && message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },
  create(base) {
    return ExecutionReverted$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseExecutionReverted();
    message.reason = object.reason ?? "";
    return message;
  }
};
function createBaseInvokeTransactionReceipt() {
  return {};
}
const InvokeTransactionReceipt$1 = {
  encode(_, writer = _m0.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeTransactionReceipt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return InvokeTransactionReceipt$1.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseInvokeTransactionReceipt();
    return message;
  }
};
function createBaseL1HandlerTransactionReceipt() {
  return { messageHash: new Uint8Array(0) };
}
const L1HandlerTransactionReceipt$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.messageHash !== undefined && message.messageHash.length !== 0) {
      writer.uint32(10).bytes(message.messageHash);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseL1HandlerTransactionReceipt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.messageHash = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { messageHash: isSet$1(object.messageHash) ? bytesFromBase64(object.messageHash) : new Uint8Array(0) };
  },
  toJSON(message) {
    const obj = {};
    if (message.messageHash !== undefined && message.messageHash.length !== 0) {
      obj.messageHash = base64FromBytes(message.messageHash);
    }
    return obj;
  },
  create(base) {
    return L1HandlerTransactionReceipt$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseL1HandlerTransactionReceipt();
    message.messageHash = object.messageHash ?? new Uint8Array(0);
    return message;
  }
};
function createBaseDeclareTransactionReceipt() {
  return {};
}
const DeclareTransactionReceipt$1 = {
  encode(_, writer = _m0.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclareTransactionReceipt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return DeclareTransactionReceipt$1.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseDeclareTransactionReceipt();
    return message;
  }
};
function createBaseDeployTransactionReceipt() {
  return { contractAddress: undefined };
}
const DeployTransactionReceipt$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.contractAddress !== undefined) {
      FieldElement.encode(message.contractAddress, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployTransactionReceipt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.contractAddress = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      contractAddress: isSet$1(object.contractAddress) ? FieldElement.fromJSON(object.contractAddress) : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.contractAddress !== undefined) {
      obj.contractAddress = FieldElement.toJSON(message.contractAddress);
    }
    return obj;
  },
  create(base) {
    return DeployTransactionReceipt$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDeployTransactionReceipt();
    message.contractAddress = object.contractAddress !== undefined && object.contractAddress !== null ? FieldElement.fromPartial(object.contractAddress) : undefined;
    return message;
  }
};
function createBaseDeployAccountTransactionReceipt() {
  return { contractAddress: undefined };
}
const DeployAccountTransactionReceipt$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.contractAddress !== undefined) {
      FieldElement.encode(message.contractAddress, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployAccountTransactionReceipt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.contractAddress = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      contractAddress: isSet$1(object.contractAddress) ? FieldElement.fromJSON(object.contractAddress) : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.contractAddress !== undefined) {
      obj.contractAddress = FieldElement.toJSON(message.contractAddress);
    }
    return obj;
  },
  create(base) {
    return DeployAccountTransactionReceipt$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDeployAccountTransactionReceipt();
    message.contractAddress = object.contractAddress !== undefined && object.contractAddress !== null ? FieldElement.fromPartial(object.contractAddress) : undefined;
    return message;
  }
};
function createBaseEvent() {
  return {
    filterIds: [],
    address: undefined,
    keys: [],
    data: [],
    eventIndex: 0,
    transactionIndex: 0,
    transactionHash: undefined,
    transactionStatus: 0
  };
}
const Event$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.filterIds !== undefined && message.filterIds.length !== 0) {
      writer.uint32(10).fork();
      for (const v of message.filterIds) {
        writer.uint32(v);
      }
      writer.ldelim();
    }
    if (message.address !== undefined) {
      FieldElement.encode(message.address, writer.uint32(18).fork()).ldelim();
    }
    if (message.keys !== undefined && message.keys.length !== 0) {
      for (const v of message.keys) {
        FieldElement.encode(v, writer.uint32(26).fork()).ldelim();
      }
    }
    if (message.data !== undefined && message.data.length !== 0) {
      for (const v of message.data) {
        FieldElement.encode(v, writer.uint32(34).fork()).ldelim();
      }
    }
    if (message.eventIndex !== undefined && message.eventIndex !== 0) {
      writer.uint32(40).uint32(message.eventIndex);
    }
    if (message.transactionIndex !== undefined && message.transactionIndex !== 0) {
      writer.uint32(48).uint32(message.transactionIndex);
    }
    if (message.transactionHash !== undefined) {
      FieldElement.encode(message.transactionHash, writer.uint32(58).fork()).ldelim();
    }
    if (message.transactionStatus !== undefined && message.transactionStatus !== 0) {
      writer.uint32(64).int32(message.transactionStatus);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.filterIds.push(reader.uint32());
            continue;
          }
          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.filterIds.push(reader.uint32());
            }
            continue;
          }
          break;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.address = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.keys.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.data.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.eventIndex = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.transactionIndex = reader.uint32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.transactionHash = FieldElement.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }
          message.transactionStatus = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      filterIds: globalThis.Array.isArray(object?.filterIds) ? object.filterIds.map((e) => globalThis.Number(e)) : [],
      address: isSet$1(object.address) ? FieldElement.fromJSON(object.address) : undefined,
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e) => FieldElement.fromJSON(e)) : [],
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e) => FieldElement.fromJSON(e)) : [],
      eventIndex: isSet$1(object.eventIndex) ? globalThis.Number(object.eventIndex) : 0,
      transactionIndex: isSet$1(object.transactionIndex) ? globalThis.Number(object.transactionIndex) : 0,
      transactionHash: isSet$1(object.transactionHash) ? FieldElement.fromJSON(object.transactionHash) : undefined,
      transactionStatus: isSet$1(object.transactionStatus) ? transactionStatusFromJSON(object.transactionStatus) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.filterIds?.length) {
      obj.filterIds = message.filterIds.map((e) => Math.round(e));
    }
    if (message.address !== undefined) {
      obj.address = FieldElement.toJSON(message.address);
    }
    if (message.keys?.length) {
      obj.keys = message.keys.map((e) => FieldElement.toJSON(e));
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => FieldElement.toJSON(e));
    }
    if (message.eventIndex !== undefined && message.eventIndex !== 0) {
      obj.eventIndex = Math.round(message.eventIndex);
    }
    if (message.transactionIndex !== undefined && message.transactionIndex !== 0) {
      obj.transactionIndex = Math.round(message.transactionIndex);
    }
    if (message.transactionHash !== undefined) {
      obj.transactionHash = FieldElement.toJSON(message.transactionHash);
    }
    if (message.transactionStatus !== undefined && message.transactionStatus !== 0) {
      obj.transactionStatus = transactionStatusToJSON(message.transactionStatus);
    }
    return obj;
  },
  create(base) {
    return Event$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseEvent();
    message.filterIds = object.filterIds?.map((e) => e) || [];
    message.address = object.address !== undefined && object.address !== null ? FieldElement.fromPartial(object.address) : undefined;
    message.keys = object.keys?.map((e) => FieldElement.fromPartial(e)) || [];
    message.data = object.data?.map((e) => FieldElement.fromPartial(e)) || [];
    message.eventIndex = object.eventIndex ?? 0;
    message.transactionIndex = object.transactionIndex ?? 0;
    message.transactionHash = object.transactionHash !== undefined && object.transactionHash !== null ? FieldElement.fromPartial(object.transactionHash) : undefined;
    message.transactionStatus = object.transactionStatus ?? 0;
    return message;
  }
};
function createBaseMessageToL1() {
  return {
    filterIds: [],
    fromAddress: undefined,
    toAddress: undefined,
    payload: [],
    messageIndex: 0,
    transactionIndex: 0,
    transactionHash: undefined,
    transactionStatus: 0
  };
}
const MessageToL1$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.filterIds !== undefined && message.filterIds.length !== 0) {
      writer.uint32(10).fork();
      for (const v of message.filterIds) {
        writer.uint32(v);
      }
      writer.ldelim();
    }
    if (message.fromAddress !== undefined) {
      FieldElement.encode(message.fromAddress, writer.uint32(18).fork()).ldelim();
    }
    if (message.toAddress !== undefined) {
      FieldElement.encode(message.toAddress, writer.uint32(26).fork()).ldelim();
    }
    if (message.payload !== undefined && message.payload.length !== 0) {
      for (const v of message.payload) {
        FieldElement.encode(v, writer.uint32(34).fork()).ldelim();
      }
    }
    if (message.messageIndex !== undefined && message.messageIndex !== 0) {
      writer.uint32(40).uint32(message.messageIndex);
    }
    if (message.transactionIndex !== undefined && message.transactionIndex !== 0) {
      writer.uint32(48).uint32(message.transactionIndex);
    }
    if (message.transactionHash !== undefined) {
      FieldElement.encode(message.transactionHash, writer.uint32(58).fork()).ldelim();
    }
    if (message.transactionStatus !== undefined && message.transactionStatus !== 0) {
      writer.uint32(64).int32(message.transactionStatus);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageToL1();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.filterIds.push(reader.uint32());
            continue;
          }
          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.filterIds.push(reader.uint32());
            }
            continue;
          }
          break;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.fromAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.toAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.payload.push(FieldElement.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.messageIndex = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.transactionIndex = reader.uint32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.transactionHash = FieldElement.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }
          message.transactionStatus = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      filterIds: globalThis.Array.isArray(object?.filterIds) ? object.filterIds.map((e) => globalThis.Number(e)) : [],
      fromAddress: isSet$1(object.fromAddress) ? FieldElement.fromJSON(object.fromAddress) : undefined,
      toAddress: isSet$1(object.toAddress) ? FieldElement.fromJSON(object.toAddress) : undefined,
      payload: globalThis.Array.isArray(object?.payload) ? object.payload.map((e) => FieldElement.fromJSON(e)) : [],
      messageIndex: isSet$1(object.messageIndex) ? globalThis.Number(object.messageIndex) : 0,
      transactionIndex: isSet$1(object.transactionIndex) ? globalThis.Number(object.transactionIndex) : 0,
      transactionHash: isSet$1(object.transactionHash) ? FieldElement.fromJSON(object.transactionHash) : undefined,
      transactionStatus: isSet$1(object.transactionStatus) ? transactionStatusFromJSON(object.transactionStatus) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.filterIds?.length) {
      obj.filterIds = message.filterIds.map((e) => Math.round(e));
    }
    if (message.fromAddress !== undefined) {
      obj.fromAddress = FieldElement.toJSON(message.fromAddress);
    }
    if (message.toAddress !== undefined) {
      obj.toAddress = FieldElement.toJSON(message.toAddress);
    }
    if (message.payload?.length) {
      obj.payload = message.payload.map((e) => FieldElement.toJSON(e));
    }
    if (message.messageIndex !== undefined && message.messageIndex !== 0) {
      obj.messageIndex = Math.round(message.messageIndex);
    }
    if (message.transactionIndex !== undefined && message.transactionIndex !== 0) {
      obj.transactionIndex = Math.round(message.transactionIndex);
    }
    if (message.transactionHash !== undefined) {
      obj.transactionHash = FieldElement.toJSON(message.transactionHash);
    }
    if (message.transactionStatus !== undefined && message.transactionStatus !== 0) {
      obj.transactionStatus = transactionStatusToJSON(message.transactionStatus);
    }
    return obj;
  },
  create(base) {
    return MessageToL1$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMessageToL1();
    message.filterIds = object.filterIds?.map((e) => e) || [];
    message.fromAddress = object.fromAddress !== undefined && object.fromAddress !== null ? FieldElement.fromPartial(object.fromAddress) : undefined;
    message.toAddress = object.toAddress !== undefined && object.toAddress !== null ? FieldElement.fromPartial(object.toAddress) : undefined;
    message.payload = object.payload?.map((e) => FieldElement.fromPartial(e)) || [];
    message.messageIndex = object.messageIndex ?? 0;
    message.transactionIndex = object.transactionIndex ?? 0;
    message.transactionHash = object.transactionHash !== undefined && object.transactionHash !== null ? FieldElement.fromPartial(object.transactionHash) : undefined;
    message.transactionStatus = object.transactionStatus ?? 0;
    return message;
  }
};
function createBaseResourcePrice() {
  return { priceInFri: undefined, priceInWei: undefined };
}
const ResourcePrice$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.priceInFri !== undefined) {
      FieldElement.encode(message.priceInFri, writer.uint32(10).fork()).ldelim();
    }
    if (message.priceInWei !== undefined) {
      FieldElement.encode(message.priceInWei, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourcePrice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.priceInFri = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.priceInWei = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      priceInFri: isSet$1(object.priceInFri) ? FieldElement.fromJSON(object.priceInFri) : undefined,
      priceInWei: isSet$1(object.priceInWei) ? FieldElement.fromJSON(object.priceInWei) : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.priceInFri !== undefined) {
      obj.priceInFri = FieldElement.toJSON(message.priceInFri);
    }
    if (message.priceInWei !== undefined) {
      obj.priceInWei = FieldElement.toJSON(message.priceInWei);
    }
    return obj;
  },
  create(base) {
    return ResourcePrice$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseResourcePrice();
    message.priceInFri = object.priceInFri !== undefined && object.priceInFri !== null ? FieldElement.fromPartial(object.priceInFri) : undefined;
    message.priceInWei = object.priceInWei !== undefined && object.priceInWei !== null ? FieldElement.fromPartial(object.priceInWei) : undefined;
    return message;
  }
};
function createBaseFeePayment() {
  return { amount: undefined, unit: 0 };
}
const FeePayment$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.amount !== undefined) {
      FieldElement.encode(message.amount, writer.uint32(10).fork()).ldelim();
    }
    if (message.unit !== undefined && message.unit !== 0) {
      writer.uint32(16).int32(message.unit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeePayment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.amount = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.unit = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      amount: isSet$1(object.amount) ? FieldElement.fromJSON(object.amount) : undefined,
      unit: isSet$1(object.unit) ? priceUnitFromJSON(object.unit) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.amount !== undefined) {
      obj.amount = FieldElement.toJSON(message.amount);
    }
    if (message.unit !== undefined && message.unit !== 0) {
      obj.unit = priceUnitToJSON(message.unit);
    }
    return obj;
  },
  create(base) {
    return FeePayment$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFeePayment();
    message.amount = object.amount !== undefined && object.amount !== null ? FieldElement.fromPartial(object.amount) : undefined;
    message.unit = object.unit ?? 0;
    return message;
  }
};
function createBaseExecutionResources() {
  return { computation: undefined, dataAvailability: undefined };
}
const ExecutionResources$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.computation !== undefined) {
      ComputationResources$1.encode(message.computation, writer.uint32(10).fork()).ldelim();
    }
    if (message.dataAvailability !== undefined) {
      DataAvailabilityResources$1.encode(message.dataAvailability, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionResources();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.computation = ComputationResources$1.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.dataAvailability = DataAvailabilityResources$1.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      computation: isSet$1(object.computation) ? ComputationResources$1.fromJSON(object.computation) : undefined,
      dataAvailability: isSet$1(object.dataAvailability) ? DataAvailabilityResources$1.fromJSON(object.dataAvailability) : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.computation !== undefined) {
      obj.computation = ComputationResources$1.toJSON(message.computation);
    }
    if (message.dataAvailability !== undefined) {
      obj.dataAvailability = DataAvailabilityResources$1.toJSON(message.dataAvailability);
    }
    return obj;
  },
  create(base) {
    return ExecutionResources$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseExecutionResources();
    message.computation = object.computation !== undefined && object.computation !== null ? ComputationResources$1.fromPartial(object.computation) : undefined;
    message.dataAvailability = object.dataAvailability !== undefined && object.dataAvailability !== null ? DataAvailabilityResources$1.fromPartial(object.dataAvailability) : undefined;
    return message;
  }
};
function createBaseComputationResources() {
  return {
    steps: BigInt("0"),
    memoryHoles: undefined,
    rangeCheckBuiltinApplications: undefined,
    pedersenBuiltinApplications: undefined,
    poseidonBuiltinApplications: undefined,
    ecOpBuiltinApplications: undefined,
    ecdsaBuiltinApplications: undefined,
    bitwiseBuiltinApplications: undefined,
    keccakBuiltinApplications: undefined,
    segmentArenaBuiltin: undefined
  };
}
const ComputationResources$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.steps !== undefined && message.steps !== BigInt("0")) {
      if (BigInt.asUintN(64, message.steps) !== message.steps) {
        throw new globalThis.Error("value provided for field message.steps of type uint64 too large");
      }
      writer.uint32(8).uint64(message.steps.toString());
    }
    if (message.memoryHoles !== undefined) {
      if (BigInt.asUintN(64, message.memoryHoles) !== message.memoryHoles) {
        throw new globalThis.Error("value provided for field message.memoryHoles of type uint64 too large");
      }
      writer.uint32(16).uint64(message.memoryHoles.toString());
    }
    if (message.rangeCheckBuiltinApplications !== undefined) {
      if (BigInt.asUintN(64, message.rangeCheckBuiltinApplications) !== message.rangeCheckBuiltinApplications) {
        throw new globalThis.Error(
          "value provided for field message.rangeCheckBuiltinApplications of type uint64 too large"
        );
      }
      writer.uint32(24).uint64(message.rangeCheckBuiltinApplications.toString());
    }
    if (message.pedersenBuiltinApplications !== undefined) {
      if (BigInt.asUintN(64, message.pedersenBuiltinApplications) !== message.pedersenBuiltinApplications) {
        throw new globalThis.Error(
          "value provided for field message.pedersenBuiltinApplications of type uint64 too large"
        );
      }
      writer.uint32(32).uint64(message.pedersenBuiltinApplications.toString());
    }
    if (message.poseidonBuiltinApplications !== undefined) {
      if (BigInt.asUintN(64, message.poseidonBuiltinApplications) !== message.poseidonBuiltinApplications) {
        throw new globalThis.Error(
          "value provided for field message.poseidonBuiltinApplications of type uint64 too large"
        );
      }
      writer.uint32(40).uint64(message.poseidonBuiltinApplications.toString());
    }
    if (message.ecOpBuiltinApplications !== undefined) {
      if (BigInt.asUintN(64, message.ecOpBuiltinApplications) !== message.ecOpBuiltinApplications) {
        throw new globalThis.Error("value provided for field message.ecOpBuiltinApplications of type uint64 too large");
      }
      writer.uint32(48).uint64(message.ecOpBuiltinApplications.toString());
    }
    if (message.ecdsaBuiltinApplications !== undefined) {
      if (BigInt.asUintN(64, message.ecdsaBuiltinApplications) !== message.ecdsaBuiltinApplications) {
        throw new globalThis.Error(
          "value provided for field message.ecdsaBuiltinApplications of type uint64 too large"
        );
      }
      writer.uint32(56).uint64(message.ecdsaBuiltinApplications.toString());
    }
    if (message.bitwiseBuiltinApplications !== undefined) {
      if (BigInt.asUintN(64, message.bitwiseBuiltinApplications) !== message.bitwiseBuiltinApplications) {
        throw new globalThis.Error(
          "value provided for field message.bitwiseBuiltinApplications of type uint64 too large"
        );
      }
      writer.uint32(64).uint64(message.bitwiseBuiltinApplications.toString());
    }
    if (message.keccakBuiltinApplications !== undefined) {
      if (BigInt.asUintN(64, message.keccakBuiltinApplications) !== message.keccakBuiltinApplications) {
        throw new globalThis.Error(
          "value provided for field message.keccakBuiltinApplications of type uint64 too large"
        );
      }
      writer.uint32(72).uint64(message.keccakBuiltinApplications.toString());
    }
    if (message.segmentArenaBuiltin !== undefined) {
      if (BigInt.asUintN(64, message.segmentArenaBuiltin) !== message.segmentArenaBuiltin) {
        throw new globalThis.Error("value provided for field message.segmentArenaBuiltin of type uint64 too large");
      }
      writer.uint32(80).uint64(message.segmentArenaBuiltin.toString());
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputationResources();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.steps = longToBigint(reader.uint64());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.memoryHoles = longToBigint(reader.uint64());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.rangeCheckBuiltinApplications = longToBigint(reader.uint64());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.pedersenBuiltinApplications = longToBigint(reader.uint64());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.poseidonBuiltinApplications = longToBigint(reader.uint64());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.ecOpBuiltinApplications = longToBigint(reader.uint64());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }
          message.ecdsaBuiltinApplications = longToBigint(reader.uint64());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }
          message.bitwiseBuiltinApplications = longToBigint(reader.uint64());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }
          message.keccakBuiltinApplications = longToBigint(reader.uint64());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }
          message.segmentArenaBuiltin = longToBigint(reader.uint64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      steps: isSet$1(object.steps) ? BigInt(object.steps) : BigInt("0"),
      memoryHoles: isSet$1(object.memoryHoles) ? BigInt(object.memoryHoles) : undefined,
      rangeCheckBuiltinApplications: isSet$1(object.rangeCheckBuiltinApplications) ? BigInt(object.rangeCheckBuiltinApplications) : undefined,
      pedersenBuiltinApplications: isSet$1(object.pedersenBuiltinApplications) ? BigInt(object.pedersenBuiltinApplications) : undefined,
      poseidonBuiltinApplications: isSet$1(object.poseidonBuiltinApplications) ? BigInt(object.poseidonBuiltinApplications) : undefined,
      ecOpBuiltinApplications: isSet$1(object.ecOpBuiltinApplications) ? BigInt(object.ecOpBuiltinApplications) : undefined,
      ecdsaBuiltinApplications: isSet$1(object.ecdsaBuiltinApplications) ? BigInt(object.ecdsaBuiltinApplications) : undefined,
      bitwiseBuiltinApplications: isSet$1(object.bitwiseBuiltinApplications) ? BigInt(object.bitwiseBuiltinApplications) : undefined,
      keccakBuiltinApplications: isSet$1(object.keccakBuiltinApplications) ? BigInt(object.keccakBuiltinApplications) : undefined,
      segmentArenaBuiltin: isSet$1(object.segmentArenaBuiltin) ? BigInt(object.segmentArenaBuiltin) : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.steps !== undefined && message.steps !== BigInt("0")) {
      obj.steps = message.steps.toString();
    }
    if (message.memoryHoles !== undefined) {
      obj.memoryHoles = message.memoryHoles.toString();
    }
    if (message.rangeCheckBuiltinApplications !== undefined) {
      obj.rangeCheckBuiltinApplications = message.rangeCheckBuiltinApplications.toString();
    }
    if (message.pedersenBuiltinApplications !== undefined) {
      obj.pedersenBuiltinApplications = message.pedersenBuiltinApplications.toString();
    }
    if (message.poseidonBuiltinApplications !== undefined) {
      obj.poseidonBuiltinApplications = message.poseidonBuiltinApplications.toString();
    }
    if (message.ecOpBuiltinApplications !== undefined) {
      obj.ecOpBuiltinApplications = message.ecOpBuiltinApplications.toString();
    }
    if (message.ecdsaBuiltinApplications !== undefined) {
      obj.ecdsaBuiltinApplications = message.ecdsaBuiltinApplications.toString();
    }
    if (message.bitwiseBuiltinApplications !== undefined) {
      obj.bitwiseBuiltinApplications = message.bitwiseBuiltinApplications.toString();
    }
    if (message.keccakBuiltinApplications !== undefined) {
      obj.keccakBuiltinApplications = message.keccakBuiltinApplications.toString();
    }
    if (message.segmentArenaBuiltin !== undefined) {
      obj.segmentArenaBuiltin = message.segmentArenaBuiltin.toString();
    }
    return obj;
  },
  create(base) {
    return ComputationResources$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseComputationResources();
    message.steps = object.steps ?? BigInt("0");
    message.memoryHoles = object.memoryHoles ?? undefined;
    message.rangeCheckBuiltinApplications = object.rangeCheckBuiltinApplications ?? undefined;
    message.pedersenBuiltinApplications = object.pedersenBuiltinApplications ?? undefined;
    message.poseidonBuiltinApplications = object.poseidonBuiltinApplications ?? undefined;
    message.ecOpBuiltinApplications = object.ecOpBuiltinApplications ?? undefined;
    message.ecdsaBuiltinApplications = object.ecdsaBuiltinApplications ?? undefined;
    message.bitwiseBuiltinApplications = object.bitwiseBuiltinApplications ?? undefined;
    message.keccakBuiltinApplications = object.keccakBuiltinApplications ?? undefined;
    message.segmentArenaBuiltin = object.segmentArenaBuiltin ?? undefined;
    return message;
  }
};
function createBaseDataAvailabilityResources() {
  return { l1Gas: BigInt("0"), l1DataGas: BigInt("0") };
}
const DataAvailabilityResources$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.l1Gas !== undefined && message.l1Gas !== BigInt("0")) {
      if (BigInt.asUintN(64, message.l1Gas) !== message.l1Gas) {
        throw new globalThis.Error("value provided for field message.l1Gas of type uint64 too large");
      }
      writer.uint32(8).uint64(message.l1Gas.toString());
    }
    if (message.l1DataGas !== undefined && message.l1DataGas !== BigInt("0")) {
      if (BigInt.asUintN(64, message.l1DataGas) !== message.l1DataGas) {
        throw new globalThis.Error("value provided for field message.l1DataGas of type uint64 too large");
      }
      writer.uint32(16).uint64(message.l1DataGas.toString());
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataAvailabilityResources();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.l1Gas = longToBigint(reader.uint64());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.l1DataGas = longToBigint(reader.uint64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      l1Gas: isSet$1(object.l1Gas) ? BigInt(object.l1Gas) : BigInt("0"),
      l1DataGas: isSet$1(object.l1DataGas) ? BigInt(object.l1DataGas) : BigInt("0")
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.l1Gas !== undefined && message.l1Gas !== BigInt("0")) {
      obj.l1Gas = message.l1Gas.toString();
    }
    if (message.l1DataGas !== undefined && message.l1DataGas !== BigInt("0")) {
      obj.l1DataGas = message.l1DataGas.toString();
    }
    return obj;
  },
  create(base) {
    return DataAvailabilityResources$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDataAvailabilityResources();
    message.l1Gas = object.l1Gas ?? BigInt("0");
    message.l1DataGas = object.l1DataGas ?? BigInt("0");
    return message;
  }
};
function createBaseResourceBoundsMapping() {
  return { l1Gas: undefined, l2Gas: undefined };
}
const ResourceBoundsMapping$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.l1Gas !== undefined) {
      ResourceBounds$1.encode(message.l1Gas, writer.uint32(10).fork()).ldelim();
    }
    if (message.l2Gas !== undefined) {
      ResourceBounds$1.encode(message.l2Gas, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceBoundsMapping();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.l1Gas = ResourceBounds$1.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.l2Gas = ResourceBounds$1.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      l1Gas: isSet$1(object.l1Gas) ? ResourceBounds$1.fromJSON(object.l1Gas) : undefined,
      l2Gas: isSet$1(object.l2Gas) ? ResourceBounds$1.fromJSON(object.l2Gas) : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.l1Gas !== undefined) {
      obj.l1Gas = ResourceBounds$1.toJSON(message.l1Gas);
    }
    if (message.l2Gas !== undefined) {
      obj.l2Gas = ResourceBounds$1.toJSON(message.l2Gas);
    }
    return obj;
  },
  create(base) {
    return ResourceBoundsMapping$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseResourceBoundsMapping();
    message.l1Gas = object.l1Gas !== undefined && object.l1Gas !== null ? ResourceBounds$1.fromPartial(object.l1Gas) : undefined;
    message.l2Gas = object.l2Gas !== undefined && object.l2Gas !== null ? ResourceBounds$1.fromPartial(object.l2Gas) : undefined;
    return message;
  }
};
function createBaseResourceBounds() {
  return { maxAmount: BigInt("0"), maxPricePerUnit: undefined };
}
const ResourceBounds$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.maxAmount !== undefined && message.maxAmount !== BigInt("0")) {
      if (BigInt.asUintN(64, message.maxAmount) !== message.maxAmount) {
        throw new globalThis.Error("value provided for field message.maxAmount of type uint64 too large");
      }
      writer.uint32(8).uint64(message.maxAmount.toString());
    }
    if (message.maxPricePerUnit !== undefined) {
      Uint128.encode(message.maxPricePerUnit, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceBounds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.maxAmount = longToBigint(reader.uint64());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.maxPricePerUnit = Uint128.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      maxAmount: isSet$1(object.maxAmount) ? BigInt(object.maxAmount) : BigInt("0"),
      maxPricePerUnit: isSet$1(object.maxPricePerUnit) ? Uint128.fromJSON(object.maxPricePerUnit) : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.maxAmount !== undefined && message.maxAmount !== BigInt("0")) {
      obj.maxAmount = message.maxAmount.toString();
    }
    if (message.maxPricePerUnit !== undefined) {
      obj.maxPricePerUnit = Uint128.toJSON(message.maxPricePerUnit);
    }
    return obj;
  },
  create(base) {
    return ResourceBounds$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseResourceBounds();
    message.maxAmount = object.maxAmount ?? BigInt("0");
    message.maxPricePerUnit = object.maxPricePerUnit !== undefined && object.maxPricePerUnit !== null ? Uint128.fromPartial(object.maxPricePerUnit) : undefined;
    return message;
  }
};
function createBaseUint128() {
  return { x0: BigInt("0"), x1: BigInt("0") };
}
const Uint128 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.x0 !== undefined && message.x0 !== BigInt("0")) {
      if (BigInt.asUintN(64, message.x0) !== message.x0) {
        throw new globalThis.Error("value provided for field message.x0 of type uint64 too large");
      }
      writer.uint32(8).uint64(message.x0.toString());
    }
    if (message.x1 !== undefined && message.x1 !== BigInt("0")) {
      if (BigInt.asUintN(64, message.x1) !== message.x1) {
        throw new globalThis.Error("value provided for field message.x1 of type uint64 too large");
      }
      writer.uint32(16).uint64(message.x1.toString());
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUint128();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.x0 = longToBigint(reader.uint64());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.x1 = longToBigint(reader.uint64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      x0: isSet$1(object.x0) ? BigInt(object.x0) : BigInt("0"),
      x1: isSet$1(object.x1) ? BigInt(object.x1) : BigInt("0")
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.x0 !== undefined && message.x0 !== BigInt("0")) {
      obj.x0 = message.x0.toString();
    }
    if (message.x1 !== undefined && message.x1 !== BigInt("0")) {
      obj.x1 = message.x1.toString();
    }
    return obj;
  },
  create(base) {
    return Uint128.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUint128();
    message.x0 = object.x0 ?? BigInt("0");
    message.x1 = object.x1 ?? BigInt("0");
    return message;
  }
};
function createBaseStorageDiff() {
  return { filterIds: [], contractAddress: undefined, storageEntries: [] };
}
const StorageDiff$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.filterIds !== undefined && message.filterIds.length !== 0) {
      writer.uint32(10).fork();
      for (const v of message.filterIds) {
        writer.uint32(v);
      }
      writer.ldelim();
    }
    if (message.contractAddress !== undefined) {
      FieldElement.encode(message.contractAddress, writer.uint32(18).fork()).ldelim();
    }
    if (message.storageEntries !== undefined && message.storageEntries.length !== 0) {
      for (const v of message.storageEntries) {
        StorageEntry$1.encode(v, writer.uint32(26).fork()).ldelim();
      }
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorageDiff();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.filterIds.push(reader.uint32());
            continue;
          }
          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.filterIds.push(reader.uint32());
            }
            continue;
          }
          break;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.contractAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.storageEntries.push(StorageEntry$1.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      filterIds: globalThis.Array.isArray(object?.filterIds) ? object.filterIds.map((e) => globalThis.Number(e)) : [],
      contractAddress: isSet$1(object.contractAddress) ? FieldElement.fromJSON(object.contractAddress) : undefined,
      storageEntries: globalThis.Array.isArray(object?.storageEntries) ? object.storageEntries.map((e) => StorageEntry$1.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.filterIds?.length) {
      obj.filterIds = message.filterIds.map((e) => Math.round(e));
    }
    if (message.contractAddress !== undefined) {
      obj.contractAddress = FieldElement.toJSON(message.contractAddress);
    }
    if (message.storageEntries?.length) {
      obj.storageEntries = message.storageEntries.map((e) => StorageEntry$1.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return StorageDiff$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStorageDiff();
    message.filterIds = object.filterIds?.map((e) => e) || [];
    message.contractAddress = object.contractAddress !== undefined && object.contractAddress !== null ? FieldElement.fromPartial(object.contractAddress) : undefined;
    message.storageEntries = object.storageEntries?.map((e) => StorageEntry$1.fromPartial(e)) || [];
    return message;
  }
};
function createBaseStorageEntry() {
  return { key: undefined, value: undefined };
}
const StorageEntry$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.key !== undefined) {
      FieldElement.encode(message.key, writer.uint32(10).fork()).ldelim();
    }
    if (message.value !== undefined) {
      FieldElement.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorageEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.key = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.value = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet$1(object.key) ? FieldElement.fromJSON(object.key) : undefined,
      value: isSet$1(object.value) ? FieldElement.fromJSON(object.value) : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== undefined) {
      obj.key = FieldElement.toJSON(message.key);
    }
    if (message.value !== undefined) {
      obj.value = FieldElement.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return StorageEntry$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStorageEntry();
    message.key = object.key !== undefined && object.key !== null ? FieldElement.fromPartial(object.key) : undefined;
    message.value = object.value !== undefined && object.value !== null ? FieldElement.fromPartial(object.value) : undefined;
    return message;
  }
};
function createBaseContractChange() {
  return { filterIds: [], change: undefined };
}
const ContractChange$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.filterIds !== undefined && message.filterIds.length !== 0) {
      writer.uint32(10).fork();
      for (const v of message.filterIds) {
        writer.uint32(v);
      }
      writer.ldelim();
    }
    switch (message.change?.$case) {
      case "declaredClass":
        DeclaredClass$1.encode(message.change.declaredClass, writer.uint32(18).fork()).ldelim();
        break;
      case "replacedClass":
        ReplacedClass$1.encode(message.change.replacedClass, writer.uint32(26).fork()).ldelim();
        break;
      case "deployedContract":
        DeployedContract$1.encode(message.change.deployedContract, writer.uint32(34).fork()).ldelim();
        break;
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.filterIds.push(reader.uint32());
            continue;
          }
          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.filterIds.push(reader.uint32());
            }
            continue;
          }
          break;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.change = { $case: "declaredClass", declaredClass: DeclaredClass$1.decode(reader, reader.uint32()) };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.change = { $case: "replacedClass", replacedClass: ReplacedClass$1.decode(reader, reader.uint32()) };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.change = {
            $case: "deployedContract",
            deployedContract: DeployedContract$1.decode(reader, reader.uint32())
          };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      filterIds: globalThis.Array.isArray(object?.filterIds) ? object.filterIds.map((e) => globalThis.Number(e)) : [],
      change: isSet$1(object.declaredClass) ? { $case: "declaredClass", declaredClass: DeclaredClass$1.fromJSON(object.declaredClass) } : isSet$1(object.replacedClass) ? { $case: "replacedClass", replacedClass: ReplacedClass$1.fromJSON(object.replacedClass) } : isSet$1(object.deployedContract) ? { $case: "deployedContract", deployedContract: DeployedContract$1.fromJSON(object.deployedContract) } : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.filterIds?.length) {
      obj.filterIds = message.filterIds.map((e) => Math.round(e));
    }
    if (message.change?.$case === "declaredClass") {
      obj.declaredClass = DeclaredClass$1.toJSON(message.change.declaredClass);
    }
    if (message.change?.$case === "replacedClass") {
      obj.replacedClass = ReplacedClass$1.toJSON(message.change.replacedClass);
    }
    if (message.change?.$case === "deployedContract") {
      obj.deployedContract = DeployedContract$1.toJSON(message.change.deployedContract);
    }
    return obj;
  },
  create(base) {
    return ContractChange$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContractChange();
    message.filterIds = object.filterIds?.map((e) => e) || [];
    if (object.change?.$case === "declaredClass" && object.change?.declaredClass !== undefined && object.change?.declaredClass !== null) {
      message.change = {
        $case: "declaredClass",
        declaredClass: DeclaredClass$1.fromPartial(object.change.declaredClass)
      };
    }
    if (object.change?.$case === "replacedClass" && object.change?.replacedClass !== undefined && object.change?.replacedClass !== null) {
      message.change = {
        $case: "replacedClass",
        replacedClass: ReplacedClass$1.fromPartial(object.change.replacedClass)
      };
    }
    if (object.change?.$case === "deployedContract" && object.change?.deployedContract !== undefined && object.change?.deployedContract !== null) {
      message.change = {
        $case: "deployedContract",
        deployedContract: DeployedContract$1.fromPartial(object.change.deployedContract)
      };
    }
    return message;
  }
};
function createBaseDeclaredClass() {
  return { classHash: undefined, compiledClassHash: undefined };
}
const DeclaredClass$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.classHash !== undefined) {
      FieldElement.encode(message.classHash, writer.uint32(10).fork()).ldelim();
    }
    if (message.compiledClassHash !== undefined) {
      FieldElement.encode(message.compiledClassHash, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclaredClass();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.classHash = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.compiledClassHash = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      classHash: isSet$1(object.classHash) ? FieldElement.fromJSON(object.classHash) : undefined,
      compiledClassHash: isSet$1(object.compiledClassHash) ? FieldElement.fromJSON(object.compiledClassHash) : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.classHash !== undefined) {
      obj.classHash = FieldElement.toJSON(message.classHash);
    }
    if (message.compiledClassHash !== undefined) {
      obj.compiledClassHash = FieldElement.toJSON(message.compiledClassHash);
    }
    return obj;
  },
  create(base) {
    return DeclaredClass$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDeclaredClass();
    message.classHash = object.classHash !== undefined && object.classHash !== null ? FieldElement.fromPartial(object.classHash) : undefined;
    message.compiledClassHash = object.compiledClassHash !== undefined && object.compiledClassHash !== null ? FieldElement.fromPartial(object.compiledClassHash) : undefined;
    return message;
  }
};
function createBaseReplacedClass() {
  return { contractAddress: undefined, classHash: undefined };
}
const ReplacedClass$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.contractAddress !== undefined) {
      FieldElement.encode(message.contractAddress, writer.uint32(10).fork()).ldelim();
    }
    if (message.classHash !== undefined) {
      FieldElement.encode(message.classHash, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplacedClass();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.contractAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.classHash = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      contractAddress: isSet$1(object.contractAddress) ? FieldElement.fromJSON(object.contractAddress) : undefined,
      classHash: isSet$1(object.classHash) ? FieldElement.fromJSON(object.classHash) : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.contractAddress !== undefined) {
      obj.contractAddress = FieldElement.toJSON(message.contractAddress);
    }
    if (message.classHash !== undefined) {
      obj.classHash = FieldElement.toJSON(message.classHash);
    }
    return obj;
  },
  create(base) {
    return ReplacedClass$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseReplacedClass();
    message.contractAddress = object.contractAddress !== undefined && object.contractAddress !== null ? FieldElement.fromPartial(object.contractAddress) : undefined;
    message.classHash = object.classHash !== undefined && object.classHash !== null ? FieldElement.fromPartial(object.classHash) : undefined;
    return message;
  }
};
function createBaseDeployedContract() {
  return { contractAddress: undefined, classHash: undefined };
}
const DeployedContract$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.contractAddress !== undefined) {
      FieldElement.encode(message.contractAddress, writer.uint32(10).fork()).ldelim();
    }
    if (message.classHash !== undefined) {
      FieldElement.encode(message.classHash, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployedContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.contractAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.classHash = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      contractAddress: isSet$1(object.contractAddress) ? FieldElement.fromJSON(object.contractAddress) : undefined,
      classHash: isSet$1(object.classHash) ? FieldElement.fromJSON(object.classHash) : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.contractAddress !== undefined) {
      obj.contractAddress = FieldElement.toJSON(message.contractAddress);
    }
    if (message.classHash !== undefined) {
      obj.classHash = FieldElement.toJSON(message.classHash);
    }
    return obj;
  },
  create(base) {
    return DeployedContract$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDeployedContract();
    message.contractAddress = object.contractAddress !== undefined && object.contractAddress !== null ? FieldElement.fromPartial(object.contractAddress) : undefined;
    message.classHash = object.classHash !== undefined && object.classHash !== null ? FieldElement.fromPartial(object.classHash) : undefined;
    return message;
  }
};
function createBaseNonceUpdate() {
  return { filterIds: [], contractAddress: undefined, nonce: undefined };
}
const NonceUpdate$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.filterIds !== undefined && message.filterIds.length !== 0) {
      writer.uint32(10).fork();
      for (const v of message.filterIds) {
        writer.uint32(v);
      }
      writer.ldelim();
    }
    if (message.contractAddress !== undefined) {
      FieldElement.encode(message.contractAddress, writer.uint32(18).fork()).ldelim();
    }
    if (message.nonce !== undefined) {
      FieldElement.encode(message.nonce, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNonceUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.filterIds.push(reader.uint32());
            continue;
          }
          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.filterIds.push(reader.uint32());
            }
            continue;
          }
          break;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.contractAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.nonce = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      filterIds: globalThis.Array.isArray(object?.filterIds) ? object.filterIds.map((e) => globalThis.Number(e)) : [],
      contractAddress: isSet$1(object.contractAddress) ? FieldElement.fromJSON(object.contractAddress) : undefined,
      nonce: isSet$1(object.nonce) ? FieldElement.fromJSON(object.nonce) : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.filterIds?.length) {
      obj.filterIds = message.filterIds.map((e) => Math.round(e));
    }
    if (message.contractAddress !== undefined) {
      obj.contractAddress = FieldElement.toJSON(message.contractAddress);
    }
    if (message.nonce !== undefined) {
      obj.nonce = FieldElement.toJSON(message.nonce);
    }
    return obj;
  },
  create(base) {
    return NonceUpdate$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseNonceUpdate();
    message.filterIds = object.filterIds?.map((e) => e) || [];
    message.contractAddress = object.contractAddress !== undefined && object.contractAddress !== null ? FieldElement.fromPartial(object.contractAddress) : undefined;
    message.nonce = object.nonce !== undefined && object.nonce !== null ? FieldElement.fromPartial(object.nonce) : undefined;
    return message;
  }
};
function bytesFromBase64(b64) {
  if (globalThis.Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes(arr) {
  if (globalThis.Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}
function toTimestamp(date) {
  const seconds = BigInt(Math.trunc(date.getTime() / 1e3));
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp(t) {
  let millis = (globalThis.Number(t.seconds?.toString()) || 0) * 1e3;
  millis += (t.nanos || 0) / 1e6;
  return new globalThis.Date(millis);
}
function fromJsonTimestamp(o) {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}
function longToBigint(long) {
  return BigInt(long.toString());
}
if (_m0.util.Long !== Long) {
  _m0.util.Long = Long;
  _m0.configure();
}
function isSet$1(value) {
  return value !== null && value !== undefined;
}
var HeaderFilter$1 = /* @__PURE__ */ ((HeaderFilter2) => {
  HeaderFilter2[HeaderFilter2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  HeaderFilter2[HeaderFilter2["ALWAYS"] = 1] = "ALWAYS";
  HeaderFilter2[HeaderFilter2["ON_DATA"] = 2] = "ON_DATA";
  HeaderFilter2[HeaderFilter2["ON_DATA_OR_ON_NEW_BLOCK"] = 3] = "ON_DATA_OR_ON_NEW_BLOCK";
  HeaderFilter2[HeaderFilter2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  return HeaderFilter2;
})(HeaderFilter$1 || {});
function headerFilterFromJSON(object) {
  switch (object) {
    case 0:
    case "HEADER_FILTER_UNSPECIFIED":
      return 0 /* UNSPECIFIED */;
    case 1:
    case "HEADER_FILTER_ALWAYS":
      return 1 /* ALWAYS */;
    case 2:
    case "HEADER_FILTER_ON_DATA":
      return 2 /* ON_DATA */;
    case 3:
    case "HEADER_FILTER_ON_DATA_OR_ON_NEW_BLOCK":
      return 3 /* ON_DATA_OR_ON_NEW_BLOCK */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function headerFilterToJSON(object) {
  switch (object) {
    case 0 /* UNSPECIFIED */:
      return "HEADER_FILTER_UNSPECIFIED";
    case 1 /* ALWAYS */:
      return "HEADER_FILTER_ALWAYS";
    case 2 /* ON_DATA */:
      return "HEADER_FILTER_ON_DATA";
    case 3 /* ON_DATA_OR_ON_NEW_BLOCK */:
      return "HEADER_FILTER_ON_DATA_OR_ON_NEW_BLOCK";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
var TransactionStatusFilter$1 = /* @__PURE__ */ ((TransactionStatusFilter2) => {
  TransactionStatusFilter2[TransactionStatusFilter2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  TransactionStatusFilter2[TransactionStatusFilter2["SUCCEEDED"] = 1] = "SUCCEEDED";
  TransactionStatusFilter2[TransactionStatusFilter2["REVERTED"] = 2] = "REVERTED";
  TransactionStatusFilter2[TransactionStatusFilter2["ALL"] = 3] = "ALL";
  TransactionStatusFilter2[TransactionStatusFilter2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  return TransactionStatusFilter2;
})(TransactionStatusFilter$1 || {});
function transactionStatusFilterFromJSON(object) {
  switch (object) {
    case 0:
    case "TRANSACTION_STATUS_FILTER_UNSPECIFIED":
      return 0 /* UNSPECIFIED */;
    case 1:
    case "TRANSACTION_STATUS_FILTER_SUCCEEDED":
      return 1 /* SUCCEEDED */;
    case 2:
    case "TRANSACTION_STATUS_FILTER_REVERTED":
      return 2 /* REVERTED */;
    case 3:
    case "TRANSACTION_STATUS_FILTER_ALL":
      return 3 /* ALL */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function transactionStatusFilterToJSON(object) {
  switch (object) {
    case 0 /* UNSPECIFIED */:
      return "TRANSACTION_STATUS_FILTER_UNSPECIFIED";
    case 1 /* SUCCEEDED */:
      return "TRANSACTION_STATUS_FILTER_SUCCEEDED";
    case 2 /* REVERTED */:
      return "TRANSACTION_STATUS_FILTER_REVERTED";
    case 3 /* ALL */:
      return "TRANSACTION_STATUS_FILTER_ALL";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function createBaseFilter() {
  return {
    header: 0,
    transactions: [],
    events: [],
    messages: [],
    storageDiffs: [],
    contractChanges: [],
    nonceUpdates: []
  };
}
const Filter$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.header !== undefined && message.header !== 0) {
      writer.uint32(8).int32(message.header);
    }
    if (message.transactions !== undefined && message.transactions.length !== 0) {
      for (const v of message.transactions) {
        TransactionFilter$1.encode(v, writer.uint32(18).fork()).ldelim();
      }
    }
    if (message.events !== undefined && message.events.length !== 0) {
      for (const v of message.events) {
        EventFilter$1.encode(v, writer.uint32(26).fork()).ldelim();
      }
    }
    if (message.messages !== undefined && message.messages.length !== 0) {
      for (const v of message.messages) {
        MessageToL1Filter$1.encode(v, writer.uint32(34).fork()).ldelim();
      }
    }
    if (message.storageDiffs !== undefined && message.storageDiffs.length !== 0) {
      for (const v of message.storageDiffs) {
        StorageDiffFilter$1.encode(v, writer.uint32(42).fork()).ldelim();
      }
    }
    if (message.contractChanges !== undefined && message.contractChanges.length !== 0) {
      for (const v of message.contractChanges) {
        ContractChangeFilter$1.encode(v, writer.uint32(50).fork()).ldelim();
      }
    }
    if (message.nonceUpdates !== undefined && message.nonceUpdates.length !== 0) {
      for (const v of message.nonceUpdates) {
        NonceUpdateFilter$1.encode(v, writer.uint32(58).fork()).ldelim();
      }
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.header = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.transactions.push(TransactionFilter$1.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.events.push(EventFilter$1.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.messages.push(MessageToL1Filter$1.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.storageDiffs.push(StorageDiffFilter$1.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.contractChanges.push(ContractChangeFilter$1.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.nonceUpdates.push(NonceUpdateFilter$1.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      header: isSet(object.header) ? headerFilterFromJSON(object.header) : 0,
      transactions: globalThis.Array.isArray(object?.transactions) ? object.transactions.map((e) => TransactionFilter$1.fromJSON(e)) : [],
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e) => EventFilter$1.fromJSON(e)) : [],
      messages: globalThis.Array.isArray(object?.messages) ? object.messages.map((e) => MessageToL1Filter$1.fromJSON(e)) : [],
      storageDiffs: globalThis.Array.isArray(object?.storageDiffs) ? object.storageDiffs.map((e) => StorageDiffFilter$1.fromJSON(e)) : [],
      contractChanges: globalThis.Array.isArray(object?.contractChanges) ? object.contractChanges.map((e) => ContractChangeFilter$1.fromJSON(e)) : [],
      nonceUpdates: globalThis.Array.isArray(object?.nonceUpdates) ? object.nonceUpdates.map((e) => NonceUpdateFilter$1.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.header !== undefined && message.header !== 0) {
      obj.header = headerFilterToJSON(message.header);
    }
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => TransactionFilter$1.toJSON(e));
    }
    if (message.events?.length) {
      obj.events = message.events.map((e) => EventFilter$1.toJSON(e));
    }
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => MessageToL1Filter$1.toJSON(e));
    }
    if (message.storageDiffs?.length) {
      obj.storageDiffs = message.storageDiffs.map((e) => StorageDiffFilter$1.toJSON(e));
    }
    if (message.contractChanges?.length) {
      obj.contractChanges = message.contractChanges.map((e) => ContractChangeFilter$1.toJSON(e));
    }
    if (message.nonceUpdates?.length) {
      obj.nonceUpdates = message.nonceUpdates.map((e) => NonceUpdateFilter$1.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return Filter$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFilter();
    message.header = object.header ?? 0;
    message.transactions = object.transactions?.map((e) => TransactionFilter$1.fromPartial(e)) || [];
    message.events = object.events?.map((e) => EventFilter$1.fromPartial(e)) || [];
    message.messages = object.messages?.map((e) => MessageToL1Filter$1.fromPartial(e)) || [];
    message.storageDiffs = object.storageDiffs?.map((e) => StorageDiffFilter$1.fromPartial(e)) || [];
    message.contractChanges = object.contractChanges?.map((e) => ContractChangeFilter$1.fromPartial(e)) || [];
    message.nonceUpdates = object.nonceUpdates?.map((e) => NonceUpdateFilter$1.fromPartial(e)) || [];
    return message;
  }
};
function createBaseEventFilter() {
  return {
    id: 0,
    address: undefined,
    keys: [],
    strict: undefined,
    transactionStatus: undefined,
    includeTransaction: undefined,
    includeReceipt: undefined,
    includeMessages: undefined,
    includeSiblings: undefined
  };
}
const EventFilter$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.id !== undefined && message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.address !== undefined) {
      FieldElement.encode(message.address, writer.uint32(18).fork()).ldelim();
    }
    if (message.keys !== undefined && message.keys.length !== 0) {
      for (const v of message.keys) {
        Key$1.encode(v, writer.uint32(26).fork()).ldelim();
      }
    }
    if (message.strict !== undefined) {
      writer.uint32(32).bool(message.strict);
    }
    if (message.transactionStatus !== undefined) {
      writer.uint32(40).int32(message.transactionStatus);
    }
    if (message.includeTransaction !== undefined) {
      writer.uint32(48).bool(message.includeTransaction);
    }
    if (message.includeReceipt !== undefined) {
      writer.uint32(56).bool(message.includeReceipt);
    }
    if (message.includeMessages !== undefined) {
      writer.uint32(64).bool(message.includeMessages);
    }
    if (message.includeSiblings !== undefined) {
      writer.uint32(72).bool(message.includeSiblings);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.id = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.address = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.keys.push(Key$1.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.strict = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.transactionStatus = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.includeTransaction = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }
          message.includeReceipt = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }
          message.includeMessages = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }
          message.includeSiblings = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      address: isSet(object.address) ? FieldElement.fromJSON(object.address) : undefined,
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e) => Key$1.fromJSON(e)) : [],
      strict: isSet(object.strict) ? globalThis.Boolean(object.strict) : undefined,
      transactionStatus: isSet(object.transactionStatus) ? transactionStatusFilterFromJSON(object.transactionStatus) : undefined,
      includeTransaction: isSet(object.includeTransaction) ? globalThis.Boolean(object.includeTransaction) : undefined,
      includeReceipt: isSet(object.includeReceipt) ? globalThis.Boolean(object.includeReceipt) : undefined,
      includeMessages: isSet(object.includeMessages) ? globalThis.Boolean(object.includeMessages) : undefined,
      includeSiblings: isSet(object.includeSiblings) ? globalThis.Boolean(object.includeSiblings) : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== undefined && message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.address !== undefined) {
      obj.address = FieldElement.toJSON(message.address);
    }
    if (message.keys?.length) {
      obj.keys = message.keys.map((e) => Key$1.toJSON(e));
    }
    if (message.strict !== undefined) {
      obj.strict = message.strict;
    }
    if (message.transactionStatus !== undefined) {
      obj.transactionStatus = transactionStatusFilterToJSON(message.transactionStatus);
    }
    if (message.includeTransaction !== undefined) {
      obj.includeTransaction = message.includeTransaction;
    }
    if (message.includeReceipt !== undefined) {
      obj.includeReceipt = message.includeReceipt;
    }
    if (message.includeMessages !== undefined) {
      obj.includeMessages = message.includeMessages;
    }
    if (message.includeSiblings !== undefined) {
      obj.includeSiblings = message.includeSiblings;
    }
    return obj;
  },
  create(base) {
    return EventFilter$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseEventFilter();
    message.id = object.id ?? 0;
    message.address = object.address !== undefined && object.address !== null ? FieldElement.fromPartial(object.address) : undefined;
    message.keys = object.keys?.map((e) => Key$1.fromPartial(e)) || [];
    message.strict = object.strict ?? undefined;
    message.transactionStatus = object.transactionStatus ?? undefined;
    message.includeTransaction = object.includeTransaction ?? undefined;
    message.includeReceipt = object.includeReceipt ?? undefined;
    message.includeMessages = object.includeMessages ?? undefined;
    message.includeSiblings = object.includeSiblings ?? undefined;
    return message;
  }
};
function createBaseKey() {
  return { value: undefined };
}
const Key$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.value !== undefined) {
      FieldElement.encode(message.value, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.value = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { value: isSet(object.value) ? FieldElement.fromJSON(object.value) : undefined };
  },
  toJSON(message) {
    const obj = {};
    if (message.value !== undefined) {
      obj.value = FieldElement.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return Key$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseKey();
    message.value = object.value !== undefined && object.value !== null ? FieldElement.fromPartial(object.value) : undefined;
    return message;
  }
};
function createBaseMessageToL1Filter() {
  return {
    id: 0,
    fromAddress: undefined,
    toAddress: undefined,
    transactionStatus: undefined,
    includeTransaction: undefined,
    includeReceipt: undefined,
    includeEvents: undefined,
    includeSiblings: undefined
  };
}
const MessageToL1Filter$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.id !== undefined && message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.fromAddress !== undefined) {
      FieldElement.encode(message.fromAddress, writer.uint32(18).fork()).ldelim();
    }
    if (message.toAddress !== undefined) {
      FieldElement.encode(message.toAddress, writer.uint32(26).fork()).ldelim();
    }
    if (message.transactionStatus !== undefined) {
      writer.uint32(32).int32(message.transactionStatus);
    }
    if (message.includeTransaction !== undefined) {
      writer.uint32(40).bool(message.includeTransaction);
    }
    if (message.includeReceipt !== undefined) {
      writer.uint32(48).bool(message.includeReceipt);
    }
    if (message.includeEvents !== undefined) {
      writer.uint32(56).bool(message.includeEvents);
    }
    if (message.includeSiblings !== undefined) {
      writer.uint32(64).bool(message.includeSiblings);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageToL1Filter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.id = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.fromAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.toAddress = FieldElement.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.transactionStatus = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.includeTransaction = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }
          message.includeReceipt = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }
          message.includeEvents = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }
          message.includeSiblings = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      fromAddress: isSet(object.fromAddress) ? FieldElement.fromJSON(object.fromAddress) : undefined,
      toAddress: isSet(object.toAddress) ? FieldElement.fromJSON(object.toAddress) : undefined,
      transactionStatus: isSet(object.transactionStatus) ? transactionStatusFilterFromJSON(object.transactionStatus) : undefined,
      includeTransaction: isSet(object.includeTransaction) ? globalThis.Boolean(object.includeTransaction) : undefined,
      includeReceipt: isSet(object.includeReceipt) ? globalThis.Boolean(object.includeReceipt) : undefined,
      includeEvents: isSet(object.includeEvents) ? globalThis.Boolean(object.includeEvents) : undefined,
      includeSiblings: isSet(object.includeSiblings) ? globalThis.Boolean(object.includeSiblings) : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== undefined && message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.fromAddress !== undefined) {
      obj.fromAddress = FieldElement.toJSON(message.fromAddress);
    }
    if (message.toAddress !== undefined) {
      obj.toAddress = FieldElement.toJSON(message.toAddress);
    }
    if (message.transactionStatus !== undefined) {
      obj.transactionStatus = transactionStatusFilterToJSON(message.transactionStatus);
    }
    if (message.includeTransaction !== undefined) {
      obj.includeTransaction = message.includeTransaction;
    }
    if (message.includeReceipt !== undefined) {
      obj.includeReceipt = message.includeReceipt;
    }
    if (message.includeEvents !== undefined) {
      obj.includeEvents = message.includeEvents;
    }
    if (message.includeSiblings !== undefined) {
      obj.includeSiblings = message.includeSiblings;
    }
    return obj;
  },
  create(base) {
    return MessageToL1Filter$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMessageToL1Filter();
    message.id = object.id ?? 0;
    message.fromAddress = object.fromAddress !== undefined && object.fromAddress !== null ? FieldElement.fromPartial(object.fromAddress) : undefined;
    message.toAddress = object.toAddress !== undefined && object.toAddress !== null ? FieldElement.fromPartial(object.toAddress) : undefined;
    message.transactionStatus = object.transactionStatus ?? undefined;
    message.includeTransaction = object.includeTransaction ?? undefined;
    message.includeReceipt = object.includeReceipt ?? undefined;
    message.includeEvents = object.includeEvents ?? undefined;
    message.includeSiblings = object.includeSiblings ?? undefined;
    return message;
  }
};
function createBaseTransactionFilter() {
  return {
    id: 0,
    transactionStatus: undefined,
    includeReceipt: undefined,
    includeEvents: undefined,
    includeMessages: undefined,
    inner: undefined
  };
}
const TransactionFilter$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.id !== undefined && message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.transactionStatus !== undefined) {
      writer.uint32(16).int32(message.transactionStatus);
    }
    if (message.includeReceipt !== undefined) {
      writer.uint32(24).bool(message.includeReceipt);
    }
    if (message.includeEvents !== undefined) {
      writer.uint32(32).bool(message.includeEvents);
    }
    if (message.includeMessages !== undefined) {
      writer.uint32(40).bool(message.includeMessages);
    }
    switch (message.inner?.$case) {
      case "invokeV0":
        InvokeTransactionV0Filter$1.encode(message.inner.invokeV0, writer.uint32(50).fork()).ldelim();
        break;
      case "invokeV1":
        InvokeTransactionV1Filter$1.encode(message.inner.invokeV1, writer.uint32(58).fork()).ldelim();
        break;
      case "invokeV3":
        InvokeTransactionV3Filter$1.encode(message.inner.invokeV3, writer.uint32(66).fork()).ldelim();
        break;
      case "deploy":
        DeployTransactionFilter$1.encode(message.inner.deploy, writer.uint32(74).fork()).ldelim();
        break;
      case "declareV0":
        DeclareV0TransactionFilter$1.encode(message.inner.declareV0, writer.uint32(82).fork()).ldelim();
        break;
      case "declareV1":
        DeclareV1TransactionFilter$1.encode(message.inner.declareV1, writer.uint32(90).fork()).ldelim();
        break;
      case "declareV2":
        DeclareV2TransactionFilter$1.encode(message.inner.declareV2, writer.uint32(98).fork()).ldelim();
        break;
      case "declareV3":
        DeclareV3TransactionFilter$1.encode(message.inner.declareV3, writer.uint32(106).fork()).ldelim();
        break;
      case "l1Handler":
        L1HandlerTransactionFilter$1.encode(message.inner.l1Handler, writer.uint32(114).fork()).ldelim();
        break;
      case "deployAccountV1":
        DeployAccountV1TransactionFilter$1.encode(message.inner.deployAccountV1, writer.uint32(122).fork()).ldelim();
        break;
      case "deployAccountV3":
        DeployAccountV3TransactionFilter$1.encode(message.inner.deployAccountV3, writer.uint32(130).fork()).ldelim();
        break;
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.id = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.transactionStatus = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }
          message.includeReceipt = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }
          message.includeEvents = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }
          message.includeMessages = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }
          message.inner = { $case: "invokeV0", invokeV0: InvokeTransactionV0Filter$1.decode(reader, reader.uint32()) };
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }
          message.inner = { $case: "invokeV1", invokeV1: InvokeTransactionV1Filter$1.decode(reader, reader.uint32()) };
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }
          message.inner = { $case: "invokeV3", invokeV3: InvokeTransactionV3Filter$1.decode(reader, reader.uint32()) };
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }
          message.inner = { $case: "deploy", deploy: DeployTransactionFilter$1.decode(reader, reader.uint32()) };
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }
          message.inner = { $case: "declareV0", declareV0: DeclareV0TransactionFilter$1.decode(reader, reader.uint32()) };
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }
          message.inner = { $case: "declareV1", declareV1: DeclareV1TransactionFilter$1.decode(reader, reader.uint32()) };
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }
          message.inner = { $case: "declareV2", declareV2: DeclareV2TransactionFilter$1.decode(reader, reader.uint32()) };
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }
          message.inner = { $case: "declareV3", declareV3: DeclareV3TransactionFilter$1.decode(reader, reader.uint32()) };
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }
          message.inner = { $case: "l1Handler", l1Handler: L1HandlerTransactionFilter$1.decode(reader, reader.uint32()) };
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }
          message.inner = {
            $case: "deployAccountV1",
            deployAccountV1: DeployAccountV1TransactionFilter$1.decode(reader, reader.uint32())
          };
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }
          message.inner = {
            $case: "deployAccountV3",
            deployAccountV3: DeployAccountV3TransactionFilter$1.decode(reader, reader.uint32())
          };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      transactionStatus: isSet(object.transactionStatus) ? transactionStatusFilterFromJSON(object.transactionStatus) : undefined,
      includeReceipt: isSet(object.includeReceipt) ? globalThis.Boolean(object.includeReceipt) : undefined,
      includeEvents: isSet(object.includeEvents) ? globalThis.Boolean(object.includeEvents) : undefined,
      includeMessages: isSet(object.includeMessages) ? globalThis.Boolean(object.includeMessages) : undefined,
      inner: isSet(object.invokeV0) ? { $case: "invokeV0", invokeV0: InvokeTransactionV0Filter$1.fromJSON(object.invokeV0) } : isSet(object.invokeV1) ? { $case: "invokeV1", invokeV1: InvokeTransactionV1Filter$1.fromJSON(object.invokeV1) } : isSet(object.invokeV3) ? { $case: "invokeV3", invokeV3: InvokeTransactionV3Filter$1.fromJSON(object.invokeV3) } : isSet(object.deploy) ? { $case: "deploy", deploy: DeployTransactionFilter$1.fromJSON(object.deploy) } : isSet(object.declareV0) ? { $case: "declareV0", declareV0: DeclareV0TransactionFilter$1.fromJSON(object.declareV0) } : isSet(object.declareV1) ? { $case: "declareV1", declareV1: DeclareV1TransactionFilter$1.fromJSON(object.declareV1) } : isSet(object.declareV2) ? { $case: "declareV2", declareV2: DeclareV2TransactionFilter$1.fromJSON(object.declareV2) } : isSet(object.declareV3) ? { $case: "declareV3", declareV3: DeclareV3TransactionFilter$1.fromJSON(object.declareV3) } : isSet(object.l1Handler) ? { $case: "l1Handler", l1Handler: L1HandlerTransactionFilter$1.fromJSON(object.l1Handler) } : isSet(object.deployAccountV1) ? {
        $case: "deployAccountV1",
        deployAccountV1: DeployAccountV1TransactionFilter$1.fromJSON(object.deployAccountV1)
      } : isSet(object.deployAccountV3) ? {
        $case: "deployAccountV3",
        deployAccountV3: DeployAccountV3TransactionFilter$1.fromJSON(object.deployAccountV3)
      } : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== undefined && message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.transactionStatus !== undefined) {
      obj.transactionStatus = transactionStatusFilterToJSON(message.transactionStatus);
    }
    if (message.includeReceipt !== undefined) {
      obj.includeReceipt = message.includeReceipt;
    }
    if (message.includeEvents !== undefined) {
      obj.includeEvents = message.includeEvents;
    }
    if (message.includeMessages !== undefined) {
      obj.includeMessages = message.includeMessages;
    }
    if (message.inner?.$case === "invokeV0") {
      obj.invokeV0 = InvokeTransactionV0Filter$1.toJSON(message.inner.invokeV0);
    }
    if (message.inner?.$case === "invokeV1") {
      obj.invokeV1 = InvokeTransactionV1Filter$1.toJSON(message.inner.invokeV1);
    }
    if (message.inner?.$case === "invokeV3") {
      obj.invokeV3 = InvokeTransactionV3Filter$1.toJSON(message.inner.invokeV3);
    }
    if (message.inner?.$case === "deploy") {
      obj.deploy = DeployTransactionFilter$1.toJSON(message.inner.deploy);
    }
    if (message.inner?.$case === "declareV0") {
      obj.declareV0 = DeclareV0TransactionFilter$1.toJSON(message.inner.declareV0);
    }
    if (message.inner?.$case === "declareV1") {
      obj.declareV1 = DeclareV1TransactionFilter$1.toJSON(message.inner.declareV1);
    }
    if (message.inner?.$case === "declareV2") {
      obj.declareV2 = DeclareV2TransactionFilter$1.toJSON(message.inner.declareV2);
    }
    if (message.inner?.$case === "declareV3") {
      obj.declareV3 = DeclareV3TransactionFilter$1.toJSON(message.inner.declareV3);
    }
    if (message.inner?.$case === "l1Handler") {
      obj.l1Handler = L1HandlerTransactionFilter$1.toJSON(message.inner.l1Handler);
    }
    if (message.inner?.$case === "deployAccountV1") {
      obj.deployAccountV1 = DeployAccountV1TransactionFilter$1.toJSON(message.inner.deployAccountV1);
    }
    if (message.inner?.$case === "deployAccountV3") {
      obj.deployAccountV3 = DeployAccountV3TransactionFilter$1.toJSON(message.inner.deployAccountV3);
    }
    return obj;
  },
  create(base) {
    return TransactionFilter$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTransactionFilter();
    message.id = object.id ?? 0;
    message.transactionStatus = object.transactionStatus ?? undefined;
    message.includeReceipt = object.includeReceipt ?? undefined;
    message.includeEvents = object.includeEvents ?? undefined;
    message.includeMessages = object.includeMessages ?? undefined;
    if (object.inner?.$case === "invokeV0" && object.inner?.invokeV0 !== undefined && object.inner?.invokeV0 !== null) {
      message.inner = { $case: "invokeV0", invokeV0: InvokeTransactionV0Filter$1.fromPartial(object.inner.invokeV0) };
    }
    if (object.inner?.$case === "invokeV1" && object.inner?.invokeV1 !== undefined && object.inner?.invokeV1 !== null) {
      message.inner = { $case: "invokeV1", invokeV1: InvokeTransactionV1Filter$1.fromPartial(object.inner.invokeV1) };
    }
    if (object.inner?.$case === "invokeV3" && object.inner?.invokeV3 !== undefined && object.inner?.invokeV3 !== null) {
      message.inner = { $case: "invokeV3", invokeV3: InvokeTransactionV3Filter$1.fromPartial(object.inner.invokeV3) };
    }
    if (object.inner?.$case === "deploy" && object.inner?.deploy !== undefined && object.inner?.deploy !== null) {
      message.inner = { $case: "deploy", deploy: DeployTransactionFilter$1.fromPartial(object.inner.deploy) };
    }
    if (object.inner?.$case === "declareV0" && object.inner?.declareV0 !== undefined && object.inner?.declareV0 !== null) {
      message.inner = { $case: "declareV0", declareV0: DeclareV0TransactionFilter$1.fromPartial(object.inner.declareV0) };
    }
    if (object.inner?.$case === "declareV1" && object.inner?.declareV1 !== undefined && object.inner?.declareV1 !== null) {
      message.inner = { $case: "declareV1", declareV1: DeclareV1TransactionFilter$1.fromPartial(object.inner.declareV1) };
    }
    if (object.inner?.$case === "declareV2" && object.inner?.declareV2 !== undefined && object.inner?.declareV2 !== null) {
      message.inner = { $case: "declareV2", declareV2: DeclareV2TransactionFilter$1.fromPartial(object.inner.declareV2) };
    }
    if (object.inner?.$case === "declareV3" && object.inner?.declareV3 !== undefined && object.inner?.declareV3 !== null) {
      message.inner = { $case: "declareV3", declareV3: DeclareV3TransactionFilter$1.fromPartial(object.inner.declareV3) };
    }
    if (object.inner?.$case === "l1Handler" && object.inner?.l1Handler !== undefined && object.inner?.l1Handler !== null) {
      message.inner = { $case: "l1Handler", l1Handler: L1HandlerTransactionFilter$1.fromPartial(object.inner.l1Handler) };
    }
    if (object.inner?.$case === "deployAccountV1" && object.inner?.deployAccountV1 !== undefined && object.inner?.deployAccountV1 !== null) {
      message.inner = {
        $case: "deployAccountV1",
        deployAccountV1: DeployAccountV1TransactionFilter$1.fromPartial(object.inner.deployAccountV1)
      };
    }
    if (object.inner?.$case === "deployAccountV3" && object.inner?.deployAccountV3 !== undefined && object.inner?.deployAccountV3 !== null) {
      message.inner = {
        $case: "deployAccountV3",
        deployAccountV3: DeployAccountV3TransactionFilter$1.fromPartial(object.inner.deployAccountV3)
      };
    }
    return message;
  }
};
function createBaseInvokeTransactionV0Filter() {
  return {};
}
const InvokeTransactionV0Filter$1 = {
  encode(_, writer = _m0.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeTransactionV0Filter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return InvokeTransactionV0Filter$1.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseInvokeTransactionV0Filter();
    return message;
  }
};
function createBaseInvokeTransactionV1Filter() {
  return {};
}
const InvokeTransactionV1Filter$1 = {
  encode(_, writer = _m0.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeTransactionV1Filter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return InvokeTransactionV1Filter$1.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseInvokeTransactionV1Filter();
    return message;
  }
};
function createBaseInvokeTransactionV3Filter() {
  return {};
}
const InvokeTransactionV3Filter$1 = {
  encode(_, writer = _m0.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeTransactionV3Filter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return InvokeTransactionV3Filter$1.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseInvokeTransactionV3Filter();
    return message;
  }
};
function createBaseDeployTransactionFilter() {
  return {};
}
const DeployTransactionFilter$1 = {
  encode(_, writer = _m0.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployTransactionFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return DeployTransactionFilter$1.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseDeployTransactionFilter();
    return message;
  }
};
function createBaseDeclareV0TransactionFilter() {
  return {};
}
const DeclareV0TransactionFilter$1 = {
  encode(_, writer = _m0.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclareV0TransactionFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return DeclareV0TransactionFilter$1.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseDeclareV0TransactionFilter();
    return message;
  }
};
function createBaseDeclareV1TransactionFilter() {
  return {};
}
const DeclareV1TransactionFilter$1 = {
  encode(_, writer = _m0.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclareV1TransactionFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return DeclareV1TransactionFilter$1.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseDeclareV1TransactionFilter();
    return message;
  }
};
function createBaseDeclareV2TransactionFilter() {
  return {};
}
const DeclareV2TransactionFilter$1 = {
  encode(_, writer = _m0.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclareV2TransactionFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return DeclareV2TransactionFilter$1.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseDeclareV2TransactionFilter();
    return message;
  }
};
function createBaseDeclareV3TransactionFilter() {
  return {};
}
const DeclareV3TransactionFilter$1 = {
  encode(_, writer = _m0.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclareV3TransactionFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return DeclareV3TransactionFilter$1.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseDeclareV3TransactionFilter();
    return message;
  }
};
function createBaseL1HandlerTransactionFilter() {
  return {};
}
const L1HandlerTransactionFilter$1 = {
  encode(_, writer = _m0.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseL1HandlerTransactionFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return L1HandlerTransactionFilter$1.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseL1HandlerTransactionFilter();
    return message;
  }
};
function createBaseDeployAccountV1TransactionFilter() {
  return {};
}
const DeployAccountV1TransactionFilter$1 = {
  encode(_, writer = _m0.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployAccountV1TransactionFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return DeployAccountV1TransactionFilter$1.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseDeployAccountV1TransactionFilter();
    return message;
  }
};
function createBaseDeployAccountV3TransactionFilter() {
  return {};
}
const DeployAccountV3TransactionFilter$1 = {
  encode(_, writer = _m0.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployAccountV3TransactionFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return DeployAccountV3TransactionFilter$1.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseDeployAccountV3TransactionFilter();
    return message;
  }
};
function createBaseStorageDiffFilter() {
  return { id: 0, contractAddress: undefined };
}
const StorageDiffFilter$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.id !== undefined && message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.contractAddress !== undefined) {
      FieldElement.encode(message.contractAddress, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorageDiffFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.id = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.contractAddress = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      contractAddress: isSet(object.contractAddress) ? FieldElement.fromJSON(object.contractAddress) : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== undefined && message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.contractAddress !== undefined) {
      obj.contractAddress = FieldElement.toJSON(message.contractAddress);
    }
    return obj;
  },
  create(base) {
    return StorageDiffFilter$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStorageDiffFilter();
    message.id = object.id ?? 0;
    message.contractAddress = object.contractAddress !== undefined && object.contractAddress !== null ? FieldElement.fromPartial(object.contractAddress) : undefined;
    return message;
  }
};
function createBaseContractChangeFilter() {
  return { id: 0, change: undefined };
}
const ContractChangeFilter$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.id !== undefined && message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    switch (message.change?.$case) {
      case "declaredClass":
        DeclaredClassFilter$1.encode(message.change.declaredClass, writer.uint32(18).fork()).ldelim();
        break;
      case "replacedClass":
        ReplacedClassFilter$1.encode(message.change.replacedClass, writer.uint32(26).fork()).ldelim();
        break;
      case "deployedContract":
        DeployedContractFilter$1.encode(message.change.deployedContract, writer.uint32(34).fork()).ldelim();
        break;
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractChangeFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.id = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.change = {
            $case: "declaredClass",
            declaredClass: DeclaredClassFilter$1.decode(reader, reader.uint32())
          };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.change = {
            $case: "replacedClass",
            replacedClass: ReplacedClassFilter$1.decode(reader, reader.uint32())
          };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.change = {
            $case: "deployedContract",
            deployedContract: DeployedContractFilter$1.decode(reader, reader.uint32())
          };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      change: isSet(object.declaredClass) ? { $case: "declaredClass", declaredClass: DeclaredClassFilter$1.fromJSON(object.declaredClass) } : isSet(object.replacedClass) ? { $case: "replacedClass", replacedClass: ReplacedClassFilter$1.fromJSON(object.replacedClass) } : isSet(object.deployedContract) ? { $case: "deployedContract", deployedContract: DeployedContractFilter$1.fromJSON(object.deployedContract) } : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== undefined && message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.change?.$case === "declaredClass") {
      obj.declaredClass = DeclaredClassFilter$1.toJSON(message.change.declaredClass);
    }
    if (message.change?.$case === "replacedClass") {
      obj.replacedClass = ReplacedClassFilter$1.toJSON(message.change.replacedClass);
    }
    if (message.change?.$case === "deployedContract") {
      obj.deployedContract = DeployedContractFilter$1.toJSON(message.change.deployedContract);
    }
    return obj;
  },
  create(base) {
    return ContractChangeFilter$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContractChangeFilter();
    message.id = object.id ?? 0;
    if (object.change?.$case === "declaredClass" && object.change?.declaredClass !== undefined && object.change?.declaredClass !== null) {
      message.change = {
        $case: "declaredClass",
        declaredClass: DeclaredClassFilter$1.fromPartial(object.change.declaredClass)
      };
    }
    if (object.change?.$case === "replacedClass" && object.change?.replacedClass !== undefined && object.change?.replacedClass !== null) {
      message.change = {
        $case: "replacedClass",
        replacedClass: ReplacedClassFilter$1.fromPartial(object.change.replacedClass)
      };
    }
    if (object.change?.$case === "deployedContract" && object.change?.deployedContract !== undefined && object.change?.deployedContract !== null) {
      message.change = {
        $case: "deployedContract",
        deployedContract: DeployedContractFilter$1.fromPartial(object.change.deployedContract)
      };
    }
    return message;
  }
};
function createBaseDeclaredClassFilter() {
  return {};
}
const DeclaredClassFilter$1 = {
  encode(_, writer = _m0.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclaredClassFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return DeclaredClassFilter$1.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseDeclaredClassFilter();
    return message;
  }
};
function createBaseReplacedClassFilter() {
  return {};
}
const ReplacedClassFilter$1 = {
  encode(_, writer = _m0.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplacedClassFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return ReplacedClassFilter$1.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseReplacedClassFilter();
    return message;
  }
};
function createBaseDeployedContractFilter() {
  return {};
}
const DeployedContractFilter$1 = {
  encode(_, writer = _m0.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployedContractFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return DeployedContractFilter$1.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseDeployedContractFilter();
    return message;
  }
};
function createBaseNonceUpdateFilter() {
  return { id: 0, contractAddress: undefined };
}
const NonceUpdateFilter$1 = {
  encode(message, writer = _m0.Writer.create()) {
    if (message.id !== undefined && message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.contractAddress !== undefined) {
      FieldElement.encode(message.contractAddress, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNonceUpdateFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }
          message.id = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.contractAddress = FieldElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      contractAddress: isSet(object.contractAddress) ? FieldElement.fromJSON(object.contractAddress) : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== undefined && message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.contractAddress !== undefined) {
      obj.contractAddress = FieldElement.toJSON(message.contractAddress);
    }
    return obj;
  },
  create(base) {
    return NonceUpdateFilter$1.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseNonceUpdateFilter();
    message.id = object.id ?? 0;
    message.contractAddress = object.contractAddress !== undefined && object.contractAddress !== null ? FieldElement.fromPartial(object.contractAddress) : undefined;
    return message;
  }
};
function isSet(value) {
  return value !== null && value !== undefined;
}

const ResourcePrice = Struct({
  priceInFri: optional(FieldElement$1),
  priceInWei: optional(FieldElement$1)
});
const L1DataAvailabilityMode = transform(
  Enums(L1DataAvailabilityMode$1),
  Literal("blob", "calldata", "unknown"),
  {
    decode(value) {
      const enumMap = {
        [L1DataAvailabilityMode$1.CALLDATA]: "calldata",
        [L1DataAvailabilityMode$1.BLOB]: "blob",
        [L1DataAvailabilityMode$1.UNSPECIFIED]: "unknown",
        [L1DataAvailabilityMode$1.UNRECOGNIZED]: "unknown"
      };
      return enumMap[value] ?? "unknown";
    },
    encode(value) {
      throw new Error("encode: not implemented");
    }
  }
);
const TransactionStatus = transform(
  Enums(TransactionStatus$1),
  Literal("unknown", "succeeded", "reverted"),
  {
    decode(value) {
      const enumMap = {
        [TransactionStatus$1.SUCCEEDED]: "succeeded",
        [TransactionStatus$1.REVERTED]: "reverted",
        [TransactionStatus$1.UNSPECIFIED]: "unknown",
        [TransactionStatus$1.UNRECOGNIZED]: "unknown"
      };
      return enumMap[value] ?? "unknown";
    },
    encode(value) {
      throw new Error("encode: not implemented");
    }
  }
);
const U128 = transform(
  Struct({
    x0: BigIntFromSelf,
    x1: BigIntFromSelf
  }),
  BigIntFromSelf,
  {
    decode(value) {
      const low = value.x0.toString(16).padStart(16, "0");
      const high = value.x1.toString(16).padStart(16, "0");
      return BigInt(`0x${low}${high}`);
    },
    encode(value) {
      throw new Error("encode: not implemented");
    }
  }
);
const ResourceBounds = Struct({
  maxAmount: optional(BigIntFromSelf),
  maxPricePerUnit: optional(U128)
});
const ResourceBoundsMapping = Struct({
  l1Gas: optional(ResourceBounds),
  l2Gas: optional(ResourceBounds)
});
const DataAvailabilityMode = transform(
  Enums(DataAvailabilityMode$1),
  Literal("l1", "l2", "unknown"),
  {
    decode(value) {
      const enumMap = {
        [DataAvailabilityMode$1.L1]: "l1",
        [DataAvailabilityMode$1.L2]: "l2",
        [DataAvailabilityMode$1.UNSPECIFIED]: "unknown",
        [DataAvailabilityMode$1.UNRECOGNIZED]: "unknown"
      };
      return enumMap[value] ?? "unknown";
    },
    encode(value) {
      throw new Error("encode: not implemented");
    }
  }
);
const BlockHeader = Struct({
  blockHash: optional(FieldElement$1),
  parentBlockHash: optional(FieldElement$1),
  blockNumber: BigIntFromSelf,
  sequencerAddress: optional(FieldElement$1),
  newRoot: optional(FieldElement$1),
  timestamp: optional(DateFromSelf),
  starknetVersion: optional(String$),
  l1GasPrice: optional(ResourcePrice),
  l1DataGasPrice: optional(ResourcePrice),
  l1DataAvailabilityMode: optional(L1DataAvailabilityMode)
});
const TransactionMeta = Struct({
  transactionIndex: optional(Number$),
  transactionHash: optional(FieldElement$1),
  transactionStatus: optional(TransactionStatus)
});
const InvokeTransactionV0 = Struct({
  _tag: tag("invokeV0"),
  invokeV0: Struct({
    maxFee: optional(FieldElement$1),
    signature: optional(Array$(FieldElement$1)),
    contractAddress: optional(FieldElement$1),
    entryPointSelector: optional(FieldElement$1),
    calldata: optional(Array$(FieldElement$1))
  })
});
const InvokeTransactionV1 = Struct({
  _tag: tag("invokeV1"),
  invokeV1: Struct({
    senderAddress: optional(FieldElement$1),
    calldata: optional(Array$(FieldElement$1)),
    maxFee: optional(FieldElement$1),
    signature: optional(Array$(FieldElement$1)),
    nonce: optional(FieldElement$1)
  })
});
const InvokeTransactionV3 = Struct({
  _tag: tag("invokeV3"),
  invokeV3: Struct({
    senderAddress: optional(FieldElement$1),
    calldata: optional(Array$(FieldElement$1)),
    signature: optional(Array$(FieldElement$1)),
    nonce: optional(FieldElement$1),
    resourceBounds: optional(ResourceBoundsMapping),
    tip: optional(BigIntFromSelf),
    paymasterData: optional(Array$(FieldElement$1)),
    accountDeploymentData: optional(Array$(FieldElement$1)),
    nonceDataAvailabilityMode: optional(DataAvailabilityMode),
    feeDataAvailabilityMode: optional(DataAvailabilityMode)
  })
});
const L1HandlerTransaction = Struct({
  _tag: tag("l1Handler"),
  l1Handler: Struct({
    nonce: optional(BigIntFromSelf),
    contractAddress: optional(FieldElement$1),
    entryPointSelector: optional(FieldElement$1),
    calldata: optional(Array$(FieldElement$1))
  })
});
const DeployTransaction = Struct({
  _tag: tag("deploy"),
  deploy: Struct({
    contractAddressSalt: optional(FieldElement$1),
    constructorCalldata: optional(Array$(FieldElement$1)),
    classHash: optional(FieldElement$1)
  })
});
const DeclareTransactionV0 = Struct({
  _tag: tag("declareV0"),
  declareV0: Struct({
    senderAddress: optional(FieldElement$1),
    maxFee: optional(FieldElement$1),
    signature: optional(Array$(FieldElement$1)),
    classHash: optional(FieldElement$1)
  })
});
const DeclareTransactionV1 = Struct({
  _tag: tag("declareV1"),
  declareV1: Struct({
    senderAddress: optional(FieldElement$1),
    maxFee: optional(FieldElement$1),
    signature: optional(Array$(FieldElement$1)),
    nonce: optional(FieldElement$1),
    classHash: optional(FieldElement$1)
  })
});
const DeclareTransactionV2 = Struct({
  _tag: tag("declareV2"),
  declareV2: Struct({
    senderAddress: optional(FieldElement$1),
    compiledClassHash: optional(FieldElement$1),
    maxFee: optional(FieldElement$1),
    signature: optional(Array$(FieldElement$1)),
    nonce: optional(FieldElement$1),
    classHash: optional(FieldElement$1)
  })
});
const DeclareTransactionV3 = Struct({
  _tag: tag("declareV3"),
  declareV3: Struct({
    senderAddress: optional(FieldElement$1),
    compiledClassHash: optional(FieldElement$1),
    signature: optional(Array$(FieldElement$1)),
    nonce: optional(FieldElement$1),
    classHash: optional(FieldElement$1),
    resourceBounds: optional(ResourceBoundsMapping),
    tip: optional(BigIntFromSelf),
    paymasterData: optional(Array$(FieldElement$1)),
    accountDeploymentData: optional(Array$(FieldElement$1)),
    nonceDataAvailabilityMode: optional(DataAvailabilityMode),
    feeDataAvailabilityMode: optional(DataAvailabilityMode)
  })
});
const DeployAccountTransactionV1 = Struct({
  _tag: tag("deployAccountV1"),
  deployAccountV1: Struct({
    maxFee: optional(FieldElement$1),
    signature: optional(Array$(FieldElement$1)),
    nonce: optional(FieldElement$1),
    contractAddressSalt: optional(FieldElement$1),
    constructorCalldata: optional(Array$(FieldElement$1)),
    classHash: optional(FieldElement$1)
  })
});
const DeployAccountTransactionV3 = Struct({
  _tag: tag("deployAccountV3"),
  deployAccountV3: Struct({
    signature: optional(Array$(FieldElement$1)),
    nonce: optional(FieldElement$1),
    contractAddressSalt: optional(FieldElement$1),
    constructorCalldata: optional(Array$(FieldElement$1)),
    classHash: optional(FieldElement$1),
    resourceBounds: optional(ResourceBoundsMapping),
    tip: optional(BigIntFromSelf),
    paymasterData: optional(Array$(FieldElement$1)),
    nonceDataAvailabilityMode: optional(DataAvailabilityMode),
    feeDataAvailabilityMode: optional(DataAvailabilityMode)
  })
});
const Transaction = Struct({
  filterIds: optional(Array$(Number$)),
  meta: optional(TransactionMeta),
  transaction: optional(
    Union(
      InvokeTransactionV0,
      InvokeTransactionV1,
      InvokeTransactionV3,
      L1HandlerTransaction,
      DeployTransaction,
      DeclareTransactionV0,
      DeclareTransactionV1,
      DeclareTransactionV2,
      DeclareTransactionV3,
      DeployAccountTransactionV1,
      DeployAccountTransactionV3
    )
  )
});
const PriceUnit = transform(
  Enums(PriceUnit$1),
  Literal("wei", "fri", "unknown"),
  {
    decode(value) {
      const enumMap = {
        [PriceUnit$1.WEI]: "wei",
        [PriceUnit$1.FRI]: "fri",
        [PriceUnit$1.UNSPECIFIED]: "unknown",
        [PriceUnit$1.UNRECOGNIZED]: "unknown"
      };
      return enumMap[value] ?? "unknown";
    },
    encode(value) {
      throw new Error("encode: not implemented");
    }
  }
);
const FeePayment = Struct({
  amount: optional(FieldElement$1),
  unit: optional(PriceUnit)
});
const ComputationResources = Struct({
  steps: optional(BigIntFromSelf),
  memoryHoles: optional(BigIntFromSelf),
  rangeCheckBuiltinApplications: optional(BigIntFromSelf),
  pedersenBuiltinApplications: optional(BigIntFromSelf),
  poseidonBuiltinApplications: optional(BigIntFromSelf),
  ecOpBuiltinApplications: optional(BigIntFromSelf),
  ecdsaBuiltinApplications: optional(BigIntFromSelf),
  bitwiseBuiltinApplications: optional(BigIntFromSelf),
  keccakBuiltinApplications: optional(BigIntFromSelf),
  segmentArenaBuiltin: optional(BigIntFromSelf)
});
const DataAvailabilityResources = Struct({
  l1Gas: optional(BigIntFromSelf),
  l1DataGas: optional(BigIntFromSelf)
});
const ExecutionResources = Struct({
  computation: optional(ComputationResources),
  dataAvailability: optional(DataAvailabilityResources)
});
const ExecutionSucceeded = Struct({
  _tag: tag("succeeded"),
  succeeded: Struct({})
});
const ExecutionReverted = Struct({
  _tag: tag("reverted"),
  reverted: Struct({
    reason: optional(String$)
  })
});
const TransactionReceiptMeta = Struct({
  transactionIndex: optional(Number$),
  transactionHash: optional(FieldElement$1),
  actualFee: optional(FeePayment),
  executionResources: optional(ExecutionResources),
  executionResult: optional(
    Union(ExecutionSucceeded, ExecutionReverted)
  )
});
const InvokeTransactionReceipt = Struct({
  _tag: tag("invoke"),
  invoke: Struct({})
});
const L1HandlerTransactionReceipt = Struct({
  _tag: tag("l1Handler"),
  l1Handler: Struct({
    messageHash: optional(Uint8ArrayFromSelf)
  })
});
const DeclareTransactionReceipt = Struct({
  _tag: tag("declare"),
  declare: Struct({})
});
const DeployTransactionReceipt = Struct({
  _tag: tag("deploy"),
  deploy: Struct({
    contractAddress: optional(FieldElement$1)
  })
});
const DeployAccountTransactionReceipt = Struct({
  _tag: tag("deployAccount"),
  deployAccount: Struct({
    contractAddress: optional(FieldElement$1)
  })
});
const TransactionReceipt = Struct({
  filterIds: optional(Array$(Number$)),
  meta: optional(TransactionReceiptMeta),
  receipt: optional(
    Union(
      InvokeTransactionReceipt,
      L1HandlerTransactionReceipt,
      DeclareTransactionReceipt,
      DeployTransactionReceipt,
      DeployAccountTransactionReceipt
    )
  )
});
const Event = Struct({
  filterIds: optional(Array$(Number$)),
  address: optional(FieldElement$1),
  keys: optional(Array$(FieldElement$1)),
  data: optional(Array$(FieldElement$1)),
  eventIndex: optional(Number$),
  transactionIndex: optional(Number$),
  transactionHash: optional(FieldElement$1),
  transactionStatus: optional(TransactionStatus)
});
const MessageToL1 = Struct({
  filterIds: optional(Array$(Number$)),
  fromAddress: optional(FieldElement$1),
  toAddress: optional(FieldElement$1),
  payload: optional(Array$(FieldElement$1)),
  messageIndex: optional(Number$),
  transactionIndex: optional(Number$),
  transactionHash: optional(FieldElement$1),
  transactionStatus: optional(TransactionStatus)
});
const StorageEntry = Struct({
  key: optional(FieldElement$1),
  value: optional(FieldElement$1)
});
const StorageDiff = Struct({
  filterIds: optional(Array$(Number$)),
  contractAddress: optional(FieldElement$1),
  storageEntries: optional(Array$(StorageEntry))
});
const DeclaredClass = Struct({
  _tag: tag("declaredClass"),
  declaredClass: Struct({
    classHash: optional(FieldElement$1),
    compiledClassHash: optional(FieldElement$1)
  })
});
const ReplacedClass = Struct({
  _tag: tag("replacedClass"),
  replacedClass: Struct({
    contractAddress: optional(FieldElement$1),
    classHash: optional(FieldElement$1)
  })
});
const DeployedContract = Struct({
  _tag: tag("deployedContract"),
  deployedContract: Struct({
    contractAddress: optional(FieldElement$1),
    classHash: optional(FieldElement$1)
  })
});
const ContractChange = Struct({
  filterIds: optional(Array$(Number$)),
  change: optional(
    Union(DeclaredClass, ReplacedClass, DeployedContract)
  )
});
const NonceUpdate = Struct({
  filterIds: optional(Array$(Number$)),
  contractAddress: optional(FieldElement$1),
  nonce: optional(FieldElement$1)
});
const Block = Struct({
  header: optional(BlockHeader),
  transactions: Array$(Transaction),
  receipts: Array$(TransactionReceipt),
  events: Array$(Event),
  messages: Array$(MessageToL1),
  storageDiffs: Array$(StorageDiff),
  contractChanges: Array$(ContractChange),
  nonceUpdates: Array$(NonceUpdate)
});
const BlockFromBytes = transform(
  Uint8ArrayFromSelf,
  NullOr(Block),
  {
    strict: false,
    decode(value) {
      if (value.length === 0) {
        return null;
      }
      return Block$1.decode(value);
    },
    encode(value) {
      if (value === null) {
        return new Uint8Array();
      }
      return Block$1.encode(value).finish();
    }
  }
);

const HeaderFilter = transform(
  Enums(HeaderFilter$1),
  Literal("always", "on_data", "on_data_or_on_new_block", "unknown"),
  {
    decode(value) {
      const enumMap = {
        [HeaderFilter$1.ALWAYS]: "always",
        [HeaderFilter$1.ON_DATA]: "on_data",
        [HeaderFilter$1.ON_DATA_OR_ON_NEW_BLOCK]: "on_data_or_on_new_block",
        [HeaderFilter$1.UNSPECIFIED]: "unknown",
        [HeaderFilter$1.UNRECOGNIZED]: "unknown"
      };
      return enumMap[value] ?? "unknown";
    },
    encode(value) {
      switch (value) {
        case "always":
          return HeaderFilter$1.ALWAYS;
        case "on_data":
          return HeaderFilter$1.ON_DATA;
        case "on_data_or_on_new_block":
          return HeaderFilter$1.ON_DATA_OR_ON_NEW_BLOCK;
        default:
          return HeaderFilter$1.UNSPECIFIED;
      }
    }
  }
);
const Key = transform(
  Struct({ value: UndefinedOr(FieldElementProto) }),
  NullOr(FieldElement$1),
  {
    decode({ value }) {
      if (value === undefined) {
        return null;
      }
      return value;
    },
    encode(value) {
      if (value === null) {
        return { value: undefined };
      }
      return { value };
    }
  }
);
const TransactionStatusFilter = transform(
  Enums(TransactionStatusFilter$1),
  Literal("succeeded", "reverted", "all", "unknown"),
  {
    decode(value) {
      const enumMap = {
        [TransactionStatusFilter$1.SUCCEEDED]: "succeeded",
        [TransactionStatusFilter$1.REVERTED]: "reverted",
        [TransactionStatusFilter$1.ALL]: "all",
        [TransactionStatusFilter$1.UNSPECIFIED]: "unknown",
        [TransactionStatusFilter$1.UNRECOGNIZED]: "unknown"
      };
      return enumMap[value] ?? "unknown";
    },
    encode(value) {
      switch (value) {
        case "succeeded":
          return TransactionStatusFilter$1.SUCCEEDED;
        case "reverted":
          return TransactionStatusFilter$1.REVERTED;
        case "all":
          return TransactionStatusFilter$1.ALL;
        default:
          return TransactionStatusFilter$1.UNSPECIFIED;
      }
    }
  }
);
const EventFilter = Struct({
  id: optional(Number$),
  address: optional(FieldElement$1),
  keys: optional(Array$(Key)),
  strict: optional(Boolean$),
  transactionStatus: optional(TransactionStatusFilter),
  includeTransaction: optional(Boolean$),
  includeReceipt: optional(Boolean$),
  includeMessages: optional(Boolean$),
  includeSiblings: optional(Boolean$)
});
const MessageToL1Filter = Struct({
  id: optional(Number$),
  fromAddress: optional(FieldElement$1),
  toAddress: optional(FieldElement$1),
  transactionStatus: optional(TransactionStatusFilter),
  includeTransaction: optional(Boolean$),
  includeReceipt: optional(Boolean$),
  includeEvents: optional(Boolean$)
});
const InvokeTransactionV0Filter = Struct({
  _tag: tag("invokeV0"),
  invokeV0: Struct({})
});
const InvokeTransactionV1Filter = Struct({
  _tag: tag("invokeV1"),
  invokeV1: Struct({})
});
const InvokeTransactionV3Filter = Struct({
  _tag: tag("invokeV3"),
  invokeV3: Struct({})
});
const DeployTransactionFilter = Struct({
  _tag: tag("deploy"),
  deploy: Struct({})
});
const DeclareV0TransactionFilter = Struct({
  _tag: tag("declareV0"),
  declareV0: Struct({})
});
const DeclareV1TransactionFilter = Struct({
  _tag: tag("declareV1"),
  declareV1: Struct({})
});
const DeclareV2TransactionFilter = Struct({
  _tag: tag("declareV2"),
  declareV2: Struct({})
});
const DeclareV3TransactionFilter = Struct({
  _tag: tag("declareV3"),
  declareV3: Struct({})
});
const L1HandlerTransactionFilter = Struct({
  _tag: tag("l1Handler"),
  l1Handler: Struct({})
});
const DeployAccountV1TransactionFilter = Struct({
  _tag: tag("deployAccountV1"),
  deployAccountV1: Struct({})
});
const DeployAccountV3TransactionFilter = Struct({
  _tag: tag("deployAccountV3"),
  deployAccountV3: Struct({})
});
const TransactionFilter = Struct({
  id: optional(Number$),
  transactionStatus: optional(TransactionStatusFilter),
  includeReceipt: optional(Boolean$),
  includeMessages: optional(Boolean$),
  includeEvents: optional(Boolean$),
  transactionType: optional(
    Union(
      InvokeTransactionV0Filter,
      InvokeTransactionV1Filter,
      InvokeTransactionV3Filter,
      DeployTransactionFilter,
      DeclareV0TransactionFilter,
      DeclareV1TransactionFilter,
      DeclareV2TransactionFilter,
      DeclareV3TransactionFilter,
      DeclareV3TransactionFilter,
      L1HandlerTransactionFilter,
      DeployAccountV1TransactionFilter,
      DeployAccountV3TransactionFilter
    )
  )
});
const StorageDiffFilter = Struct({
  id: optional(Number$),
  contractAddress: optional(FieldElement$1)
});
const DeclaredClassFilter = Struct({
  _tag: tag("declaredClass"),
  declaredClass: Struct({})
});
const ReplacedClassFilter = Struct({
  _tag: tag("replacedClass"),
  replacedClass: Struct({})
});
const DeployedContractFilter = Struct({
  _tag: tag("deployedContract"),
  deployedContract: Struct({})
});
const ContractChangeFilter = Struct({
  id: optional(Number$),
  change: optional(
    Union(
      DeclaredClassFilter,
      ReplacedClassFilter,
      DeployedContractFilter
    )
  )
});
const NonceUpdateFilter = Struct({
  id: optional(Number$),
  contractAddress: optional(FieldElement$1)
});
const Filter = Struct({
  header: optional(HeaderFilter),
  transactions: optional(Array$(TransactionFilter)),
  events: optional(Array$(EventFilter)),
  messages: optional(Array$(MessageToL1Filter)),
  storageDiffs: optional(Array$(StorageDiffFilter)),
  contractChanges: optional(Array$(ContractChangeFilter)),
  nonceUpdates: optional(Array$(NonceUpdateFilter))
});
encodeSync(Filter);
decodeSync(Filter);
const FilterFromBytes = transform(
  Uint8ArrayFromSelf,
  Filter,
  {
    strict: false,
    decode(value) {
      return Filter$1.decode(value);
    },
    encode(value) {
      return Filter$1.encode(value).finish();
    }
  }
);
encodeSync(FilterFromBytes);
decodeSync(FilterFromBytes);
function mergeFilter(a, b) {
  const header = mergeHeaderFilter(a.header, b.header);
  return {
    header,
    transactions: [...a.transactions ?? [], ...b.transactions ?? []],
    events: [...a.events ?? [], ...b.events ?? []],
    messages: [...a.messages ?? [], ...b.messages ?? []],
    storageDiffs: [...a.storageDiffs ?? [], ...b.storageDiffs ?? []],
    contractChanges: [
      ...a.contractChanges ?? [],
      ...b.contractChanges ?? []
    ],
    nonceUpdates: [...a.nonceUpdates ?? [], ...b.nonceUpdates ?? []]
  };
}
function mergeHeaderFilter(a, b) {
  if (a === undefined) {
    return b;
  }
  if (b === undefined) {
    return a;
  }
  if (a === "always" || b === "always") {
    return "always";
  }
  if (a === "on_data_or_on_new_block" || b === "on_data_or_on_new_block") {
    return "on_data_or_on_new_block";
  }
  return "on_data";
}

const StarknetStream = new StreamConfig(
  FilterFromBytes,
  BlockFromBytes,
  mergeFilter
);

const _LAErKnZ6Sk = defineIndexer(StarknetStream)({
  streamUrl: "https://starknet.preview.apibara.org",
  startingCursor: {
    orderKey: 631125n
  },
  filter: {
    events: [
      {
        address: "0x0350a4930de406346a8efd088cea7475a88197f90a1237958b516fe81d68403e"
        // keys: [hash.getSelectorFromName("Deposit")],
      }
    ]
  },
  async transform({ block }) {
    const { events, header } = block;
    for (const event of events) {
      console.log(`Event ${event.eventIndex} tx=${event.transactionHash}`);
    }
  }
});

const indexers = [
      { name: "yielder", indexer: _LAErKnZ6Sk }
    ];

function murmurHash(key, seed = 0) {
  if (typeof key === "string") {
    key = createBuffer(key);
  }
  let i = 0;
  let h1 = seed;
  let k1;
  let h1b;
  const remainder = key.length & 3;
  const bytes = key.length - remainder;
  const c1 = 3432918353;
  const c2 = 461845907;
  while (i < bytes) {
    k1 = key[i] & 255 | (key[++i] & 255) << 8 | (key[++i] & 255) << 16 | (key[++i] & 255) << 24;
    ++i;
    k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;
    k1 = k1 << 15 | k1 >>> 17;
    k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;
    h1 ^= k1;
    h1 = h1 << 13 | h1 >>> 19;
    h1b = (h1 & 65535) * 5 + (((h1 >>> 16) * 5 & 65535) << 16) & 4294967295;
    h1 = (h1b & 65535) + 27492 + (((h1b >>> 16) + 58964 & 65535) << 16);
  }
  k1 = 0;
  switch (remainder) {
    case 3: {
      k1 ^= (key[i + 2] & 255) << 16;
    }
    case 2: {
      k1 ^= (key[i + 1] & 255) << 8;
    }
    case 1: {
      k1 ^= key[i] & 255;
      k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;
      k1 = k1 << 15 | k1 >>> 17;
      k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;
      h1 ^= k1;
    }
  }
  h1 ^= key.length;
  h1 ^= h1 >>> 16;
  h1 = (h1 & 65535) * 2246822507 + (((h1 >>> 16) * 2246822507 & 65535) << 16) & 4294967295;
  h1 ^= h1 >>> 13;
  h1 = (h1 & 65535) * 3266489909 + (((h1 >>> 16) * 3266489909 & 65535) << 16) & 4294967295;
  h1 ^= h1 >>> 16;
  return h1 >>> 0;
}
function createBuffer(val) {
  return new TextEncoder().encode(val);
}

const INDEXER_COLOR_MAP = [
  colors.red,
  colors.green,
  colors.yellow,
  colors.blue,
  colors.magenta,
  colors.cyan
];
const TYPE_COLOR_MAP = {
  info: "cyan",
  fail: "red",
  success: "green",
  ready: "green",
  start: "magenta"
};
const LEVEL_COLOR_MAP = {
  0: "red",
  1: "yellow"
};
const MAX_INDEXER_NAME_LENGTH = 20;
class DefaultReporter {
  tag;
  constructor(indexer, indexers, preset) {
    const color = INDEXER_COLOR_MAP[murmurHash(indexer) % INDEXER_COLOR_MAP.length];
    const presetLength = preset ? preset.length : 0;
    const longestIndexerName = Math.max(...indexers.map((i) => i.length), indexer.length) + presetLength;
    const paddedIndexer = `${indexer}${preset ? `:${preset} ` : ""}`.padEnd(longestIndexerName, " ").slice(0, Math.min(longestIndexerName, MAX_INDEXER_NAME_LENGTH));
    this.tag = color(`${paddedIndexer} |`);
  }
  log(logObj, ctx) {
    const { args } = logObj;
    const typeColor = TYPE_COLOR_MAP[logObj.type] || LEVEL_COLOR_MAP[logObj.level] || "gray";
    const type = getColor(typeColor, "white")(logObj.type);
    console.log(`${this.tag} ${type}`, ...args);
  }
}
function createLogger({
  indexer,
  indexers,
  preset
}) {
  return new DefaultReporter(indexer, indexers, preset);
}

const availableIndexers = indexers.map((i) => i.name);
function createIndexer(indexerName, preset) {
  let runtimeConfig = { ...config.runtimeConfig };
  if (preset) {
    if (config.presets === undefined) {
      throw new Error(
        `Specified preset "${preset}" but no presets were defined`
      );
    }
    if (config.presets[preset] === undefined) {
      throw new Error(`Specified preset "${preset}" but it was not defined`);
    }
    const presetValue = config.presets[preset];
    runtimeConfig = { ...runtimeConfig, ...presetValue.runtimeConfig };
  }
  const indexerDefinition = indexers.find((i) => i.name === indexerName);
  if (indexerDefinition === undefined) {
    throw new Error(
      `Specified indexer "${indexerName}" but it was not defined`
    );
  }
  const definition = typeof indexerDefinition.indexer === "function" ? indexerDefinition.indexer(runtimeConfig) : indexerDefinition.indexer;
  let reporter = createLogger({
    indexer: indexerName,
    preset,
    indexers: availableIndexers
  });
  if (config.logger) {
    reporter = config.logger({
      indexer: indexerName,
      preset,
      indexers: availableIndexers
    });
  }
  definition.plugins = [
    inMemoryPersistence(),
    ...definition.plugins ?? [],
    logger({ logger: reporter })
  ];
  return createIndexer$1(definition);
}

const startCommand = defineCommand({
  meta: {
    name: "start",
    description: "Start the indexer"
  },
  args: {
    indexers: {
      type: "string",
      description: "Which indexers to run"
    },
    preset: {
      type: "string",
      description: "Preset to use"
    }
  },
  async run({ args }) {
    const { indexers: indexersArgs, preset } = args;
    let selectedIndexers = availableIndexers;
    if (indexersArgs) {
      selectedIndexers = indexersArgs.split(",");
    }
    for (const indexer of selectedIndexers) {
      if (!availableIndexers.includes(indexer)) {
        throw new Error(
          `Specified indexer "${indexer}" but it was not defined`
        );
      }
    }
    await Promise.all(
      selectedIndexers.map(async (indexer) => {
        const indexerInstance = createIndexer(indexer, preset);
        const client = createClient(
          indexerInstance.streamConfig,
          indexerInstance.options.streamUrl
        );
        await runWithReconnect(client, indexerInstance);
      })
    );
  }
});
const mainCli = defineCommand({
  meta: {
    name: "indexer-dev-runner",
    description: "Run indexer in dev mode"
  },
  subCommands: {
    start: () => startCommand
  }
});
runMain(mainCli);
const dev = {};

export { dev as default, mainCli };
//# sourceMappingURL=dev.mjs.map
